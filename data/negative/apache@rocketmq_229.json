{
  "id" : 229,
  "expression" : "defaultMQPushConsumer",
  "projectName" : "apache@rocketmq",
  "commitID" : "7692d466e1fda6c29d52a61617cab1d82de8b884",
  "filePath" : "/client/src/main/java/org/apache/rocketmq/client/impl/consumer/ConsumeMessageOrderlyService.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "defaultMQPushConsumer",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 21,
      "startLineNumber" : 499,
      "startColumnNumber" : 52,
      "endLineNumber" : 499,
      "endColumnNumber" : 73
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 499,
        "startColumnNumber" : 52,
        "endLineNumber" : 499,
        "endColumnNumber" : 93
      },
      "nodeContext" : "defaultMQPushConsumer.getConsumeTimeout()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 499,
        "startColumnNumber" : 52,
        "endLineNumber" : 499,
        "endColumnNumber" : 105
      },
      "nodeContext" : "defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 66,
        "startLineNumber" : 499,
        "startColumnNumber" : 39,
        "endLineNumber" : 499,
        "endColumnNumber" : 105
      },
      "nodeContext" : "consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 504,
        "startLineNumber" : 499,
        "startColumnNumber" : 35,
        "endLineNumber" : 505,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n  returnType=ConsumeReturnType.TIME_OUT;\n}\n else if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n  returnType=ConsumeReturnType.FAILED;\n}\n else if (ConsumeOrderlyStatus.SUCCESS == status) {\n  returnType=ConsumeReturnType.SUCCESS;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 42,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 845,
        "startLineNumber" : 493,
        "startColumnNumber" : 28,
        "endLineNumber" : 505,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (null == status) {\n  if (hasException) {\n    returnType=ConsumeReturnType.EXCEPTION;\n  }\n else {\n    returnType=ConsumeReturnType.RETURNNULL;\n  }\n}\n else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n  returnType=ConsumeReturnType.TIME_OUT;\n}\n else if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n  returnType=ConsumeReturnType.FAILED;\n}\n else if (ConsumeOrderlyStatus.SUCCESS == status) {\n  returnType=ConsumeReturnType.SUCCESS;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 63,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 5419,
        "startLineNumber" : 442,
        "startColumnNumber" : 45,
        "endLineNumber" : 526,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n  ConsumeOrderlyStatus status=null;\n  ConsumeMessageContext consumeMessageContext=null;\n  if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n    consumeMessageContext=new ConsumeMessageContext();\n    consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n    consumeMessageContext.setMq(messageQueue);\n    consumeMessageContext.setMsgList(msgs);\n    consumeMessageContext.setSuccess(false);\n    consumeMessageContext.setProps(new HashMap<String,String>());\n    ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n  }\n  long beginTimestamp=System.currentTimeMillis();\n  ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n  boolean hasException=false;\n  try {\n    this.processQueue.getLockConsume().lock();\n    if (this.processQueue.isDropped()) {\n      log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n      break;\n    }\n    status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n  }\n catch (  Throwable e) {\n    log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n    hasException=true;\n  }\n finally {\n    this.processQueue.getLockConsume().unlock();\n  }\n  if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n    log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n  }\n  long consumeRT=System.currentTimeMillis() - beginTimestamp;\n  if (null == status) {\n    if (hasException) {\n      returnType=ConsumeReturnType.EXCEPTION;\n    }\n else {\n      returnType=ConsumeReturnType.RETURNNULL;\n    }\n  }\n else   if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n    returnType=ConsumeReturnType.TIME_OUT;\n  }\n else   if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n    returnType=ConsumeReturnType.FAILED;\n  }\n else   if (ConsumeOrderlyStatus.SUCCESS == status) {\n    returnType=ConsumeReturnType.SUCCESS;\n  }\n  if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n    consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n  }\n  if (null == status) {\n    status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n  }\n  if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n    consumeMessageContext.setStatus(status.toString());\n    consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n    ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n  }\n  ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n  continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 370,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5526,
        "startLineNumber" : 442,
        "startColumnNumber" : 24,
        "endLineNumber" : 528,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (!msgs.isEmpty()) {\n  final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n  ConsumeOrderlyStatus status=null;\n  ConsumeMessageContext consumeMessageContext=null;\n  if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n    consumeMessageContext=new ConsumeMessageContext();\n    consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n    consumeMessageContext.setMq(messageQueue);\n    consumeMessageContext.setMsgList(msgs);\n    consumeMessageContext.setSuccess(false);\n    consumeMessageContext.setProps(new HashMap<String,String>());\n    ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n  }\n  long beginTimestamp=System.currentTimeMillis();\n  ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n  boolean hasException=false;\n  try {\n    this.processQueue.getLockConsume().lock();\n    if (this.processQueue.isDropped()) {\n      log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n      break;\n    }\n    status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n  }\n catch (  Throwable e) {\n    log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n    hasException=true;\n  }\n finally {\n    this.processQueue.getLockConsume().unlock();\n  }\n  if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n    log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n  }\n  long consumeRT=System.currentTimeMillis() - beginTimestamp;\n  if (null == status) {\n    if (hasException) {\n      returnType=ConsumeReturnType.EXCEPTION;\n    }\n else {\n      returnType=ConsumeReturnType.RETURNNULL;\n    }\n  }\n else   if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n    returnType=ConsumeReturnType.TIME_OUT;\n  }\n else   if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n    returnType=ConsumeReturnType.FAILED;\n  }\n else   if (ConsumeOrderlyStatus.SUCCESS == status) {\n    returnType=ConsumeReturnType.SUCCESS;\n  }\n  if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n    consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n  }\n  if (null == status) {\n    status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n  }\n  if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n    consumeMessageContext.setStatus(status.toString());\n    consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n    ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n  }\n  ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n  continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n}\n else {\n  continueConsume=false;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 380,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 7437,
        "startLineNumber" : 412,
        "startColumnNumber" : 76,
        "endLineNumber" : 529,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (this.processQueue.isDropped()) {\n    log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n    break;\n  }\n  if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) {\n    log.warn(\"the message queue not locked, so consume later, {}\",this.messageQueue);\n    ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n    break;\n  }\n  if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) {\n    log.warn(\"the message queue lock expired, so consume later, {}\",this.messageQueue);\n    ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n    break;\n  }\n  long interval=System.currentTimeMillis() - beginTime;\n  if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n    ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue,messageQueue,10);\n    break;\n  }\n  final int consumeBatchSize=ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n  List<MessageExt> msgs=this.processQueue.takeMessags(consumeBatchSize);\n  if (!msgs.isEmpty()) {\n    final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n    ConsumeOrderlyStatus status=null;\n    ConsumeMessageContext consumeMessageContext=null;\n    if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n      consumeMessageContext=new ConsumeMessageContext();\n      consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n      consumeMessageContext.setMq(messageQueue);\n      consumeMessageContext.setMsgList(msgs);\n      consumeMessageContext.setSuccess(false);\n      consumeMessageContext.setProps(new HashMap<String,String>());\n      ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n    }\n    long beginTimestamp=System.currentTimeMillis();\n    ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n    boolean hasException=false;\n    try {\n      this.processQueue.getLockConsume().lock();\n      if (this.processQueue.isDropped()) {\n        log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n        break;\n      }\n      status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n    }\n catch (    Throwable e) {\n      log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n      hasException=true;\n    }\n finally {\n      this.processQueue.getLockConsume().unlock();\n    }\n    if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n      log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n    }\n    long consumeRT=System.currentTimeMillis() - beginTimestamp;\n    if (null == status) {\n      if (hasException) {\n        returnType=ConsumeReturnType.EXCEPTION;\n      }\n else {\n        returnType=ConsumeReturnType.RETURNNULL;\n      }\n    }\n else     if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n      returnType=ConsumeReturnType.TIME_OUT;\n    }\n else     if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n      returnType=ConsumeReturnType.FAILED;\n    }\n else     if (ConsumeOrderlyStatus.SUCCESS == status) {\n      returnType=ConsumeReturnType.SUCCESS;\n    }\n    if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n      consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n    }\n    if (null == status) {\n      status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n    }\n    if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n      consumeMessageContext.setStatus(status.toString());\n      consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n      ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n    }\n    ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n    continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n  }\n else {\n    continueConsume=false;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 526,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7493,
        "startLineNumber" : 412,
        "startColumnNumber" : 20,
        "endLineNumber" : 529,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (boolean continueConsume=true; continueConsume; ) {\n  if (this.processQueue.isDropped()) {\n    log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n    break;\n  }\n  if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) {\n    log.warn(\"the message queue not locked, so consume later, {}\",this.messageQueue);\n    ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n    break;\n  }\n  if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) {\n    log.warn(\"the message queue lock expired, so consume later, {}\",this.messageQueue);\n    ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n    break;\n  }\n  long interval=System.currentTimeMillis() - beginTime;\n  if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n    ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue,messageQueue,10);\n    break;\n  }\n  final int consumeBatchSize=ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n  List<MessageExt> msgs=this.processQueue.takeMessags(consumeBatchSize);\n  if (!msgs.isEmpty()) {\n    final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n    ConsumeOrderlyStatus status=null;\n    ConsumeMessageContext consumeMessageContext=null;\n    if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n      consumeMessageContext=new ConsumeMessageContext();\n      consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n      consumeMessageContext.setMq(messageQueue);\n      consumeMessageContext.setMsgList(msgs);\n      consumeMessageContext.setSuccess(false);\n      consumeMessageContext.setProps(new HashMap<String,String>());\n      ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n    }\n    long beginTimestamp=System.currentTimeMillis();\n    ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n    boolean hasException=false;\n    try {\n      this.processQueue.getLockConsume().lock();\n      if (this.processQueue.isDropped()) {\n        log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n        break;\n      }\n      status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n    }\n catch (    Throwable e) {\n      log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n      hasException=true;\n    }\n finally {\n      this.processQueue.getLockConsume().unlock();\n    }\n    if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n      log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n    }\n    long consumeRT=System.currentTimeMillis() - beginTimestamp;\n    if (null == status) {\n      if (hasException) {\n        returnType=ConsumeReturnType.EXCEPTION;\n      }\n else {\n        returnType=ConsumeReturnType.RETURNNULL;\n      }\n    }\n else     if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n      returnType=ConsumeReturnType.TIME_OUT;\n    }\n else     if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n      returnType=ConsumeReturnType.FAILED;\n    }\n else     if (ConsumeOrderlyStatus.SUCCESS == status) {\n      returnType=ConsumeReturnType.SUCCESS;\n    }\n    if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n      consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n    }\n    if (null == status) {\n      status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n    }\n    if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n      consumeMessageContext.setStatus(status.toString());\n      consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n      ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n    }\n    ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n    continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n  }\n else {\n    continueConsume=false;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 533,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7604,
        "startLineNumber" : 410,
        "startColumnNumber" : 93,
        "endLineNumber" : 530,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  final long beginTime=System.currentTimeMillis();\n  for (boolean continueConsume=true; continueConsume; ) {\n    if (this.processQueue.isDropped()) {\n      log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n      break;\n    }\n    if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) {\n      log.warn(\"the message queue not locked, so consume later, {}\",this.messageQueue);\n      ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n      break;\n    }\n    if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) {\n      log.warn(\"the message queue lock expired, so consume later, {}\",this.messageQueue);\n      ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n      break;\n    }\n    long interval=System.currentTimeMillis() - beginTime;\n    if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n      ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue,messageQueue,10);\n      break;\n    }\n    final int consumeBatchSize=ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n    List<MessageExt> msgs=this.processQueue.takeMessags(consumeBatchSize);\n    if (!msgs.isEmpty()) {\n      final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n      ConsumeOrderlyStatus status=null;\n      ConsumeMessageContext consumeMessageContext=null;\n      if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n        consumeMessageContext=new ConsumeMessageContext();\n        consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n        consumeMessageContext.setMq(messageQueue);\n        consumeMessageContext.setMsgList(msgs);\n        consumeMessageContext.setSuccess(false);\n        consumeMessageContext.setProps(new HashMap<String,String>());\n        ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n      }\n      long beginTimestamp=System.currentTimeMillis();\n      ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n      boolean hasException=false;\n      try {\n        this.processQueue.getLockConsume().lock();\n        if (this.processQueue.isDropped()) {\n          log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n          break;\n        }\n        status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n      }\n catch (      Throwable e) {\n        log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n        hasException=true;\n      }\n finally {\n        this.processQueue.getLockConsume().unlock();\n      }\n      if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n        log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n      }\n      long consumeRT=System.currentTimeMillis() - beginTimestamp;\n      if (null == status) {\n        if (hasException) {\n          returnType=ConsumeReturnType.EXCEPTION;\n        }\n else {\n          returnType=ConsumeReturnType.RETURNNULL;\n        }\n      }\n else       if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n        returnType=ConsumeReturnType.TIME_OUT;\n      }\n else       if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n        returnType=ConsumeReturnType.FAILED;\n      }\n else       if (ConsumeOrderlyStatus.SUCCESS == status) {\n        returnType=ConsumeReturnType.SUCCESS;\n      }\n      if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n        consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n      }\n      if (null == status) {\n        status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n      }\n      if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n        consumeMessageContext.setStatus(status.toString());\n        consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n        ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n      }\n      ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n      continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n    }\n else {\n      continueConsume=false;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 542,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8193,
        "startLineNumber" : 409,
        "startColumnNumber" : 16,
        "endLineNumber" : 537,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {\n  final long beginTime=System.currentTimeMillis();\n  for (boolean continueConsume=true; continueConsume; ) {\n    if (this.processQueue.isDropped()) {\n      log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n      break;\n    }\n    if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) {\n      log.warn(\"the message queue not locked, so consume later, {}\",this.messageQueue);\n      ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n      break;\n    }\n    if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) {\n      log.warn(\"the message queue lock expired, so consume later, {}\",this.messageQueue);\n      ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n      break;\n    }\n    long interval=System.currentTimeMillis() - beginTime;\n    if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n      ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue,messageQueue,10);\n      break;\n    }\n    final int consumeBatchSize=ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n    List<MessageExt> msgs=this.processQueue.takeMessags(consumeBatchSize);\n    if (!msgs.isEmpty()) {\n      final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n      ConsumeOrderlyStatus status=null;\n      ConsumeMessageContext consumeMessageContext=null;\n      if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n        consumeMessageContext=new ConsumeMessageContext();\n        consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n        consumeMessageContext.setMq(messageQueue);\n        consumeMessageContext.setMsgList(msgs);\n        consumeMessageContext.setSuccess(false);\n        consumeMessageContext.setProps(new HashMap<String,String>());\n        ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n      }\n      long beginTimestamp=System.currentTimeMillis();\n      ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n      boolean hasException=false;\n      try {\n        this.processQueue.getLockConsume().lock();\n        if (this.processQueue.isDropped()) {\n          log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n          break;\n        }\n        status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n      }\n catch (      Throwable e) {\n        log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n        hasException=true;\n      }\n finally {\n        this.processQueue.getLockConsume().unlock();\n      }\n      if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n        log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n      }\n      long consumeRT=System.currentTimeMillis() - beginTimestamp;\n      if (null == status) {\n        if (hasException) {\n          returnType=ConsumeReturnType.EXCEPTION;\n        }\n else {\n          returnType=ConsumeReturnType.RETURNNULL;\n        }\n      }\n else       if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n        returnType=ConsumeReturnType.TIME_OUT;\n      }\n else       if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n        returnType=ConsumeReturnType.FAILED;\n      }\n else       if (ConsumeOrderlyStatus.SUCCESS == status) {\n        returnType=ConsumeReturnType.SUCCESS;\n      }\n      if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n        consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n      }\n      if (null == status) {\n        status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n      }\n      if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n        consumeMessageContext.setStatus(status.toString());\n        consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n        ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n      }\n      ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n      continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n    }\n else {\n      continueConsume=false;\n    }\n  }\n}\n else {\n  if (this.processQueue.isDropped()) {\n    log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n    return;\n  }\n  ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,100);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 597,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.SynchronizedStatement,body]",
      "nodePosition" : {
        "charLength" : 8225,
        "startLineNumber" : 408,
        "startColumnNumber" : 35,
        "endLineNumber" : 538,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {\n    final long beginTime=System.currentTimeMillis();\n    for (boolean continueConsume=true; continueConsume; ) {\n      if (this.processQueue.isDropped()) {\n        log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n        break;\n      }\n      if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) {\n        log.warn(\"the message queue not locked, so consume later, {}\",this.messageQueue);\n        ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n        break;\n      }\n      if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) {\n        log.warn(\"the message queue lock expired, so consume later, {}\",this.messageQueue);\n        ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n        break;\n      }\n      long interval=System.currentTimeMillis() - beginTime;\n      if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n        ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue,messageQueue,10);\n        break;\n      }\n      final int consumeBatchSize=ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n      List<MessageExt> msgs=this.processQueue.takeMessags(consumeBatchSize);\n      if (!msgs.isEmpty()) {\n        final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n        ConsumeOrderlyStatus status=null;\n        ConsumeMessageContext consumeMessageContext=null;\n        if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n          consumeMessageContext=new ConsumeMessageContext();\n          consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n          consumeMessageContext.setMq(messageQueue);\n          consumeMessageContext.setMsgList(msgs);\n          consumeMessageContext.setSuccess(false);\n          consumeMessageContext.setProps(new HashMap<String,String>());\n          ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n        }\n        long beginTimestamp=System.currentTimeMillis();\n        ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n        boolean hasException=false;\n        try {\n          this.processQueue.getLockConsume().lock();\n          if (this.processQueue.isDropped()) {\n            log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n            break;\n          }\n          status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n        }\n catch (        Throwable e) {\n          log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n          hasException=true;\n        }\n finally {\n          this.processQueue.getLockConsume().unlock();\n        }\n        if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n          log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n        }\n        long consumeRT=System.currentTimeMillis() - beginTimestamp;\n        if (null == status) {\n          if (hasException) {\n            returnType=ConsumeReturnType.EXCEPTION;\n          }\n else {\n            returnType=ConsumeReturnType.RETURNNULL;\n          }\n        }\n else         if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n          returnType=ConsumeReturnType.TIME_OUT;\n        }\n else         if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n          returnType=ConsumeReturnType.FAILED;\n        }\n else         if (ConsumeOrderlyStatus.SUCCESS == status) {\n          returnType=ConsumeReturnType.SUCCESS;\n        }\n        if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n          consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n        }\n        if (null == status) {\n          status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n        }\n        if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n          consumeMessageContext.setStatus(status.toString());\n          consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n          ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n        }\n        ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n        continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n      }\n else {\n        continueConsume=false;\n      }\n    }\n  }\n else {\n    if (this.processQueue.isDropped()) {\n      log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n      return;\n    }\n    ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,100);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 598,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8248,
        "startLineNumber" : 408,
        "startColumnNumber" : 12,
        "endLineNumber" : 538,
        "endColumnNumber" : 13
      },
      "nodeContext" : "synchronized (objLock) {\n  if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {\n    final long beginTime=System.currentTimeMillis();\n    for (boolean continueConsume=true; continueConsume; ) {\n      if (this.processQueue.isDropped()) {\n        log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n        break;\n      }\n      if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) {\n        log.warn(\"the message queue not locked, so consume later, {}\",this.messageQueue);\n        ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n        break;\n      }\n      if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) {\n        log.warn(\"the message queue lock expired, so consume later, {}\",this.messageQueue);\n        ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n        break;\n      }\n      long interval=System.currentTimeMillis() - beginTime;\n      if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n        ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue,messageQueue,10);\n        break;\n      }\n      final int consumeBatchSize=ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n      List<MessageExt> msgs=this.processQueue.takeMessags(consumeBatchSize);\n      if (!msgs.isEmpty()) {\n        final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n        ConsumeOrderlyStatus status=null;\n        ConsumeMessageContext consumeMessageContext=null;\n        if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n          consumeMessageContext=new ConsumeMessageContext();\n          consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n          consumeMessageContext.setMq(messageQueue);\n          consumeMessageContext.setMsgList(msgs);\n          consumeMessageContext.setSuccess(false);\n          consumeMessageContext.setProps(new HashMap<String,String>());\n          ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n        }\n        long beginTimestamp=System.currentTimeMillis();\n        ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n        boolean hasException=false;\n        try {\n          this.processQueue.getLockConsume().lock();\n          if (this.processQueue.isDropped()) {\n            log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n            break;\n          }\n          status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n        }\n catch (        Throwable e) {\n          log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n          hasException=true;\n        }\n finally {\n          this.processQueue.getLockConsume().unlock();\n        }\n        if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n          log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n        }\n        long consumeRT=System.currentTimeMillis() - beginTimestamp;\n        if (null == status) {\n          if (hasException) {\n            returnType=ConsumeReturnType.EXCEPTION;\n          }\n else {\n            returnType=ConsumeReturnType.RETURNNULL;\n          }\n        }\n else         if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n          returnType=ConsumeReturnType.TIME_OUT;\n        }\n else         if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n          returnType=ConsumeReturnType.FAILED;\n        }\n else         if (ConsumeOrderlyStatus.SUCCESS == status) {\n          returnType=ConsumeReturnType.SUCCESS;\n        }\n        if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n          consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n        }\n        if (null == status) {\n          status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n        }\n        if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n          consumeMessageContext.setStatus(status.toString());\n          consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n          ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n        }\n        ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n        continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n      }\n else {\n        continueConsume=false;\n      }\n    }\n  }\n else {\n    if (this.processQueue.isDropped()) {\n      log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n      return;\n    }\n    ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,100);\n  }\n}\n",
      "nodeType" : "SynchronizedStatement",
      "astNodeNumber" : 600,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8568,
        "startLineNumber" : 401,
        "startColumnNumber" : 26,
        "endLineNumber" : 539,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  if (this.processQueue.isDropped()) {\n    log.warn(\"run, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n    return;\n  }\n  final Object objLock=messageQueueLock.fetchLockObject(this.messageQueue);\nsynchronized (objLock) {\n    if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {\n      final long beginTime=System.currentTimeMillis();\n      for (boolean continueConsume=true; continueConsume; ) {\n        if (this.processQueue.isDropped()) {\n          log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n          break;\n        }\n        if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) {\n          log.warn(\"the message queue not locked, so consume later, {}\",this.messageQueue);\n          ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n          break;\n        }\n        if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) {\n          log.warn(\"the message queue lock expired, so consume later, {}\",this.messageQueue);\n          ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n          break;\n        }\n        long interval=System.currentTimeMillis() - beginTime;\n        if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n          ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue,messageQueue,10);\n          break;\n        }\n        final int consumeBatchSize=ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n        List<MessageExt> msgs=this.processQueue.takeMessags(consumeBatchSize);\n        if (!msgs.isEmpty()) {\n          final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n          ConsumeOrderlyStatus status=null;\n          ConsumeMessageContext consumeMessageContext=null;\n          if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n            consumeMessageContext=new ConsumeMessageContext();\n            consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n            consumeMessageContext.setMq(messageQueue);\n            consumeMessageContext.setMsgList(msgs);\n            consumeMessageContext.setSuccess(false);\n            consumeMessageContext.setProps(new HashMap<String,String>());\n            ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n          }\n          long beginTimestamp=System.currentTimeMillis();\n          ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n          boolean hasException=false;\n          try {\n            this.processQueue.getLockConsume().lock();\n            if (this.processQueue.isDropped()) {\n              log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n              break;\n            }\n            status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n          }\n catch (          Throwable e) {\n            log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n            hasException=true;\n          }\n finally {\n            this.processQueue.getLockConsume().unlock();\n          }\n          if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n            log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n          }\n          long consumeRT=System.currentTimeMillis() - beginTimestamp;\n          if (null == status) {\n            if (hasException) {\n              returnType=ConsumeReturnType.EXCEPTION;\n            }\n else {\n              returnType=ConsumeReturnType.RETURNNULL;\n            }\n          }\n else           if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n            returnType=ConsumeReturnType.TIME_OUT;\n          }\n else           if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n            returnType=ConsumeReturnType.FAILED;\n          }\n else           if (ConsumeOrderlyStatus.SUCCESS == status) {\n            returnType=ConsumeReturnType.SUCCESS;\n          }\n          if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n            consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n          }\n          if (null == status) {\n            status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n          }\n          if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n            consumeMessageContext.setStatus(status.toString());\n            consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n            ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n          }\n          ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n          continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n        }\n else {\n          continueConsume=false;\n        }\n      }\n    }\n else {\n      if (this.processQueue.isDropped()) {\n        log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n        return;\n      }\n      ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,100);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 629,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8604,
        "startLineNumber" : 400,
        "startColumnNumber" : 8,
        "endLineNumber" : 539,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(){\n  if (this.processQueue.isDropped()) {\n    log.warn(\"run, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n    return;\n  }\n  final Object objLock=messageQueueLock.fetchLockObject(this.messageQueue);\nsynchronized (objLock) {\n    if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {\n      final long beginTime=System.currentTimeMillis();\n      for (boolean continueConsume=true; continueConsume; ) {\n        if (this.processQueue.isDropped()) {\n          log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n          break;\n        }\n        if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) {\n          log.warn(\"the message queue not locked, so consume later, {}\",this.messageQueue);\n          ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n          break;\n        }\n        if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) {\n          log.warn(\"the message queue lock expired, so consume later, {}\",this.messageQueue);\n          ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,10);\n          break;\n        }\n        long interval=System.currentTimeMillis() - beginTime;\n        if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n          ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue,messageQueue,10);\n          break;\n        }\n        final int consumeBatchSize=ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n        List<MessageExt> msgs=this.processQueue.takeMessags(consumeBatchSize);\n        if (!msgs.isEmpty()) {\n          final ConsumeOrderlyContext context=new ConsumeOrderlyContext(this.messageQueue);\n          ConsumeOrderlyStatus status=null;\n          ConsumeMessageContext consumeMessageContext=null;\n          if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n            consumeMessageContext=new ConsumeMessageContext();\n            consumeMessageContext.setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup());\n            consumeMessageContext.setMq(messageQueue);\n            consumeMessageContext.setMsgList(msgs);\n            consumeMessageContext.setSuccess(false);\n            consumeMessageContext.setProps(new HashMap<String,String>());\n            ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n          }\n          long beginTimestamp=System.currentTimeMillis();\n          ConsumeReturnType returnType=ConsumeReturnType.SUCCESS;\n          boolean hasException=false;\n          try {\n            this.processQueue.getLockConsume().lock();\n            if (this.processQueue.isDropped()) {\n              log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n              break;\n            }\n            status=messageListener.consumeMessage(Collections.unmodifiableList(msgs),context);\n          }\n catch (          Throwable e) {\n            log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",RemotingHelper.exceptionSimpleDesc(e),ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n            hasException=true;\n          }\n finally {\n            this.processQueue.getLockConsume().unlock();\n          }\n          if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n            log.warn(\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\",ConsumeMessageOrderlyService.this.consumerGroup,msgs,messageQueue);\n          }\n          long consumeRT=System.currentTimeMillis() - beginTimestamp;\n          if (null == status) {\n            if (hasException) {\n              returnType=ConsumeReturnType.EXCEPTION;\n            }\n else {\n              returnType=ConsumeReturnType.RETURNNULL;\n            }\n          }\n else           if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n            returnType=ConsumeReturnType.TIME_OUT;\n          }\n else           if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) {\n            returnType=ConsumeReturnType.FAILED;\n          }\n else           if (ConsumeOrderlyStatus.SUCCESS == status) {\n            returnType=ConsumeReturnType.SUCCESS;\n          }\n          if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n            consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE,returnType.name());\n          }\n          if (null == status) {\n            status=ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n          }\n          if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n            consumeMessageContext.setStatus(status.toString());\n            consumeMessageContext.setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status);\n            ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n          }\n          ConsumeMessageOrderlyService.this.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup,messageQueue.getTopic(),consumeRT);\n          continueConsume=ConsumeMessageOrderlyService.this.processConsumeResult(msgs,status,context,this);\n        }\n else {\n          continueConsume=false;\n        }\n      }\n    }\n else {\n      if (this.processQueue.isDropped()) {\n        log.warn(\"the message queue not be able to consume, because it's dropped. {}\",this.messageQueue);\n        return;\n      }\n      ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue,this.processQueue,100);\n    }\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 635,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 66,
        "startLineNumber" : 499,
        "startColumnNumber" : 39,
        "endLineNumber" : 499,
        "endColumnNumber" : 105
      },
      "nodeContext" : "consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "org.apache.rocketmq.client.consumer.DefaultMQPushConsumer"
  } ],
  "positionList" : [ {
    "charLength" : 21,
    "startLineNumber" : 499,
    "startColumnNumber" : 52,
    "endLineNumber" : 499,
    "endColumnNumber" : 73
  } ],
  "layoutRelationDataList" : [ ]
}