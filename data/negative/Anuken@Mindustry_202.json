{
  "id" : 202,
  "expression" : "unit",
  "projectName" : "Anuken@Mindustry",
  "commitID" : "6807b589a333a4204e542f811dfdf2cc82d0a8d4",
  "filePath" : "core/src/mindustry/logic/LExecutor.java",
  "occurrences" : 34,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 346,
      "startColumnNumber" : 31,
      "endLineNumber" : 346,
      "endColumnNumber" : 35
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 346,
        "startColumnNumber" : 31,
        "endLineNumber" : 346,
        "endColumnNumber" : 59
      },
      "nodeContext" : "unit instanceof Minerc miner",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 117,
        "startLineNumber" : 346,
        "startColumnNumber" : 28,
        "endLineNumber" : 348,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (unit instanceof Minerc miner) {\n  miner.mineTile(null);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 322,
        "startLineNumber" : 345,
        "startColumnNumber" : 53,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (unit instanceof   Minerc miner) {\n    miner.mineTile(null);\n  }\n  if (unit instanceof   Builderc build) {\n    build.clearBuilding();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 26,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 351,
        "startLineNumber" : 345,
        "startColumnNumber" : 24,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (type == LUnitControl.stop) {\n  if (unit instanceof   Minerc miner) {\n    miner.mineTile(null);\n  }\n  if (unit instanceof   Builderc build) {\n    build.clearBuilding();\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 32,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 731,
        "startLineNumber" : 336,
        "startColumnNumber" : 49,
        "endLineNumber" : 353,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  ai.control=type;\n  ai.moveX=exec.numf(p1);\n  ai.moveY=exec.numf(p2);\n  if (type == LUnitControl.approach) {\n    ai.moveRad=exec.numf(p3);\n  }\n  if (type == LUnitControl.stop) {\n    if (unit instanceof     Minerc miner) {\n      miner.mineTile(null);\n    }\n    if (unit instanceof     Builderc build) {\n      build.clearBuilding();\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 73,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 346,
        "startColumnNumber" : 31,
        "endLineNumber" : 346,
        "endColumnNumber" : 59
      },
      "nodeContext" : "unit instanceof Minerc miner",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 349,
      "startColumnNumber" : 31,
      "endLineNumber" : 349,
      "endColumnNumber" : 35
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 30,
        "startLineNumber" : 349,
        "startColumnNumber" : 31,
        "endLineNumber" : 349,
        "endColumnNumber" : 61
      },
      "nodeContext" : "unit instanceof Builderc build",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 120,
        "startLineNumber" : 349,
        "startColumnNumber" : 28,
        "endLineNumber" : 351,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (unit instanceof Builderc build) {\n  build.clearBuilding();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 322,
        "startLineNumber" : 345,
        "startColumnNumber" : 53,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (unit instanceof   Minerc miner) {\n    miner.mineTile(null);\n  }\n  if (unit instanceof   Builderc build) {\n    build.clearBuilding();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 26,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 351,
        "startLineNumber" : 345,
        "startColumnNumber" : 24,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (type == LUnitControl.stop) {\n  if (unit instanceof   Minerc miner) {\n    miner.mineTile(null);\n  }\n  if (unit instanceof   Builderc build) {\n    build.clearBuilding();\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 32,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 731,
        "startLineNumber" : 336,
        "startColumnNumber" : 49,
        "endLineNumber" : 353,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  ai.control=type;\n  ai.moveX=exec.numf(p1);\n  ai.moveY=exec.numf(p2);\n  if (type == LUnitControl.approach) {\n    ai.moveRad=exec.numf(p3);\n  }\n  if (type == LUnitControl.stop) {\n    if (unit instanceof     Minerc miner) {\n      miner.mineTile(null);\n    }\n    if (unit instanceof     Builderc build) {\n      build.clearBuilding();\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 73,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 30,
        "startLineNumber" : 349,
        "startColumnNumber" : 31,
        "endLineNumber" : 349,
        "endColumnNumber" : 61
      },
      "nodeContext" : "unit instanceof Builderc build",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 355,
      "startColumnNumber" : 40,
      "endLineNumber" : 355,
      "endColumnNumber" : 44
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,expression]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 355,
        "startColumnNumber" : 40,
        "endLineNumber" : 355,
        "endColumnNumber" : 96
      },
      "nodeContext" : "unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 15,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 355,
        "startColumnNumber" : 40,
        "endLineNumber" : 355,
        "endColumnNumber" : 104
      },
      "nodeContext" : "unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 18,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 355,
        "startColumnNumber" : 24,
        "endLineNumber" : 355,
        "endColumnNumber" : 105
      },
      "nodeContext" : "exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 22,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 355,
        "startColumnNumber" : 24,
        "endLineNumber" : 355,
        "endColumnNumber" : 106
      },
      "nodeContext" : "exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 23,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 130,
        "startLineNumber" : 354,
        "startColumnNumber" : 35,
        "endLineNumber" : 356,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 24,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 355,
        "startColumnNumber" : 24,
        "endLineNumber" : 355,
        "endColumnNumber" : 106
      },
      "nodeContext" : "exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 23,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 375,
      "startColumnNumber" : 24,
      "endLineNumber" : 375,
      "endColumnNumber" : 28
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,leftHandSide]",
      "nodePosition" : {
        "charLength" : 9,
        "startLineNumber" : 375,
        "startColumnNumber" : 24,
        "endLineNumber" : 375,
        "endColumnNumber" : 33
      },
      "nodeContext" : "unit.flag",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 24,
        "startLineNumber" : 375,
        "startColumnNumber" : 24,
        "endLineNumber" : 375,
        "endColumnNumber" : 48
      },
      "nodeContext" : "unit.flag=exec.num(p1)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 375,
        "startColumnNumber" : 24,
        "endLineNumber" : 375,
        "endColumnNumber" : 49
      },
      "nodeContext" : "unit.flag=exec.num(p1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 73,
        "startLineNumber" : 374,
        "startColumnNumber" : 33,
        "endLineNumber" : 376,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  unit.flag=exec.num(p1);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 375,
        "startColumnNumber" : 24,
        "endLineNumber" : 375,
        "endColumnNumber" : 49
      },
      "nodeContext" : "unit.flag=exec.num(p1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 379,
      "startColumnNumber" : 27,
      "endLineNumber" : 379,
      "endColumnNumber" : 31
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 379,
        "startColumnNumber" : 27,
        "endLineNumber" : 379,
        "endColumnNumber" : 55
      },
      "nodeContext" : "unit instanceof Minerc miner",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 140,
        "startLineNumber" : 379,
        "startColumnNumber" : 24,
        "endLineNumber" : 381,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Minerc miner) {\n  miner.mineTile(miner.validMine(tile) ? tile : null);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 271,
        "startLineNumber" : 377,
        "startColumnNumber" : 33,
        "endLineNumber" : 382,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Tile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\n  if (unit instanceof   Minerc miner) {\n    miner.mineTile(miner.validMine(tile) ? tile : null);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 36,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 379,
        "startColumnNumber" : 27,
        "endLineNumber" : 379,
        "endColumnNumber" : 55
      },
      "nodeContext" : "unit instanceof Minerc miner",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 386,
      "startColumnNumber" : 27,
      "endLineNumber" : 386,
      "endColumnNumber" : 31
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 386,
        "startColumnNumber" : 27,
        "endLineNumber" : 386,
        "endColumnNumber" : 55
      },
      "nodeContext" : "unit instanceof Payloadc pay",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 386,
        "startColumnNumber" : 27,
        "endLineNumber" : 386,
        "endColumnNumber" : 75
      },
      "nodeContext" : "unit instanceof Payloadc pay && pay.hasPayload()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 215,
        "startLineNumber" : 386,
        "startColumnNumber" : 24,
        "endLineNumber" : 389,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay && pay.hasPayload()) {\n  Call.payloadDropped(unit,unit.x,unit.y);\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 31,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 316,
        "startLineNumber" : 383,
        "startColumnNumber" : 36,
        "endLineNumber" : 390,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay && pay.hasPayload()) {\n    Call.payloadDropped(unit,unit.x,unit.y);\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 39,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 386,
        "startColumnNumber" : 27,
        "endLineNumber" : 386,
        "endColumnNumber" : 75
      },
      "nodeContext" : "unit instanceof Payloadc pay && pay.hasPayload()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 10,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 387,
      "startColumnNumber" : 48,
      "endLineNumber" : 387,
      "endColumnNumber" : 52
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 387,
        "startColumnNumber" : 28,
        "endLineNumber" : 387,
        "endColumnNumber" : 69
      },
      "nodeContext" : "Call.payloadDropped(unit,unit.x,unit.y)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 10,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 387,
        "startColumnNumber" : 28,
        "endLineNumber" : 387,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Call.payloadDropped(unit,unit.x,unit.y);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 163,
        "startLineNumber" : 386,
        "startColumnNumber" : 76,
        "endLineNumber" : 389,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Call.payloadDropped(unit,unit.x,unit.y);\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 20,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 215,
        "startLineNumber" : 386,
        "startColumnNumber" : 24,
        "endLineNumber" : 389,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay && pay.hasPayload()) {\n  Call.payloadDropped(unit,unit.x,unit.y);\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 31,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 316,
        "startLineNumber" : 383,
        "startColumnNumber" : 36,
        "endLineNumber" : 390,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay && pay.hasPayload()) {\n    Call.payloadDropped(unit,unit.x,unit.y);\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 39,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 387,
        "startColumnNumber" : 28,
        "endLineNumber" : 387,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Call.payloadDropped(unit,unit.x,unit.y);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 387,
      "startColumnNumber" : 54,
      "endLineNumber" : 387,
      "endColumnNumber" : 58
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 387,
        "startColumnNumber" : 54,
        "endLineNumber" : 387,
        "endColumnNumber" : 60
      },
      "nodeContext" : "unit.x",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 387,
        "startColumnNumber" : 28,
        "endLineNumber" : 387,
        "endColumnNumber" : 69
      },
      "nodeContext" : "Call.payloadDropped(unit,unit.x,unit.y)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 10,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 387,
        "startColumnNumber" : 28,
        "endLineNumber" : 387,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Call.payloadDropped(unit,unit.x,unit.y);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 163,
        "startLineNumber" : 386,
        "startColumnNumber" : 76,
        "endLineNumber" : 389,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Call.payloadDropped(unit,unit.x,unit.y);\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 20,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 215,
        "startLineNumber" : 386,
        "startColumnNumber" : 24,
        "endLineNumber" : 389,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay && pay.hasPayload()) {\n  Call.payloadDropped(unit,unit.x,unit.y);\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 31,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 316,
        "startLineNumber" : 383,
        "startColumnNumber" : 36,
        "endLineNumber" : 390,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay && pay.hasPayload()) {\n    Call.payloadDropped(unit,unit.x,unit.y);\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 39,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 387,
        "startColumnNumber" : 28,
        "endLineNumber" : 387,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Call.payloadDropped(unit,unit.x,unit.y);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 387,
      "startColumnNumber" : 62,
      "endLineNumber" : 387,
      "endColumnNumber" : 66
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 387,
        "startColumnNumber" : 62,
        "endLineNumber" : 387,
        "endColumnNumber" : 68
      },
      "nodeContext" : "unit.y",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 387,
        "startColumnNumber" : 28,
        "endLineNumber" : 387,
        "endColumnNumber" : 69
      },
      "nodeContext" : "Call.payloadDropped(unit,unit.x,unit.y)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 10,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 387,
        "startColumnNumber" : 28,
        "endLineNumber" : 387,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Call.payloadDropped(unit,unit.x,unit.y);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 163,
        "startLineNumber" : 386,
        "startColumnNumber" : 76,
        "endLineNumber" : 389,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Call.payloadDropped(unit,unit.x,unit.y);\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 20,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 215,
        "startLineNumber" : 386,
        "startColumnNumber" : 24,
        "endLineNumber" : 389,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay && pay.hasPayload()) {\n  Call.payloadDropped(unit,unit.x,unit.y);\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 31,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 316,
        "startLineNumber" : 383,
        "startColumnNumber" : 36,
        "endLineNumber" : 390,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay && pay.hasPayload()) {\n    Call.payloadDropped(unit,unit.x,unit.y);\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 39,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 387,
        "startColumnNumber" : 28,
        "endLineNumber" : 387,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Call.payloadDropped(unit,unit.x,unit.y);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 394,
      "startColumnNumber" : 27,
      "endLineNumber" : 394,
      "endColumnNumber" : 31
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 394,
        "startColumnNumber" : 27,
        "endLineNumber" : 394,
        "endColumnNumber" : 55
      },
      "nodeContext" : "unit instanceof Payloadc pay",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 394,
        "startColumnNumber" : 27,
        "endLineNumber" : 394,
        "endColumnNumber" : 55
      },
      "nodeContext" : "unit instanceof Payloadc pay",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 397,
      "startColumnNumber" : 60,
      "endLineNumber" : 397,
      "endColumnNumber" : 64
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 9,
        "startLineNumber" : 397,
        "startColumnNumber" : 60,
        "endLineNumber" : 397,
        "endColumnNumber" : 69
      },
      "nodeContext" : "unit.team",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 170,
        "startLineNumber" : 397,
        "startColumnNumber" : 46,
        "endLineNumber" : 397,
        "endColumnNumber" : 216
      },
      "nodeContext" : "Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 46,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 179,
        "startLineNumber" : 397,
        "startColumnNumber" : 37,
        "endLineNumber" : 397,
        "endColumnNumber" : 216
      },
      "nodeContext" : "result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f))",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 48,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 185,
        "startLineNumber" : 397,
        "startColumnNumber" : 32,
        "endLineNumber" : 397,
        "endColumnNumber" : 217
      },
      "nodeContext" : "Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 410,
        "startLineNumber" : 396,
        "startColumnNumber" : 45,
        "endLineNumber" : 402,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 63,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 185,
        "startLineNumber" : 397,
        "startColumnNumber" : 32,
        "endLineNumber" : 397,
        "endColumnNumber" : 217
      },
      "nodeContext" : "Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 397,
      "startColumnNumber" : 71,
      "endLineNumber" : 397,
      "endColumnNumber" : 75
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 397,
        "startColumnNumber" : 71,
        "endLineNumber" : 397,
        "endColumnNumber" : 77
      },
      "nodeContext" : "unit.x",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 170,
        "startLineNumber" : 397,
        "startColumnNumber" : 46,
        "endLineNumber" : 397,
        "endColumnNumber" : 216
      },
      "nodeContext" : "Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 46,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 179,
        "startLineNumber" : 397,
        "startColumnNumber" : 37,
        "endLineNumber" : 397,
        "endColumnNumber" : 216
      },
      "nodeContext" : "result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f))",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 48,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 185,
        "startLineNumber" : 397,
        "startColumnNumber" : 32,
        "endLineNumber" : 397,
        "endColumnNumber" : 217
      },
      "nodeContext" : "Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 410,
        "startLineNumber" : 396,
        "startColumnNumber" : 45,
        "endLineNumber" : 402,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 63,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 185,
        "startLineNumber" : 397,
        "startColumnNumber" : 32,
        "endLineNumber" : 397,
        "endColumnNumber" : 217
      },
      "nodeContext" : "Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 397,
      "startColumnNumber" : 79,
      "endLineNumber" : 397,
      "endColumnNumber" : 83
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 397,
        "startColumnNumber" : 79,
        "endLineNumber" : 397,
        "endColumnNumber" : 85
      },
      "nodeContext" : "unit.y",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 170,
        "startLineNumber" : 397,
        "startColumnNumber" : 46,
        "endLineNumber" : 397,
        "endColumnNumber" : 216
      },
      "nodeContext" : "Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 46,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 179,
        "startLineNumber" : 397,
        "startColumnNumber" : 37,
        "endLineNumber" : 397,
        "endColumnNumber" : 216
      },
      "nodeContext" : "result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f))",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 48,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 185,
        "startLineNumber" : 397,
        "startColumnNumber" : 32,
        "endLineNumber" : 397,
        "endColumnNumber" : 217
      },
      "nodeContext" : "Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 410,
        "startLineNumber" : 396,
        "startColumnNumber" : 45,
        "endLineNumber" : 402,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 63,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 185,
        "startLineNumber" : 397,
        "startColumnNumber" : 32,
        "endLineNumber" : 397,
        "endColumnNumber" : 217
      },
      "nodeContext" : "Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 397,
      "startColumnNumber" : 87,
      "endLineNumber" : 397,
      "endColumnNumber" : 91
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.FieldAccess,expression]",
      "nodePosition" : {
        "charLength" : 11,
        "startLineNumber" : 397,
        "startColumnNumber" : 87,
        "endLineNumber" : 397,
        "endColumnNumber" : 98
      },
      "nodeContext" : "unit.type()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 397,
        "startColumnNumber" : 87,
        "endLineNumber" : 397,
        "endColumnNumber" : 106
      },
      "nodeContext" : "unit.type().hitSize",
      "nodeType" : "FieldAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 24,
        "startLineNumber" : 397,
        "startColumnNumber" : 87,
        "endLineNumber" : 397,
        "endColumnNumber" : 111
      },
      "nodeContext" : "unit.type().hitSize * 2f",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 170,
        "startLineNumber" : 397,
        "startColumnNumber" : 46,
        "endLineNumber" : 397,
        "endColumnNumber" : 216
      },
      "nodeContext" : "Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 46,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 179,
        "startLineNumber" : 397,
        "startColumnNumber" : 37,
        "endLineNumber" : 397,
        "endColumnNumber" : 216
      },
      "nodeContext" : "result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f))",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 48,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 185,
        "startLineNumber" : 397,
        "startColumnNumber" : 32,
        "endLineNumber" : 397,
        "endColumnNumber" : 217
      },
      "nodeContext" : "Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 410,
        "startLineNumber" : 396,
        "startColumnNumber" : 45,
        "endLineNumber" : 402,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 63,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 185,
        "startLineNumber" : 397,
        "startColumnNumber" : 32,
        "endLineNumber" : 397,
        "endColumnNumber" : 217
      },
      "nodeContext" : "Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 400,
      "startColumnNumber" : 59,
      "endLineNumber" : 400,
      "endColumnNumber" : 63
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 36,
        "startLineNumber" : 400,
        "startColumnNumber" : 36,
        "endLineNumber" : 400,
        "endColumnNumber" : 72
      },
      "nodeContext" : "Call.pickedUnitPayload(unit,result)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 400,
        "startColumnNumber" : 36,
        "endLineNumber" : 400,
        "endColumnNumber" : 73
      },
      "nodeContext" : "Call.pickedUnitPayload(unit,result);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 109,
        "startLineNumber" : 399,
        "startColumnNumber" : 50,
        "endLineNumber" : 401,
        "endColumnNumber" : 33
      },
      "nodeContext" : "{\n  Call.pickedUnitPayload(unit,result);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 127,
        "startLineNumber" : 399,
        "startColumnNumber" : 32,
        "endLineNumber" : 401,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (result != null) {\n  Call.pickedUnitPayload(unit,result);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 410,
        "startLineNumber" : 396,
        "startColumnNumber" : 45,
        "endLineNumber" : 402,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 63,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 400,
        "startColumnNumber" : 36,
        "endLineNumber" : 400,
        "endColumnNumber" : 73
      },
      "nodeContext" : "Call.pickedUnitPayload(unit,result);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 403,
      "startColumnNumber" : 65,
      "endLineNumber" : 403,
      "endColumnNumber" : 69
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 403,
        "startColumnNumber" : 65,
        "endLineNumber" : 403,
        "endColumnNumber" : 71
      },
      "nodeContext" : "unit.x",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 403,
        "startColumnNumber" : 48,
        "endLineNumber" : 403,
        "endColumnNumber" : 80
      },
      "nodeContext" : "world.buildWorld(unit.x,unit.y)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 9,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 403,
        "startColumnNumber" : 41,
        "endLineNumber" : 403,
        "endColumnNumber" : 80
      },
      "nodeContext" : "tile=world.buildWorld(unit.x,unit.y)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 403,
        "startColumnNumber" : 32,
        "endLineNumber" : 403,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Building tile=world.buildWorld(unit.x,unit.y);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 918,
        "startLineNumber" : 402,
        "startColumnNumber" : 33,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 81,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 403,
        "startColumnNumber" : 32,
        "endLineNumber" : 403,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Building tile=world.buildWorld(unit.x,unit.y);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 403,
      "startColumnNumber" : 73,
      "endLineNumber" : 403,
      "endColumnNumber" : 77
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 403,
        "startColumnNumber" : 73,
        "endLineNumber" : 403,
        "endColumnNumber" : 79
      },
      "nodeContext" : "unit.y",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 403,
        "startColumnNumber" : 48,
        "endLineNumber" : 403,
        "endColumnNumber" : 80
      },
      "nodeContext" : "world.buildWorld(unit.x,unit.y)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 9,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 403,
        "startColumnNumber" : 41,
        "endLineNumber" : 403,
        "endColumnNumber" : 80
      },
      "nodeContext" : "tile=world.buildWorld(unit.x,unit.y)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 403,
        "startColumnNumber" : 32,
        "endLineNumber" : 403,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Building tile=world.buildWorld(unit.x,unit.y);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 918,
        "startLineNumber" : 402,
        "startColumnNumber" : 33,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 81,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 403,
        "startColumnNumber" : 32,
        "endLineNumber" : 403,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Building tile=world.buildWorld(unit.x,unit.y);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 406,
      "startColumnNumber" : 64,
      "endLineNumber" : 406,
      "endColumnNumber" : 68
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 9,
        "startLineNumber" : 406,
        "startColumnNumber" : 64,
        "endLineNumber" : 406,
        "endColumnNumber" : 73
      },
      "nodeContext" : "unit.team",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 406,
        "startColumnNumber" : 51,
        "endLineNumber" : 406,
        "endColumnNumber" : 73
      },
      "nodeContext" : "tile.team == unit.team",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 406,
        "startColumnNumber" : 35,
        "endLineNumber" : 406,
        "endColumnNumber" : 73
      },
      "nodeContext" : "tile != null && tile.team == unit.team",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 703,
        "startLineNumber" : 406,
        "startColumnNumber" : 32,
        "endLineNumber" : 415,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (tile != null && tile.team == unit.team) {\n  if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n    Call.pickedBuildPayload(unit,tile,true);\n  }\n else {\n    Payload current=tile.getPayload();\n    if (current != null && pay.canPickupPayload(current)) {\n      Call.pickedBuildPayload(unit,tile,false);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 66,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 918,
        "startLineNumber" : 402,
        "startColumnNumber" : 33,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 81,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 406,
        "startColumnNumber" : 35,
        "endLineNumber" : 406,
        "endColumnNumber" : 73
      },
      "nodeContext" : "tile != null && tile.team == unit.team",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 408,
      "startColumnNumber" : 64,
      "endLineNumber" : 408,
      "endColumnNumber" : 68
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 408,
        "startColumnNumber" : 40,
        "endLineNumber" : 408,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Call.pickedBuildPayload(unit,tile,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 408,
        "startColumnNumber" : 40,
        "endLineNumber" : 408,
        "endColumnNumber" : 82
      },
      "nodeContext" : "Call.pickedBuildPayload(unit,tile,true);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 122,
        "startLineNumber" : 407,
        "startColumnNumber" : 135,
        "endLineNumber" : 409,
        "endColumnNumber" : 37
      },
      "nodeContext" : "{\n  Call.pickedBuildPayload(unit,tile,true);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 589,
        "startLineNumber" : 407,
        "startColumnNumber" : 36,
        "endLineNumber" : 414,
        "endColumnNumber" : 37
      },
      "nodeContext" : "if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n  Call.pickedBuildPayload(unit,tile,true);\n}\n else {\n  Payload current=tile.getPayload();\n  if (current != null && pay.canPickupPayload(current)) {\n    Call.pickedBuildPayload(unit,tile,false);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 53,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 661,
        "startLineNumber" : 406,
        "startColumnNumber" : 74,
        "endLineNumber" : 415,
        "endColumnNumber" : 33
      },
      "nodeContext" : "{\n  if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n    Call.pickedBuildPayload(unit,tile,true);\n  }\n else {\n    Payload current=tile.getPayload();\n    if (current != null && pay.canPickupPayload(current)) {\n      Call.pickedBuildPayload(unit,tile,false);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 54,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 703,
        "startLineNumber" : 406,
        "startColumnNumber" : 32,
        "endLineNumber" : 415,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (tile != null && tile.team == unit.team) {\n  if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n    Call.pickedBuildPayload(unit,tile,true);\n  }\n else {\n    Payload current=tile.getPayload();\n    if (current != null && pay.canPickupPayload(current)) {\n      Call.pickedBuildPayload(unit,tile,false);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 66,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 918,
        "startLineNumber" : 402,
        "startColumnNumber" : 33,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 81,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 408,
        "startColumnNumber" : 40,
        "endLineNumber" : 408,
        "endColumnNumber" : 82
      },
      "nodeContext" : "Call.pickedBuildPayload(unit,tile,true);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 412,
      "startColumnNumber" : 68,
      "endLineNumber" : 412,
      "endColumnNumber" : 72
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 412,
        "startColumnNumber" : 44,
        "endLineNumber" : 412,
        "endColumnNumber" : 86
      },
      "nodeContext" : "Call.pickedBuildPayload(unit,tile,false)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 412,
        "startColumnNumber" : 44,
        "endLineNumber" : 412,
        "endColumnNumber" : 87
      },
      "nodeContext" : "Call.pickedBuildPayload(unit,tile,false);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 131,
        "startLineNumber" : 411,
        "startColumnNumber" : 92,
        "endLineNumber" : 413,
        "endColumnNumber" : 41
      },
      "nodeContext" : "{\n  Call.pickedBuildPayload(unit,tile,false);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 183,
        "startLineNumber" : 411,
        "startColumnNumber" : 40,
        "endLineNumber" : 413,
        "endColumnNumber" : 41
      },
      "nodeContext" : "if (current != null && pay.canPickupPayload(current)) {\n  Call.pickedBuildPayload(unit,tile,false);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 17,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 364,
        "startLineNumber" : 409,
        "startColumnNumber" : 41,
        "endLineNumber" : 414,
        "endColumnNumber" : 37
      },
      "nodeContext" : "{\n  Payload current=tile.getPayload();\n  if (current != null && pay.canPickupPayload(current)) {\n    Call.pickedBuildPayload(unit,tile,false);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 26,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 589,
        "startLineNumber" : 407,
        "startColumnNumber" : 36,
        "endLineNumber" : 414,
        "endColumnNumber" : 37
      },
      "nodeContext" : "if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n  Call.pickedBuildPayload(unit,tile,true);\n}\n else {\n  Payload current=tile.getPayload();\n  if (current != null && pay.canPickupPayload(current)) {\n    Call.pickedBuildPayload(unit,tile,false);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 53,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 661,
        "startLineNumber" : 406,
        "startColumnNumber" : 74,
        "endLineNumber" : 415,
        "endColumnNumber" : 33
      },
      "nodeContext" : "{\n  if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n    Call.pickedBuildPayload(unit,tile,true);\n  }\n else {\n    Payload current=tile.getPayload();\n    if (current != null && pay.canPickupPayload(current)) {\n      Call.pickedBuildPayload(unit,tile,false);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 54,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 703,
        "startLineNumber" : 406,
        "startColumnNumber" : 32,
        "endLineNumber" : 415,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (tile != null && tile.team == unit.team) {\n  if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n    Call.pickedBuildPayload(unit,tile,true);\n  }\n else {\n    Payload current=tile.getPayload();\n    if (current != null && pay.canPickupPayload(current)) {\n      Call.pickedBuildPayload(unit,tile,false);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 66,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 918,
        "startLineNumber" : 402,
        "startColumnNumber" : 33,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 81,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1349,
        "startLineNumber" : 396,
        "startColumnNumber" : 28,
        "endLineNumber" : 416,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (exec.bool(p1)) {\n  Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n  if (result != null) {\n    Call.pickedUnitPayload(unit,result);\n  }\n}\n else {\n  Building tile=world.buildWorld(unit.x,unit.y);\n  if (tile != null && tile.team == unit.team) {\n    if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n      Call.pickedBuildPayload(unit,tile,true);\n    }\n else {\n      Payload current=tile.getPayload();\n      if (current != null && pay.canPickupPayload(current)) {\n        Call.pickedBuildPayload(unit,tile,false);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 149,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1506,
        "startLineNumber" : 394,
        "startColumnNumber" : 56,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 158,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1538,
        "startLineNumber" : 394,
        "startColumnNumber" : 24,
        "endLineNumber" : 418,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Payloadc pay) {\n  if (exec.bool(p1)) {\n    Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n    if (result != null) {\n      Call.pickedUnitPayload(unit,result);\n    }\n  }\n else {\n    Building tile=world.buildWorld(unit.x,unit.y);\n    if (tile != null && tile.team == unit.team) {\n      if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n        Call.pickedBuildPayload(unit,tile,true);\n      }\n else {\n        Payload current=tile.getPayload();\n        if (current != null && pay.canPickupPayload(current)) {\n          Call.pickedBuildPayload(unit,tile,false);\n        }\n      }\n    }\n  }\n  ai.payTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 165,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1639,
        "startLineNumber" : 391,
        "startColumnNumber" : 36,
        "endLineNumber" : 419,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.payTimer > 0)   return;\n  if (unit instanceof   Payloadc pay) {\n    if (exec.bool(p1)) {\n      Unit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\n      if (result != null) {\n        Call.pickedUnitPayload(unit,result);\n      }\n    }\n else {\n      Building tile=world.buildWorld(unit.x,unit.y);\n      if (tile != null && tile.team == unit.team) {\n        if (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\n          Call.pickedBuildPayload(unit,tile,true);\n        }\n else {\n          Payload current=tile.getPayload();\n          if (current != null && pay.canPickupPayload(current)) {\n            Call.pickedBuildPayload(unit,tile,false);\n          }\n        }\n      }\n    }\n    ai.payTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 173,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 412,
        "startColumnNumber" : 44,
        "endLineNumber" : 412,
        "endColumnNumber" : 87
      },
      "nodeContext" : "Call.pickedBuildPayload(unit,tile,false);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 421,
      "startColumnNumber" : 27,
      "endLineNumber" : 421,
      "endColumnNumber" : 31
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 421,
        "startColumnNumber" : 27,
        "endLineNumber" : 421,
        "endColumnNumber" : 59
      },
      "nodeContext" : "unit instanceof Builderc builder",
      "nodeType" : "PatternInstanceofExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 421,
        "startColumnNumber" : 27,
        "endLineNumber" : 421,
        "endColumnNumber" : 98
      },
      "nodeContext" : "unit instanceof Builderc builder && exec.obj(p3) instanceof Block block",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 16,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1024,
        "startLineNumber" : 421,
        "startColumnNumber" : 24,
        "endLineNumber" : 440,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\n  int x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\n  int rot=exec.numi(p4);\n  if (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\n    ai.plan.progress=0;\n    ai.plan.initialized=false;\n    ai.plan.stuck=false;\n  }\n  ai.plan.set(x,y,rot,block);\n  ai.plan.config=null;\n  if (ai.plan.tile() != null) {\n    builder.clearBuilding();\n    builder.updateBuilding(true);\n    builder.addBuild(ai.plan);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 144,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1072,
        "startLineNumber" : 420,
        "startColumnNumber" : 34,
        "endLineNumber" : 441,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (unit instanceof   Builderc builder && exec.obj(p3) instanceof   Block block) {\n    int x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\n    int rot=exec.numi(p4);\n    if (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\n      ai.plan.progress=0;\n      ai.plan.initialized=false;\n      ai.plan.stuck=false;\n    }\n    ai.plan.set(x,y,rot,block);\n    ai.plan.config=null;\n    if (ai.plan.tile() != null) {\n      builder.clearBuilding();\n      builder.updateBuilding(true);\n      builder.addBuild(ai.plan);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 145,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 421,
        "startColumnNumber" : 27,
        "endLineNumber" : 421,
        "endColumnNumber" : 98
      },
      "nodeContext" : "unit instanceof Builderc builder && exec.obj(p3) instanceof Block block",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 16,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 444,
      "startColumnNumber" : 47,
      "endLineNumber" : 444,
      "endColumnNumber" : 51
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 12,
        "startLineNumber" : 444,
        "startColumnNumber" : 47,
        "endLineNumber" : 444,
        "endColumnNumber" : 59
      },
      "nodeContext" : "unit.range()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 444,
        "startColumnNumber" : 38,
        "endLineNumber" : 444,
        "endColumnNumber" : 75
      },
      "nodeContext" : "Math.max(unit.range(),buildingRange)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 444,
        "startColumnNumber" : 30,
        "endLineNumber" : 444,
        "endColumnNumber" : 75
      },
      "nodeContext" : "range=Math.max(unit.range(),buildingRange)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 444,
        "startColumnNumber" : 24,
        "endLineNumber" : 444,
        "endColumnNumber" : 76
      },
      "nodeContext" : "float range=Math.max(unit.range(),buildingRange);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 847,
        "startLineNumber" : 442,
        "startColumnNumber" : 37,
        "endLineNumber" : 455,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  float x=exec.numf(p1), y=exec.numf(p2);\n  float range=Math.max(unit.range(),buildingRange);\n  if (!unit.within(x,y,range)) {\n    exec.setobj(p3,null);\n    exec.setnum(p4,0);\n  }\n else {\n    Tile tile=world.tileWorld(x,y);\n    Block block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\n    exec.setobj(p3,block);\n    exec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 114,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 444,
        "startColumnNumber" : 24,
        "endLineNumber" : 444,
        "endColumnNumber" : 76
      },
      "nodeContext" : "float range=Math.max(unit.range(),buildingRange);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 445,
      "startColumnNumber" : 28,
      "endLineNumber" : 445,
      "endColumnNumber" : 32
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.PrefixExpression,operand]",
      "nodePosition" : {
        "charLength" : 24,
        "startLineNumber" : 445,
        "startColumnNumber" : 28,
        "endLineNumber" : 445,
        "endColumnNumber" : 52
      },
      "nodeContext" : "unit.within(x,y,range)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 445,
        "startColumnNumber" : 27,
        "endLineNumber" : 445,
        "endColumnNumber" : 52
      },
      "nodeContext" : "!unit.within(x,y,range)",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 654,
        "startLineNumber" : 445,
        "startColumnNumber" : 24,
        "endLineNumber" : 454,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (!unit.within(x,y,range)) {\n  exec.setobj(p3,null);\n  exec.setnum(p4,0);\n}\n else {\n  Tile tile=world.tileWorld(x,y);\n  Block block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\n  exec.setobj(p3,block);\n  exec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 88,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 847,
        "startLineNumber" : 442,
        "startColumnNumber" : 37,
        "endLineNumber" : 455,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  float x=exec.numf(p1), y=exec.numf(p2);\n  float range=Math.max(unit.range(),buildingRange);\n  if (!unit.within(x,y,range)) {\n    exec.setobj(p3,null);\n    exec.setnum(p4,0);\n  }\n else {\n    Tile tile=world.tileWorld(x,y);\n    Block block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\n    exec.setobj(p3,block);\n    exec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 114,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 445,
        "startColumnNumber" : 27,
        "endLineNumber" : 445,
        "endColumnNumber" : 52
      },
      "nodeContext" : "!unit.within(x,y,range)",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 461,
      "startColumnNumber" : 47,
      "endLineNumber" : 461,
      "endColumnNumber" : 51
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.QualifiedName,qualifier]",
      "nodePosition" : {
        "charLength" : 10,
        "startLineNumber" : 461,
        "startColumnNumber" : 47,
        "endLineNumber" : 461,
        "endColumnNumber" : 57
      },
      "nodeContext" : "unit.stack",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 461,
        "startColumnNumber" : 47,
        "endLineNumber" : 461,
        "endColumnNumber" : 64
      },
      "nodeContext" : "unit.stack.amount",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 461,
        "startColumnNumber" : 38,
        "endLineNumber" : 461,
        "endColumnNumber" : 73
      },
      "nodeContext" : "Math.min(unit.stack.amount,amount)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 461,
        "startColumnNumber" : 28,
        "endLineNumber" : 461,
        "endColumnNumber" : 73
      },
      "nodeContext" : "dropped=Math.min(unit.stack.amount,amount)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 461,
        "startColumnNumber" : 24,
        "endLineNumber" : 461,
        "endColumnNumber" : 74
      },
      "nodeContext" : "int dropped=Math.min(unit.stack.amount,amount);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 13,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 735,
        "startLineNumber" : 456,
        "startColumnNumber" : 37,
        "endLineNumber" : 469,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p2);\n  int dropped=Math.min(unit.stack.amount,amount);\n  if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n    int accepted=build.acceptStack(unit.item(),dropped,unit);\n    if (accepted > 0) {\n      Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 94,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 461,
        "startColumnNumber" : 24,
        "endLineNumber" : 461,
        "endColumnNumber" : 74
      },
      "nodeContext" : "int dropped=Math.min(unit.stack.amount,amount);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 13,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 462,
      "startColumnNumber" : 59,
      "endLineNumber" : 462,
      "endColumnNumber" : 63
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 462,
        "startColumnNumber" : 59,
        "endLineNumber" : 462,
        "endColumnNumber" : 101
      },
      "nodeContext" : "unit.within(build,logicItemTransferRange)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 462,
        "startColumnNumber" : 27,
        "endLineNumber" : 462,
        "endColumnNumber" : 101
      },
      "nodeContext" : "build != null && dropped > 0 && unit.within(build,logicItemTransferRange)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 462,
        "startColumnNumber" : 24,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 56,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 735,
        "startLineNumber" : 456,
        "startColumnNumber" : 37,
        "endLineNumber" : 469,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p2);\n  int dropped=Math.min(unit.stack.amount,amount);\n  if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n    int accepted=build.acceptStack(unit.item(),dropped,unit);\n    if (accepted > 0) {\n      Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 94,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 462,
        "startColumnNumber" : 27,
        "endLineNumber" : 462,
        "endColumnNumber" : 101
      },
      "nodeContext" : "build != null && dropped > 0 && unit.within(build,logicItemTransferRange)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 463,
      "startColumnNumber" : 61,
      "endLineNumber" : 463,
      "endColumnNumber" : 65
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 11,
        "startLineNumber" : 463,
        "startColumnNumber" : 61,
        "endLineNumber" : 463,
        "endColumnNumber" : 72
      },
      "nodeContext" : "unit.item()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 463,
        "startColumnNumber" : 43,
        "endLineNumber" : 463,
        "endColumnNumber" : 88
      },
      "nodeContext" : "build.acceptStack(unit.item(),dropped,unit)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 463,
        "startColumnNumber" : 32,
        "endLineNumber" : 463,
        "endColumnNumber" : 88
      },
      "nodeContext" : "accepted=build.acceptStack(unit.item(),dropped,unit)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 61,
        "startLineNumber" : 463,
        "startColumnNumber" : 28,
        "endLineNumber" : 463,
        "endColumnNumber" : 89
      },
      "nodeContext" : "int accepted=build.acceptStack(unit.item(),dropped,unit);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 368,
        "startLineNumber" : 462,
        "startColumnNumber" : 102,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 42,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 462,
        "startColumnNumber" : 24,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 56,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 735,
        "startLineNumber" : 456,
        "startColumnNumber" : 37,
        "endLineNumber" : 469,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p2);\n  int dropped=Math.min(unit.stack.amount,amount);\n  if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n    int accepted=build.acceptStack(unit.item(),dropped,unit);\n    if (accepted > 0) {\n      Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 94,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 61,
        "startLineNumber" : 463,
        "startColumnNumber" : 28,
        "endLineNumber" : 463,
        "endColumnNumber" : 89
      },
      "nodeContext" : "int accepted=build.acceptStack(unit.item(),dropped,unit);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 12,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 463,
      "startColumnNumber" : 83,
      "endLineNumber" : 463,
      "endColumnNumber" : 87
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 463,
        "startColumnNumber" : 43,
        "endLineNumber" : 463,
        "endColumnNumber" : 88
      },
      "nodeContext" : "build.acceptStack(unit.item(),dropped,unit)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 463,
        "startColumnNumber" : 32,
        "endLineNumber" : 463,
        "endColumnNumber" : 88
      },
      "nodeContext" : "accepted=build.acceptStack(unit.item(),dropped,unit)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 61,
        "startLineNumber" : 463,
        "startColumnNumber" : 28,
        "endLineNumber" : 463,
        "endColumnNumber" : 89
      },
      "nodeContext" : "int accepted=build.acceptStack(unit.item(),dropped,unit);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 368,
        "startLineNumber" : 462,
        "startColumnNumber" : 102,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 42,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 462,
        "startColumnNumber" : 24,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 56,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 735,
        "startLineNumber" : 456,
        "startColumnNumber" : 37,
        "endLineNumber" : 469,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p2);\n  int dropped=Math.min(unit.stack.amount,amount);\n  if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n    int accepted=build.acceptStack(unit.item(),dropped,unit);\n    if (accepted > 0) {\n      Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 94,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 61,
        "startLineNumber" : 463,
        "startColumnNumber" : 28,
        "endLineNumber" : 463,
        "endColumnNumber" : 89
      },
      "nodeContext" : "int accepted=build.acceptStack(unit.item(),dropped,unit);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 12,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 465,
      "startColumnNumber" : 52,
      "endLineNumber" : 465,
      "endColumnNumber" : 56
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 103
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 15,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 206,
        "startLineNumber" : 464,
        "startColumnNumber" : 44,
        "endLineNumber" : 467,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 25,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 222,
        "startLineNumber" : 464,
        "startColumnNumber" : 28,
        "endLineNumber" : 467,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (accepted > 0) {\n  Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 29,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 368,
        "startLineNumber" : 462,
        "startColumnNumber" : 102,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 42,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 462,
        "startColumnNumber" : 24,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 56,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 735,
        "startLineNumber" : 456,
        "startColumnNumber" : 37,
        "endLineNumber" : 469,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p2);\n  int dropped=Math.min(unit.stack.amount,amount);\n  if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n    int accepted=build.acceptStack(unit.item(),dropped,unit);\n    if (accepted > 0) {\n      Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 94,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 465,
      "startColumnNumber" : 58,
      "endLineNumber" : 465,
      "endColumnNumber" : 62
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 11,
        "startLineNumber" : 465,
        "startColumnNumber" : 58,
        "endLineNumber" : 465,
        "endColumnNumber" : 69
      },
      "nodeContext" : "unit.item()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 103
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 15,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 206,
        "startLineNumber" : 464,
        "startColumnNumber" : 44,
        "endLineNumber" : 467,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 25,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 222,
        "startLineNumber" : 464,
        "startColumnNumber" : 28,
        "endLineNumber" : 467,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (accepted > 0) {\n  Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 29,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 368,
        "startLineNumber" : 462,
        "startColumnNumber" : 102,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 42,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 462,
        "startColumnNumber" : 24,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 56,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 735,
        "startLineNumber" : 456,
        "startColumnNumber" : 37,
        "endLineNumber" : 469,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p2);\n  int dropped=Math.min(unit.stack.amount,amount);\n  if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n    int accepted=build.acceptStack(unit.item(),dropped,unit);\n    if (accepted > 0) {\n      Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 94,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 465,
      "startColumnNumber" : 81,
      "endLineNumber" : 465,
      "endColumnNumber" : 85
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 465,
        "startColumnNumber" : 81,
        "endLineNumber" : 465,
        "endColumnNumber" : 87
      },
      "nodeContext" : "unit.x",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 103
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 15,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 206,
        "startLineNumber" : 464,
        "startColumnNumber" : 44,
        "endLineNumber" : 467,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 25,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 222,
        "startLineNumber" : 464,
        "startColumnNumber" : 28,
        "endLineNumber" : 467,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (accepted > 0) {\n  Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 29,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 368,
        "startLineNumber" : 462,
        "startColumnNumber" : 102,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 42,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 462,
        "startColumnNumber" : 24,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 56,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 735,
        "startLineNumber" : 456,
        "startColumnNumber" : 37,
        "endLineNumber" : 469,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p2);\n  int dropped=Math.min(unit.stack.amount,amount);\n  if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n    int accepted=build.acceptStack(unit.item(),dropped,unit);\n    if (accepted > 0) {\n      Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 94,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 465,
      "startColumnNumber" : 89,
      "endLineNumber" : 465,
      "endColumnNumber" : 93
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 465,
        "startColumnNumber" : 89,
        "endLineNumber" : 465,
        "endColumnNumber" : 95
      },
      "nodeContext" : "unit.y",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 103
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 15,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 206,
        "startLineNumber" : 464,
        "startColumnNumber" : 44,
        "endLineNumber" : 467,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 25,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 222,
        "startLineNumber" : 464,
        "startColumnNumber" : 28,
        "endLineNumber" : 467,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (accepted > 0) {\n  Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 29,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 368,
        "startLineNumber" : 462,
        "startColumnNumber" : 102,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 42,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 462,
        "startColumnNumber" : 24,
        "endLineNumber" : 468,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 56,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 735,
        "startLineNumber" : 456,
        "startColumnNumber" : 37,
        "endLineNumber" : 469,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p2);\n  int dropped=Math.min(unit.stack.amount,amount);\n  if (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\n    int accepted=build.acceptStack(unit.item(),dropped,unit);\n    if (accepted > 0) {\n      Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 94,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 465,
        "startColumnNumber" : 32,
        "endLineNumber" : 465,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : null
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 476,
      "startColumnNumber" : 81,
      "endLineNumber" : 476,
      "endColumnNumber" : 85
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 476,
        "startColumnNumber" : 81,
        "endLineNumber" : 476,
        "endColumnNumber" : 123
      },
      "nodeContext" : "unit.within(build,logicItemTransferRange)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 476,
        "startColumnNumber" : 27,
        "endLineNumber" : 476,
        "endColumnNumber" : 123
      },
      "nodeContext" : "build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 19,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 460,
        "startLineNumber" : 476,
        "startColumnNumber" : 24,
        "endLineNumber" : 483,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\n  int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n  if (taken > 0) {\n    Call.takeItems(build,item,taken,unit);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 63,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 675,
        "startLineNumber" : 470,
        "startColumnNumber" : 37,
        "endLineNumber" : 484,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p3);\n  if (build != null && exec.obj(p2) instanceof   Item item && unit.within(build,logicItemTransferRange)) {\n    int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n    if (taken > 0) {\n      Call.takeItems(build,item,taken,unit);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 88,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 476,
        "startColumnNumber" : 27,
        "endLineNumber" : 476,
        "endColumnNumber" : 123
      },
      "nodeContext" : "build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 19,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 477,
      "startColumnNumber" : 89,
      "endLineNumber" : 477,
      "endColumnNumber" : 93
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 477,
        "startColumnNumber" : 89,
        "endLineNumber" : 477,
        "endColumnNumber" : 111
      },
      "nodeContext" : "unit.maxAccepted(item)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 477,
        "startColumnNumber" : 72,
        "endLineNumber" : 477,
        "endColumnNumber" : 112
      },
      "nodeContext" : "Math.min(amount,unit.maxAccepted(item))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 73,
        "startLineNumber" : 477,
        "startColumnNumber" : 40,
        "endLineNumber" : 477,
        "endColumnNumber" : 113
      },
      "nodeContext" : "Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 17,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 477,
        "startColumnNumber" : 32,
        "endLineNumber" : 477,
        "endColumnNumber" : 113
      },
      "nodeContext" : "taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)))",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 19,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 86,
        "startLineNumber" : 477,
        "startColumnNumber" : 28,
        "endLineNumber" : 477,
        "endColumnNumber" : 114
      },
      "nodeContext" : "int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 21,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 360,
        "startLineNumber" : 476,
        "startColumnNumber" : 124,
        "endLineNumber" : 483,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n  if (taken > 0) {\n    Call.takeItems(build,item,taken,unit);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 43,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 460,
        "startLineNumber" : 476,
        "startColumnNumber" : 24,
        "endLineNumber" : 483,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\n  int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n  if (taken > 0) {\n    Call.takeItems(build,item,taken,unit);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 63,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 675,
        "startLineNumber" : 470,
        "startColumnNumber" : 37,
        "endLineNumber" : 484,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p3);\n  if (build != null && exec.obj(p2) instanceof   Item item && unit.within(build,logicItemTransferRange)) {\n    int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n    if (taken > 0) {\n      Call.takeItems(build,item,taken,unit);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 88,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 86,
        "startLineNumber" : 477,
        "startColumnNumber" : 28,
        "endLineNumber" : 477,
        "endColumnNumber" : 114
      },
      "nodeContext" : "int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 21,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  }, {
    "nodeContext" : "unit",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 480,
      "startColumnNumber" : 67,
      "endLineNumber" : 480,
      "endColumnNumber" : 71
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 480,
        "startColumnNumber" : 32,
        "endLineNumber" : 480,
        "endColumnNumber" : 72
      },
      "nodeContext" : "Call.takeItems(build,item,taken,unit)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 480,
        "startColumnNumber" : 32,
        "endLineNumber" : 480,
        "endColumnNumber" : 73
      },
      "nodeContext" : "Call.takeItems(build,item,taken,unit);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 175,
        "startLineNumber" : 479,
        "startColumnNumber" : 41,
        "endLineNumber" : 482,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Call.takeItems(build,item,taken,unit);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 17,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 188,
        "startLineNumber" : 479,
        "startColumnNumber" : 28,
        "endLineNumber" : 482,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (taken > 0) {\n  Call.takeItems(build,item,taken,unit);\n  ai.itemTimer=LogicAI.transferDelay;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 21,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 360,
        "startLineNumber" : 476,
        "startColumnNumber" : 124,
        "endLineNumber" : 483,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n  if (taken > 0) {\n    Call.takeItems(build,item,taken,unit);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 43,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 460,
        "startLineNumber" : 476,
        "startColumnNumber" : 24,
        "endLineNumber" : 483,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\n  int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n  if (taken > 0) {\n    Call.takeItems(build,item,taken,unit);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 63,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 675,
        "startLineNumber" : 470,
        "startColumnNumber" : 37,
        "endLineNumber" : 484,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int amount=exec.numi(p3);\n  if (build != null && exec.obj(p2) instanceof   Item item && unit.within(build,logicItemTransferRange)) {\n    int taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\n    if (taken > 0) {\n      Call.takeItems(build,item,taken,unit);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 88,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7656,
        "startLineNumber" : 335,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=exec.numf(p1);\n    ai.moveY=exec.numf(p2);\n    if (type == LUnitControl.approach) {\n      ai.moveRad=exec.numf(p3);\n    }\n    if (type == LUnitControl.stop) {\n      if (unit instanceof       Minerc miner) {\n        miner.mineTile(null);\n      }\n      if (unit instanceof       Builderc build) {\n        build.clearBuilding();\n      }\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 916,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7752,
        "startLineNumber" : 332,
        "startColumnNumber" : 58,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 925,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7798,
        "startLineNumber" : 332,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=exec.numf(p1);\n      ai.moveY=exec.numf(p2);\n      if (type == LUnitControl.approach) {\n        ai.moveRad=exec.numf(p3);\n      }\n      if (type == LUnitControl.stop) {\n        if (unit instanceof         Minerc miner) {\n          miner.mineTile(null);\n        }\n        if (unit instanceof         Builderc build) {\n          build.clearBuilding();\n        }\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(exec.numf(p1),exec.numf(p2));\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 936,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7970,
        "startLineNumber" : 327,
        "startColumnNumber" : 39,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 955,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8019,
        "startLineNumber" : 326,
        "startColumnNumber" : 8,
        "endLineNumber" : 488,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=exec.numf(p1);\n        ai.moveY=exec.numf(p2);\n        if (type == LUnitControl.approach) {\n          ai.moveRad=exec.numf(p3);\n        }\n        if (type == LUnitControl.stop) {\n          if (unit instanceof           Minerc miner) {\n            miner.mineTile(null);\n          }\n          if (unit instanceof           Builderc build) {\n            build.clearBuilding();\n          }\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(exec.numf(p1),exec.numf(p2),exec.numf(p3)) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(exec.numf(p1),exec.numf(p2));\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(exec.numf(p1),exec.numf(p2));\nif (unit instanceof Minerc miner) {\nminer.mineTile(miner.validMine(tile) ? tile : null);\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type().hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit instanceof Builderc builder && exec.obj(p3) instanceof Block block) {\nint x=world.toTile(exec.numf(p1)), y=world.toTile(exec.numf(p2));\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || builder.plans().isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=null;\nif (ai.plan.tile() != null) {\nbuilder.clearBuilding();\nbuilder.updateBuilding(true);\nbuilder.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat x=exec.numf(p1), y=exec.numf(p2);\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x,y,range)) {\nexec.setobj(p3,null);\nexec.setnum(p4,0);\n}\n else {\nTile tile=world.tileWorld(x,y);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setnum(p4,tile != null && tile.build != null ? tile.build.rotation : 0);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p2);\nint dropped=Math.min(unit.stack.amount,amount);\nif (build != null && dropped > 0 && unit.within(build,logicItemTransferRange)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 965,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 480,
        "startColumnNumber" : 32,
        "endLineNumber" : 480,
        "endColumnNumber" : 73
      },
      "nodeContext" : "Call.takeItems(build,item,taken,unit);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "mindustry.game.Unit"
  } ],
  "positionList" : [ {
    "charLength" : 4,
    "startLineNumber" : 346,
    "startColumnNumber" : 31,
    "endLineNumber" : 346,
    "endColumnNumber" : 35
  }, {
    "charLength" : 4,
    "startLineNumber" : 349,
    "startColumnNumber" : 31,
    "endLineNumber" : 349,
    "endColumnNumber" : 35
  }, {
    "charLength" : 4,
    "startLineNumber" : 355,
    "startColumnNumber" : 40,
    "endLineNumber" : 355,
    "endColumnNumber" : 44
  }, {
    "charLength" : 4,
    "startLineNumber" : 375,
    "startColumnNumber" : 24,
    "endLineNumber" : 375,
    "endColumnNumber" : 28
  }, {
    "charLength" : 4,
    "startLineNumber" : 379,
    "startColumnNumber" : 27,
    "endLineNumber" : 379,
    "endColumnNumber" : 31
  }, {
    "charLength" : 4,
    "startLineNumber" : 386,
    "startColumnNumber" : 27,
    "endLineNumber" : 386,
    "endColumnNumber" : 31
  }, {
    "charLength" : 4,
    "startLineNumber" : 387,
    "startColumnNumber" : 48,
    "endLineNumber" : 387,
    "endColumnNumber" : 52
  }, {
    "charLength" : 4,
    "startLineNumber" : 387,
    "startColumnNumber" : 54,
    "endLineNumber" : 387,
    "endColumnNumber" : 58
  }, {
    "charLength" : 4,
    "startLineNumber" : 387,
    "startColumnNumber" : 62,
    "endLineNumber" : 387,
    "endColumnNumber" : 66
  }, {
    "charLength" : 4,
    "startLineNumber" : 394,
    "startColumnNumber" : 27,
    "endLineNumber" : 394,
    "endColumnNumber" : 31
  }, {
    "charLength" : 4,
    "startLineNumber" : 397,
    "startColumnNumber" : 60,
    "endLineNumber" : 397,
    "endColumnNumber" : 64
  }, {
    "charLength" : 4,
    "startLineNumber" : 397,
    "startColumnNumber" : 71,
    "endLineNumber" : 397,
    "endColumnNumber" : 75
  }, {
    "charLength" : 4,
    "startLineNumber" : 397,
    "startColumnNumber" : 79,
    "endLineNumber" : 397,
    "endColumnNumber" : 83
  }, {
    "charLength" : 4,
    "startLineNumber" : 397,
    "startColumnNumber" : 87,
    "endLineNumber" : 397,
    "endColumnNumber" : 91
  }, {
    "charLength" : 4,
    "startLineNumber" : 400,
    "startColumnNumber" : 59,
    "endLineNumber" : 400,
    "endColumnNumber" : 63
  }, {
    "charLength" : 4,
    "startLineNumber" : 403,
    "startColumnNumber" : 65,
    "endLineNumber" : 403,
    "endColumnNumber" : 69
  }, {
    "charLength" : 4,
    "startLineNumber" : 403,
    "startColumnNumber" : 73,
    "endLineNumber" : 403,
    "endColumnNumber" : 77
  }, {
    "charLength" : 4,
    "startLineNumber" : 406,
    "startColumnNumber" : 64,
    "endLineNumber" : 406,
    "endColumnNumber" : 68
  }, {
    "charLength" : 4,
    "startLineNumber" : 408,
    "startColumnNumber" : 64,
    "endLineNumber" : 408,
    "endColumnNumber" : 68
  }, {
    "charLength" : 4,
    "startLineNumber" : 412,
    "startColumnNumber" : 68,
    "endLineNumber" : 412,
    "endColumnNumber" : 72
  }, {
    "charLength" : 4,
    "startLineNumber" : 421,
    "startColumnNumber" : 27,
    "endLineNumber" : 421,
    "endColumnNumber" : 31
  }, {
    "charLength" : 4,
    "startLineNumber" : 444,
    "startColumnNumber" : 47,
    "endLineNumber" : 444,
    "endColumnNumber" : 51
  }, {
    "charLength" : 4,
    "startLineNumber" : 445,
    "startColumnNumber" : 28,
    "endLineNumber" : 445,
    "endColumnNumber" : 32
  }, {
    "charLength" : 4,
    "startLineNumber" : 461,
    "startColumnNumber" : 47,
    "endLineNumber" : 461,
    "endColumnNumber" : 51
  }, {
    "charLength" : 4,
    "startLineNumber" : 462,
    "startColumnNumber" : 59,
    "endLineNumber" : 462,
    "endColumnNumber" : 63
  }, {
    "charLength" : 4,
    "startLineNumber" : 463,
    "startColumnNumber" : 61,
    "endLineNumber" : 463,
    "endColumnNumber" : 65
  }, {
    "charLength" : 4,
    "startLineNumber" : 463,
    "startColumnNumber" : 83,
    "endLineNumber" : 463,
    "endColumnNumber" : 87
  }, {
    "charLength" : 4,
    "startLineNumber" : 465,
    "startColumnNumber" : 52,
    "endLineNumber" : 465,
    "endColumnNumber" : 56
  }, {
    "charLength" : 4,
    "startLineNumber" : 465,
    "startColumnNumber" : 58,
    "endLineNumber" : 465,
    "endColumnNumber" : 62
  }, {
    "charLength" : 4,
    "startLineNumber" : 465,
    "startColumnNumber" : 81,
    "endLineNumber" : 465,
    "endColumnNumber" : 85
  }, {
    "charLength" : 4,
    "startLineNumber" : 465,
    "startColumnNumber" : 89,
    "endLineNumber" : 465,
    "endColumnNumber" : 93
  }, {
    "charLength" : 4,
    "startLineNumber" : 476,
    "startColumnNumber" : 81,
    "endLineNumber" : 476,
    "endColumnNumber" : 85
  }, {
    "charLength" : 4,
    "startLineNumber" : 477,
    "startColumnNumber" : 89,
    "endLineNumber" : 477,
    "endColumnNumber" : 93
  }, {
    "charLength" : 4,
    "startLineNumber" : 480,
    "startColumnNumber" : 67,
    "endLineNumber" : 480,
    "endColumnNumber" : 71
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 30,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 31,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 32,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 33,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 30,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 31,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 32,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 33,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 30,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 31,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 32,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 33,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 20,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 21,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 22,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 23,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 24,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 25,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 26,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 27,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 28,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 29,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 30,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 31,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 32,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 33,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 14,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 15,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 16,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 17,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 18,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 19,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 20,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 21,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 22,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 23,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 24,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 25,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 26,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 27,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 28,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 29,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 30,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 31,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 32,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 33,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 20,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 21,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 22,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 23,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 24,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 25,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 26,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 27,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 28,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 29,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 30,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 31,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 32,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 33,
    "layout" : 4
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 0
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 0
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 30,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 31,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 32,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 33,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 1
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 1
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 1
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 1
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 11,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 12,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 13,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 14,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 15,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 16,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 17,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 18,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 19,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 20,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 21,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 22,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 23,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 24,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 25,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 26,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 27,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 28,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 29,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 30,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 31,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 32,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 33,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 11,
    "layout" : 1
  }, {
    "firstKey" : 10,
    "secondKey" : 12,
    "layout" : 1
  }, {
    "firstKey" : 10,
    "secondKey" : 13,
    "layout" : 1
  }, {
    "firstKey" : 10,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 10,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 20,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 21,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 22,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 23,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 24,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 25,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 26,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 27,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 28,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 29,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 30,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 31,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 32,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 33,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 10,
    "layout" : 1
  }, {
    "firstKey" : 11,
    "secondKey" : 12,
    "layout" : 1
  }, {
    "firstKey" : 11,
    "secondKey" : 13,
    "layout" : 1
  }, {
    "firstKey" : 11,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 11,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 20,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 21,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 22,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 23,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 24,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 25,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 26,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 27,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 28,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 29,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 30,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 31,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 32,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 33,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 12,
    "secondKey" : 10,
    "layout" : 1
  }, {
    "firstKey" : 12,
    "secondKey" : 11,
    "layout" : 1
  }, {
    "firstKey" : 12,
    "secondKey" : 13,
    "layout" : 1
  }, {
    "firstKey" : 12,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 12,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 20,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 21,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 22,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 23,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 24,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 25,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 26,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 27,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 28,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 29,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 30,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 31,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 32,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 33,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 0,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 1,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 2,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 3,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 4,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 5,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 6,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 7,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 8,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 18,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 19,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 20,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 21,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 22,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 23,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 24,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 25,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 26,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 27,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 28,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 29,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 30,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 31,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 32,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 33,
    "layout" : 11
  }, {
    "firstKey" : 14,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 14,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 14,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 14,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 14,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 14,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 14,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 14,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 14,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 14,
    "secondKey" : 20,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 21,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 22,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 23,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 24,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 25,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 26,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 27,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 28,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 29,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 30,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 31,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 32,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 33,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 15,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 15,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 15,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 15,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 15,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 15,
    "secondKey" : 16,
    "layout" : 1
  }, {
    "firstKey" : 15,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 20,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 21,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 22,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 23,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 24,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 25,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 26,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 27,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 28,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 29,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 30,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 31,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 32,
    "layout" : 9
  }, {
    "firstKey" : 15,
    "secondKey" : 33,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 16,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 16,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 16,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 16,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 16,
    "secondKey" : 15,
    "layout" : 1
  }, {
    "firstKey" : 16,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 20,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 21,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 22,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 23,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 24,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 25,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 26,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 27,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 28,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 29,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 30,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 31,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 32,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 33,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 17,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 17,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 17,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 17,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 17,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 17,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 17,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 17,
    "secondKey" : 18,
    "layout" : 3
  }, {
    "firstKey" : 17,
    "secondKey" : 19,
    "layout" : 3
  }, {
    "firstKey" : 17,
    "secondKey" : 20,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 21,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 22,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 23,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 24,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 25,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 26,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 27,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 28,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 29,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 30,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 31,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 32,
    "layout" : 9
  }, {
    "firstKey" : 17,
    "secondKey" : 33,
    "layout" : 9
  }, {
    "firstKey" : 18,
    "secondKey" : 0,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 1,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 2,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 3,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 4,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 5,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 6,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 7,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 8,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 18,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 18,
    "secondKey" : 19,
    "layout" : 3
  }, {
    "firstKey" : 18,
    "secondKey" : 20,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 21,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 22,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 23,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 24,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 25,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 26,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 27,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 28,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 29,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 30,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 31,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 32,
    "layout" : 11
  }, {
    "firstKey" : 18,
    "secondKey" : 33,
    "layout" : 11
  }, {
    "firstKey" : 19,
    "secondKey" : 0,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 1,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 2,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 3,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 4,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 5,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 6,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 7,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 8,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 9,
    "layout" : 11
  }, {
    "firstKey" : 19,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 19,
    "secondKey" : 11,
    "layout" : 9
  }, {
    "firstKey" : 19,
    "secondKey" : 12,
    "layout" : 9
  }, {
    "firstKey" : 19,
    "secondKey" : 13,
    "layout" : 9
  }, {
    "firstKey" : 19,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 19,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 19,
    "secondKey" : 16,
    "layout" : 8
  }, {
    "firstKey" : 19,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 19,
    "secondKey" : 20,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 21,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 22,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 23,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 24,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 25,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 26,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 27,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 28,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 29,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 30,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 31,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 32,
    "layout" : 13
  }, {
    "firstKey" : 19,
    "secondKey" : 33,
    "layout" : 13
  }, {
    "firstKey" : 20,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 21,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 22,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 23,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 24,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 25,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 26,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 27,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 28,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 29,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 30,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 31,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 32,
    "layout" : 4
  }, {
    "firstKey" : 20,
    "secondKey" : 33,
    "layout" : 4
  }, {
    "firstKey" : 21,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 22,
    "layout" : 4
  }, {
    "firstKey" : 21,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 30,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 31,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 32,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 33,
    "layout" : 5
  }, {
    "firstKey" : 22,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 20,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 21,
    "layout" : 3
  }, {
    "firstKey" : 22,
    "secondKey" : 23,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 24,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 25,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 26,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 27,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 28,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 29,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 30,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 31,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 32,
    "layout" : 4
  }, {
    "firstKey" : 22,
    "secondKey" : 33,
    "layout" : 4
  }, {
    "firstKey" : 23,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 23,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 23,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 23,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 23,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 23,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 23,
    "secondKey" : 30,
    "layout" : 5
  }, {
    "firstKey" : 23,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 24,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 20,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 21,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 22,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 23,
    "layout" : 3
  }, {
    "firstKey" : 24,
    "secondKey" : 25,
    "layout" : 2
  }, {
    "firstKey" : 24,
    "secondKey" : 26,
    "layout" : 2
  }, {
    "firstKey" : 24,
    "secondKey" : 27,
    "layout" : 2
  }, {
    "firstKey" : 24,
    "secondKey" : 28,
    "layout" : 2
  }, {
    "firstKey" : 24,
    "secondKey" : 29,
    "layout" : 2
  }, {
    "firstKey" : 24,
    "secondKey" : 30,
    "layout" : 2
  }, {
    "firstKey" : 24,
    "secondKey" : 31,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 32,
    "layout" : 4
  }, {
    "firstKey" : 24,
    "secondKey" : 33,
    "layout" : 4
  }, {
    "firstKey" : 25,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 18,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 19,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 25,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 26,
    "layout" : 1
  }, {
    "firstKey" : 25,
    "secondKey" : 27,
    "layout" : 4
  }, {
    "firstKey" : 25,
    "secondKey" : 28,
    "layout" : 4
  }, {
    "firstKey" : 25,
    "secondKey" : 29,
    "layout" : 4
  }, {
    "firstKey" : 25,
    "secondKey" : 30,
    "layout" : 4
  }, {
    "firstKey" : 25,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 26,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 24,
    "layout" : 4
  }, {
    "firstKey" : 26,
    "secondKey" : 25,
    "layout" : 0
  }, {
    "firstKey" : 26,
    "secondKey" : 27,
    "layout" : 3
  }, {
    "firstKey" : 26,
    "secondKey" : 28,
    "layout" : 3
  }, {
    "firstKey" : 26,
    "secondKey" : 29,
    "layout" : 3
  }, {
    "firstKey" : 26,
    "secondKey" : 30,
    "layout" : 3
  }, {
    "firstKey" : 26,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 27,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 18,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 19,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 27,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 25,
    "layout" : 4
  }, {
    "firstKey" : 27,
    "secondKey" : 26,
    "layout" : 4
  }, {
    "firstKey" : 27,
    "secondKey" : 28,
    "layout" : 0
  }, {
    "firstKey" : 27,
    "secondKey" : 29,
    "layout" : 0
  }, {
    "firstKey" : 27,
    "secondKey" : 30,
    "layout" : 0
  }, {
    "firstKey" : 27,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 28,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 16,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 17,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 18,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 19,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 20,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 21,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 22,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 28,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 28,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 27,
    "layout" : 1
  }, {
    "firstKey" : 28,
    "secondKey" : 29,
    "layout" : 1
  }, {
    "firstKey" : 28,
    "secondKey" : 30,
    "layout" : 1
  }, {
    "firstKey" : 28,
    "secondKey" : 31,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 32,
    "layout" : 8
  }, {
    "firstKey" : 28,
    "secondKey" : 33,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 16,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 17,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 18,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 19,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 20,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 21,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 22,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 29,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 29,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 29,
    "secondKey" : 27,
    "layout" : 1
  }, {
    "firstKey" : 29,
    "secondKey" : 28,
    "layout" : 1
  }, {
    "firstKey" : 29,
    "secondKey" : 30,
    "layout" : 1
  }, {
    "firstKey" : 29,
    "secondKey" : 31,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 32,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 33,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 16,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 17,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 18,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 19,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 20,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 21,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 22,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 30,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 30,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 27,
    "layout" : 1
  }, {
    "firstKey" : 30,
    "secondKey" : 28,
    "layout" : 1
  }, {
    "firstKey" : 30,
    "secondKey" : 29,
    "layout" : 1
  }, {
    "firstKey" : 30,
    "secondKey" : 31,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 32,
    "layout" : 8
  }, {
    "firstKey" : 30,
    "secondKey" : 33,
    "layout" : 8
  }, {
    "firstKey" : 31,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 20,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 21,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 22,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 23,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 24,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 25,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 26,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 27,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 28,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 29,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 30,
    "layout" : 4
  }, {
    "firstKey" : 31,
    "secondKey" : 32,
    "layout" : 2
  }, {
    "firstKey" : 31,
    "secondKey" : 33,
    "layout" : 2
  }, {
    "firstKey" : 32,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 16,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 17,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 18,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 19,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 20,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 21,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 22,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 23,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 24,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 25,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 26,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 27,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 28,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 29,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 30,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 32,
    "secondKey" : 33,
    "layout" : 5
  }, {
    "firstKey" : 33,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 18,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 19,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 24,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 25,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 26,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 27,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 28,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 29,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 31,
    "layout" : 5
  }, {
    "firstKey" : 33,
    "secondKey" : 32,
    "layout" : 4
  } ]
}