{
  "id" : 104,
  "expression" : "Files.exists(path)",
  "projectName" : "SeleniumHQ@selenium",
  "commitID" : "c146621f39dbec94114835aa1f6af6a0e1fa4cd0",
  "filePath" : "/java/buildtools/src/dev/selenium/tools/jar/MergeJars.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "Files.exists(path)",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 18,
      "startLineNumber" : 75,
      "startColumnNumber" : 15,
      "endLineNumber" : 75,
      "endColumnNumber" : 33
    },
    "astNodeNumber" : 4,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 75,
        "startColumnNumber" : 14,
        "endLineNumber" : 75,
        "endColumnNumber" : 33
      },
      "nodeContext" : "!Files.exists(path)",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 75,
        "startColumnNumber" : 14,
        "endLineNumber" : 75,
        "endColumnNumber" : 60
      },
      "nodeContext" : "!Files.exists(path) || !Files.isReadable(path)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 153,
        "startLineNumber" : 75,
        "startColumnNumber" : 10,
        "endLineNumber" : 77,
        "endColumnNumber" : 11
      },
      "nodeContext" : "if (!Files.exists(path) || !Files.isReadable(path)) {\n  throw new IllegalArgumentException(\"Source must a readable file: \" + path);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 20,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 605,
        "startLineNumber" : 63,
        "startColumnNumber" : 6,
        "endLineNumber" : 83,
        "endColumnNumber" : 7
      },
      "nodeContext" : "switch (args[i]) {\ncase \"--compression\":case \"--normalize\":  break;\ncase \"--output\":out=Paths.get(args[++i]);\nbreak;\ncase \"--sources\":Path path=Paths.get(args[++i]);\nif (!Files.exists(path) || !Files.isReadable(path)) {\nthrow new IllegalArgumentException(\"Source must a readable file: \" + path);\n}\nsources.add(path);\nbreak;\ndefault:throw new IllegalArgumentException(\"Unable to parse command line: \" + Arrays.toString(args));\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 73,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 619,
        "startLineNumber" : 62,
        "startColumnNumber" : 42,
        "endLineNumber" : 84,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\nswitch (args[i]) {\ncase \"--compression\":case \"--normalize\":    break;\ncase \"--output\":  out=Paths.get(args[++i]);\nbreak;\ncase \"--sources\":Path path=Paths.get(args[++i]);\nif (!Files.exists(path) || !Files.isReadable(path)) {\nthrow new IllegalArgumentException(\"Source must a readable file: \" + path);\n}\nsources.add(path);\nbreak;\ndefault:throw new IllegalArgumentException(\"Unable to parse command line: \" + Arrays.toString(args));\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 74,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 657,
        "startLineNumber" : 62,
        "startColumnNumber" : 4,
        "endLineNumber" : 84,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (int i=0; i < args.length; i++) {\nswitch (args[i]) {\ncase \"--compression\":case \"--normalize\":    break;\ncase \"--output\":  out=Paths.get(args[++i]);\nbreak;\ncase \"--sources\":Path path=Paths.get(args[++i]);\nif (!Files.exists(path) || !Files.isReadable(path)) {\nthrow new IllegalArgumentException(\"Source must a readable file: \" + path);\n}\nsources.add(path);\nbreak;\ndefault:throw new IllegalArgumentException(\"Unable to parse command line: \" + Arrays.toString(args));\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 87,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5671,
        "startLineNumber" : 58,
        "startColumnNumber" : 60,
        "endLineNumber" : 224,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  Path out=null;\n  SortedSet<Path> sources=new TreeSet<>();\n  for (int i=0; i < args.length; i++) {\nswitch (args[i]) {\ncase \"--compression\":case \"--normalize\":      break;\ncase \"--output\":    out=Paths.get(args[++i]);\n  break;\ncase \"--sources\":Path path=Paths.get(args[++i]);\nif (!Files.exists(path) || !Files.isReadable(path)) {\nthrow new IllegalArgumentException(\"Source must a readable file: \" + path);\n}\nsources.add(path);\nbreak;\ndefault:throw new IllegalArgumentException(\"Unable to parse command line: \" + Arrays.toString(args));\n}\n}\nObjects.requireNonNull(out,\"Output path must be set.\");\nif (sources.isEmpty()) {\ntry (OutputStream fos=Files.newOutputStream(out);JarOutputStream jos=new JarOutputStream(fos)){\n}\n return;\n}\nFile tempDir=TemporaryFilesystem.getDefaultTmpFS().createTempDir(\"mergejars\",\"\");\nPath temp=tempDir.toPath();\nManifest manifest=new Manifest();\nmanifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,\"1.0\");\nMap<String,Set<String>> allServices=new TreeMap<>();\nMap<Path,SortedMap<Path,Path>> allPaths=new TreeMap<>();\nfor (Path source : sources) {\ntry (InputStream fis=Files.newInputStream(source);ZipInputStream zis=new ZipInputStream(fis)){\nZipEntry entry;\nwhile ((entry=zis.getNextEntry()) != null) {\nif (\"META-INF/MANIFEST.MF\".equals(entry.getName())) {\nManifest other=new Manifest(zis);\nmanifest=merge(manifest,other);\ncontinue;\n}\nif (entry.isDirectory()) {\nzis.readAllBytes();\ncontinue;\n}\nif (entry.getName().startsWith(\"META-INF/services/\")) {\nString servicesName=entry.getName().substring(\"META-INF/services/\".length());\nSet<String> services=allServices.computeIfAbsent(servicesName,key -> new TreeSet<>());\nString content=new String(zis.readAllBytes());\nservices.addAll(Arrays.asList(content.split(\"\\n\")));\ncontinue;\n}\nPath outPath=temp.resolve(entry.getName()).normalize();\nif (!outPath.startsWith(temp)) {\nthrow new IllegalStateException(\"Attempt to write jar entry somewhere weird: \" + outPath);\n}\nif (!Files.exists(outPath.getParent())) {\nFiles.createDirectories(outPath.getParent());\n}\ntry (OutputStream os=Files.newOutputStream(outPath)){\nzis.transferTo(os);\n}\n SortedMap<Path,Path> dirPaths=allPaths.computeIfAbsent(temp.relativize(outPath.getParent()),path -> new TreeMap<>());\ndirPaths.put(temp.relativize(outPath),outPath);\n}\n}\n }\nmanifest.getMainAttributes().put(new Attributes.Name(\"Created-By\"),\"mergejars\");\nSet<String> seen=new HashSet<>(Set.of(\"META-INF/\",\"META-INF/MANIFEST.MF\"));\ntry (OutputStream os=Files.newOutputStream(out);JarOutputStream jos=new JarOutputStream(os)){\njos.setMethod(DEFLATED);\njos.setLevel(BEST_COMPRESSION);\nJarEntry entry=new JarEntry(\"META-INF/\");\nentry=resetTime(entry);\njos.putNextEntry(entry);\njos.closeEntry();\nentry=new JarEntry(\"META-INF/MANIFEST.MF\");\nentry=resetTime(entry);\nByteArrayOutputStream bos=new ByteArrayOutputStream();\nmanifest.write(bos);\nentry.setSize(bos.size());\njos.putNextEntry(entry);\njos.write(bos.toByteArray());\njos.closeEntry();\nif (!allServices.isEmpty()) {\nentry=new JarEntry(\"META-INF/services/\");\nentry=resetTime(entry);\njos.putNextEntry(entry);\njos.closeEntry();\nfor (Map.Entry<String,Set<String>> kv : allServices.entrySet()) {\nentry=new JarEntry(\"META-INF/services/\" + kv.getKey());\nentry=resetTime(entry);\nbos=new ByteArrayOutputStream();\nbos.write(String.join(\"\\n\",kv.getValue()).getBytes());\nentry.setSize(bos.size());\njos.putNextEntry(entry);\njos.write(bos.toByteArray());\njos.closeEntry();\n}\n}\nallPaths.forEach((dir,entries) -> {\ntry {\nString name=dir.toString().replace('\\\\','/') + \"/\";\nif (seen.add(name)) {\nJarEntry je=new JarEntry(name);\nje=resetTime(je);\njos.putNextEntry(je);\njos.closeEntry();\n}\nfor (Map.Entry<Path,Path> me : entries.entrySet()) {\nname=me.getKey().toString().replace('\\\\','/');\nif (seen.add(name)) {\nJarEntry je=new JarEntry(name);\nje=resetTime(je);\njos.putNextEntry(je);\ntry (InputStream fis=Files.newInputStream(me.getValue())){\nfis.transferTo(jos);\n}\n jos.closeEntry();\n}\n}\n}\n catch (IOException e) {\nthrow new UncheckedIOException(e);\n}\n}\n);\n}\n TemporaryFilesystem.getDefaultTmpFS().deleteTempDir(tempDir);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 837,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5729,
        "startLineNumber" : 58,
        "startColumnNumber" : 2,
        "endLineNumber" : 224,
        "endColumnNumber" : 3
      },
      "nodeContext" : "public static void main(String[] args) throws IOException {\n  Path out=null;\n  SortedSet<Path> sources=new TreeSet<>();\n  for (int i=0; i < args.length; i++) {\nswitch (args[i]) {\ncase \"--compression\":case \"--normalize\":      break;\ncase \"--output\":    out=Paths.get(args[++i]);\n  break;\ncase \"--sources\":Path path=Paths.get(args[++i]);\nif (!Files.exists(path) || !Files.isReadable(path)) {\nthrow new IllegalArgumentException(\"Source must a readable file: \" + path);\n}\nsources.add(path);\nbreak;\ndefault:throw new IllegalArgumentException(\"Unable to parse command line: \" + Arrays.toString(args));\n}\n}\nObjects.requireNonNull(out,\"Output path must be set.\");\nif (sources.isEmpty()) {\ntry (OutputStream fos=Files.newOutputStream(out);JarOutputStream jos=new JarOutputStream(fos)){\n}\n return;\n}\nFile tempDir=TemporaryFilesystem.getDefaultTmpFS().createTempDir(\"mergejars\",\"\");\nPath temp=tempDir.toPath();\nManifest manifest=new Manifest();\nmanifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,\"1.0\");\nMap<String,Set<String>> allServices=new TreeMap<>();\nMap<Path,SortedMap<Path,Path>> allPaths=new TreeMap<>();\nfor (Path source : sources) {\ntry (InputStream fis=Files.newInputStream(source);ZipInputStream zis=new ZipInputStream(fis)){\nZipEntry entry;\nwhile ((entry=zis.getNextEntry()) != null) {\nif (\"META-INF/MANIFEST.MF\".equals(entry.getName())) {\nManifest other=new Manifest(zis);\nmanifest=merge(manifest,other);\ncontinue;\n}\nif (entry.isDirectory()) {\nzis.readAllBytes();\ncontinue;\n}\nif (entry.getName().startsWith(\"META-INF/services/\")) {\nString servicesName=entry.getName().substring(\"META-INF/services/\".length());\nSet<String> services=allServices.computeIfAbsent(servicesName,key -> new TreeSet<>());\nString content=new String(zis.readAllBytes());\nservices.addAll(Arrays.asList(content.split(\"\\n\")));\ncontinue;\n}\nPath outPath=temp.resolve(entry.getName()).normalize();\nif (!outPath.startsWith(temp)) {\nthrow new IllegalStateException(\"Attempt to write jar entry somewhere weird: \" + outPath);\n}\nif (!Files.exists(outPath.getParent())) {\nFiles.createDirectories(outPath.getParent());\n}\ntry (OutputStream os=Files.newOutputStream(outPath)){\nzis.transferTo(os);\n}\n SortedMap<Path,Path> dirPaths=allPaths.computeIfAbsent(temp.relativize(outPath.getParent()),path -> new TreeMap<>());\ndirPaths.put(temp.relativize(outPath),outPath);\n}\n}\n }\nmanifest.getMainAttributes().put(new Attributes.Name(\"Created-By\"),\"mergejars\");\nSet<String> seen=new HashSet<>(Set.of(\"META-INF/\",\"META-INF/MANIFEST.MF\"));\ntry (OutputStream os=Files.newOutputStream(out);JarOutputStream jos=new JarOutputStream(os)){\njos.setMethod(DEFLATED);\njos.setLevel(BEST_COMPRESSION);\nJarEntry entry=new JarEntry(\"META-INF/\");\nentry=resetTime(entry);\njos.putNextEntry(entry);\njos.closeEntry();\nentry=new JarEntry(\"META-INF/MANIFEST.MF\");\nentry=resetTime(entry);\nByteArrayOutputStream bos=new ByteArrayOutputStream();\nmanifest.write(bos);\nentry.setSize(bos.size());\njos.putNextEntry(entry);\njos.write(bos.toByteArray());\njos.closeEntry();\nif (!allServices.isEmpty()) {\nentry=new JarEntry(\"META-INF/services/\");\nentry=resetTime(entry);\njos.putNextEntry(entry);\njos.closeEntry();\nfor (Map.Entry<String,Set<String>> kv : allServices.entrySet()) {\nentry=new JarEntry(\"META-INF/services/\" + kv.getKey());\nentry=resetTime(entry);\nbos=new ByteArrayOutputStream();\nbos.write(String.join(\"\\n\",kv.getValue()).getBytes());\nentry.setSize(bos.size());\njos.putNextEntry(entry);\njos.write(bos.toByteArray());\njos.closeEntry();\n}\n}\nallPaths.forEach((dir,entries) -> {\ntry {\nString name=dir.toString().replace('\\\\','/') + \"/\";\nif (seen.add(name)) {\nJarEntry je=new JarEntry(name);\nje=resetTime(je);\njos.putNextEntry(je);\njos.closeEntry();\n}\nfor (Map.Entry<Path,Path> me : entries.entrySet()) {\nname=me.getKey().toString().replace('\\\\','/');\nif (seen.add(name)) {\nJarEntry je=new JarEntry(name);\nje=resetTime(je);\njos.putNextEntry(je);\ntry (InputStream fis=Files.newInputStream(me.getValue())){\nfis.transferTo(jos);\n}\n jos.closeEntry();\n}\n}\n}\n catch (IOException e) {\nthrow new UncheckedIOException(e);\n}\n}\n);\n}\n TemporaryFilesystem.getDefaultTmpFS().deleteTempDir(tempDir);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 850,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 75,
        "startColumnNumber" : 14,
        "endLineNumber" : 75,
        "endColumnNumber" : 60
      },
      "nodeContext" : "!Files.exists(path) || !Files.isReadable(path)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    },
    "tokenLength" : 3,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 18,
    "startLineNumber" : 75,
    "startColumnNumber" : 15,
    "endLineNumber" : 75,
    "endColumnNumber" : 33
  } ],
  "layoutRelationDataList" : [ ]
}