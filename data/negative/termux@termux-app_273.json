{
  "id" : 273,
  "expression" : "effectiveBottomMargin",
  "projectName" : "termux@termux-app",
  "commitID" : "c6d6a6363730a1bb49aef4c94ebabc9e4f01606b",
  "filePath" : "app/src/main/java/com/termux/terminal/TerminalEmulator.java",
  "occurrences" : 4,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "effectiveBottomMargin",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 21,
      "startLineNumber" : 613,
      "startColumnNumber" : 75,
      "endLineNumber" : 613,
      "endColumnNumber" : 96
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 613,
        "startColumnNumber" : 75,
        "endLineNumber" : 613,
        "endColumnNumber" : 100
      },
      "nodeContext" : "effectiveBottomMargin + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 613,
        "startColumnNumber" : 16,
        "endLineNumber" : 613,
        "endColumnNumber" : 101
      },
      "nodeContext" : "Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 91,
        "startLineNumber" : 613,
        "startColumnNumber" : 10,
        "endLineNumber" : 613,
        "endColumnNumber" : 101
      },
      "nodeContext" : "top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 613,
        "startColumnNumber" : 6,
        "endLineNumber" : 613,
        "endColumnNumber" : 102
      },
      "nodeContext" : "int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 613,
        "startColumnNumber" : 6,
        "endLineNumber" : 613,
        "endColumnNumber" : 102
      },
      "nodeContext" : "int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "effectiveBottomMargin",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 21,
      "startLineNumber" : 615,
      "startColumnNumber" : 82,
      "endLineNumber" : 615,
      "endColumnNumber" : 103
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 615,
        "startColumnNumber" : 19,
        "endLineNumber" : 615,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 94,
        "startLineNumber" : 615,
        "startColumnNumber" : 10,
        "endLineNumber" : 615,
        "endColumnNumber" : 104
      },
      "nodeContext" : "bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 14,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 99,
        "startLineNumber" : 615,
        "startColumnNumber" : 6,
        "endLineNumber" : 615,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 99,
        "startLineNumber" : 615,
        "startColumnNumber" : 6,
        "endLineNumber" : 615,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "effectiveBottomMargin",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 21,
      "startLineNumber" : 630,
      "startColumnNumber" : 48,
      "endLineNumber" : 630,
      "endColumnNumber" : 69
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 630,
        "startColumnNumber" : 15,
        "endLineNumber" : 630,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1,effectiveBottomMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 630,
        "startColumnNumber" : 15,
        "endLineNumber" : 630,
        "endColumnNumber" : 91
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 630,
        "startColumnNumber" : 9,
        "endLineNumber" : 630,
        "endColumnNumber" : 91
      },
      "nodeContext" : "top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 630,
        "startColumnNumber" : 5,
        "endLineNumber" : 630,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 630,
        "startColumnNumber" : 5,
        "endLineNumber" : 630,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "effectiveBottomMargin",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 21,
      "startLineNumber" : 632,
      "startColumnNumber" : 55,
      "endLineNumber" : 632,
      "endColumnNumber" : 76
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 632,
        "startColumnNumber" : 55,
        "endLineNumber" : 632,
        "endColumnNumber" : 80
      },
      "nodeContext" : "effectiveBottomMargin - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 632,
        "startColumnNumber" : 9,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 21,
    "startLineNumber" : 613,
    "startColumnNumber" : 75,
    "endLineNumber" : 613,
    "endColumnNumber" : 96
  }, {
    "charLength" : 21,
    "startLineNumber" : 615,
    "startColumnNumber" : 82,
    "endLineNumber" : 615,
    "endColumnNumber" : 103
  }, {
    "charLength" : 21,
    "startLineNumber" : 630,
    "startColumnNumber" : 48,
    "endLineNumber" : 630,
    "endColumnNumber" : 69
  }, {
    "charLength" : 21,
    "startLineNumber" : 632,
    "startColumnNumber" : 55,
    "endLineNumber" : 632,
    "endColumnNumber" : 76
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 5
  } ]
}