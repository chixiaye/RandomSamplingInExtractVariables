{
  "id" : 89,
  "expression" : "selectCycleChild(key,graphPath,cycleStart)",
  "projectName" : "bazelbuild@bazel",
  "commitID" : "302971e1b3d803069ac949c0085c0d2a3916c8ab",
  "filePath" : "/src/main/java/com/google/devtools/build/skyframe/SimpleCycleDetector.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "selectCycleChild(key,graphPath,cycleStart)",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 44,
      "startLineNumber" : 231,
      "startColumnNumber" : 30,
      "endLineNumber" : 231,
      "endColumnNumber" : 74
    },
    "astNodeNumber" : 5,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 231,
        "startColumnNumber" : 17,
        "endLineNumber" : 231,
        "endColumnNumber" : 74
      },
      "nodeContext" : "cycleChild=selectCycleChild(key,graphPath,cycleStart)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 65,
        "startLineNumber" : 231,
        "startColumnNumber" : 10,
        "endLineNumber" : 231,
        "endColumnNumber" : 75
      },
      "nodeContext" : "SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1778,
        "startLineNumber" : 227,
        "startColumnNumber" : 42,
        "endLineNumber" : 259,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n  Set<SkyKey> removedDeps=removeDescendantsOfCycleValue(key,entry,cycleChild,toVisit,graphPath.size() - cycleStart,evaluatorContext);\n  ValueWithMetadata dummyValue=ValueWithMetadata.wrapWithMetadata(new SkyValue(){\n  }\n);\n  SkyFunctionEnvironment env=SkyFunctionEnvironment.createForError(key,entry.getTemporaryDirectDeps(),ImmutableMap.of(cycleChild,dummyValue),Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n  List<ErrorInfo> allErrors=getChildrenErrorsForCycleChecking(Iterables.concat(entry.getTemporaryDirectDeps()),cycleChild,evaluatorContext);\n  CycleInfo cycleInfo=new CycleInfo(cycle);\n  allErrors.add(ErrorInfo.fromCycle(cycleInfo));\n  env.setError(entry,ErrorInfo.fromChildErrors(key,allErrors));\n  Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n  evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n  continue;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 135,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2252,
        "startLineNumber" : 227,
        "startColumnNumber" : 8,
        "endLineNumber" : 269,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (evaluatorContext.keepGoing()) {\n  SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n  Set<SkyKey> removedDeps=removeDescendantsOfCycleValue(key,entry,cycleChild,toVisit,graphPath.size() - cycleStart,evaluatorContext);\n  ValueWithMetadata dummyValue=ValueWithMetadata.wrapWithMetadata(new SkyValue(){\n  }\n);\n  SkyFunctionEnvironment env=SkyFunctionEnvironment.createForError(key,entry.getTemporaryDirectDeps(),ImmutableMap.of(cycleChild,dummyValue),Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n  List<ErrorInfo> allErrors=getChildrenErrorsForCycleChecking(Iterables.concat(entry.getTemporaryDirectDeps()),cycleChild,evaluatorContext);\n  CycleInfo cycleInfo=new CycleInfo(cycle);\n  allErrors.add(ErrorInfo.fromCycle(cycleInfo));\n  env.setError(entry,ErrorInfo.fromChildErrors(key,allErrors));\n  Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n  evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n  continue;\n}\n else {\n  Preconditions.checkState(graphPath.get(0).equals(root),\"%s not reached from %s. ValueEntry: %s\",key,root,entry);\n  return ErrorInfo.fromCycle(new CycleInfo(graphPath.subList(0,cycleStart),cycle));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 168,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 3980,
        "startLineNumber" : 191,
        "startColumnNumber" : 33,
        "endLineNumber" : 270,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int cycleStart=graphPath.indexOf(key);\n  cyclesFound++;\n  Iterable<SkyKey> cycle=graphPath.subList(cycleStart,graphPath.size());\n  logger.atInfo().log(\"Found cycle : %s from %s\",cycle,graphPath);\n  if (entry.isDirty()) {\n    int loopCount=0;\n    Version graphVersion=evaluatorContext.getGraphVersion();\n    while (entry.getDirtyState() == NodeEntry.DirtyState.CHECK_DEPENDENCIES) {\n      entry.signalDep(graphVersion,null);\n      loopCount++;\n    }\n    if (loopCount > 1 && !entry.getVersion().equals(graphVersion)) {\n      BugReport.sendBugReport(new IllegalStateException(\"Entry needed multiple signaling but didn't have the graph version: \" + key + \", \"+ entry+ \", \"+ graphVersion+ \", \"+ graphPath));\n    }\n    if (entry.getDirtyState() == NodeEntry.DirtyState.NEEDS_REBUILDING) {\n      entry.markRebuilding();\n    }\n else     if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n      continue;\n    }\n  }\n  if (evaluatorContext.keepGoing()) {\n    SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n    Set<SkyKey> removedDeps=removeDescendantsOfCycleValue(key,entry,cycleChild,toVisit,graphPath.size() - cycleStart,evaluatorContext);\n    ValueWithMetadata dummyValue=ValueWithMetadata.wrapWithMetadata(new SkyValue(){\n    }\n);\n    SkyFunctionEnvironment env=SkyFunctionEnvironment.createForError(key,entry.getTemporaryDirectDeps(),ImmutableMap.of(cycleChild,dummyValue),Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n    List<ErrorInfo> allErrors=getChildrenErrorsForCycleChecking(Iterables.concat(entry.getTemporaryDirectDeps()),cycleChild,evaluatorContext);\n    CycleInfo cycleInfo=new CycleInfo(cycle);\n    allErrors.add(ErrorInfo.fromCycle(cycleInfo));\n    env.setError(entry,ErrorInfo.fromChildErrors(key,allErrors));\n    Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n    evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n    continue;\n  }\n else {\n    Preconditions.checkState(graphPath.get(0).equals(root),\"%s not reached from %s. ValueEntry: %s\",key,root,entry);\n    return ErrorInfo.fromCycle(new CycleInfo(graphPath.subList(0,cycleStart),cycle));\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 295,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4007,
        "startLineNumber" : 191,
        "startColumnNumber" : 6,
        "endLineNumber" : 270,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (pathSet.contains(key)) {\n  int cycleStart=graphPath.indexOf(key);\n  cyclesFound++;\n  Iterable<SkyKey> cycle=graphPath.subList(cycleStart,graphPath.size());\n  logger.atInfo().log(\"Found cycle : %s from %s\",cycle,graphPath);\n  if (entry.isDirty()) {\n    int loopCount=0;\n    Version graphVersion=evaluatorContext.getGraphVersion();\n    while (entry.getDirtyState() == NodeEntry.DirtyState.CHECK_DEPENDENCIES) {\n      entry.signalDep(graphVersion,null);\n      loopCount++;\n    }\n    if (loopCount > 1 && !entry.getVersion().equals(graphVersion)) {\n      BugReport.sendBugReport(new IllegalStateException(\"Entry needed multiple signaling but didn't have the graph version: \" + key + \", \"+ entry+ \", \"+ graphVersion+ \", \"+ graphPath));\n    }\n    if (entry.getDirtyState() == NodeEntry.DirtyState.NEEDS_REBUILDING) {\n      entry.markRebuilding();\n    }\n else     if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n      continue;\n    }\n  }\n  if (evaluatorContext.keepGoing()) {\n    SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n    Set<SkyKey> removedDeps=removeDescendantsOfCycleValue(key,entry,cycleChild,toVisit,graphPath.size() - cycleStart,evaluatorContext);\n    ValueWithMetadata dummyValue=ValueWithMetadata.wrapWithMetadata(new SkyValue(){\n    }\n);\n    SkyFunctionEnvironment env=SkyFunctionEnvironment.createForError(key,entry.getTemporaryDirectDeps(),ImmutableMap.of(cycleChild,dummyValue),Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n    List<ErrorInfo> allErrors=getChildrenErrorsForCycleChecking(Iterables.concat(entry.getTemporaryDirectDeps()),cycleChild,evaluatorContext);\n    CycleInfo cycleInfo=new CycleInfo(cycle);\n    allErrors.add(ErrorInfo.fromCycle(cycleInfo));\n    env.setError(entry,ErrorInfo.fromChildErrors(key,allErrors));\n    Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n    evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n    continue;\n  }\n else {\n    Preconditions.checkState(graphPath.get(0).equals(root),\"%s not reached from %s. ValueEntry: %s\",key,root,entry);\n    return ErrorInfo.fromCycle(new CycleInfo(graphPath.subList(0,cycleStart),cycle));\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 300,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 9707,
        "startLineNumber" : 110,
        "startColumnNumber" : 31,
        "endLineNumber" : 315,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  SkyKey key=toVisit.pop();\n  NodeEntry entry;\n  if (key == CHILDREN_FINISHED) {\n    key=graphPath.remove(graphPath.size() - 1);\n    entry=Preconditions.checkNotNull(evaluatorContext.getGraph().get(null,Reason.CYCLE_CHECKING,key),key);\n    pathSet.remove(key);\n    if (entry.isDone()) {\n      continue;\n    }\n    if (!evaluatorContext.keepGoing()) {\n      continue;\n    }\n    Set<SkyKey> removedDeps=ImmutableSet.of();\n    if (cyclesFound < MAX_CYCLES) {\n      Preconditions.checkState(entry.isReady(),\"%s not ready. ValueEntry: %s\",key,entry);\n    }\n else     if (!entry.isReady()) {\n      removedDeps=removeIncompleteChildrenForCycle(key,entry,Iterables.concat(entry.getTemporaryDirectDeps()),evaluatorContext);\n    }\n    if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n      continue;\n    }\n    maybeMarkRebuilding(entry);\n    GroupedList<SkyKey> directDeps=entry.getTemporaryDirectDeps();\n    List<ErrorInfo> errorDeps=getChildrenErrorsForCycle(key,Iterables.concat(directDeps),directDeps.numElements(),entry,evaluatorContext);\n    Preconditions.checkState(!errorDeps.isEmpty(),\"Node %s was not successfully evaluated, but had no child errors. NodeEntry: %s\",key,entry);\n    SkyFunctionEnvironment env;\n    try {\n      env=SkyFunctionEnvironment.create(key,directDeps,Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n    }\n catch (    UndonePreviouslyRequestedDeps undoneDeps) {\n      throw new IllegalStateException(\"Previously requested dep not done: \" + undoneDeps.getDepKeys(),undoneDeps);\n    }\n    env.setError(entry,ErrorInfo.fromChildErrors(key,errorDeps));\n    Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n    evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n  }\n else {\n    entry=evaluatorContext.getGraph().get(null,Reason.CYCLE_CHECKING,key);\n  }\n  Preconditions.checkNotNull(entry,key);\n  if (entry.isDone()) {\n    continue;\n  }\n  if (cyclesFound == MAX_CYCLES) {\n    continue;\n  }\n  if (pathSet.contains(key)) {\n    int cycleStart=graphPath.indexOf(key);\n    cyclesFound++;\n    Iterable<SkyKey> cycle=graphPath.subList(cycleStart,graphPath.size());\n    logger.atInfo().log(\"Found cycle : %s from %s\",cycle,graphPath);\n    if (entry.isDirty()) {\n      int loopCount=0;\n      Version graphVersion=evaluatorContext.getGraphVersion();\n      while (entry.getDirtyState() == NodeEntry.DirtyState.CHECK_DEPENDENCIES) {\n        entry.signalDep(graphVersion,null);\n        loopCount++;\n      }\n      if (loopCount > 1 && !entry.getVersion().equals(graphVersion)) {\n        BugReport.sendBugReport(new IllegalStateException(\"Entry needed multiple signaling but didn't have the graph version: \" + key + \", \"+ entry+ \", \"+ graphVersion+ \", \"+ graphPath));\n      }\n      if (entry.getDirtyState() == NodeEntry.DirtyState.NEEDS_REBUILDING) {\n        entry.markRebuilding();\n      }\n else       if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n        continue;\n      }\n    }\n    if (evaluatorContext.keepGoing()) {\n      SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n      Set<SkyKey> removedDeps=removeDescendantsOfCycleValue(key,entry,cycleChild,toVisit,graphPath.size() - cycleStart,evaluatorContext);\n      ValueWithMetadata dummyValue=ValueWithMetadata.wrapWithMetadata(new SkyValue(){\n      }\n);\n      SkyFunctionEnvironment env=SkyFunctionEnvironment.createForError(key,entry.getTemporaryDirectDeps(),ImmutableMap.of(cycleChild,dummyValue),Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n      List<ErrorInfo> allErrors=getChildrenErrorsForCycleChecking(Iterables.concat(entry.getTemporaryDirectDeps()),cycleChild,evaluatorContext);\n      CycleInfo cycleInfo=new CycleInfo(cycle);\n      allErrors.add(ErrorInfo.fromCycle(cycleInfo));\n      env.setError(entry,ErrorInfo.fromChildErrors(key,allErrors));\n      Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n      evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n      continue;\n    }\n else {\n      Preconditions.checkState(graphPath.get(0).equals(root),\"%s not reached from %s. ValueEntry: %s\",key,root,entry);\n      return ErrorInfo.fromCycle(new CycleInfo(graphPath.subList(0,cycleStart),cycle));\n    }\n  }\n  GroupedList<SkyKey> temporaryDirectDeps=entry.getTemporaryDirectDeps();\n  Iterable<SkyKey> children=temporaryDirectDeps.getAllElementsAsIterable();\n  if (temporaryDirectDeps.isEmpty()) {\n    continue;\n  }\n  Map<SkyKey,? extends NodeEntry> childrenNodes=evaluatorContext.getGraph().getBatch(key,Reason.EXISTENCE_CHECKING,children);\n  if (childrenNodes.size() != temporaryDirectDeps.numElements()) {\n    ImmutableSet<SkyKey> childrenSet=ImmutableSet.copyOf(children);\n    Set<SkyKey> missingChildren=Sets.difference(childrenSet,childrenNodes.keySet());\n    if (missingChildren.isEmpty()) {\n      logger.atWarning().log(\"Mismatch for children?? %d, %d, %s, %s, %s, %s\",childrenNodes.size(),temporaryDirectDeps.numElements(),childrenSet,childrenNodes,key,entry);\n    }\n else {\n      evaluatorContext.getGraphInconsistencyReceiver().noteInconsistencyAndMaybeThrow(key,missingChildren,Inconsistency.ALREADY_DECLARED_CHILD_MISSING);\n      entry.removeUnfinishedDeps(missingChildren);\n    }\n  }\n  children=Maps.filterValues(childrenNodes,nodeEntry -> !nodeEntry.isDone()).keySet();\n  toVisit.push(CHILDREN_FINISHED);\n  graphPath.add(key);\n  pathSet.add(key);\n  for (  SkyKey nextValue : children) {\n    toVisit.push(nextValue);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 735,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 9734,
        "startLineNumber" : 110,
        "startColumnNumber" : 4,
        "endLineNumber" : 315,
        "endColumnNumber" : 5
      },
      "nodeContext" : "while (!toVisit.isEmpty()) {\n  SkyKey key=toVisit.pop();\n  NodeEntry entry;\n  if (key == CHILDREN_FINISHED) {\n    key=graphPath.remove(graphPath.size() - 1);\n    entry=Preconditions.checkNotNull(evaluatorContext.getGraph().get(null,Reason.CYCLE_CHECKING,key),key);\n    pathSet.remove(key);\n    if (entry.isDone()) {\n      continue;\n    }\n    if (!evaluatorContext.keepGoing()) {\n      continue;\n    }\n    Set<SkyKey> removedDeps=ImmutableSet.of();\n    if (cyclesFound < MAX_CYCLES) {\n      Preconditions.checkState(entry.isReady(),\"%s not ready. ValueEntry: %s\",key,entry);\n    }\n else     if (!entry.isReady()) {\n      removedDeps=removeIncompleteChildrenForCycle(key,entry,Iterables.concat(entry.getTemporaryDirectDeps()),evaluatorContext);\n    }\n    if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n      continue;\n    }\n    maybeMarkRebuilding(entry);\n    GroupedList<SkyKey> directDeps=entry.getTemporaryDirectDeps();\n    List<ErrorInfo> errorDeps=getChildrenErrorsForCycle(key,Iterables.concat(directDeps),directDeps.numElements(),entry,evaluatorContext);\n    Preconditions.checkState(!errorDeps.isEmpty(),\"Node %s was not successfully evaluated, but had no child errors. NodeEntry: %s\",key,entry);\n    SkyFunctionEnvironment env;\n    try {\n      env=SkyFunctionEnvironment.create(key,directDeps,Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n    }\n catch (    UndonePreviouslyRequestedDeps undoneDeps) {\n      throw new IllegalStateException(\"Previously requested dep not done: \" + undoneDeps.getDepKeys(),undoneDeps);\n    }\n    env.setError(entry,ErrorInfo.fromChildErrors(key,errorDeps));\n    Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n    evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n  }\n else {\n    entry=evaluatorContext.getGraph().get(null,Reason.CYCLE_CHECKING,key);\n  }\n  Preconditions.checkNotNull(entry,key);\n  if (entry.isDone()) {\n    continue;\n  }\n  if (cyclesFound == MAX_CYCLES) {\n    continue;\n  }\n  if (pathSet.contains(key)) {\n    int cycleStart=graphPath.indexOf(key);\n    cyclesFound++;\n    Iterable<SkyKey> cycle=graphPath.subList(cycleStart,graphPath.size());\n    logger.atInfo().log(\"Found cycle : %s from %s\",cycle,graphPath);\n    if (entry.isDirty()) {\n      int loopCount=0;\n      Version graphVersion=evaluatorContext.getGraphVersion();\n      while (entry.getDirtyState() == NodeEntry.DirtyState.CHECK_DEPENDENCIES) {\n        entry.signalDep(graphVersion,null);\n        loopCount++;\n      }\n      if (loopCount > 1 && !entry.getVersion().equals(graphVersion)) {\n        BugReport.sendBugReport(new IllegalStateException(\"Entry needed multiple signaling but didn't have the graph version: \" + key + \", \"+ entry+ \", \"+ graphVersion+ \", \"+ graphPath));\n      }\n      if (entry.getDirtyState() == NodeEntry.DirtyState.NEEDS_REBUILDING) {\n        entry.markRebuilding();\n      }\n else       if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n        continue;\n      }\n    }\n    if (evaluatorContext.keepGoing()) {\n      SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n      Set<SkyKey> removedDeps=removeDescendantsOfCycleValue(key,entry,cycleChild,toVisit,graphPath.size() - cycleStart,evaluatorContext);\n      ValueWithMetadata dummyValue=ValueWithMetadata.wrapWithMetadata(new SkyValue(){\n      }\n);\n      SkyFunctionEnvironment env=SkyFunctionEnvironment.createForError(key,entry.getTemporaryDirectDeps(),ImmutableMap.of(cycleChild,dummyValue),Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n      List<ErrorInfo> allErrors=getChildrenErrorsForCycleChecking(Iterables.concat(entry.getTemporaryDirectDeps()),cycleChild,evaluatorContext);\n      CycleInfo cycleInfo=new CycleInfo(cycle);\n      allErrors.add(ErrorInfo.fromCycle(cycleInfo));\n      env.setError(entry,ErrorInfo.fromChildErrors(key,allErrors));\n      Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n      evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n      continue;\n    }\n else {\n      Preconditions.checkState(graphPath.get(0).equals(root),\"%s not reached from %s. ValueEntry: %s\",key,root,entry);\n      return ErrorInfo.fromCycle(new CycleInfo(graphPath.subList(0,cycleStart),cycle));\n    }\n  }\n  GroupedList<SkyKey> temporaryDirectDeps=entry.getTemporaryDirectDeps();\n  Iterable<SkyKey> children=temporaryDirectDeps.getAllElementsAsIterable();\n  if (temporaryDirectDeps.isEmpty()) {\n    continue;\n  }\n  Map<SkyKey,? extends NodeEntry> childrenNodes=evaluatorContext.getGraph().getBatch(key,Reason.EXISTENCE_CHECKING,children);\n  if (childrenNodes.size() != temporaryDirectDeps.numElements()) {\n    ImmutableSet<SkyKey> childrenSet=ImmutableSet.copyOf(children);\n    Set<SkyKey> missingChildren=Sets.difference(childrenSet,childrenNodes.keySet());\n    if (missingChildren.isEmpty()) {\n      logger.atWarning().log(\"Mismatch for children?? %d, %d, %s, %s, %s, %s\",childrenNodes.size(),temporaryDirectDeps.numElements(),childrenSet,childrenNodes,key,entry);\n    }\n else {\n      evaluatorContext.getGraphInconsistencyReceiver().noteInconsistencyAndMaybeThrow(key,missingChildren,Inconsistency.ALREADY_DECLARED_CHILD_MISSING);\n      entry.removeUnfinishedDeps(missingChildren);\n    }\n  }\n  children=Maps.filterValues(childrenNodes,nodeEntry -> !nodeEntry.isDone()).keySet();\n  toVisit.push(CHILDREN_FINISHED);\n  graphPath.add(key);\n  pathSet.add(key);\n  for (  SkyKey nextValue : children) {\n    toVisit.push(nextValue);\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 740,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 10967,
        "startLineNumber" : 89,
        "startColumnNumber" : 34,
        "endLineNumber" : 319,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  int cyclesFound=0;\n  List<SkyKey> graphPath=new ArrayList<>();\n  Set<SkyKey> pathSet=new HashSet<>();\n  Deque<SkyKey> toVisit=new ArrayDeque<>();\n  toVisit.push(root);\n  while (!toVisit.isEmpty()) {\n    SkyKey key=toVisit.pop();\n    NodeEntry entry;\n    if (key == CHILDREN_FINISHED) {\n      key=graphPath.remove(graphPath.size() - 1);\n      entry=Preconditions.checkNotNull(evaluatorContext.getGraph().get(null,Reason.CYCLE_CHECKING,key),key);\n      pathSet.remove(key);\n      if (entry.isDone()) {\n        continue;\n      }\n      if (!evaluatorContext.keepGoing()) {\n        continue;\n      }\n      Set<SkyKey> removedDeps=ImmutableSet.of();\n      if (cyclesFound < MAX_CYCLES) {\n        Preconditions.checkState(entry.isReady(),\"%s not ready. ValueEntry: %s\",key,entry);\n      }\n else       if (!entry.isReady()) {\n        removedDeps=removeIncompleteChildrenForCycle(key,entry,Iterables.concat(entry.getTemporaryDirectDeps()),evaluatorContext);\n      }\n      if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n        continue;\n      }\n      maybeMarkRebuilding(entry);\n      GroupedList<SkyKey> directDeps=entry.getTemporaryDirectDeps();\n      List<ErrorInfo> errorDeps=getChildrenErrorsForCycle(key,Iterables.concat(directDeps),directDeps.numElements(),entry,evaluatorContext);\n      Preconditions.checkState(!errorDeps.isEmpty(),\"Node %s was not successfully evaluated, but had no child errors. NodeEntry: %s\",key,entry);\n      SkyFunctionEnvironment env;\n      try {\n        env=SkyFunctionEnvironment.create(key,directDeps,Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n      }\n catch (      UndonePreviouslyRequestedDeps undoneDeps) {\n        throw new IllegalStateException(\"Previously requested dep not done: \" + undoneDeps.getDepKeys(),undoneDeps);\n      }\n      env.setError(entry,ErrorInfo.fromChildErrors(key,errorDeps));\n      Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n      evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n    }\n else {\n      entry=evaluatorContext.getGraph().get(null,Reason.CYCLE_CHECKING,key);\n    }\n    Preconditions.checkNotNull(entry,key);\n    if (entry.isDone()) {\n      continue;\n    }\n    if (cyclesFound == MAX_CYCLES) {\n      continue;\n    }\n    if (pathSet.contains(key)) {\n      int cycleStart=graphPath.indexOf(key);\n      cyclesFound++;\n      Iterable<SkyKey> cycle=graphPath.subList(cycleStart,graphPath.size());\n      logger.atInfo().log(\"Found cycle : %s from %s\",cycle,graphPath);\n      if (entry.isDirty()) {\n        int loopCount=0;\n        Version graphVersion=evaluatorContext.getGraphVersion();\n        while (entry.getDirtyState() == NodeEntry.DirtyState.CHECK_DEPENDENCIES) {\n          entry.signalDep(graphVersion,null);\n          loopCount++;\n        }\n        if (loopCount > 1 && !entry.getVersion().equals(graphVersion)) {\n          BugReport.sendBugReport(new IllegalStateException(\"Entry needed multiple signaling but didn't have the graph version: \" + key + \", \"+ entry+ \", \"+ graphVersion+ \", \"+ graphPath));\n        }\n        if (entry.getDirtyState() == NodeEntry.DirtyState.NEEDS_REBUILDING) {\n          entry.markRebuilding();\n        }\n else         if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n          continue;\n        }\n      }\n      if (evaluatorContext.keepGoing()) {\n        SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n        Set<SkyKey> removedDeps=removeDescendantsOfCycleValue(key,entry,cycleChild,toVisit,graphPath.size() - cycleStart,evaluatorContext);\n        ValueWithMetadata dummyValue=ValueWithMetadata.wrapWithMetadata(new SkyValue(){\n        }\n);\n        SkyFunctionEnvironment env=SkyFunctionEnvironment.createForError(key,entry.getTemporaryDirectDeps(),ImmutableMap.of(cycleChild,dummyValue),Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n        List<ErrorInfo> allErrors=getChildrenErrorsForCycleChecking(Iterables.concat(entry.getTemporaryDirectDeps()),cycleChild,evaluatorContext);\n        CycleInfo cycleInfo=new CycleInfo(cycle);\n        allErrors.add(ErrorInfo.fromCycle(cycleInfo));\n        env.setError(entry,ErrorInfo.fromChildErrors(key,allErrors));\n        Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n        evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n        continue;\n      }\n else {\n        Preconditions.checkState(graphPath.get(0).equals(root),\"%s not reached from %s. ValueEntry: %s\",key,root,entry);\n        return ErrorInfo.fromCycle(new CycleInfo(graphPath.subList(0,cycleStart),cycle));\n      }\n    }\n    GroupedList<SkyKey> temporaryDirectDeps=entry.getTemporaryDirectDeps();\n    Iterable<SkyKey> children=temporaryDirectDeps.getAllElementsAsIterable();\n    if (temporaryDirectDeps.isEmpty()) {\n      continue;\n    }\n    Map<SkyKey,? extends NodeEntry> childrenNodes=evaluatorContext.getGraph().getBatch(key,Reason.EXISTENCE_CHECKING,children);\n    if (childrenNodes.size() != temporaryDirectDeps.numElements()) {\n      ImmutableSet<SkyKey> childrenSet=ImmutableSet.copyOf(children);\n      Set<SkyKey> missingChildren=Sets.difference(childrenSet,childrenNodes.keySet());\n      if (missingChildren.isEmpty()) {\n        logger.atWarning().log(\"Mismatch for children?? %d, %d, %s, %s, %s, %s\",childrenNodes.size(),temporaryDirectDeps.numElements(),childrenSet,childrenNodes,key,entry);\n      }\n else {\n        evaluatorContext.getGraphInconsistencyReceiver().noteInconsistencyAndMaybeThrow(key,missingChildren,Inconsistency.ALREADY_DECLARED_CHILD_MISSING);\n        entry.removeUnfinishedDeps(missingChildren);\n      }\n    }\n    children=Maps.filterValues(childrenNodes,nodeEntry -> !nodeEntry.isDone()).keySet();\n    toVisit.push(CHILDREN_FINISHED);\n    graphPath.add(key);\n    pathSet.add(key);\n    for (    SkyKey nextValue : children) {\n      toVisit.push(nextValue);\n    }\n  }\n  return evaluatorContext.keepGoing() ? getAndCheckDoneForCycle(root,evaluatorContext).getErrorInfo() : null;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 799,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11697,
        "startLineNumber" : 80,
        "startColumnNumber" : 2,
        "endLineNumber" : 319,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * The algorithm for this cycle detector is as follows. We visit the graph depth-first, keeping track of the path we are currently on. We skip any DONE nodes (they are transitively error-free). If we come to a node already on the path, we immediately construct a cycle. If we are in the noKeepGoing case, we return ErrorInfo with that cycle to the caller. Otherwise, we continue. Once all of a node's children are done, we construct an error value for it, based on those children. Finally, when the original root's node is constructed, we return its ErrorInfo.\n */\nprivate static ErrorInfo checkForCycles(SkyKey root,ParallelEvaluatorContext evaluatorContext) throws InterruptedException {\n  int cyclesFound=0;\n  List<SkyKey> graphPath=new ArrayList<>();\n  Set<SkyKey> pathSet=new HashSet<>();\n  Deque<SkyKey> toVisit=new ArrayDeque<>();\n  toVisit.push(root);\n  while (!toVisit.isEmpty()) {\n    SkyKey key=toVisit.pop();\n    NodeEntry entry;\n    if (key == CHILDREN_FINISHED) {\n      key=graphPath.remove(graphPath.size() - 1);\n      entry=Preconditions.checkNotNull(evaluatorContext.getGraph().get(null,Reason.CYCLE_CHECKING,key),key);\n      pathSet.remove(key);\n      if (entry.isDone()) {\n        continue;\n      }\n      if (!evaluatorContext.keepGoing()) {\n        continue;\n      }\n      Set<SkyKey> removedDeps=ImmutableSet.of();\n      if (cyclesFound < MAX_CYCLES) {\n        Preconditions.checkState(entry.isReady(),\"%s not ready. ValueEntry: %s\",key,entry);\n      }\n else       if (!entry.isReady()) {\n        removedDeps=removeIncompleteChildrenForCycle(key,entry,Iterables.concat(entry.getTemporaryDirectDeps()),evaluatorContext);\n      }\n      if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n        continue;\n      }\n      maybeMarkRebuilding(entry);\n      GroupedList<SkyKey> directDeps=entry.getTemporaryDirectDeps();\n      List<ErrorInfo> errorDeps=getChildrenErrorsForCycle(key,Iterables.concat(directDeps),directDeps.numElements(),entry,evaluatorContext);\n      Preconditions.checkState(!errorDeps.isEmpty(),\"Node %s was not successfully evaluated, but had no child errors. NodeEntry: %s\",key,entry);\n      SkyFunctionEnvironment env;\n      try {\n        env=SkyFunctionEnvironment.create(key,directDeps,Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n      }\n catch (      UndonePreviouslyRequestedDeps undoneDeps) {\n        throw new IllegalStateException(\"Previously requested dep not done: \" + undoneDeps.getDepKeys(),undoneDeps);\n      }\n      env.setError(entry,ErrorInfo.fromChildErrors(key,errorDeps));\n      Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n      evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n    }\n else {\n      entry=evaluatorContext.getGraph().get(null,Reason.CYCLE_CHECKING,key);\n    }\n    Preconditions.checkNotNull(entry,key);\n    if (entry.isDone()) {\n      continue;\n    }\n    if (cyclesFound == MAX_CYCLES) {\n      continue;\n    }\n    if (pathSet.contains(key)) {\n      int cycleStart=graphPath.indexOf(key);\n      cyclesFound++;\n      Iterable<SkyKey> cycle=graphPath.subList(cycleStart,graphPath.size());\n      logger.atInfo().log(\"Found cycle : %s from %s\",cycle,graphPath);\n      if (entry.isDirty()) {\n        int loopCount=0;\n        Version graphVersion=evaluatorContext.getGraphVersion();\n        while (entry.getDirtyState() == NodeEntry.DirtyState.CHECK_DEPENDENCIES) {\n          entry.signalDep(graphVersion,null);\n          loopCount++;\n        }\n        if (loopCount > 1 && !entry.getVersion().equals(graphVersion)) {\n          BugReport.sendBugReport(new IllegalStateException(\"Entry needed multiple signaling but didn't have the graph version: \" + key + \", \"+ entry+ \", \"+ graphVersion+ \", \"+ graphPath));\n        }\n        if (entry.getDirtyState() == NodeEntry.DirtyState.NEEDS_REBUILDING) {\n          entry.markRebuilding();\n        }\n else         if (maybeHandleVerifiedCleanNode(key,entry,evaluatorContext,graphPath)) {\n          continue;\n        }\n      }\n      if (evaluatorContext.keepGoing()) {\n        SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n        Set<SkyKey> removedDeps=removeDescendantsOfCycleValue(key,entry,cycleChild,toVisit,graphPath.size() - cycleStart,evaluatorContext);\n        ValueWithMetadata dummyValue=ValueWithMetadata.wrapWithMetadata(new SkyValue(){\n        }\n);\n        SkyFunctionEnvironment env=SkyFunctionEnvironment.createForError(key,entry.getTemporaryDirectDeps(),ImmutableMap.of(cycleChild,dummyValue),Sets.difference(entry.getAllRemainingDirtyDirectDeps(),removedDeps),evaluatorContext);\n        List<ErrorInfo> allErrors=getChildrenErrorsForCycleChecking(Iterables.concat(entry.getTemporaryDirectDeps()),cycleChild,evaluatorContext);\n        CycleInfo cycleInfo=new CycleInfo(cycle);\n        allErrors.add(ErrorInfo.fromCycle(cycleInfo));\n        env.setError(entry,ErrorInfo.fromChildErrors(key,allErrors));\n        Set<SkyKey> reverseDeps=env.commitAndGetParents(entry);\n        evaluatorContext.signalParentsOnAbort(key,reverseDeps,entry.getVersion());\n        continue;\n      }\n else {\n        Preconditions.checkState(graphPath.get(0).equals(root),\"%s not reached from %s. ValueEntry: %s\",key,root,entry);\n        return ErrorInfo.fromCycle(new CycleInfo(graphPath.subList(0,cycleStart),cycle));\n      }\n    }\n    GroupedList<SkyKey> temporaryDirectDeps=entry.getTemporaryDirectDeps();\n    Iterable<SkyKey> children=temporaryDirectDeps.getAllElementsAsIterable();\n    if (temporaryDirectDeps.isEmpty()) {\n      continue;\n    }\n    Map<SkyKey,? extends NodeEntry> childrenNodes=evaluatorContext.getGraph().getBatch(key,Reason.EXISTENCE_CHECKING,children);\n    if (childrenNodes.size() != temporaryDirectDeps.numElements()) {\n      ImmutableSet<SkyKey> childrenSet=ImmutableSet.copyOf(children);\n      Set<SkyKey> missingChildren=Sets.difference(childrenSet,childrenNodes.keySet());\n      if (missingChildren.isEmpty()) {\n        logger.atWarning().log(\"Mismatch for children?? %d, %d, %s, %s, %s, %s\",childrenNodes.size(),temporaryDirectDeps.numElements(),childrenSet,childrenNodes,key,entry);\n      }\n else {\n        evaluatorContext.getGraphInconsistencyReceiver().noteInconsistencyAndMaybeThrow(key,missingChildren,Inconsistency.ALREADY_DECLARED_CHILD_MISSING);\n        entry.removeUnfinishedDeps(missingChildren);\n      }\n    }\n    children=Maps.filterValues(childrenNodes,nodeEntry -> !nodeEntry.isDone()).keySet();\n    toVisit.push(CHILDREN_FINISHED);\n    graphPath.add(key);\n    pathSet.add(key);\n    for (    SkyKey nextValue : children) {\n      toVisit.push(nextValue);\n    }\n  }\n  return evaluatorContext.keepGoing() ? getAndCheckDoneForCycle(root,evaluatorContext).getErrorInfo() : null;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 816,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 65,
        "startLineNumber" : 231,
        "startColumnNumber" : 10,
        "endLineNumber" : 231,
        "endColumnNumber" : 75
      },
      "nodeContext" : "SkyKey cycleChild=selectCycleChild(key,graphPath,cycleStart);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 4
    },
    "tokenLength" : 4,
    "type" : "com.google.devtools.build.skyframe.SkyKey"
  } ],
  "positionList" : [ {
    "charLength" : 44,
    "startLineNumber" : 231,
    "startColumnNumber" : 30,
    "endLineNumber" : 231,
    "endColumnNumber" : 74
  } ],
  "layoutRelationDataList" : [ ]
}