{
  "id" : 45,
  "expression" : "Pair",
  "projectName" : "thingsboard@thingsboard",
  "commitID" : "7c2b3a9fbf84cc58aa7546029c5c7c10a662c55a",
  "filePath" : "/dao/src/test/java/org/apache/cassandra/io/sstable/Descriptor.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "Pair",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 317,
      "startColumnNumber" : 15,
      "endLineNumber" : 317,
      "endColumnNumber" : 19
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ReturnStatement,expression]",
      "nodePosition" : {
        "charLength" : 251,
        "startLineNumber" : 317,
        "startColumnNumber" : 15,
        "endLineNumber" : 320,
        "endColumnNumber" : 26
      },
      "nodeContext" : "Pair.create(new Descriptor(version,parentDirectory,ksname,cfname,generation,fmt,Component.digestFor(version.uncompressedChecksumType())),component)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 19,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 259,
        "startLineNumber" : 317,
        "startColumnNumber" : 8,
        "endLineNumber" : 320,
        "endColumnNumber" : 27
      },
      "nodeContext" : "return Pair.create(new Descriptor(version,parentDirectory,ksname,cfname,generation,fmt,Component.digestFor(version.uncompressedChecksumType())),component);\n",
      "nodeType" : "ReturnStatement",
      "astNodeNumber" : 20,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 2706,
        "startLineNumber" : 249,
        "startColumnNumber" : 4,
        "endLineNumber" : 321,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  File parentDirectory=directory != null ? directory : new File(\".\");\n  StringTokenizer st=new StringTokenizer(name,String.valueOf(separator));\n  String nexttok;\n  Deque<String> tokenStack=new ArrayDeque<>();\n  while (st.hasMoreTokens()) {\n    tokenStack.push(st.nextToken());\n  }\n  String component=skipComponent ? null : tokenStack.pop();\n  nexttok=tokenStack.pop();\n  SSTableFormat.Type fmt=SSTableFormat.Type.LEGACY;\n  if (!CharMatcher.digit().matchesAllOf(nexttok)) {\n    fmt=SSTableFormat.Type.validate(nexttok);\n    nexttok=tokenStack.pop();\n  }\n  int generation=Integer.parseInt(nexttok);\n  nexttok=tokenStack.pop();\n  if (!Version.validate(nexttok))   throw new UnsupportedOperationException(\"SSTable \" + name + \" is too old to open.  Upgrade to 2.0 first, and run upgradesstables\");\n  Version version=fmt.info.getVersion(nexttok);\n  String ksname, cfname;\n  if (version.hasNewFileName()) {\n    File cfDirectory=parentDirectory;\n    String indexName=\"\";\n    if (cfDirectory.getName().startsWith(Directories.SECONDARY_INDEX_NAME_SEPARATOR)) {\n      indexName=cfDirectory.getName();\n      cfDirectory=cfDirectory.getParentFile();\n    }\n    if (cfDirectory.getName().equals(Directories.BACKUPS_SUBDIR)) {\n      cfDirectory=cfDirectory.getParentFile();\n    }\n else     if (cfDirectory.getParentFile().getName().equals(Directories.SNAPSHOT_SUBDIR)) {\n      cfDirectory=cfDirectory.getParentFile().getParentFile();\n    }\n    cfname=cfDirectory.getName().split(\"-\")[0] + indexName;\n    ksname=cfDirectory.getParentFile().getName();\n  }\n else {\n    cfname=tokenStack.pop();\n    ksname=tokenStack.pop();\n  }\n  assert tokenStack.isEmpty() : \"Invalid file name \" + name + \" in \"+ directory;\n  return Pair.create(new Descriptor(version,parentDirectory,ksname,cfname,generation,fmt,Component.digestFor(version.uncompressedChecksumType())),component);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 294,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3587,
        "startLineNumber" : 231,
        "startColumnNumber" : 4,
        "endLineNumber" : 321,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Filename of the form is vary by version: <ul> <li>&lt;ksname&gt;-&lt;cfname&gt;-(tmp-)?&lt;version&gt;-&lt;gen&gt;-&lt;component&gt; for cassandra 2.0 and before</li> <li>(&lt;tmp marker&gt;-)?&lt;version&gt;-&lt;gen&gt;-&lt;component&gt; for cassandra 3.0 and later</li> </ul> If this is for SSTable of secondary index, directory should ends with index name for 2.1+.\n * @param directory The directory of the SSTable files\n * @param name The name of the SSTable file\n * @param skipComponent true if the name param should not be parsed for a component tag\n * @return A Descriptor for the SSTable, and the Component remainder.\n */\n@SuppressWarnings(\"deprecation\") public static Pair<Descriptor,String> fromFilename(File directory,String name,boolean skipComponent){\n  File parentDirectory=directory != null ? directory : new File(\".\");\n  StringTokenizer st=new StringTokenizer(name,String.valueOf(separator));\n  String nexttok;\n  Deque<String> tokenStack=new ArrayDeque<>();\n  while (st.hasMoreTokens()) {\n    tokenStack.push(st.nextToken());\n  }\n  String component=skipComponent ? null : tokenStack.pop();\n  nexttok=tokenStack.pop();\n  SSTableFormat.Type fmt=SSTableFormat.Type.LEGACY;\n  if (!CharMatcher.digit().matchesAllOf(nexttok)) {\n    fmt=SSTableFormat.Type.validate(nexttok);\n    nexttok=tokenStack.pop();\n  }\n  int generation=Integer.parseInt(nexttok);\n  nexttok=tokenStack.pop();\n  if (!Version.validate(nexttok))   throw new UnsupportedOperationException(\"SSTable \" + name + \" is too old to open.  Upgrade to 2.0 first, and run upgradesstables\");\n  Version version=fmt.info.getVersion(nexttok);\n  String ksname, cfname;\n  if (version.hasNewFileName()) {\n    File cfDirectory=parentDirectory;\n    String indexName=\"\";\n    if (cfDirectory.getName().startsWith(Directories.SECONDARY_INDEX_NAME_SEPARATOR)) {\n      indexName=cfDirectory.getName();\n      cfDirectory=cfDirectory.getParentFile();\n    }\n    if (cfDirectory.getName().equals(Directories.BACKUPS_SUBDIR)) {\n      cfDirectory=cfDirectory.getParentFile();\n    }\n else     if (cfDirectory.getParentFile().getName().equals(Directories.SNAPSHOT_SUBDIR)) {\n      cfDirectory=cfDirectory.getParentFile().getParentFile();\n    }\n    cfname=cfDirectory.getName().split(\"-\")[0] + indexName;\n    ksname=cfDirectory.getParentFile().getName();\n  }\n else {\n    cfname=tokenStack.pop();\n    ksname=tokenStack.pop();\n  }\n  assert tokenStack.isEmpty() : \"Invalid file name \" + name + \" in \"+ directory;\n  return Pair.create(new Descriptor(version,parentDirectory,ksname,cfname,generation,fmt,Component.digestFor(version.uncompressedChecksumType())),component);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 320,
      "astHeight" : 12
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ReturnStatement,expression]",
      "nodePosition" : {
        "charLength" : 251,
        "startLineNumber" : 317,
        "startColumnNumber" : 15,
        "endLineNumber" : 320,
        "endColumnNumber" : 26
      },
      "nodeContext" : "Pair.create(new Descriptor(version,parentDirectory,ksname,cfname,generation,fmt,Component.digestFor(version.uncompressedChecksumType())),component)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 19,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : null
  } ],
  "positionList" : [ {
    "charLength" : 4,
    "startLineNumber" : 317,
    "startColumnNumber" : 15,
    "endLineNumber" : 317,
    "endColumnNumber" : 19
  } ],
  "layoutRelationDataList" : [ ]
}