{
  "id" : 244,
  "expression" : "TextStyle",
  "projectName" : "termux@termux-app",
  "commitID" : "c6d6a6363730a1bb49aef4c94ebabc9e4f01606b",
  "filePath" : "app/src/main/java/com/termux/terminal/TerminalEmulator.java",
  "occurrences" : 16,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 620,
      "startColumnNumber" : 27,
      "endLineNumber" : 620,
      "endColumnNumber" : 36
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 620,
        "startColumnNumber" : 27,
        "endLineNumber" : 620,
        "endColumnNumber" : 79
      },
      "nodeContext" : "TextStyle.decodeEffect(mScreen.getStyleAt(row,col))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 94,
        "startLineNumber" : 620,
        "startColumnNumber" : 27,
        "endLineNumber" : 620,
        "endColumnNumber" : 121
      },
      "nodeContext" : "TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 620,
        "startColumnNumber" : 26,
        "endLineNumber" : 620,
        "endColumnNumber" : 122
      },
      "nodeContext" : "(TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 101,
        "startLineNumber" : 620,
        "startColumnNumber" : 26,
        "endLineNumber" : 620,
        "endColumnNumber" : 127
      },
      "nodeContext" : "(TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 115,
        "startLineNumber" : 620,
        "startColumnNumber" : 12,
        "endLineNumber" : 620,
        "endColumnNumber" : 127
      },
      "nodeContext" : "!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 227,
        "startLineNumber" : 620,
        "startColumnNumber" : 8,
        "endLineNumber" : 621,
        "endColumnNumber" : 106
      },
      "nodeContext" : "if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 34,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 280,
        "startLineNumber" : 619,
        "startColumnNumber" : 7,
        "endLineNumber" : 621,
        "endColumnNumber" : 106
      },
      "nodeContext" : "for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 47,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 332,
        "startLineNumber" : 618,
        "startColumnNumber" : 6,
        "endLineNumber" : 621,
        "endColumnNumber" : 106
      },
      "nodeContext" : "for (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 60,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 115,
        "startLineNumber" : 620,
        "startColumnNumber" : 12,
        "endLineNumber" : 620,
        "endColumnNumber" : 127
      },
      "nodeContext" : "!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 620,
      "startColumnNumber" : 82,
      "endLineNumber" : 620,
      "endColumnNumber" : 91
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 620,
        "startColumnNumber" : 82,
        "endLineNumber" : 620,
        "endColumnNumber" : 121
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_PROTECTED",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 94,
        "startLineNumber" : 620,
        "startColumnNumber" : 27,
        "endLineNumber" : 620,
        "endColumnNumber" : 121
      },
      "nodeContext" : "TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 620,
        "startColumnNumber" : 26,
        "endLineNumber" : 620,
        "endColumnNumber" : 122
      },
      "nodeContext" : "(TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 101,
        "startLineNumber" : 620,
        "startColumnNumber" : 26,
        "endLineNumber" : 620,
        "endColumnNumber" : 127
      },
      "nodeContext" : "(TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 115,
        "startLineNumber" : 620,
        "startColumnNumber" : 12,
        "endLineNumber" : 620,
        "endColumnNumber" : 127
      },
      "nodeContext" : "!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 227,
        "startLineNumber" : 620,
        "startColumnNumber" : 8,
        "endLineNumber" : 621,
        "endColumnNumber" : 106
      },
      "nodeContext" : "if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 34,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 280,
        "startLineNumber" : 619,
        "startColumnNumber" : 7,
        "endLineNumber" : 621,
        "endColumnNumber" : 106
      },
      "nodeContext" : "for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 47,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 332,
        "startLineNumber" : 618,
        "startColumnNumber" : 6,
        "endLineNumber" : 621,
        "endColumnNumber" : 106
      },
      "nodeContext" : "for (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 60,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 115,
        "startLineNumber" : 620,
        "startColumnNumber" : 12,
        "endLineNumber" : 620,
        "endColumnNumber" : 127
      },
      "nodeContext" : "!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 640,
      "startColumnNumber" : 16,
      "endLineNumber" : 640,
      "endColumnNumber" : 25
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 640,
        "startColumnNumber" : 16,
        "endLineNumber" : 640,
        "endColumnNumber" : 50
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BOLD",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 164,
        "startLineNumber" : 640,
        "startColumnNumber" : 16,
        "endLineNumber" : 641,
        "endColumnNumber" : 49
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 166,
        "startLineNumber" : 640,
        "startColumnNumber" : 15,
        "endLineNumber" : 641,
        "endColumnNumber" : 50
      },
      "nodeContext" : "(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 14,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 640,
        "startColumnNumber" : 8,
        "endLineNumber" : 641,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 16,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 174,
        "startLineNumber" : 640,
        "startColumnNumber" : 8,
        "endLineNumber" : 641,
        "endColumnNumber" : 51
      },
      "nodeContext" : "bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 640,
        "startColumnNumber" : 16,
        "endLineNumber" : 640,
        "endColumnNumber" : 50
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BOLD",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 640,
      "startColumnNumber" : 53,
      "endLineNumber" : 640,
      "endColumnNumber" : 62
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 640,
        "startColumnNumber" : 53,
        "endLineNumber" : 640,
        "endColumnNumber" : 92
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 164,
        "startLineNumber" : 640,
        "startColumnNumber" : 16,
        "endLineNumber" : 641,
        "endColumnNumber" : 49
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 166,
        "startLineNumber" : 640,
        "startColumnNumber" : 15,
        "endLineNumber" : 641,
        "endColumnNumber" : 50
      },
      "nodeContext" : "(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 14,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 640,
        "startColumnNumber" : 8,
        "endLineNumber" : 641,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 16,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 174,
        "startLineNumber" : 640,
        "startColumnNumber" : 8,
        "endLineNumber" : 641,
        "endColumnNumber" : 51
      },
      "nodeContext" : "bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 640,
        "startColumnNumber" : 53,
        "endLineNumber" : 640,
        "endColumnNumber" : 92
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 640,
      "startColumnNumber" : 95,
      "endLineNumber" : 640,
      "endColumnNumber" : 104
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.InfixExpression,extendedOperands]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 640,
        "startColumnNumber" : 95,
        "endLineNumber" : 640,
        "endColumnNumber" : 130
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BLINK",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 164,
        "startLineNumber" : 640,
        "startColumnNumber" : 16,
        "endLineNumber" : 641,
        "endColumnNumber" : 49
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 166,
        "startLineNumber" : 640,
        "startColumnNumber" : 15,
        "endLineNumber" : 641,
        "endColumnNumber" : 50
      },
      "nodeContext" : "(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 14,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 640,
        "startColumnNumber" : 8,
        "endLineNumber" : 641,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 16,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 174,
        "startLineNumber" : 640,
        "startColumnNumber" : 8,
        "endLineNumber" : 641,
        "endColumnNumber" : 51
      },
      "nodeContext" : "bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.InfixExpression,extendedOperands]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 640,
        "startColumnNumber" : 95,
        "endLineNumber" : 640,
        "endColumnNumber" : 130
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BLINK",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 641,
      "startColumnNumber" : 12,
      "endLineNumber" : 641,
      "endColumnNumber" : 21
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.InfixExpression,extendedOperands]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 641,
        "startColumnNumber" : 12,
        "endLineNumber" : 641,
        "endColumnNumber" : 49
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 164,
        "startLineNumber" : 640,
        "startColumnNumber" : 16,
        "endLineNumber" : 641,
        "endColumnNumber" : 49
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 166,
        "startLineNumber" : 640,
        "startColumnNumber" : 15,
        "endLineNumber" : 641,
        "endColumnNumber" : 50
      },
      "nodeContext" : "(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 14,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 640,
        "startColumnNumber" : 8,
        "endLineNumber" : 641,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 16,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 174,
        "startLineNumber" : 640,
        "startColumnNumber" : 8,
        "endLineNumber" : 641,
        "endColumnNumber" : 51
      },
      "nodeContext" : "bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.InfixExpression,extendedOperands]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 641,
        "startColumnNumber" : 12,
        "endLineNumber" : 641,
        "endColumnNumber" : 49
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 645,
      "startColumnNumber" : 15,
      "endLineNumber" : 645,
      "endColumnNumber" : 24
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 645,
        "startColumnNumber" : 15,
        "endLineNumber" : 645,
        "endColumnNumber" : 49
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BOLD",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 645,
        "startColumnNumber" : 8,
        "endLineNumber" : 645,
        "endColumnNumber" : 49
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 645,
        "startColumnNumber" : 8,
        "endLineNumber" : 645,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 645,
        "startColumnNumber" : 8,
        "endLineNumber" : 645,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 648,
      "startColumnNumber" : 15,
      "endLineNumber" : 648,
      "endColumnNumber" : 24
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 648,
        "startColumnNumber" : 15,
        "endLineNumber" : 648,
        "endColumnNumber" : 54
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 648,
        "startColumnNumber" : 8,
        "endLineNumber" : 648,
        "endColumnNumber" : 54
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 648,
        "startColumnNumber" : 8,
        "endLineNumber" : 648,
        "endColumnNumber" : 55
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 648,
        "startColumnNumber" : 8,
        "endLineNumber" : 648,
        "endColumnNumber" : 55
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 651,
      "startColumnNumber" : 15,
      "endLineNumber" : 651,
      "endColumnNumber" : 24
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 651,
        "startColumnNumber" : 15,
        "endLineNumber" : 651,
        "endColumnNumber" : 50
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BLINK",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 651,
        "startColumnNumber" : 8,
        "endLineNumber" : 651,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 651,
        "startColumnNumber" : 8,
        "endLineNumber" : 651,
        "endColumnNumber" : 51
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 651,
        "startColumnNumber" : 8,
        "endLineNumber" : 651,
        "endColumnNumber" : 51
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 654,
      "startColumnNumber" : 15,
      "endLineNumber" : 654,
      "endColumnNumber" : 24
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 654,
        "startColumnNumber" : 15,
        "endLineNumber" : 654,
        "endColumnNumber" : 52
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 654,
        "startColumnNumber" : 8,
        "endLineNumber" : 654,
        "endColumnNumber" : 52
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 654,
        "startColumnNumber" : 8,
        "endLineNumber" : 654,
        "endColumnNumber" : 53
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 654,
        "startColumnNumber" : 8,
        "endLineNumber" : 654,
        "endColumnNumber" : 53
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 657,
      "startColumnNumber" : 15,
      "endLineNumber" : 657,
      "endColumnNumber" : 24
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 657,
        "startColumnNumber" : 15,
        "endLineNumber" : 657,
        "endColumnNumber" : 49
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BOLD",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 657,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 49
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 657,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 657,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 661,
      "startColumnNumber" : 15,
      "endLineNumber" : 661,
      "endColumnNumber" : 24
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 661,
        "startColumnNumber" : 15,
        "endLineNumber" : 661,
        "endColumnNumber" : 54
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 661,
        "startColumnNumber" : 8,
        "endLineNumber" : 661,
        "endColumnNumber" : 54
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 661,
        "startColumnNumber" : 8,
        "endLineNumber" : 661,
        "endColumnNumber" : 55
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 661,
        "startColumnNumber" : 8,
        "endLineNumber" : 661,
        "endColumnNumber" : 55
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 665,
      "startColumnNumber" : 15,
      "endLineNumber" : 665,
      "endColumnNumber" : 24
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 665,
        "startColumnNumber" : 15,
        "endLineNumber" : 665,
        "endColumnNumber" : 50
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_BLINK",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 665,
        "startColumnNumber" : 8,
        "endLineNumber" : 665,
        "endColumnNumber" : 50
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 665,
        "startColumnNumber" : 8,
        "endLineNumber" : 665,
        "endColumnNumber" : 51
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 665,
        "startColumnNumber" : 8,
        "endLineNumber" : 665,
        "endColumnNumber" : 51
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 669,
      "startColumnNumber" : 15,
      "endLineNumber" : 669,
      "endColumnNumber" : 24
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 669,
        "startColumnNumber" : 15,
        "endLineNumber" : 669,
        "endColumnNumber" : 52
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 669,
        "startColumnNumber" : 8,
        "endLineNumber" : 669,
        "endColumnNumber" : 52
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 669,
        "startColumnNumber" : 8,
        "endLineNumber" : 669,
        "endColumnNumber" : 53
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 669,
        "startColumnNumber" : 8,
        "endLineNumber" : 669,
        "endColumnNumber" : 53
      },
      "nodeContext" : "bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 694,
      "startColumnNumber" : 18,
      "endLineNumber" : 694,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.PrefixExpression,operand]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 694,
        "startColumnNumber" : 18,
        "endLineNumber" : 694,
        "endColumnNumber" : 57
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_PROTECTED",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 694,
        "startColumnNumber" : 17,
        "endLineNumber" : 694,
        "endColumnNumber" : 57
      },
      "nodeContext" : "~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 694,
        "startColumnNumber" : 6,
        "endLineNumber" : 694,
        "endColumnNumber" : 57
      },
      "nodeContext" : "mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED",
      "nodeType" : "Assignment",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 694,
        "startColumnNumber" : 6,
        "endLineNumber" : 694,
        "endColumnNumber" : 58
      },
      "nodeContext" : "mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 116,
        "startLineNumber" : 692,
        "startColumnNumber" : 31,
        "endLineNumber" : 695,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 8,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 320,
        "startLineNumber" : 692,
        "startColumnNumber" : 5,
        "endLineNumber" : 700,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (arg == 0 || arg == 2) {\n  mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\n  mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 32,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 410,
        "startLineNumber" : 689,
        "startColumnNumber" : 18,
        "endLineNumber" : 701,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int arg=getArg0(0);\n  if (arg == 0 || arg == 2) {\n    mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else   if (arg == 1) {\n    mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else {\n    unknownSequence(b);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 40,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 462,
        "startLineNumber" : 689,
        "startColumnNumber" : 4,
        "endLineNumber" : 703,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'q') {\n  int arg=getArg0(0);\n  if (arg == 0 || arg == 2) {\n    mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else   if (arg == 1) {\n    mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else {\n    unknownSequence(b);\n  }\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 49,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 694,
        "startColumnNumber" : 6,
        "endLineNumber" : 694,
        "endColumnNumber" : 58
      },
      "nodeContext" : "mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  }, {
    "nodeContext" : "TextStyle",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 697,
      "startColumnNumber" : 17,
      "endLineNumber" : 697,
      "endColumnNumber" : 26
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 697,
        "startColumnNumber" : 17,
        "endLineNumber" : 697,
        "endColumnNumber" : 56
      },
      "nodeContext" : "TextStyle.CHARACTER_ATTRIBUTE_PROTECTED",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 697,
        "startColumnNumber" : 6,
        "endLineNumber" : 697,
        "endColumnNumber" : 56
      },
      "nodeContext" : "mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 697,
        "startColumnNumber" : 6,
        "endLineNumber" : 697,
        "endColumnNumber" : 57
      },
      "nodeContext" : "mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 118,
        "startLineNumber" : 695,
        "startColumnNumber" : 26,
        "endLineNumber" : 698,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 7,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 172,
        "startLineNumber" : 695,
        "startColumnNumber" : 12,
        "endLineNumber" : 700,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (arg == 1) {\n  mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 320,
        "startLineNumber" : 692,
        "startColumnNumber" : 5,
        "endLineNumber" : 700,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (arg == 0 || arg == 2) {\n  mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\n  mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 32,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 410,
        "startLineNumber" : 689,
        "startColumnNumber" : 18,
        "endLineNumber" : 701,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int arg=getArg0(0);\n  if (arg == 0 || arg == 2) {\n    mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else   if (arg == 1) {\n    mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else {\n    unknownSequence(b);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 40,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 462,
        "startLineNumber" : 689,
        "startColumnNumber" : 4,
        "endLineNumber" : 703,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'q') {\n  int arg=getArg0(0);\n  if (arg == 0 || arg == 2) {\n    mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else   if (arg == 1) {\n    mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else {\n    unknownSequence(b);\n  }\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 49,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 697,
        "startColumnNumber" : 6,
        "endLineNumber" : 697,
        "endColumnNumber" : 57
      },
      "nodeContext" : "mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.termux.terminal.TextStyle"
  } ],
  "positionList" : [ {
    "charLength" : 9,
    "startLineNumber" : 620,
    "startColumnNumber" : 27,
    "endLineNumber" : 620,
    "endColumnNumber" : 36
  }, {
    "charLength" : 9,
    "startLineNumber" : 620,
    "startColumnNumber" : 82,
    "endLineNumber" : 620,
    "endColumnNumber" : 91
  }, {
    "charLength" : 9,
    "startLineNumber" : 640,
    "startColumnNumber" : 16,
    "endLineNumber" : 640,
    "endColumnNumber" : 25
  }, {
    "charLength" : 9,
    "startLineNumber" : 640,
    "startColumnNumber" : 53,
    "endLineNumber" : 640,
    "endColumnNumber" : 62
  }, {
    "charLength" : 9,
    "startLineNumber" : 640,
    "startColumnNumber" : 95,
    "endLineNumber" : 640,
    "endColumnNumber" : 104
  }, {
    "charLength" : 9,
    "startLineNumber" : 641,
    "startColumnNumber" : 12,
    "endLineNumber" : 641,
    "endColumnNumber" : 21
  }, {
    "charLength" : 9,
    "startLineNumber" : 645,
    "startColumnNumber" : 15,
    "endLineNumber" : 645,
    "endColumnNumber" : 24
  }, {
    "charLength" : 9,
    "startLineNumber" : 648,
    "startColumnNumber" : 15,
    "endLineNumber" : 648,
    "endColumnNumber" : 24
  }, {
    "charLength" : 9,
    "startLineNumber" : 651,
    "startColumnNumber" : 15,
    "endLineNumber" : 651,
    "endColumnNumber" : 24
  }, {
    "charLength" : 9,
    "startLineNumber" : 654,
    "startColumnNumber" : 15,
    "endLineNumber" : 654,
    "endColumnNumber" : 24
  }, {
    "charLength" : 9,
    "startLineNumber" : 657,
    "startColumnNumber" : 15,
    "endLineNumber" : 657,
    "endColumnNumber" : 24
  }, {
    "charLength" : 9,
    "startLineNumber" : 661,
    "startColumnNumber" : 15,
    "endLineNumber" : 661,
    "endColumnNumber" : 24
  }, {
    "charLength" : 9,
    "startLineNumber" : 665,
    "startColumnNumber" : 15,
    "endLineNumber" : 665,
    "endColumnNumber" : 24
  }, {
    "charLength" : 9,
    "startLineNumber" : 669,
    "startColumnNumber" : 15,
    "endLineNumber" : 669,
    "endColumnNumber" : 24
  }, {
    "charLength" : 9,
    "startLineNumber" : 694,
    "startColumnNumber" : 18,
    "endLineNumber" : 694,
    "endColumnNumber" : 27
  }, {
    "charLength" : 9,
    "startLineNumber" : 697,
    "startColumnNumber" : 17,
    "endLineNumber" : 697,
    "endColumnNumber" : 26
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 1
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 11,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 12,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 13,
    "layout" : 10
  }, {
    "firstKey" : 0,
    "secondKey" : 14,
    "layout" : 11
  }, {
    "firstKey" : 0,
    "secondKey" : 15,
    "layout" : 11
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 1
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 11,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 12,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 13,
    "layout" : 10
  }, {
    "firstKey" : 1,
    "secondKey" : 14,
    "layout" : 11
  }, {
    "firstKey" : 1,
    "secondKey" : 15,
    "layout" : 11
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 1
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 1
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 1
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 14,
    "layout" : 11
  }, {
    "firstKey" : 2,
    "secondKey" : 15,
    "layout" : 11
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 1
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 1
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 14,
    "layout" : 11
  }, {
    "firstKey" : 3,
    "secondKey" : 15,
    "layout" : 11
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 1
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 1
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 14,
    "layout" : 11
  }, {
    "firstKey" : 4,
    "secondKey" : 15,
    "layout" : 11
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 1
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 1
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 14,
    "layout" : 11
  }, {
    "firstKey" : 5,
    "secondKey" : 15,
    "layout" : 11
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 6,
    "secondKey" : 15,
    "layout" : 9
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 7,
    "secondKey" : 15,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 15,
    "layout" : 9
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 9,
    "secondKey" : 15,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 10,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 15,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 11,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 11,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 15,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 12,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 12,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 12,
    "secondKey" : 15,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 13,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 13,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 13,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 15,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 15,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 14,
    "layout" : 5
  } ]
}