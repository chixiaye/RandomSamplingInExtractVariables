{
  "id" : 400,
  "expression" : "0",
  "projectName" : "alibaba@nacos",
  "commitID" : "4e7346db1d6657ffe07c96bebd2d348229c2812f",
  "filePath" : "core/src/main/java/com/alibaba/nacos/core/remote/ConnectionManager.java",
  "occurrences" : 13,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 293,
      "startColumnNumber" : 59,
      "endLineNumber" : 293,
      "endColumnNumber" : 60
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 15,
        "startLineNumber" : 293,
        "startColumnNumber" : 45,
        "endLineNumber" : 293,
        "endColumnNumber" : 60
      },
      "nodeContext" : "loadClient >= 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 293,
        "startColumnNumber" : 28,
        "endLineNumber" : 293,
        "endColumnNumber" : 60
      },
      "nodeContext" : "isLoaderClient=loadClient >= 0",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 293,
        "startColumnNumber" : 20,
        "endLineNumber" : 293,
        "endColumnNumber" : 61
      },
      "nodeContext" : "boolean isLoaderClient=loadClient >= 0;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 293,
        "startColumnNumber" : 20,
        "endLineNumber" : 293,
        "endColumnNumber" : 61
      },
      "nodeContext" : "boolean isLoaderClient=loadClient >= 0;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 295,
      "startColumnNumber" : 56,
      "endLineNumber" : 295,
      "endColumnNumber" : 57
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 295,
        "startColumnNumber" : 37,
        "endLineNumber" : 295,
        "endColumnNumber" : 57
      },
      "nodeContext" : "currentMaxClient < 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 80,
        "startLineNumber" : 295,
        "startColumnNumber" : 37,
        "endLineNumber" : 295,
        "endColumnNumber" : 117
      },
      "nodeContext" : "currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0)",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 295,
        "startColumnNumber" : 24,
        "endLineNumber" : 295,
        "endColumnNumber" : 117
      },
      "nodeContext" : "expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 295,
        "startColumnNumber" : 20,
        "endLineNumber" : 295,
        "endColumnNumber" : 118
      },
      "nodeContext" : "int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 295,
        "startColumnNumber" : 20,
        "endLineNumber" : 295,
        "endColumnNumber" : 118
      },
      "nodeContext" : "int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 295,
      "startColumnNumber" : 60,
      "endLineNumber" : 295,
      "endColumnNumber" : 61
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 80,
        "startLineNumber" : 295,
        "startColumnNumber" : 37,
        "endLineNumber" : 295,
        "endColumnNumber" : 117
      },
      "nodeContext" : "currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0)",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 295,
        "startColumnNumber" : 24,
        "endLineNumber" : 295,
        "endColumnNumber" : 117
      },
      "nodeContext" : "expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 295,
        "startColumnNumber" : 20,
        "endLineNumber" : 295,
        "endColumnNumber" : 118
      },
      "nodeContext" : "int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 295,
        "startColumnNumber" : 20,
        "endLineNumber" : 295,
        "endColumnNumber" : 118
      },
      "nodeContext" : "int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 295,
      "startColumnNumber" : 115,
      "endLineNumber" : 295,
      "endColumnNumber" : 116
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,elseExpression]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 295,
        "startColumnNumber" : 64,
        "endLineNumber" : 295,
        "endColumnNumber" : 117
      },
      "nodeContext" : "Math.max(currentSdkClientCount - currentMaxClient,0)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 80,
        "startLineNumber" : 295,
        "startColumnNumber" : 37,
        "endLineNumber" : 295,
        "endColumnNumber" : 117
      },
      "nodeContext" : "currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0)",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 295,
        "startColumnNumber" : 24,
        "endLineNumber" : 295,
        "endColumnNumber" : 117
      },
      "nodeContext" : "expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 295,
        "startColumnNumber" : 20,
        "endLineNumber" : 295,
        "endColumnNumber" : 118
      },
      "nodeContext" : "int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 295,
        "startColumnNumber" : 20,
        "endLineNumber" : 295,
        "endColumnNumber" : 118
      },
      "nodeContext" : "int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 315,
      "startColumnNumber" : 49,
      "endLineNumber" : 315,
      "endColumnNumber" : 50
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 315,
        "startColumnNumber" : 32,
        "endLineNumber" : 315,
        "endColumnNumber" : 50
      },
      "nodeContext" : "countLimitOfIp < 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 263,
        "startLineNumber" : 315,
        "startColumnNumber" : 28,
        "endLineNumber" : 318,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (countLimitOfIp < 0) {\n  int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n  countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 22,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1179,
        "startLineNumber" : 312,
        "startColumnNumber" : 101,
        "endLineNumber" : 329,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n  if (countLimitOfIp < 0) {\n    int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n    countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n  }\n  if (countLimitOfIp < 0) {\n    countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n  }\n  if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n    AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n    if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n      expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 85,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1256,
        "startLineNumber" : 312,
        "startColumnNumber" : 24,
        "endLineNumber" : 329,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n  int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n  if (countLimitOfIp < 0) {\n    int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n    countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n  }\n  if (countLimitOfIp < 0) {\n    countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n  }\n  if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n    AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n    if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n      expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 97,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1545,
        "startLineNumber" : 307,
        "startColumnNumber" : 72,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 126,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1597,
        "startLineNumber" : 307,
        "startColumnNumber" : 20,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 139,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 315,
        "startColumnNumber" : 32,
        "endLineNumber" : 315,
        "endColumnNumber" : 50
      },
      "nodeContext" : "countLimitOfIp < 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 317,
      "startColumnNumber" : 67,
      "endLineNumber" : 317,
      "endColumnNumber" : 68
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,expression]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 317,
        "startColumnNumber" : 49,
        "endLineNumber" : 317,
        "endColumnNumber" : 68
      },
      "nodeContext" : "countLimitOfApp < 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 317,
        "startColumnNumber" : 49,
        "endLineNumber" : 317,
        "endColumnNumber" : 103
      },
      "nodeContext" : "countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 317,
        "startColumnNumber" : 32,
        "endLineNumber" : 317,
        "endColumnNumber" : 103
      },
      "nodeContext" : "countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp",
      "nodeType" : "Assignment",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 317,
        "startColumnNumber" : 32,
        "endLineNumber" : 317,
        "endColumnNumber" : 104
      },
      "nodeContext" : "countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 239,
        "startLineNumber" : 315,
        "startColumnNumber" : 52,
        "endLineNumber" : 318,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n  countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 18,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 263,
        "startLineNumber" : 315,
        "startColumnNumber" : 28,
        "endLineNumber" : 318,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (countLimitOfIp < 0) {\n  int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n  countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 22,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1179,
        "startLineNumber" : 312,
        "startColumnNumber" : 101,
        "endLineNumber" : 329,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n  if (countLimitOfIp < 0) {\n    int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n    countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n  }\n  if (countLimitOfIp < 0) {\n    countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n  }\n  if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n    AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n    if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n      expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 85,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1256,
        "startLineNumber" : 312,
        "startColumnNumber" : 24,
        "endLineNumber" : 329,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n  int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n  if (countLimitOfIp < 0) {\n    int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n    countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n  }\n  if (countLimitOfIp < 0) {\n    countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n  }\n  if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n    AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n    if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n      expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 97,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1545,
        "startLineNumber" : 307,
        "startColumnNumber" : 72,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 126,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1597,
        "startLineNumber" : 307,
        "startColumnNumber" : 20,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 139,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 317,
        "startColumnNumber" : 32,
        "endLineNumber" : 317,
        "endColumnNumber" : 104
      },
      "nodeContext" : "countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 319,
      "startColumnNumber" : 49,
      "endLineNumber" : 319,
      "endColumnNumber" : 50
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 319,
        "startColumnNumber" : 32,
        "endLineNumber" : 319,
        "endColumnNumber" : 50
      },
      "nodeContext" : "countLimitOfIp < 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 159,
        "startLineNumber" : 319,
        "startColumnNumber" : 28,
        "endLineNumber" : 321,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (countLimitOfIp < 0) {\n  countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 11,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1179,
        "startLineNumber" : 312,
        "startColumnNumber" : 101,
        "endLineNumber" : 329,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n  if (countLimitOfIp < 0) {\n    int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n    countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n  }\n  if (countLimitOfIp < 0) {\n    countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n  }\n  if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n    AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n    if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n      expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 85,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1256,
        "startLineNumber" : 312,
        "startColumnNumber" : 24,
        "endLineNumber" : 329,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n  int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n  if (countLimitOfIp < 0) {\n    int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n    countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n  }\n  if (countLimitOfIp < 0) {\n    countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n  }\n  if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n    AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n    if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n      expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 97,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1545,
        "startLineNumber" : 307,
        "startColumnNumber" : 72,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 126,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1597,
        "startLineNumber" : 307,
        "startColumnNumber" : 20,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 139,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 319,
        "startColumnNumber" : 32,
        "endLineNumber" : 319,
        "endColumnNumber" : 50
      },
      "nodeContext" : "countLimitOfIp < 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 323,
      "startColumnNumber" : 50,
      "endLineNumber" : 323,
      "endColumnNumber" : 51
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 323,
        "startColumnNumber" : 32,
        "endLineNumber" : 323,
        "endColumnNumber" : 51
      },
      "nodeContext" : "countLimitOfIp >= 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 66,
        "startLineNumber" : 323,
        "startColumnNumber" : 32,
        "endLineNumber" : 323,
        "endColumnNumber" : 98
      },
      "nodeContext" : "countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 460,
        "startLineNumber" : 323,
        "startColumnNumber" : 28,
        "endLineNumber" : 328,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n  AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n  if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n    expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 43,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1179,
        "startLineNumber" : 312,
        "startColumnNumber" : 101,
        "endLineNumber" : 329,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n  if (countLimitOfIp < 0) {\n    int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n    countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n  }\n  if (countLimitOfIp < 0) {\n    countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n  }\n  if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n    AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n    if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n      expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 85,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1256,
        "startLineNumber" : 312,
        "startColumnNumber" : 24,
        "endLineNumber" : 329,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n  int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n  if (countLimitOfIp < 0) {\n    int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n    countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n  }\n  if (countLimitOfIp < 0) {\n    countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n  }\n  if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n    AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n    if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n      expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 97,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1545,
        "startLineNumber" : 307,
        "startColumnNumber" : 72,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 126,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1597,
        "startLineNumber" : 307,
        "startColumnNumber" : 20,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 139,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 66,
        "startLineNumber" : 323,
        "startColumnNumber" : 32,
        "endLineNumber" : 323,
        "endColumnNumber" : 98
      },
      "nodeContext" : "countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 335,
      "startColumnNumber" : 44,
      "endLineNumber" : 335,
      "endColumnNumber" : 45
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 335,
        "startColumnNumber" : 24,
        "endLineNumber" : 335,
        "endColumnNumber" : 45
      },
      "nodeContext" : "expelForIp.size() > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 143,
        "startLineNumber" : 335,
        "startColumnNumber" : 20,
        "endLineNumber" : 337,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (expelForIp.size() > 0) {\n  Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 335,
        "startColumnNumber" : 24,
        "endLineNumber" : 335,
        "endColumnNumber" : 45
      },
      "nodeContext" : "expelForIp.size() > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 346,
      "startColumnNumber" : 68,
      "endLineNumber" : 346,
      "endColumnNumber" : 69
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 346,
        "startColumnNumber" : 47,
        "endLineNumber" : 346,
        "endColumnNumber" : 69
      },
      "nodeContext" : "integer.intValue() > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 346,
        "startColumnNumber" : 28,
        "endLineNumber" : 346,
        "endColumnNumber" : 69
      },
      "nodeContext" : "integer != null && integer.intValue() > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 453,
        "startLineNumber" : 346,
        "startColumnNumber" : 24,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (integer != null && integer.intValue() > 0) {\n  integer.decrementAndGet();\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n}\n else if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n  outDatedConnections.add(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 47,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 740,
        "startLineNumber" : 342,
        "startColumnNumber" : 72,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 75,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 792,
        "startLineNumber" : 342,
        "startColumnNumber" : 20,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 88,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 346,
        "startColumnNumber" : 28,
        "endLineNumber" : 346,
        "endColumnNumber" : 69
      },
      "nodeContext" : "integer != null && integer.intValue() > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 357,
      "startColumnNumber" : 37,
      "endLineNumber" : 357,
      "endColumnNumber" : 38
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 357,
        "startColumnNumber" : 24,
        "endLineNumber" : 357,
        "endColumnNumber" : 38
      },
      "nodeContext" : "expelCount > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 661,
        "startLineNumber" : 357,
        "startColumnNumber" : 20,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (expelCount > 0) {\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 357,
        "startColumnNumber" : 24,
        "endLineNumber" : 357,
        "endColumnNumber" : 38
      },
      "nodeContext" : "expelCount > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 361,
      "startColumnNumber" : 67,
      "endLineNumber" : 361,
      "endColumnNumber" : 68
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.InfixExpression,extendedOperands]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 361,
        "startColumnNumber" : 54,
        "endLineNumber" : 361,
        "endColumnNumber" : 68
      },
      "nodeContext" : "expelCount > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 147,
        "startLineNumber" : 360,
        "startColumnNumber" : 32,
        "endLineNumber" : 361,
        "endColumnNumber" : 68
      },
      "nodeContext" : "!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 18,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 419,
        "startLineNumber" : 360,
        "startColumnNumber" : 28,
        "endLineNumber" : 365,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n  outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 541,
        "startLineNumber" : 358,
        "startColumnNumber" : 76,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 50,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 593,
        "startLineNumber" : 358,
        "startColumnNumber" : 24,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 63,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 641,
        "startLineNumber" : 357,
        "startColumnNumber" : 40,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 64,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 661,
        "startLineNumber" : 357,
        "startColumnNumber" : 20,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (expelCount > 0) {\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.InfixExpression,extendedOperands]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 361,
        "startColumnNumber" : 54,
        "endLineNumber" : 361,
        "endColumnNumber" : 68
      },
      "nodeContext" : "expelCount > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 373,
      "startColumnNumber" : 41,
      "endLineNumber" : 373,
      "endColumnNumber" : 42
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 8,
        "startLineNumber" : 373,
        "startColumnNumber" : 35,
        "endLineNumber" : 373,
        "endColumnNumber" : 43
      },
      "nodeContext" : "split[0]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 373,
        "startColumnNumber" : 24,
        "endLineNumber" : 373,
        "endColumnNumber" : 43
      },
      "nodeContext" : "serverIp=split[0]",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 373,
        "startColumnNumber" : 24,
        "endLineNumber" : 373,
        "endColumnNumber" : 44
      },
      "nodeContext" : "serverIp=split[0];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 196,
        "startLineNumber" : 371,
        "startColumnNumber" : 110,
        "endLineNumber" : 375,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  String[] split=redirectAddress.split(Constants.COLON);\n  serverIp=split[0];\n  serverPort=split[1];\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 26,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 286,
        "startLineNumber" : 371,
        "startColumnNumber" : 20,
        "endLineNumber" : 375,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n  String[] split=redirectAddress.split(Constants.COLON);\n  serverIp=split[0];\n  serverPort=split[1];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 38,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 373,
        "startColumnNumber" : 24,
        "endLineNumber" : 373,
        "endColumnNumber" : 44
      },
      "nodeContext" : "serverIp=split[0];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 1,
    "startLineNumber" : 293,
    "startColumnNumber" : 59,
    "endLineNumber" : 293,
    "endColumnNumber" : 60
  }, {
    "charLength" : 1,
    "startLineNumber" : 295,
    "startColumnNumber" : 56,
    "endLineNumber" : 295,
    "endColumnNumber" : 57
  }, {
    "charLength" : 1,
    "startLineNumber" : 295,
    "startColumnNumber" : 60,
    "endLineNumber" : 295,
    "endColumnNumber" : 61
  }, {
    "charLength" : 1,
    "startLineNumber" : 295,
    "startColumnNumber" : 115,
    "endLineNumber" : 295,
    "endColumnNumber" : 116
  }, {
    "charLength" : 1,
    "startLineNumber" : 315,
    "startColumnNumber" : 49,
    "endLineNumber" : 315,
    "endColumnNumber" : 50
  }, {
    "charLength" : 1,
    "startLineNumber" : 317,
    "startColumnNumber" : 67,
    "endLineNumber" : 317,
    "endColumnNumber" : 68
  }, {
    "charLength" : 1,
    "startLineNumber" : 319,
    "startColumnNumber" : 49,
    "endLineNumber" : 319,
    "endColumnNumber" : 50
  }, {
    "charLength" : 1,
    "startLineNumber" : 323,
    "startColumnNumber" : 50,
    "endLineNumber" : 323,
    "endColumnNumber" : 51
  }, {
    "charLength" : 1,
    "startLineNumber" : 335,
    "startColumnNumber" : 44,
    "endLineNumber" : 335,
    "endColumnNumber" : 45
  }, {
    "charLength" : 1,
    "startLineNumber" : 346,
    "startColumnNumber" : 68,
    "endLineNumber" : 346,
    "endColumnNumber" : 69
  }, {
    "charLength" : 1,
    "startLineNumber" : 357,
    "startColumnNumber" : 37,
    "endLineNumber" : 357,
    "endColumnNumber" : 38
  }, {
    "charLength" : 1,
    "startLineNumber" : 361,
    "startColumnNumber" : 67,
    "endLineNumber" : 361,
    "endColumnNumber" : 68
  }, {
    "charLength" : 1,
    "startLineNumber" : 373,
    "startColumnNumber" : 41,
    "endLineNumber" : 373,
    "endColumnNumber" : 42
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 1
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 0
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 0
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 1
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 1
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 2
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 2
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 11,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 12,
    "layout" : 10
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 2
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 2
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 2
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 11,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 12,
    "layout" : 2
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 2
  }, {
    "firstKey" : 10,
    "secondKey" : 11,
    "layout" : 1
  }, {
    "firstKey" : 10,
    "secondKey" : 12,
    "layout" : 2
  }, {
    "firstKey" : 11,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 12,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 11,
    "layout" : 5
  } ]
}