{
  "id" : 167,
  "expression" : "2",
  "projectName" : "termux@termux-app",
  "commitID" : "c6d6a6363730a1bb49aef4c94ebabc9e4f01606b",
  "filePath" : "app/src/main/java/com/termux/terminal/TerminalEmulator.java",
  "occurrences" : 8,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "2",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 586,
      "startColumnNumber" : 49,
      "endLineNumber" : 586,
      "endColumnNumber" : 50
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 586,
        "startColumnNumber" : 42,
        "endLineNumber" : 586,
        "endColumnNumber" : 64
      },
      "nodeContext" : "getArg(2,mRows,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 586,
        "startColumnNumber" : 42,
        "endLineNumber" : 586,
        "endColumnNumber" : 85
      },
      "nodeContext" : "getArg(2,mRows,true) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 586,
        "startColumnNumber" : 33,
        "endLineNumber" : 586,
        "endColumnNumber" : 97
      },
      "nodeContext" : "Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 586,
        "startColumnNumber" : 24,
        "endLineNumber" : 586,
        "endColumnNumber" : 105
      },
      "nodeContext" : "Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 586,
        "startColumnNumber" : 9,
        "endLineNumber" : 586,
        "endColumnNumber" : 105
      },
      "nodeContext" : "bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 101,
        "startLineNumber" : 586,
        "startColumnNumber" : 5,
        "endLineNumber" : 586,
        "endColumnNumber" : 106
      },
      "nodeContext" : "int bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 101,
        "startLineNumber" : 586,
        "startColumnNumber" : 5,
        "endLineNumber" : 586,
        "endColumnNumber" : 106
      },
      "nodeContext" : "int bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "2",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 632,
      "startColumnNumber" : 34,
      "endLineNumber" : 632,
      "endColumnNumber" : 35
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 632,
        "startColumnNumber" : 27,
        "endLineNumber" : 632,
        "endColumnNumber" : 49
      },
      "nodeContext" : "getArg(2,mRows,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 632,
        "startColumnNumber" : 27,
        "endLineNumber" : 632,
        "endColumnNumber" : 53
      },
      "nodeContext" : "getArg(2,mRows,true) + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 632,
        "startColumnNumber" : 9,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "2",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 692,
      "startColumnNumber" : 28,
      "endLineNumber" : 692,
      "endColumnNumber" : 29
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 8,
        "startLineNumber" : 692,
        "startColumnNumber" : 21,
        "endLineNumber" : 692,
        "endColumnNumber" : 29
      },
      "nodeContext" : "arg == 2",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 692,
        "startColumnNumber" : 9,
        "endLineNumber" : 692,
        "endColumnNumber" : 29
      },
      "nodeContext" : "arg == 0 || arg == 2",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 320,
        "startLineNumber" : 692,
        "startColumnNumber" : 5,
        "endLineNumber" : 700,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (arg == 0 || arg == 2) {\n  mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\n  mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 32,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 410,
        "startLineNumber" : 689,
        "startColumnNumber" : 18,
        "endLineNumber" : 701,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int arg=getArg0(0);\n  if (arg == 0 || arg == 2) {\n    mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else   if (arg == 1) {\n    mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else {\n    unknownSequence(b);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 40,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 462,
        "startLineNumber" : 689,
        "startColumnNumber" : 4,
        "endLineNumber" : 703,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'q') {\n  int arg=getArg0(0);\n  if (arg == 0 || arg == 2) {\n    mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else   if (arg == 1) {\n    mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else {\n    unknownSequence(b);\n  }\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 49,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 692,
        "startColumnNumber" : 9,
        "endLineNumber" : 692,
        "endColumnNumber" : 29
      },
      "nodeContext" : "arg == 0 || arg == 2",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "2",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 741,
      "startColumnNumber" : 44,
      "endLineNumber" : 741,
      "endColumnNumber" : 45
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 741,
        "startColumnNumber" : 14,
        "endLineNumber" : 741,
        "endColumnNumber" : 45
      },
      "nodeContext" : "(mScreen == mAltBuffer) ? 1 : 2",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 741,
        "startColumnNumber" : 6,
        "endLineNumber" : 741,
        "endColumnNumber" : 45
      },
      "nodeContext" : "value=(mScreen == mAltBuffer) ? 1 : 2",
      "nodeType" : "Assignment",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 741,
        "startColumnNumber" : 6,
        "endLineNumber" : 741,
        "endColumnNumber" : 46
      },
      "nodeContext" : "value=(mScreen == mAltBuffer) ? 1 : 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 106,
        "startLineNumber" : 739,
        "startColumnNumber" : 53,
        "endLineNumber" : 742,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  value=(mScreen == mAltBuffer) ? 1 : 2;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 11,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 529,
        "startLineNumber" : 739,
        "startColumnNumber" : 5,
        "endLineNumber" : 750,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mode == 47 || mode == 1047 || mode == 1049) {\n  value=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\n  int internalBit=mapDecSetBitToInternalBit(mode);\n  if (internalBit == -1) {\n    value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n  }\n else {\n    Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n    value=0;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 706,
        "startLineNumber" : 735,
        "startColumnNumber" : 18,
        "endLineNumber" : 752,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 86,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 735,
        "startColumnNumber" : 4,
        "endLineNumber" : 754,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'p') {\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 95,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 741,
        "startColumnNumber" : 6,
        "endLineNumber" : 741,
        "endColumnNumber" : 46
      },
      "nodeContext" : "value=(mScreen == mAltBuffer) ? 1 : 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "2",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 745,
      "startColumnNumber" : 57,
      "endLineNumber" : 745,
      "endColumnNumber" : 58
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 745,
        "startColumnNumber" : 15,
        "endLineNumber" : 745,
        "endColumnNumber" : 58
      },
      "nodeContext" : "isDecsetInternalBitSet(internalBit) ? 1 : 2",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 745,
        "startColumnNumber" : 7,
        "endLineNumber" : 745,
        "endColumnNumber" : 58
      },
      "nodeContext" : "value=isDecsetInternalBitSet(internalBit) ? 1 : 2",
      "nodeType" : "Assignment",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 745,
        "startColumnNumber" : 7,
        "endLineNumber" : 745,
        "endColumnNumber" : 59
      },
      "nodeContext" : "value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 744,
        "startColumnNumber" : 29,
        "endLineNumber" : 746,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 10,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 297,
        "startLineNumber" : 744,
        "startColumnNumber" : 6,
        "endLineNumber" : 749,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (internalBit == -1) {\n  value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\n  Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n  value=0;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 30,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 369,
        "startLineNumber" : 742,
        "startColumnNumber" : 12,
        "endLineNumber" : 750,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int internalBit=mapDecSetBitToInternalBit(mode);\n  if (internalBit == -1) {\n    value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n  }\n else {\n    Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n    value=0;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 38,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 529,
        "startLineNumber" : 739,
        "startColumnNumber" : 5,
        "endLineNumber" : 750,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mode == 47 || mode == 1047 || mode == 1049) {\n  value=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\n  int internalBit=mapDecSetBitToInternalBit(mode);\n  if (internalBit == -1) {\n    value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n  }\n else {\n    Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n    value=0;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 706,
        "startLineNumber" : 735,
        "startColumnNumber" : 18,
        "endLineNumber" : 752,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 86,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 735,
        "startColumnNumber" : 4,
        "endLineNumber" : 754,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'p') {\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 95,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 745,
        "startColumnNumber" : 7,
        "endLineNumber" : 745,
        "endColumnNumber" : 59
      },
      "nodeContext" : "value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "2",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 763,
      "startColumnNumber" : 10,
      "endLineNumber" : 763,
      "endColumnNumber" : 11
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 7,
        "startLineNumber" : 763,
        "startColumnNumber" : 5,
        "endLineNumber" : 763,
        "endColumnNumber" : 12
      },
      "nodeContext" : "case 2:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 2,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 441,
        "startLineNumber" : 760,
        "startColumnNumber" : 5,
        "endLineNumber" : 774,
        "endColumnNumber" : 6
      },
      "nodeContext" : "switch (arg) {\ncase 0:case 1:case 2:  mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 31,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 698,
        "startLineNumber" : 758,
        "startColumnNumber" : 4,
        "endLineNumber" : 782,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:    mCursorStyle=CURSOR_STYLE_BLOCK;\n  break;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 46,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 7,
        "startLineNumber" : 763,
        "startColumnNumber" : 5,
        "endLineNumber" : 763,
        "endColumnNumber" : 12
      },
      "nodeContext" : "case 2:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 2,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "2",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 786,
      "startColumnNumber" : 76,
      "endLineNumber" : 786,
      "endColumnNumber" : 77
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 786,
        "startColumnNumber" : 51,
        "endLineNumber" : 786,
        "endColumnNumber" : 77
      },
      "nodeContext" : "attributeChangeExtent <= 2",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 786,
        "startColumnNumber" : 21,
        "endLineNumber" : 786,
        "endColumnNumber" : 77
      },
      "nodeContext" : "attributeChangeExtent >= 0 && attributeChangeExtent <= 2",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 786,
        "startColumnNumber" : 20,
        "endLineNumber" : 786,
        "endColumnNumber" : 78
      },
      "nodeContext" : "(attributeChangeExtent >= 0 && attributeChangeExtent <= 2)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 70,
        "startLineNumber" : 786,
        "startColumnNumber" : 8,
        "endLineNumber" : 786,
        "endColumnNumber" : 78
      },
      "nodeContext" : "b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 311,
        "startLineNumber" : 786,
        "startColumnNumber" : 4,
        "endLineNumber" : 791,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\n  setDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 26,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 70,
        "startLineNumber" : 786,
        "startColumnNumber" : 8,
        "endLineNumber" : 786,
        "endColumnNumber" : 78
      },
      "nodeContext" : "b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 12,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "2",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 788,
      "startColumnNumber" : 91,
      "endLineNumber" : 788,
      "endColumnNumber" : 92
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 788,
        "startColumnNumber" : 66,
        "endLineNumber" : 788,
        "endColumnNumber" : 92
      },
      "nodeContext" : "attributeChangeExtent == 2",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 788,
        "startColumnNumber" : 5,
        "endLineNumber" : 788,
        "endColumnNumber" : 93
      },
      "nodeContext" : "setDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 89,
        "startLineNumber" : 788,
        "startColumnNumber" : 5,
        "endLineNumber" : 788,
        "endColumnNumber" : 94
      },
      "nodeContext" : "setDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 197,
        "startLineNumber" : 786,
        "startColumnNumber" : 80,
        "endLineNumber" : 789,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  setDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 311,
        "startLineNumber" : 786,
        "startColumnNumber" : 4,
        "endLineNumber" : 791,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\n  setDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 26,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 89,
        "startLineNumber" : 788,
        "startColumnNumber" : 5,
        "endLineNumber" : 788,
        "endColumnNumber" : 94
      },
      "nodeContext" : "setDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 1,
    "startLineNumber" : 586,
    "startColumnNumber" : 49,
    "endLineNumber" : 586,
    "endColumnNumber" : 50
  }, {
    "charLength" : 1,
    "startLineNumber" : 632,
    "startColumnNumber" : 34,
    "endLineNumber" : 632,
    "endColumnNumber" : 35
  }, {
    "charLength" : 1,
    "startLineNumber" : 692,
    "startColumnNumber" : 28,
    "endLineNumber" : 692,
    "endColumnNumber" : 29
  }, {
    "charLength" : 1,
    "startLineNumber" : 741,
    "startColumnNumber" : 44,
    "endLineNumber" : 741,
    "endColumnNumber" : 45
  }, {
    "charLength" : 1,
    "startLineNumber" : 745,
    "startColumnNumber" : 57,
    "endLineNumber" : 745,
    "endColumnNumber" : 58
  }, {
    "charLength" : 1,
    "startLineNumber" : 763,
    "startColumnNumber" : 10,
    "endLineNumber" : 763,
    "endColumnNumber" : 11
  }, {
    "charLength" : 1,
    "startLineNumber" : 786,
    "startColumnNumber" : 76,
    "endLineNumber" : 786,
    "endColumnNumber" : 77
  }, {
    "charLength" : 1,
    "startLineNumber" : 788,
    "startColumnNumber" : 91,
    "endLineNumber" : 788,
    "endColumnNumber" : 92
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 4
  } ]
}