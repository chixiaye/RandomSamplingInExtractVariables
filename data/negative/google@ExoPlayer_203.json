{
  "id" : 203,
  "expression" : "textPaddingX",
  "projectName" : "google@ExoPlayer",
  "commitID" : "4803ab3bd12b71fc32150e96475c0e16aaf6ddc5",
  "filePath" : "/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java",
  "occurrences" : 3,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "textPaddingX",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 12,
      "startLineNumber" : 239,
      "startColumnNumber" : 39,
      "endLineNumber" : 239,
      "endColumnNumber" : 51
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 16,
        "startLineNumber" : 239,
        "startColumnNumber" : 39,
        "endLineNumber" : 239,
        "endColumnNumber" : 55
      },
      "nodeContext" : "textPaddingX * 2",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 30,
        "startLineNumber" : 239,
        "startColumnNumber" : 25,
        "endLineNumber" : 239,
        "endColumnNumber" : 55
      },
      "nodeContext" : "parentWidth - textPaddingX * 2",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 239,
        "startColumnNumber" : 8,
        "endLineNumber" : 239,
        "endColumnNumber" : 55
      },
      "nodeContext" : "availableWidth=parentWidth - textPaddingX * 2",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 239,
        "startColumnNumber" : 4,
        "endLineNumber" : 239,
        "endColumnNumber" : 56
      },
      "nodeContext" : "int availableWidth=parentWidth - textPaddingX * 2;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5463,
        "startLineNumber" : 228,
        "startColumnNumber" : 33,
        "endLineNumber" : 369,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  SpannableStringBuilder cueText=this.cueText instanceof SpannableStringBuilder ? (SpannableStringBuilder)this.cueText : new SpannableStringBuilder(this.cueText);\n  int parentWidth=parentRight - parentLeft;\n  int parentHeight=parentBottom - parentTop;\n  textPaint.setTextSize(defaultTextSizePx);\n  int textPaddingX=(int)(defaultTextSizePx * INNER_PADDING_RATIO + 0.5f);\n  int availableWidth=parentWidth - textPaddingX * 2;\n  if (cueSize != Cue.DIMEN_UNSET) {\n    availableWidth=(int)(availableWidth * cueSize);\n  }\n  if (availableWidth <= 0) {\n    Log.w(TAG,\"Skipped drawing subtitle cue (insufficient space)\");\n    return;\n  }\n  if (cueTextSizePx > 0) {\n    cueText.setSpan(new AbsoluteSizeSpan((int)cueTextSizePx),0,cueText.length(),Spanned.SPAN_PRIORITY);\n  }\n  SpannableStringBuilder cueTextEdge=new SpannableStringBuilder(cueText);\n  if (edgeType == CaptionStyleCompat.EDGE_TYPE_OUTLINE) {\n    ForegroundColorSpan[] foregroundColorSpans=cueTextEdge.getSpans(0,cueTextEdge.length(),ForegroundColorSpan.class);\n    for (    ForegroundColorSpan foregroundColorSpan : foregroundColorSpans) {\n      cueTextEdge.removeSpan(foregroundColorSpan);\n    }\n  }\n  if (Color.alpha(backgroundColor) > 0) {\n    if (edgeType == CaptionStyleCompat.EDGE_TYPE_NONE || edgeType == CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW) {\n      cueText.setSpan(new BackgroundColorSpan(backgroundColor),0,cueText.length(),Spanned.SPAN_PRIORITY);\n    }\n else {\n      cueTextEdge.setSpan(new BackgroundColorSpan(backgroundColor),0,cueTextEdge.length(),Spanned.SPAN_PRIORITY);\n    }\n  }\n  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;\n  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);\n  int textHeight=textLayout.getHeight();\n  int textWidth=0;\n  int lineCount=textLayout.getLineCount();\n  for (int i=0; i < lineCount; i++) {\n    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);\n  }\n  if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {\n    textWidth=availableWidth;\n  }\n  textWidth+=textPaddingX * 2;\n  int textLeft;\n  int textRight;\n  if (cuePosition != Cue.DIMEN_UNSET) {\n    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;\nswitch (cuePositionAnchor) {\ncase Cue.ANCHOR_TYPE_END:      textLeft=anchorPosition - textWidth;\n    break;\ncase Cue.ANCHOR_TYPE_MIDDLE:  textLeft=(anchorPosition * 2 - textWidth) / 2;\nbreak;\ncase Cue.ANCHOR_TYPE_START:case Cue.TYPE_UNSET:default:textLeft=anchorPosition;\n}\ntextLeft=Math.max(textLeft,parentLeft);\ntextRight=Math.min(textLeft + textWidth,parentRight);\n}\n else {\ntextLeft=(parentWidth - textWidth) / 2 + parentLeft;\ntextRight=textLeft + textWidth;\n}\ntextWidth=textRight - textLeft;\nif (textWidth <= 0) {\nLog.w(TAG,\"Skipped drawing subtitle cue (invalid horizontal positioning)\");\nreturn;\n}\nint textTop;\nif (cueLine != Cue.DIMEN_UNSET) {\nif (cueLineType == Cue.LINE_TYPE_FRACTION) {\nint anchorPosition=Math.round(parentHeight * cueLine) + parentTop;\ntextTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;\n}\n else {\nint firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);\nif (cueLine >= 0) {\ntextTop=Math.round(cueLine * firstLineHeight) + parentTop;\n}\n else {\ntextTop=Math.round((cueLine + 1) * firstLineHeight) + parentBottom - textHeight;\n}\n}\nif (textTop + textHeight > parentBottom) {\ntextTop=parentBottom - textHeight;\n}\n else if (textTop < parentTop) {\ntextTop=parentTop;\n}\n}\n else {\ntextTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);\n}\nthis.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.edgeLayout=new StaticLayout(cueTextEdge,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.textLeft=textLeft;\nthis.textTop=textTop;\nthis.textPaddingX=textPaddingX;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 616,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5524,
        "startLineNumber" : 227,
        "startColumnNumber" : 2,
        "endLineNumber" : 369,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@RequiresNonNull(\"cueText\") private void setupTextLayout(){\n  SpannableStringBuilder cueText=this.cueText instanceof SpannableStringBuilder ? (SpannableStringBuilder)this.cueText : new SpannableStringBuilder(this.cueText);\n  int parentWidth=parentRight - parentLeft;\n  int parentHeight=parentBottom - parentTop;\n  textPaint.setTextSize(defaultTextSizePx);\n  int textPaddingX=(int)(defaultTextSizePx * INNER_PADDING_RATIO + 0.5f);\n  int availableWidth=parentWidth - textPaddingX * 2;\n  if (cueSize != Cue.DIMEN_UNSET) {\n    availableWidth=(int)(availableWidth * cueSize);\n  }\n  if (availableWidth <= 0) {\n    Log.w(TAG,\"Skipped drawing subtitle cue (insufficient space)\");\n    return;\n  }\n  if (cueTextSizePx > 0) {\n    cueText.setSpan(new AbsoluteSizeSpan((int)cueTextSizePx),0,cueText.length(),Spanned.SPAN_PRIORITY);\n  }\n  SpannableStringBuilder cueTextEdge=new SpannableStringBuilder(cueText);\n  if (edgeType == CaptionStyleCompat.EDGE_TYPE_OUTLINE) {\n    ForegroundColorSpan[] foregroundColorSpans=cueTextEdge.getSpans(0,cueTextEdge.length(),ForegroundColorSpan.class);\n    for (    ForegroundColorSpan foregroundColorSpan : foregroundColorSpans) {\n      cueTextEdge.removeSpan(foregroundColorSpan);\n    }\n  }\n  if (Color.alpha(backgroundColor) > 0) {\n    if (edgeType == CaptionStyleCompat.EDGE_TYPE_NONE || edgeType == CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW) {\n      cueText.setSpan(new BackgroundColorSpan(backgroundColor),0,cueText.length(),Spanned.SPAN_PRIORITY);\n    }\n else {\n      cueTextEdge.setSpan(new BackgroundColorSpan(backgroundColor),0,cueTextEdge.length(),Spanned.SPAN_PRIORITY);\n    }\n  }\n  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;\n  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);\n  int textHeight=textLayout.getHeight();\n  int textWidth=0;\n  int lineCount=textLayout.getLineCount();\n  for (int i=0; i < lineCount; i++) {\n    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);\n  }\n  if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {\n    textWidth=availableWidth;\n  }\n  textWidth+=textPaddingX * 2;\n  int textLeft;\n  int textRight;\n  if (cuePosition != Cue.DIMEN_UNSET) {\n    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;\nswitch (cuePositionAnchor) {\ncase Cue.ANCHOR_TYPE_END:      textLeft=anchorPosition - textWidth;\n    break;\ncase Cue.ANCHOR_TYPE_MIDDLE:  textLeft=(anchorPosition * 2 - textWidth) / 2;\nbreak;\ncase Cue.ANCHOR_TYPE_START:case Cue.TYPE_UNSET:default:textLeft=anchorPosition;\n}\ntextLeft=Math.max(textLeft,parentLeft);\ntextRight=Math.min(textLeft + textWidth,parentRight);\n}\n else {\ntextLeft=(parentWidth - textWidth) / 2 + parentLeft;\ntextRight=textLeft + textWidth;\n}\ntextWidth=textRight - textLeft;\nif (textWidth <= 0) {\nLog.w(TAG,\"Skipped drawing subtitle cue (invalid horizontal positioning)\");\nreturn;\n}\nint textTop;\nif (cueLine != Cue.DIMEN_UNSET) {\nif (cueLineType == Cue.LINE_TYPE_FRACTION) {\nint anchorPosition=Math.round(parentHeight * cueLine) + parentTop;\ntextTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;\n}\n else {\nint firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);\nif (cueLine >= 0) {\ntextTop=Math.round(cueLine * firstLineHeight) + parentTop;\n}\n else {\ntextTop=Math.round((cueLine + 1) * firstLineHeight) + parentBottom - textHeight;\n}\n}\nif (textTop + textHeight > parentBottom) {\ntextTop=parentBottom - textHeight;\n}\n else if (textTop < parentTop) {\ntextTop=parentTop;\n}\n}\n else {\ntextTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);\n}\nthis.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.edgeLayout=new StaticLayout(cueTextEdge,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.textLeft=textLeft;\nthis.textTop=textTop;\nthis.textPaddingX=textPaddingX;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 623,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 239,
        "startColumnNumber" : 4,
        "endLineNumber" : 239,
        "endColumnNumber" : 56
      },
      "nodeContext" : "int availableWidth=parentWidth - textPaddingX * 2;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "textPaddingX",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 12,
      "startLineNumber" : 298,
      "startColumnNumber" : 17,
      "endLineNumber" : 298,
      "endColumnNumber" : 29
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 16,
        "startLineNumber" : 298,
        "startColumnNumber" : 17,
        "endLineNumber" : 298,
        "endColumnNumber" : 33
      },
      "nodeContext" : "textPaddingX * 2",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 298,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 33
      },
      "nodeContext" : "textWidth+=textPaddingX * 2",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 30,
        "startLineNumber" : 298,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 34
      },
      "nodeContext" : "textWidth+=textPaddingX * 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5463,
        "startLineNumber" : 228,
        "startColumnNumber" : 33,
        "endLineNumber" : 369,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  SpannableStringBuilder cueText=this.cueText instanceof SpannableStringBuilder ? (SpannableStringBuilder)this.cueText : new SpannableStringBuilder(this.cueText);\n  int parentWidth=parentRight - parentLeft;\n  int parentHeight=parentBottom - parentTop;\n  textPaint.setTextSize(defaultTextSizePx);\n  int textPaddingX=(int)(defaultTextSizePx * INNER_PADDING_RATIO + 0.5f);\n  int availableWidth=parentWidth - textPaddingX * 2;\n  if (cueSize != Cue.DIMEN_UNSET) {\n    availableWidth=(int)(availableWidth * cueSize);\n  }\n  if (availableWidth <= 0) {\n    Log.w(TAG,\"Skipped drawing subtitle cue (insufficient space)\");\n    return;\n  }\n  if (cueTextSizePx > 0) {\n    cueText.setSpan(new AbsoluteSizeSpan((int)cueTextSizePx),0,cueText.length(),Spanned.SPAN_PRIORITY);\n  }\n  SpannableStringBuilder cueTextEdge=new SpannableStringBuilder(cueText);\n  if (edgeType == CaptionStyleCompat.EDGE_TYPE_OUTLINE) {\n    ForegroundColorSpan[] foregroundColorSpans=cueTextEdge.getSpans(0,cueTextEdge.length(),ForegroundColorSpan.class);\n    for (    ForegroundColorSpan foregroundColorSpan : foregroundColorSpans) {\n      cueTextEdge.removeSpan(foregroundColorSpan);\n    }\n  }\n  if (Color.alpha(backgroundColor) > 0) {\n    if (edgeType == CaptionStyleCompat.EDGE_TYPE_NONE || edgeType == CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW) {\n      cueText.setSpan(new BackgroundColorSpan(backgroundColor),0,cueText.length(),Spanned.SPAN_PRIORITY);\n    }\n else {\n      cueTextEdge.setSpan(new BackgroundColorSpan(backgroundColor),0,cueTextEdge.length(),Spanned.SPAN_PRIORITY);\n    }\n  }\n  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;\n  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);\n  int textHeight=textLayout.getHeight();\n  int textWidth=0;\n  int lineCount=textLayout.getLineCount();\n  for (int i=0; i < lineCount; i++) {\n    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);\n  }\n  if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {\n    textWidth=availableWidth;\n  }\n  textWidth+=textPaddingX * 2;\n  int textLeft;\n  int textRight;\n  if (cuePosition != Cue.DIMEN_UNSET) {\n    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;\nswitch (cuePositionAnchor) {\ncase Cue.ANCHOR_TYPE_END:      textLeft=anchorPosition - textWidth;\n    break;\ncase Cue.ANCHOR_TYPE_MIDDLE:  textLeft=(anchorPosition * 2 - textWidth) / 2;\nbreak;\ncase Cue.ANCHOR_TYPE_START:case Cue.TYPE_UNSET:default:textLeft=anchorPosition;\n}\ntextLeft=Math.max(textLeft,parentLeft);\ntextRight=Math.min(textLeft + textWidth,parentRight);\n}\n else {\ntextLeft=(parentWidth - textWidth) / 2 + parentLeft;\ntextRight=textLeft + textWidth;\n}\ntextWidth=textRight - textLeft;\nif (textWidth <= 0) {\nLog.w(TAG,\"Skipped drawing subtitle cue (invalid horizontal positioning)\");\nreturn;\n}\nint textTop;\nif (cueLine != Cue.DIMEN_UNSET) {\nif (cueLineType == Cue.LINE_TYPE_FRACTION) {\nint anchorPosition=Math.round(parentHeight * cueLine) + parentTop;\ntextTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;\n}\n else {\nint firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);\nif (cueLine >= 0) {\ntextTop=Math.round(cueLine * firstLineHeight) + parentTop;\n}\n else {\ntextTop=Math.round((cueLine + 1) * firstLineHeight) + parentBottom - textHeight;\n}\n}\nif (textTop + textHeight > parentBottom) {\ntextTop=parentBottom - textHeight;\n}\n else if (textTop < parentTop) {\ntextTop=parentTop;\n}\n}\n else {\ntextTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);\n}\nthis.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.edgeLayout=new StaticLayout(cueTextEdge,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.textLeft=textLeft;\nthis.textTop=textTop;\nthis.textPaddingX=textPaddingX;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 616,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5524,
        "startLineNumber" : 227,
        "startColumnNumber" : 2,
        "endLineNumber" : 369,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@RequiresNonNull(\"cueText\") private void setupTextLayout(){\n  SpannableStringBuilder cueText=this.cueText instanceof SpannableStringBuilder ? (SpannableStringBuilder)this.cueText : new SpannableStringBuilder(this.cueText);\n  int parentWidth=parentRight - parentLeft;\n  int parentHeight=parentBottom - parentTop;\n  textPaint.setTextSize(defaultTextSizePx);\n  int textPaddingX=(int)(defaultTextSizePx * INNER_PADDING_RATIO + 0.5f);\n  int availableWidth=parentWidth - textPaddingX * 2;\n  if (cueSize != Cue.DIMEN_UNSET) {\n    availableWidth=(int)(availableWidth * cueSize);\n  }\n  if (availableWidth <= 0) {\n    Log.w(TAG,\"Skipped drawing subtitle cue (insufficient space)\");\n    return;\n  }\n  if (cueTextSizePx > 0) {\n    cueText.setSpan(new AbsoluteSizeSpan((int)cueTextSizePx),0,cueText.length(),Spanned.SPAN_PRIORITY);\n  }\n  SpannableStringBuilder cueTextEdge=new SpannableStringBuilder(cueText);\n  if (edgeType == CaptionStyleCompat.EDGE_TYPE_OUTLINE) {\n    ForegroundColorSpan[] foregroundColorSpans=cueTextEdge.getSpans(0,cueTextEdge.length(),ForegroundColorSpan.class);\n    for (    ForegroundColorSpan foregroundColorSpan : foregroundColorSpans) {\n      cueTextEdge.removeSpan(foregroundColorSpan);\n    }\n  }\n  if (Color.alpha(backgroundColor) > 0) {\n    if (edgeType == CaptionStyleCompat.EDGE_TYPE_NONE || edgeType == CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW) {\n      cueText.setSpan(new BackgroundColorSpan(backgroundColor),0,cueText.length(),Spanned.SPAN_PRIORITY);\n    }\n else {\n      cueTextEdge.setSpan(new BackgroundColorSpan(backgroundColor),0,cueTextEdge.length(),Spanned.SPAN_PRIORITY);\n    }\n  }\n  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;\n  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);\n  int textHeight=textLayout.getHeight();\n  int textWidth=0;\n  int lineCount=textLayout.getLineCount();\n  for (int i=0; i < lineCount; i++) {\n    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);\n  }\n  if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {\n    textWidth=availableWidth;\n  }\n  textWidth+=textPaddingX * 2;\n  int textLeft;\n  int textRight;\n  if (cuePosition != Cue.DIMEN_UNSET) {\n    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;\nswitch (cuePositionAnchor) {\ncase Cue.ANCHOR_TYPE_END:      textLeft=anchorPosition - textWidth;\n    break;\ncase Cue.ANCHOR_TYPE_MIDDLE:  textLeft=(anchorPosition * 2 - textWidth) / 2;\nbreak;\ncase Cue.ANCHOR_TYPE_START:case Cue.TYPE_UNSET:default:textLeft=anchorPosition;\n}\ntextLeft=Math.max(textLeft,parentLeft);\ntextRight=Math.min(textLeft + textWidth,parentRight);\n}\n else {\ntextLeft=(parentWidth - textWidth) / 2 + parentLeft;\ntextRight=textLeft + textWidth;\n}\ntextWidth=textRight - textLeft;\nif (textWidth <= 0) {\nLog.w(TAG,\"Skipped drawing subtitle cue (invalid horizontal positioning)\");\nreturn;\n}\nint textTop;\nif (cueLine != Cue.DIMEN_UNSET) {\nif (cueLineType == Cue.LINE_TYPE_FRACTION) {\nint anchorPosition=Math.round(parentHeight * cueLine) + parentTop;\ntextTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;\n}\n else {\nint firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);\nif (cueLine >= 0) {\ntextTop=Math.round(cueLine * firstLineHeight) + parentTop;\n}\n else {\ntextTop=Math.round((cueLine + 1) * firstLineHeight) + parentBottom - textHeight;\n}\n}\nif (textTop + textHeight > parentBottom) {\ntextTop=parentBottom - textHeight;\n}\n else if (textTop < parentTop) {\ntextTop=parentTop;\n}\n}\n else {\ntextTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);\n}\nthis.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.edgeLayout=new StaticLayout(cueTextEdge,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.textLeft=textLeft;\nthis.textTop=textTop;\nthis.textPaddingX=textPaddingX;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 623,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 30,
        "startLineNumber" : 298,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 34
      },
      "nodeContext" : "textWidth+=textPaddingX * 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "textPaddingX",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 12,
      "startLineNumber" : 368,
      "startColumnNumber" : 24,
      "endLineNumber" : 368,
      "endColumnNumber" : 36
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 368,
        "startColumnNumber" : 4,
        "endLineNumber" : 368,
        "endColumnNumber" : 36
      },
      "nodeContext" : "this.textPaddingX=textPaddingX",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 368,
        "startColumnNumber" : 4,
        "endLineNumber" : 368,
        "endColumnNumber" : 37
      },
      "nodeContext" : "this.textPaddingX=textPaddingX;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5463,
        "startLineNumber" : 228,
        "startColumnNumber" : 33,
        "endLineNumber" : 369,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  SpannableStringBuilder cueText=this.cueText instanceof SpannableStringBuilder ? (SpannableStringBuilder)this.cueText : new SpannableStringBuilder(this.cueText);\n  int parentWidth=parentRight - parentLeft;\n  int parentHeight=parentBottom - parentTop;\n  textPaint.setTextSize(defaultTextSizePx);\n  int textPaddingX=(int)(defaultTextSizePx * INNER_PADDING_RATIO + 0.5f);\n  int availableWidth=parentWidth - textPaddingX * 2;\n  if (cueSize != Cue.DIMEN_UNSET) {\n    availableWidth=(int)(availableWidth * cueSize);\n  }\n  if (availableWidth <= 0) {\n    Log.w(TAG,\"Skipped drawing subtitle cue (insufficient space)\");\n    return;\n  }\n  if (cueTextSizePx > 0) {\n    cueText.setSpan(new AbsoluteSizeSpan((int)cueTextSizePx),0,cueText.length(),Spanned.SPAN_PRIORITY);\n  }\n  SpannableStringBuilder cueTextEdge=new SpannableStringBuilder(cueText);\n  if (edgeType == CaptionStyleCompat.EDGE_TYPE_OUTLINE) {\n    ForegroundColorSpan[] foregroundColorSpans=cueTextEdge.getSpans(0,cueTextEdge.length(),ForegroundColorSpan.class);\n    for (    ForegroundColorSpan foregroundColorSpan : foregroundColorSpans) {\n      cueTextEdge.removeSpan(foregroundColorSpan);\n    }\n  }\n  if (Color.alpha(backgroundColor) > 0) {\n    if (edgeType == CaptionStyleCompat.EDGE_TYPE_NONE || edgeType == CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW) {\n      cueText.setSpan(new BackgroundColorSpan(backgroundColor),0,cueText.length(),Spanned.SPAN_PRIORITY);\n    }\n else {\n      cueTextEdge.setSpan(new BackgroundColorSpan(backgroundColor),0,cueTextEdge.length(),Spanned.SPAN_PRIORITY);\n    }\n  }\n  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;\n  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);\n  int textHeight=textLayout.getHeight();\n  int textWidth=0;\n  int lineCount=textLayout.getLineCount();\n  for (int i=0; i < lineCount; i++) {\n    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);\n  }\n  if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {\n    textWidth=availableWidth;\n  }\n  textWidth+=textPaddingX * 2;\n  int textLeft;\n  int textRight;\n  if (cuePosition != Cue.DIMEN_UNSET) {\n    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;\nswitch (cuePositionAnchor) {\ncase Cue.ANCHOR_TYPE_END:      textLeft=anchorPosition - textWidth;\n    break;\ncase Cue.ANCHOR_TYPE_MIDDLE:  textLeft=(anchorPosition * 2 - textWidth) / 2;\nbreak;\ncase Cue.ANCHOR_TYPE_START:case Cue.TYPE_UNSET:default:textLeft=anchorPosition;\n}\ntextLeft=Math.max(textLeft,parentLeft);\ntextRight=Math.min(textLeft + textWidth,parentRight);\n}\n else {\ntextLeft=(parentWidth - textWidth) / 2 + parentLeft;\ntextRight=textLeft + textWidth;\n}\ntextWidth=textRight - textLeft;\nif (textWidth <= 0) {\nLog.w(TAG,\"Skipped drawing subtitle cue (invalid horizontal positioning)\");\nreturn;\n}\nint textTop;\nif (cueLine != Cue.DIMEN_UNSET) {\nif (cueLineType == Cue.LINE_TYPE_FRACTION) {\nint anchorPosition=Math.round(parentHeight * cueLine) + parentTop;\ntextTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;\n}\n else {\nint firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);\nif (cueLine >= 0) {\ntextTop=Math.round(cueLine * firstLineHeight) + parentTop;\n}\n else {\ntextTop=Math.round((cueLine + 1) * firstLineHeight) + parentBottom - textHeight;\n}\n}\nif (textTop + textHeight > parentBottom) {\ntextTop=parentBottom - textHeight;\n}\n else if (textTop < parentTop) {\ntextTop=parentTop;\n}\n}\n else {\ntextTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);\n}\nthis.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.edgeLayout=new StaticLayout(cueTextEdge,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.textLeft=textLeft;\nthis.textTop=textTop;\nthis.textPaddingX=textPaddingX;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 616,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5524,
        "startLineNumber" : 227,
        "startColumnNumber" : 2,
        "endLineNumber" : 369,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@RequiresNonNull(\"cueText\") private void setupTextLayout(){\n  SpannableStringBuilder cueText=this.cueText instanceof SpannableStringBuilder ? (SpannableStringBuilder)this.cueText : new SpannableStringBuilder(this.cueText);\n  int parentWidth=parentRight - parentLeft;\n  int parentHeight=parentBottom - parentTop;\n  textPaint.setTextSize(defaultTextSizePx);\n  int textPaddingX=(int)(defaultTextSizePx * INNER_PADDING_RATIO + 0.5f);\n  int availableWidth=parentWidth - textPaddingX * 2;\n  if (cueSize != Cue.DIMEN_UNSET) {\n    availableWidth=(int)(availableWidth * cueSize);\n  }\n  if (availableWidth <= 0) {\n    Log.w(TAG,\"Skipped drawing subtitle cue (insufficient space)\");\n    return;\n  }\n  if (cueTextSizePx > 0) {\n    cueText.setSpan(new AbsoluteSizeSpan((int)cueTextSizePx),0,cueText.length(),Spanned.SPAN_PRIORITY);\n  }\n  SpannableStringBuilder cueTextEdge=new SpannableStringBuilder(cueText);\n  if (edgeType == CaptionStyleCompat.EDGE_TYPE_OUTLINE) {\n    ForegroundColorSpan[] foregroundColorSpans=cueTextEdge.getSpans(0,cueTextEdge.length(),ForegroundColorSpan.class);\n    for (    ForegroundColorSpan foregroundColorSpan : foregroundColorSpans) {\n      cueTextEdge.removeSpan(foregroundColorSpan);\n    }\n  }\n  if (Color.alpha(backgroundColor) > 0) {\n    if (edgeType == CaptionStyleCompat.EDGE_TYPE_NONE || edgeType == CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW) {\n      cueText.setSpan(new BackgroundColorSpan(backgroundColor),0,cueText.length(),Spanned.SPAN_PRIORITY);\n    }\n else {\n      cueTextEdge.setSpan(new BackgroundColorSpan(backgroundColor),0,cueTextEdge.length(),Spanned.SPAN_PRIORITY);\n    }\n  }\n  Alignment textAlignment=cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;\n  textLayout=new StaticLayout(cueText,textPaint,availableWidth,textAlignment,spacingMult,spacingAdd,true);\n  int textHeight=textLayout.getHeight();\n  int textWidth=0;\n  int lineCount=textLayout.getLineCount();\n  for (int i=0; i < lineCount; i++) {\n    textWidth=Math.max((int)Math.ceil(textLayout.getLineWidth(i)),textWidth);\n  }\n  if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {\n    textWidth=availableWidth;\n  }\n  textWidth+=textPaddingX * 2;\n  int textLeft;\n  int textRight;\n  if (cuePosition != Cue.DIMEN_UNSET) {\n    int anchorPosition=Math.round(parentWidth * cuePosition) + parentLeft;\nswitch (cuePositionAnchor) {\ncase Cue.ANCHOR_TYPE_END:      textLeft=anchorPosition - textWidth;\n    break;\ncase Cue.ANCHOR_TYPE_MIDDLE:  textLeft=(anchorPosition * 2 - textWidth) / 2;\nbreak;\ncase Cue.ANCHOR_TYPE_START:case Cue.TYPE_UNSET:default:textLeft=anchorPosition;\n}\ntextLeft=Math.max(textLeft,parentLeft);\ntextRight=Math.min(textLeft + textWidth,parentRight);\n}\n else {\ntextLeft=(parentWidth - textWidth) / 2 + parentLeft;\ntextRight=textLeft + textWidth;\n}\ntextWidth=textRight - textLeft;\nif (textWidth <= 0) {\nLog.w(TAG,\"Skipped drawing subtitle cue (invalid horizontal positioning)\");\nreturn;\n}\nint textTop;\nif (cueLine != Cue.DIMEN_UNSET) {\nif (cueLineType == Cue.LINE_TYPE_FRACTION) {\nint anchorPosition=Math.round(parentHeight * cueLine) + parentTop;\ntextTop=cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2 : anchorPosition;\n}\n else {\nint firstLineHeight=textLayout.getLineBottom(0) - textLayout.getLineTop(0);\nif (cueLine >= 0) {\ntextTop=Math.round(cueLine * firstLineHeight) + parentTop;\n}\n else {\ntextTop=Math.round((cueLine + 1) * firstLineHeight) + parentBottom - textHeight;\n}\n}\nif (textTop + textHeight > parentBottom) {\ntextTop=parentBottom - textHeight;\n}\n else if (textTop < parentTop) {\ntextTop=parentTop;\n}\n}\n else {\ntextTop=parentBottom - textHeight - (int)(parentHeight * bottomPaddingFraction);\n}\nthis.textLayout=new StaticLayout(cueText,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.edgeLayout=new StaticLayout(cueTextEdge,textPaint,textWidth,textAlignment,spacingMult,spacingAdd,true);\nthis.textLeft=textLeft;\nthis.textTop=textTop;\nthis.textPaddingX=textPaddingX;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 623,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 368,
        "startColumnNumber" : 4,
        "endLineNumber" : 368,
        "endColumnNumber" : 37
      },
      "nodeContext" : "this.textPaddingX=textPaddingX;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 12,
    "startLineNumber" : 239,
    "startColumnNumber" : 39,
    "endLineNumber" : 239,
    "endColumnNumber" : 51
  }, {
    "charLength" : 12,
    "startLineNumber" : 298,
    "startColumnNumber" : 17,
    "endLineNumber" : 298,
    "endColumnNumber" : 29
  }, {
    "charLength" : 12,
    "startLineNumber" : 368,
    "startColumnNumber" : 24,
    "endLineNumber" : 368,
    "endColumnNumber" : 36
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 2
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 2
  } ]
}