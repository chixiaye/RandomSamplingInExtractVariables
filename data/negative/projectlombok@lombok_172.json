{
  "id" : 172,
  "expression" : "((AbstractMethodDeclaration)blockNode)",
  "projectName" : "projectlombok@lombok",
  "commitID" : "25def866b50860715ee7c315c678b8c3d1ba9b56",
  "filePath" : "/src/core/lombok/eclipse/handlers/HandleCleanup.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "((AbstractMethodDeclaration)blockNode)",
    "nodeType" : "ParenthesizedExpression",
    "nodePosition" : {
      "charLength" : 38,
      "startLineNumber" : 86,
      "startColumnNumber" : 16,
      "endLineNumber" : 86,
      "endColumnNumber" : 54
    },
    "astNodeNumber" : 5,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 86,
        "startColumnNumber" : 16,
        "endLineNumber" : 86,
        "endColumnNumber" : 65
      },
      "nodeContext" : "((AbstractMethodDeclaration)blockNode).statements",
      "nodeType" : "FieldAccess",
      "astNodeNumber" : 7,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 62,
        "startLineNumber" : 86,
        "startColumnNumber" : 3,
        "endLineNumber" : 86,
        "endColumnNumber" : 65
      },
      "nodeContext" : "statements=((AbstractMethodDeclaration)blockNode).statements",
      "nodeType" : "Assignment",
      "astNodeNumber" : 9,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 86,
        "startColumnNumber" : 3,
        "endLineNumber" : 86,
        "endColumnNumber" : 66
      },
      "nodeContext" : "statements=((AbstractMethodDeclaration)blockNode).statements;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 84,
        "startColumnNumber" : 54,
        "endLineNumber" : 87,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  isSwitch=false;\n  statements=((AbstractMethodDeclaration)blockNode).statements;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 15,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 510,
        "startLineNumber" : 84,
        "startColumnNumber" : 2,
        "endLineNumber" : 96,
        "endColumnNumber" : 3
      },
      "nodeContext" : "if (blockNode instanceof AbstractMethodDeclaration) {\n  isSwitch=false;\n  statements=((AbstractMethodDeclaration)blockNode).statements;\n}\n else if (blockNode instanceof Block) {\n  isSwitch=false;\n  statements=((Block)blockNode).statements;\n}\n else if (blockNode instanceof SwitchStatement) {\n  isSwitch=true;\n  statements=((SwitchStatement)blockNode).statements;\n}\n else {\n  annotationNode.addError(\"@Cleanup is legal only on a local variable declaration inside a block.\");\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 67,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6172,
        "startLineNumber" : 60,
        "startColumnNumber" : 102,
        "endLineNumber" : 226,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  String cleanupName=annotation.getInstance().value();\n  if (cleanupName.length() == 0) {\n    annotationNode.addError(\"cleanupName cannot be the empty string.\");\n    return;\n  }\n  if (annotationNode.up().getKind() != Kind.LOCAL) {\n    annotationNode.addError(\"@Cleanup is legal only on local variable declarations.\");\n    return;\n  }\n  LocalDeclaration decl=(LocalDeclaration)annotationNode.up().get();\n  if (decl.initialization == null) {\n    annotationNode.addError(\"@Cleanup variable declarations need to be initialized.\");\n    return;\n  }\n  EclipseNode ancestor=annotationNode.up().directUp();\n  ASTNode blockNode=ancestor.get();\n  final boolean isSwitch;\n  final Statement[] statements;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    isSwitch=false;\n    statements=((AbstractMethodDeclaration)blockNode).statements;\n  }\n else   if (blockNode instanceof Block) {\n    isSwitch=false;\n    statements=((Block)blockNode).statements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    isSwitch=true;\n    statements=((SwitchStatement)blockNode).statements;\n  }\n else {\n    annotationNode.addError(\"@Cleanup is legal only on a local variable declaration inside a block.\");\n    return;\n  }\n  if (statements == null) {\n    annotationNode.addError(\"LOMBOK BUG: Parent block does not contain any statements.\");\n    return;\n  }\n  int start=0;\n  for (; start < statements.length; start++) {\n    if (statements[start] == decl)     break;\n  }\n  if (start == statements.length) {\n    annotationNode.addError(\"LOMBOK BUG: Can't find this local variable declaration inside its parent.\");\n    return;\n  }\n  start++;\n  int end;\n  if (isSwitch) {\n    end=start + 1;\n    for (; end < statements.length; end++) {\n      if (statements[end] instanceof CaseStatement) {\n        break;\n      }\n    }\n  }\n else   end=statements.length;\n  Statement[] tryBlock=new Statement[end - start];\n  System.arraycopy(statements,start,tryBlock,0,end - start);\n  int newStatementsLength=statements.length - (end - start);\n  newStatementsLength+=1;\n  Statement[] newStatements=new Statement[newStatementsLength];\n  System.arraycopy(statements,0,newStatements,0,start);\n  System.arraycopy(statements,end,newStatements,start + 1,statements.length - end);\n  doAssignmentCheck(annotationNode,tryBlock,decl.name);\n  TryStatement tryStatement=new TryStatement();\n  setGeneratedBy(tryStatement,ast);\n  tryStatement.tryBlock=new Block(0);\n  tryStatement.tryBlock.statements=tryBlock;\n  setGeneratedBy(tryStatement.tryBlock,ast);\n  int ss=decl.declarationSourceEnd + 1;\n  int se=ss;\n  if (tryBlock.length > 0) {\n    se=tryBlock[tryBlock.length - 1].sourceEnd + 1;\n    tryStatement.sourceStart=ss;\n    tryStatement.sourceEnd=se;\n    tryStatement.tryBlock.sourceStart=ss;\n    tryStatement.tryBlock.sourceEnd=se;\n  }\n  newStatements[start]=tryStatement;\n  Statement[] finallyBlock=new Statement[1];\n  MessageSend unsafeClose=new MessageSend();\n  setGeneratedBy(unsafeClose,ast);\n  unsafeClose.sourceStart=ast.sourceStart;\n  unsafeClose.sourceEnd=ast.sourceEnd;\n  SingleNameReference receiver=new SingleNameReference(decl.name,0);\n  setGeneratedBy(receiver,ast);\n  unsafeClose.receiver=receiver;\n  long nameSourcePosition=(long)ast.sourceStart << 32 | ast.sourceEnd;\n  if (ast.memberValuePairs() != null)   for (  MemberValuePair pair : ast.memberValuePairs()) {\n    if (pair.name != null && new String(pair.name).equals(\"value\")) {\n      nameSourcePosition=(long)pair.value.sourceStart << 32 | pair.value.sourceEnd;\n      break;\n    }\n  }\n  unsafeClose.nameSourcePosition=nameSourcePosition;\n  unsafeClose.selector=cleanupName.toCharArray();\n  int pS=ast.sourceStart, pE=ast.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  SingleNameReference varName=new SingleNameReference(decl.name,p);\n  setGeneratedBy(varName,ast);\n  NullLiteral nullLiteral=new NullLiteral(pS,pE);\n  setGeneratedBy(nullLiteral,ast);\n  MessageSend preventNullAnalysis=preventNullAnalysis(ast,varName);\n  EqualExpression equalExpression=new EqualExpression(preventNullAnalysis,nullLiteral,OperatorIds.NOT_EQUAL);\n  equalExpression.sourceStart=pS;\n  equalExpression.sourceEnd=pE;\n  setGeneratedBy(equalExpression,ast);\n  Block closeBlock=new Block(0);\n  closeBlock.statements=new Statement[1];\n  closeBlock.statements[0]=unsafeClose;\n  setGeneratedBy(closeBlock,ast);\n  IfStatement ifStatement=new IfStatement(equalExpression,closeBlock,0,0);\n  setGeneratedBy(ifStatement,ast);\n  finallyBlock[0]=ifStatement;\n  tryStatement.finallyBlock=new Block(0);\n  if (!isSwitch) {\n    tryStatement.finallyBlock.sourceStart=blockNode.sourceEnd;\n    tryStatement.finallyBlock.sourceEnd=blockNode.sourceEnd;\n  }\n  setGeneratedBy(tryStatement.finallyBlock,ast);\n  tryStatement.finallyBlock.statements=finallyBlock;\n  tryStatement.catchArguments=null;\n  tryStatement.catchBlocks=null;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    ((AbstractMethodDeclaration)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof Block) {\n    ((Block)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    ((SwitchStatement)blockNode).statements=newStatements;\n  }\n  ancestor.rebuild();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 850,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6273,
        "startLineNumber" : 60,
        "startColumnNumber" : 1,
        "endLineNumber" : 226,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void handle(AnnotationValues<Cleanup> annotation,Annotation ast,EclipseNode annotationNode){\n  String cleanupName=annotation.getInstance().value();\n  if (cleanupName.length() == 0) {\n    annotationNode.addError(\"cleanupName cannot be the empty string.\");\n    return;\n  }\n  if (annotationNode.up().getKind() != Kind.LOCAL) {\n    annotationNode.addError(\"@Cleanup is legal only on local variable declarations.\");\n    return;\n  }\n  LocalDeclaration decl=(LocalDeclaration)annotationNode.up().get();\n  if (decl.initialization == null) {\n    annotationNode.addError(\"@Cleanup variable declarations need to be initialized.\");\n    return;\n  }\n  EclipseNode ancestor=annotationNode.up().directUp();\n  ASTNode blockNode=ancestor.get();\n  final boolean isSwitch;\n  final Statement[] statements;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    isSwitch=false;\n    statements=((AbstractMethodDeclaration)blockNode).statements;\n  }\n else   if (blockNode instanceof Block) {\n    isSwitch=false;\n    statements=((Block)blockNode).statements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    isSwitch=true;\n    statements=((SwitchStatement)blockNode).statements;\n  }\n else {\n    annotationNode.addError(\"@Cleanup is legal only on a local variable declaration inside a block.\");\n    return;\n  }\n  if (statements == null) {\n    annotationNode.addError(\"LOMBOK BUG: Parent block does not contain any statements.\");\n    return;\n  }\n  int start=0;\n  for (; start < statements.length; start++) {\n    if (statements[start] == decl)     break;\n  }\n  if (start == statements.length) {\n    annotationNode.addError(\"LOMBOK BUG: Can't find this local variable declaration inside its parent.\");\n    return;\n  }\n  start++;\n  int end;\n  if (isSwitch) {\n    end=start + 1;\n    for (; end < statements.length; end++) {\n      if (statements[end] instanceof CaseStatement) {\n        break;\n      }\n    }\n  }\n else   end=statements.length;\n  Statement[] tryBlock=new Statement[end - start];\n  System.arraycopy(statements,start,tryBlock,0,end - start);\n  int newStatementsLength=statements.length - (end - start);\n  newStatementsLength+=1;\n  Statement[] newStatements=new Statement[newStatementsLength];\n  System.arraycopy(statements,0,newStatements,0,start);\n  System.arraycopy(statements,end,newStatements,start + 1,statements.length - end);\n  doAssignmentCheck(annotationNode,tryBlock,decl.name);\n  TryStatement tryStatement=new TryStatement();\n  setGeneratedBy(tryStatement,ast);\n  tryStatement.tryBlock=new Block(0);\n  tryStatement.tryBlock.statements=tryBlock;\n  setGeneratedBy(tryStatement.tryBlock,ast);\n  int ss=decl.declarationSourceEnd + 1;\n  int se=ss;\n  if (tryBlock.length > 0) {\n    se=tryBlock[tryBlock.length - 1].sourceEnd + 1;\n    tryStatement.sourceStart=ss;\n    tryStatement.sourceEnd=se;\n    tryStatement.tryBlock.sourceStart=ss;\n    tryStatement.tryBlock.sourceEnd=se;\n  }\n  newStatements[start]=tryStatement;\n  Statement[] finallyBlock=new Statement[1];\n  MessageSend unsafeClose=new MessageSend();\n  setGeneratedBy(unsafeClose,ast);\n  unsafeClose.sourceStart=ast.sourceStart;\n  unsafeClose.sourceEnd=ast.sourceEnd;\n  SingleNameReference receiver=new SingleNameReference(decl.name,0);\n  setGeneratedBy(receiver,ast);\n  unsafeClose.receiver=receiver;\n  long nameSourcePosition=(long)ast.sourceStart << 32 | ast.sourceEnd;\n  if (ast.memberValuePairs() != null)   for (  MemberValuePair pair : ast.memberValuePairs()) {\n    if (pair.name != null && new String(pair.name).equals(\"value\")) {\n      nameSourcePosition=(long)pair.value.sourceStart << 32 | pair.value.sourceEnd;\n      break;\n    }\n  }\n  unsafeClose.nameSourcePosition=nameSourcePosition;\n  unsafeClose.selector=cleanupName.toCharArray();\n  int pS=ast.sourceStart, pE=ast.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  SingleNameReference varName=new SingleNameReference(decl.name,p);\n  setGeneratedBy(varName,ast);\n  NullLiteral nullLiteral=new NullLiteral(pS,pE);\n  setGeneratedBy(nullLiteral,ast);\n  MessageSend preventNullAnalysis=preventNullAnalysis(ast,varName);\n  EqualExpression equalExpression=new EqualExpression(preventNullAnalysis,nullLiteral,OperatorIds.NOT_EQUAL);\n  equalExpression.sourceStart=pS;\n  equalExpression.sourceEnd=pE;\n  setGeneratedBy(equalExpression,ast);\n  Block closeBlock=new Block(0);\n  closeBlock.statements=new Statement[1];\n  closeBlock.statements[0]=unsafeClose;\n  setGeneratedBy(closeBlock,ast);\n  IfStatement ifStatement=new IfStatement(equalExpression,closeBlock,0,0);\n  setGeneratedBy(ifStatement,ast);\n  finallyBlock[0]=ifStatement;\n  tryStatement.finallyBlock=new Block(0);\n  if (!isSwitch) {\n    tryStatement.finallyBlock.sourceStart=blockNode.sourceEnd;\n    tryStatement.finallyBlock.sourceEnd=blockNode.sourceEnd;\n  }\n  setGeneratedBy(tryStatement.finallyBlock,ast);\n  tryStatement.finallyBlock.statements=finallyBlock;\n  tryStatement.catchArguments=null;\n  tryStatement.catchBlocks=null;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    ((AbstractMethodDeclaration)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof Block) {\n    ((Block)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    ((SwitchStatement)blockNode).statements=newStatements;\n  }\n  ancestor.rebuild();\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 86,
        "startColumnNumber" : 3,
        "endLineNumber" : 86,
        "endColumnNumber" : 66
      },
      "nodeContext" : "statements=((AbstractMethodDeclaration)blockNode).statements;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 7
    },
    "tokenLength" : 2,
    "type" : "lombok.eclipse.handlers.AbstractMethodDeclaration"
  }, {
    "nodeContext" : "((AbstractMethodDeclaration)blockNode)",
    "nodeType" : "ParenthesizedExpression",
    "nodePosition" : {
      "charLength" : 38,
      "startLineNumber" : 218,
      "startColumnNumber" : 3,
      "endLineNumber" : 218,
      "endColumnNumber" : 41
    },
    "astNodeNumber" : 5,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,leftHandSide]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 218,
        "startColumnNumber" : 3,
        "endLineNumber" : 218,
        "endColumnNumber" : 52
      },
      "nodeContext" : "((AbstractMethodDeclaration)blockNode).statements",
      "nodeType" : "FieldAccess",
      "astNodeNumber" : 7,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 65,
        "startLineNumber" : 218,
        "startColumnNumber" : 3,
        "endLineNumber" : 218,
        "endColumnNumber" : 68
      },
      "nodeContext" : "((AbstractMethodDeclaration)blockNode).statements=newStatements",
      "nodeType" : "Assignment",
      "astNodeNumber" : 9,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 66,
        "startLineNumber" : 218,
        "startColumnNumber" : 3,
        "endLineNumber" : 218,
        "endColumnNumber" : 69
      },
      "nodeContext" : "((AbstractMethodDeclaration)blockNode).statements=newStatements;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 75,
        "startLineNumber" : 217,
        "startColumnNumber" : 54,
        "endLineNumber" : 219,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  ((AbstractMethodDeclaration)blockNode).statements=newStatements;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 11,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 333,
        "startLineNumber" : 217,
        "startColumnNumber" : 2,
        "endLineNumber" : 223,
        "endColumnNumber" : 3
      },
      "nodeContext" : "if (blockNode instanceof AbstractMethodDeclaration) {\n  ((AbstractMethodDeclaration)blockNode).statements=newStatements;\n}\n else if (blockNode instanceof Block) {\n  ((Block)blockNode).statements=newStatements;\n}\n else if (blockNode instanceof SwitchStatement) {\n  ((SwitchStatement)blockNode).statements=newStatements;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 48,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6172,
        "startLineNumber" : 60,
        "startColumnNumber" : 102,
        "endLineNumber" : 226,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  String cleanupName=annotation.getInstance().value();\n  if (cleanupName.length() == 0) {\n    annotationNode.addError(\"cleanupName cannot be the empty string.\");\n    return;\n  }\n  if (annotationNode.up().getKind() != Kind.LOCAL) {\n    annotationNode.addError(\"@Cleanup is legal only on local variable declarations.\");\n    return;\n  }\n  LocalDeclaration decl=(LocalDeclaration)annotationNode.up().get();\n  if (decl.initialization == null) {\n    annotationNode.addError(\"@Cleanup variable declarations need to be initialized.\");\n    return;\n  }\n  EclipseNode ancestor=annotationNode.up().directUp();\n  ASTNode blockNode=ancestor.get();\n  final boolean isSwitch;\n  final Statement[] statements;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    isSwitch=false;\n    statements=((AbstractMethodDeclaration)blockNode).statements;\n  }\n else   if (blockNode instanceof Block) {\n    isSwitch=false;\n    statements=((Block)blockNode).statements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    isSwitch=true;\n    statements=((SwitchStatement)blockNode).statements;\n  }\n else {\n    annotationNode.addError(\"@Cleanup is legal only on a local variable declaration inside a block.\");\n    return;\n  }\n  if (statements == null) {\n    annotationNode.addError(\"LOMBOK BUG: Parent block does not contain any statements.\");\n    return;\n  }\n  int start=0;\n  for (; start < statements.length; start++) {\n    if (statements[start] == decl)     break;\n  }\n  if (start == statements.length) {\n    annotationNode.addError(\"LOMBOK BUG: Can't find this local variable declaration inside its parent.\");\n    return;\n  }\n  start++;\n  int end;\n  if (isSwitch) {\n    end=start + 1;\n    for (; end < statements.length; end++) {\n      if (statements[end] instanceof CaseStatement) {\n        break;\n      }\n    }\n  }\n else   end=statements.length;\n  Statement[] tryBlock=new Statement[end - start];\n  System.arraycopy(statements,start,tryBlock,0,end - start);\n  int newStatementsLength=statements.length - (end - start);\n  newStatementsLength+=1;\n  Statement[] newStatements=new Statement[newStatementsLength];\n  System.arraycopy(statements,0,newStatements,0,start);\n  System.arraycopy(statements,end,newStatements,start + 1,statements.length - end);\n  doAssignmentCheck(annotationNode,tryBlock,decl.name);\n  TryStatement tryStatement=new TryStatement();\n  setGeneratedBy(tryStatement,ast);\n  tryStatement.tryBlock=new Block(0);\n  tryStatement.tryBlock.statements=tryBlock;\n  setGeneratedBy(tryStatement.tryBlock,ast);\n  int ss=decl.declarationSourceEnd + 1;\n  int se=ss;\n  if (tryBlock.length > 0) {\n    se=tryBlock[tryBlock.length - 1].sourceEnd + 1;\n    tryStatement.sourceStart=ss;\n    tryStatement.sourceEnd=se;\n    tryStatement.tryBlock.sourceStart=ss;\n    tryStatement.tryBlock.sourceEnd=se;\n  }\n  newStatements[start]=tryStatement;\n  Statement[] finallyBlock=new Statement[1];\n  MessageSend unsafeClose=new MessageSend();\n  setGeneratedBy(unsafeClose,ast);\n  unsafeClose.sourceStart=ast.sourceStart;\n  unsafeClose.sourceEnd=ast.sourceEnd;\n  SingleNameReference receiver=new SingleNameReference(decl.name,0);\n  setGeneratedBy(receiver,ast);\n  unsafeClose.receiver=receiver;\n  long nameSourcePosition=(long)ast.sourceStart << 32 | ast.sourceEnd;\n  if (ast.memberValuePairs() != null)   for (  MemberValuePair pair : ast.memberValuePairs()) {\n    if (pair.name != null && new String(pair.name).equals(\"value\")) {\n      nameSourcePosition=(long)pair.value.sourceStart << 32 | pair.value.sourceEnd;\n      break;\n    }\n  }\n  unsafeClose.nameSourcePosition=nameSourcePosition;\n  unsafeClose.selector=cleanupName.toCharArray();\n  int pS=ast.sourceStart, pE=ast.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  SingleNameReference varName=new SingleNameReference(decl.name,p);\n  setGeneratedBy(varName,ast);\n  NullLiteral nullLiteral=new NullLiteral(pS,pE);\n  setGeneratedBy(nullLiteral,ast);\n  MessageSend preventNullAnalysis=preventNullAnalysis(ast,varName);\n  EqualExpression equalExpression=new EqualExpression(preventNullAnalysis,nullLiteral,OperatorIds.NOT_EQUAL);\n  equalExpression.sourceStart=pS;\n  equalExpression.sourceEnd=pE;\n  setGeneratedBy(equalExpression,ast);\n  Block closeBlock=new Block(0);\n  closeBlock.statements=new Statement[1];\n  closeBlock.statements[0]=unsafeClose;\n  setGeneratedBy(closeBlock,ast);\n  IfStatement ifStatement=new IfStatement(equalExpression,closeBlock,0,0);\n  setGeneratedBy(ifStatement,ast);\n  finallyBlock[0]=ifStatement;\n  tryStatement.finallyBlock=new Block(0);\n  if (!isSwitch) {\n    tryStatement.finallyBlock.sourceStart=blockNode.sourceEnd;\n    tryStatement.finallyBlock.sourceEnd=blockNode.sourceEnd;\n  }\n  setGeneratedBy(tryStatement.finallyBlock,ast);\n  tryStatement.finallyBlock.statements=finallyBlock;\n  tryStatement.catchArguments=null;\n  tryStatement.catchBlocks=null;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    ((AbstractMethodDeclaration)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof Block) {\n    ((Block)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    ((SwitchStatement)blockNode).statements=newStatements;\n  }\n  ancestor.rebuild();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 850,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6273,
        "startLineNumber" : 60,
        "startColumnNumber" : 1,
        "endLineNumber" : 226,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void handle(AnnotationValues<Cleanup> annotation,Annotation ast,EclipseNode annotationNode){\n  String cleanupName=annotation.getInstance().value();\n  if (cleanupName.length() == 0) {\n    annotationNode.addError(\"cleanupName cannot be the empty string.\");\n    return;\n  }\n  if (annotationNode.up().getKind() != Kind.LOCAL) {\n    annotationNode.addError(\"@Cleanup is legal only on local variable declarations.\");\n    return;\n  }\n  LocalDeclaration decl=(LocalDeclaration)annotationNode.up().get();\n  if (decl.initialization == null) {\n    annotationNode.addError(\"@Cleanup variable declarations need to be initialized.\");\n    return;\n  }\n  EclipseNode ancestor=annotationNode.up().directUp();\n  ASTNode blockNode=ancestor.get();\n  final boolean isSwitch;\n  final Statement[] statements;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    isSwitch=false;\n    statements=((AbstractMethodDeclaration)blockNode).statements;\n  }\n else   if (blockNode instanceof Block) {\n    isSwitch=false;\n    statements=((Block)blockNode).statements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    isSwitch=true;\n    statements=((SwitchStatement)blockNode).statements;\n  }\n else {\n    annotationNode.addError(\"@Cleanup is legal only on a local variable declaration inside a block.\");\n    return;\n  }\n  if (statements == null) {\n    annotationNode.addError(\"LOMBOK BUG: Parent block does not contain any statements.\");\n    return;\n  }\n  int start=0;\n  for (; start < statements.length; start++) {\n    if (statements[start] == decl)     break;\n  }\n  if (start == statements.length) {\n    annotationNode.addError(\"LOMBOK BUG: Can't find this local variable declaration inside its parent.\");\n    return;\n  }\n  start++;\n  int end;\n  if (isSwitch) {\n    end=start + 1;\n    for (; end < statements.length; end++) {\n      if (statements[end] instanceof CaseStatement) {\n        break;\n      }\n    }\n  }\n else   end=statements.length;\n  Statement[] tryBlock=new Statement[end - start];\n  System.arraycopy(statements,start,tryBlock,0,end - start);\n  int newStatementsLength=statements.length - (end - start);\n  newStatementsLength+=1;\n  Statement[] newStatements=new Statement[newStatementsLength];\n  System.arraycopy(statements,0,newStatements,0,start);\n  System.arraycopy(statements,end,newStatements,start + 1,statements.length - end);\n  doAssignmentCheck(annotationNode,tryBlock,decl.name);\n  TryStatement tryStatement=new TryStatement();\n  setGeneratedBy(tryStatement,ast);\n  tryStatement.tryBlock=new Block(0);\n  tryStatement.tryBlock.statements=tryBlock;\n  setGeneratedBy(tryStatement.tryBlock,ast);\n  int ss=decl.declarationSourceEnd + 1;\n  int se=ss;\n  if (tryBlock.length > 0) {\n    se=tryBlock[tryBlock.length - 1].sourceEnd + 1;\n    tryStatement.sourceStart=ss;\n    tryStatement.sourceEnd=se;\n    tryStatement.tryBlock.sourceStart=ss;\n    tryStatement.tryBlock.sourceEnd=se;\n  }\n  newStatements[start]=tryStatement;\n  Statement[] finallyBlock=new Statement[1];\n  MessageSend unsafeClose=new MessageSend();\n  setGeneratedBy(unsafeClose,ast);\n  unsafeClose.sourceStart=ast.sourceStart;\n  unsafeClose.sourceEnd=ast.sourceEnd;\n  SingleNameReference receiver=new SingleNameReference(decl.name,0);\n  setGeneratedBy(receiver,ast);\n  unsafeClose.receiver=receiver;\n  long nameSourcePosition=(long)ast.sourceStart << 32 | ast.sourceEnd;\n  if (ast.memberValuePairs() != null)   for (  MemberValuePair pair : ast.memberValuePairs()) {\n    if (pair.name != null && new String(pair.name).equals(\"value\")) {\n      nameSourcePosition=(long)pair.value.sourceStart << 32 | pair.value.sourceEnd;\n      break;\n    }\n  }\n  unsafeClose.nameSourcePosition=nameSourcePosition;\n  unsafeClose.selector=cleanupName.toCharArray();\n  int pS=ast.sourceStart, pE=ast.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  SingleNameReference varName=new SingleNameReference(decl.name,p);\n  setGeneratedBy(varName,ast);\n  NullLiteral nullLiteral=new NullLiteral(pS,pE);\n  setGeneratedBy(nullLiteral,ast);\n  MessageSend preventNullAnalysis=preventNullAnalysis(ast,varName);\n  EqualExpression equalExpression=new EqualExpression(preventNullAnalysis,nullLiteral,OperatorIds.NOT_EQUAL);\n  equalExpression.sourceStart=pS;\n  equalExpression.sourceEnd=pE;\n  setGeneratedBy(equalExpression,ast);\n  Block closeBlock=new Block(0);\n  closeBlock.statements=new Statement[1];\n  closeBlock.statements[0]=unsafeClose;\n  setGeneratedBy(closeBlock,ast);\n  IfStatement ifStatement=new IfStatement(equalExpression,closeBlock,0,0);\n  setGeneratedBy(ifStatement,ast);\n  finallyBlock[0]=ifStatement;\n  tryStatement.finallyBlock=new Block(0);\n  if (!isSwitch) {\n    tryStatement.finallyBlock.sourceStart=blockNode.sourceEnd;\n    tryStatement.finallyBlock.sourceEnd=blockNode.sourceEnd;\n  }\n  setGeneratedBy(tryStatement.finallyBlock,ast);\n  tryStatement.finallyBlock.statements=finallyBlock;\n  tryStatement.catchArguments=null;\n  tryStatement.catchBlocks=null;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    ((AbstractMethodDeclaration)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof Block) {\n    ((Block)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    ((SwitchStatement)blockNode).statements=newStatements;\n  }\n  ancestor.rebuild();\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 66,
        "startLineNumber" : 218,
        "startColumnNumber" : 3,
        "endLineNumber" : 218,
        "endColumnNumber" : 69
      },
      "nodeContext" : "((AbstractMethodDeclaration)blockNode).statements=newStatements;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 7
    },
    "tokenLength" : 2,
    "type" : "lombok.eclipse.handlers.AbstractMethodDeclaration"
  } ],
  "positionList" : [ {
    "charLength" : 38,
    "startLineNumber" : 86,
    "startColumnNumber" : 16,
    "endLineNumber" : 86,
    "endColumnNumber" : 54
  }, {
    "charLength" : 38,
    "startLineNumber" : 218,
    "startColumnNumber" : 3,
    "endLineNumber" : 218,
    "endColumnNumber" : 41
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 5
  } ]
}