{
  "id" : 2,
  "expression" : "TypeExtractor.getForClass(CommonRangeBoundaries.class)",
  "projectName" : "apache@flink",
  "commitID" : "f8cb19e70ca7da6423dfb01b97e05c4d520c9fde",
  "filePath" : "/flink-optimizer/src/main/java/org/apache/flink/optimizer/traversals/RangePartitionRewriter.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "TypeExtractor.getForClass(CommonRangeBoundaries.class)",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 54,
      "startLineNumber" : 185,
      "startColumnNumber" : 16,
      "endLineNumber" : 185,
      "endColumnNumber" : 70
    },
    "astNodeNumber" : 6,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 90,
        "startLineNumber" : 184,
        "startColumnNumber" : 53,
        "endLineNumber" : 185,
        "endColumnNumber" : 70
      },
      "nodeContext" : "rbTypeInformation=TypeExtractor.getForClass(CommonRangeBoundaries.class)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 136,
        "startLineNumber" : 184,
        "startColumnNumber" : 8,
        "endLineNumber" : 185,
        "endColumnNumber" : 71
      },
      "nodeContext" : "final TypeInformation<CommonRangeBoundaries> rbTypeInformation=TypeExtractor.getForClass(CommonRangeBoundaries.class);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8462,
        "startLineNumber" : 126,
        "startColumnNumber" : 72,
        "endLineNumber" : 265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  final List<Channel> sourceNewOutputChannels=new ArrayList<>();\n  final PlanNode sourceNode=channel.getSource();\n  final PlanNode targetNode=channel.getTarget();\n  final int sourceParallelism=sourceNode.getParallelism();\n  final int targetParallelism=targetNode.getParallelism();\n  final Costs defaultZeroCosts=new Costs(0,0,0);\n  final TypeComparatorFactory<?> comparator=Utils.getShipComparator(channel,this.plan.getOriginalPlan().getExecutionConfig());\n  final int sampleSize=SAMPLES_PER_PARTITION * targetParallelism;\n  final SampleInPartition sampleInPartition=new SampleInPartition(false,sampleSize,SEED);\n  final TypeInformation<?> sourceOutputType=sourceNode.getOptimizerNode().getOperator().getOperatorInfo().getOutputType();\n  final TypeInformation<IntermediateSampleData> isdTypeInformation=TypeExtractor.getForClass(IntermediateSampleData.class);\n  final UnaryOperatorInformation sipOperatorInformation=new UnaryOperatorInformation(sourceOutputType,isdTypeInformation);\n  final MapPartitionOperatorBase sipOperatorBase=new MapPartitionOperatorBase(sampleInPartition,sipOperatorInformation,SIP_NAME);\n  final MapPartitionNode sipNode=new MapPartitionNode(sipOperatorBase);\n  final Channel sipChannel=new Channel(sourceNode,TempMode.NONE);\n  sipChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);\n  final SingleInputPlanNode sipPlanNode=new SingleInputPlanNode(sipNode,SIP_NAME,sipChannel,DriverStrategy.MAP_PARTITION);\n  sipNode.setParallelism(sourceParallelism);\n  sipPlanNode.setParallelism(sourceParallelism);\n  sipPlanNode.initProperties(new GlobalProperties(),new LocalProperties());\n  sipPlanNode.setCosts(defaultZeroCosts);\n  sipChannel.setTarget(sipPlanNode);\n  this.plan.getAllNodes().add(sipPlanNode);\n  sourceNewOutputChannels.add(sipChannel);\n  final SampleInCoordinator sampleInCoordinator=new SampleInCoordinator(false,sampleSize,SEED);\n  final UnaryOperatorInformation sicOperatorInformation=new UnaryOperatorInformation(isdTypeInformation,sourceOutputType);\n  final GroupReduceOperatorBase sicOperatorBase=new GroupReduceOperatorBase(sampleInCoordinator,sicOperatorInformation,SIC_NAME);\n  final GroupReduceNode sicNode=new GroupReduceNode(sicOperatorBase);\n  final Channel sicChannel=new Channel(sipPlanNode,TempMode.NONE);\n  sicChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);\n  final SingleInputPlanNode sicPlanNode=new SingleInputPlanNode(sicNode,SIC_NAME,sicChannel,DriverStrategy.ALL_GROUP_REDUCE);\n  sicNode.setParallelism(1);\n  sicPlanNode.setParallelism(1);\n  sicPlanNode.initProperties(new GlobalProperties(),new LocalProperties());\n  sicPlanNode.setCosts(defaultZeroCosts);\n  sicChannel.setTarget(sicPlanNode);\n  sipPlanNode.addOutgoingChannel(sicChannel);\n  this.plan.getAllNodes().add(sicPlanNode);\n  final RangeBoundaryBuilder rangeBoundaryBuilder=new RangeBoundaryBuilder(comparator,targetParallelism);\n  final TypeInformation<CommonRangeBoundaries> rbTypeInformation=TypeExtractor.getForClass(CommonRangeBoundaries.class);\n  final UnaryOperatorInformation rbOperatorInformation=new UnaryOperatorInformation(sourceOutputType,rbTypeInformation);\n  final MapPartitionOperatorBase rbOperatorBase=new MapPartitionOperatorBase(rangeBoundaryBuilder,rbOperatorInformation,RB_NAME);\n  final MapPartitionNode rbNode=new MapPartitionNode(rbOperatorBase);\n  final Channel rbChannel=new Channel(sicPlanNode,TempMode.NONE);\n  rbChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);\n  final SingleInputPlanNode rbPlanNode=new SingleInputPlanNode(rbNode,RB_NAME,rbChannel,DriverStrategy.MAP_PARTITION);\n  rbNode.setParallelism(1);\n  rbPlanNode.setParallelism(1);\n  rbPlanNode.initProperties(new GlobalProperties(),new LocalProperties());\n  rbPlanNode.setCosts(defaultZeroCosts);\n  rbChannel.setTarget(rbPlanNode);\n  sicPlanNode.addOutgoingChannel(rbChannel);\n  this.plan.getAllNodes().add(rbPlanNode);\n  final AssignRangeIndex assignRangeIndex=new AssignRangeIndex(comparator);\n  final TypeInformation<Tuple2> ariOutputTypeInformation=new TupleTypeInfo<>(BasicTypeInfo.INT_TYPE_INFO,sourceOutputType);\n  final UnaryOperatorInformation ariOperatorInformation=new UnaryOperatorInformation(sourceOutputType,ariOutputTypeInformation);\n  final MapPartitionOperatorBase ariOperatorBase=new MapPartitionOperatorBase(assignRangeIndex,ariOperatorInformation,ARI_NAME);\n  final MapPartitionNode ariNode=new MapPartitionNode(ariOperatorBase);\n  final Channel ariChannel=new Channel(sourceNode,TempMode.NONE);\n  ariChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.BATCH);\n  final SingleInputPlanNode ariPlanNode=new SingleInputPlanNode(ariNode,ARI_NAME,ariChannel,DriverStrategy.MAP_PARTITION);\n  ariNode.setParallelism(sourceParallelism);\n  ariPlanNode.setParallelism(sourceParallelism);\n  ariPlanNode.initProperties(new GlobalProperties(),new LocalProperties());\n  ariPlanNode.setCosts(defaultZeroCosts);\n  ariChannel.setTarget(ariPlanNode);\n  this.plan.getAllNodes().add(ariPlanNode);\n  sourceNewOutputChannels.add(ariChannel);\n  final NamedChannel broadcastChannel=new NamedChannel(\"RangeBoundaries\",rbPlanNode);\n  broadcastChannel.setShipStrategy(ShipStrategyType.BROADCAST,DataExchangeMode.PIPELINED);\n  broadcastChannel.setTarget(ariPlanNode);\n  List<NamedChannel> broadcastChannels=new ArrayList<>(1);\n  broadcastChannels.add(broadcastChannel);\n  ariPlanNode.setBroadcastInputs(broadcastChannels);\n  final Channel partChannel=new Channel(ariPlanNode,TempMode.NONE);\n  final FieldList keys=new FieldList(0);\n  partChannel.setShipStrategy(ShipStrategyType.PARTITION_CUSTOM,keys,idPartitioner,DataExchangeMode.PIPELINED);\n  ariPlanNode.addOutgoingChannel(partChannel);\n  final RemoveRangeIndex partitionIDRemoveWrapper=new RemoveRangeIndex();\n  final UnaryOperatorInformation prOperatorInformation=new UnaryOperatorInformation(ariOutputTypeInformation,sourceOutputType);\n  final MapOperatorBase prOperatorBase=new MapOperatorBase(partitionIDRemoveWrapper,prOperatorInformation,PR_NAME);\n  final MapNode prRemoverNode=new MapNode(prOperatorBase);\n  final SingleInputPlanNode prPlanNode=new SingleInputPlanNode(prRemoverNode,PR_NAME,partChannel,DriverStrategy.MAP);\n  partChannel.setTarget(prPlanNode);\n  prRemoverNode.setParallelism(targetParallelism);\n  prPlanNode.setParallelism(targetParallelism);\n  GlobalProperties globalProperties=new GlobalProperties();\n  globalProperties.setRangePartitioned(new Ordering(0,null,Order.ASCENDING));\n  prPlanNode.initProperties(globalProperties,new LocalProperties());\n  prPlanNode.setCosts(defaultZeroCosts);\n  this.plan.getAllNodes().add(prPlanNode);\n  channel.setSource(prPlanNode);\n  channel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);\n  prPlanNode.addOutgoingChannel(channel);\n  return sourceNewOutputChannels;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 881,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8530,
        "startLineNumber" : 126,
        "startColumnNumber" : 4,
        "endLineNumber" : 265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private List<Channel> rewriteRangePartitionChannel(Channel channel){\n  final List<Channel> sourceNewOutputChannels=new ArrayList<>();\n  final PlanNode sourceNode=channel.getSource();\n  final PlanNode targetNode=channel.getTarget();\n  final int sourceParallelism=sourceNode.getParallelism();\n  final int targetParallelism=targetNode.getParallelism();\n  final Costs defaultZeroCosts=new Costs(0,0,0);\n  final TypeComparatorFactory<?> comparator=Utils.getShipComparator(channel,this.plan.getOriginalPlan().getExecutionConfig());\n  final int sampleSize=SAMPLES_PER_PARTITION * targetParallelism;\n  final SampleInPartition sampleInPartition=new SampleInPartition(false,sampleSize,SEED);\n  final TypeInformation<?> sourceOutputType=sourceNode.getOptimizerNode().getOperator().getOperatorInfo().getOutputType();\n  final TypeInformation<IntermediateSampleData> isdTypeInformation=TypeExtractor.getForClass(IntermediateSampleData.class);\n  final UnaryOperatorInformation sipOperatorInformation=new UnaryOperatorInformation(sourceOutputType,isdTypeInformation);\n  final MapPartitionOperatorBase sipOperatorBase=new MapPartitionOperatorBase(sampleInPartition,sipOperatorInformation,SIP_NAME);\n  final MapPartitionNode sipNode=new MapPartitionNode(sipOperatorBase);\n  final Channel sipChannel=new Channel(sourceNode,TempMode.NONE);\n  sipChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);\n  final SingleInputPlanNode sipPlanNode=new SingleInputPlanNode(sipNode,SIP_NAME,sipChannel,DriverStrategy.MAP_PARTITION);\n  sipNode.setParallelism(sourceParallelism);\n  sipPlanNode.setParallelism(sourceParallelism);\n  sipPlanNode.initProperties(new GlobalProperties(),new LocalProperties());\n  sipPlanNode.setCosts(defaultZeroCosts);\n  sipChannel.setTarget(sipPlanNode);\n  this.plan.getAllNodes().add(sipPlanNode);\n  sourceNewOutputChannels.add(sipChannel);\n  final SampleInCoordinator sampleInCoordinator=new SampleInCoordinator(false,sampleSize,SEED);\n  final UnaryOperatorInformation sicOperatorInformation=new UnaryOperatorInformation(isdTypeInformation,sourceOutputType);\n  final GroupReduceOperatorBase sicOperatorBase=new GroupReduceOperatorBase(sampleInCoordinator,sicOperatorInformation,SIC_NAME);\n  final GroupReduceNode sicNode=new GroupReduceNode(sicOperatorBase);\n  final Channel sicChannel=new Channel(sipPlanNode,TempMode.NONE);\n  sicChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);\n  final SingleInputPlanNode sicPlanNode=new SingleInputPlanNode(sicNode,SIC_NAME,sicChannel,DriverStrategy.ALL_GROUP_REDUCE);\n  sicNode.setParallelism(1);\n  sicPlanNode.setParallelism(1);\n  sicPlanNode.initProperties(new GlobalProperties(),new LocalProperties());\n  sicPlanNode.setCosts(defaultZeroCosts);\n  sicChannel.setTarget(sicPlanNode);\n  sipPlanNode.addOutgoingChannel(sicChannel);\n  this.plan.getAllNodes().add(sicPlanNode);\n  final RangeBoundaryBuilder rangeBoundaryBuilder=new RangeBoundaryBuilder(comparator,targetParallelism);\n  final TypeInformation<CommonRangeBoundaries> rbTypeInformation=TypeExtractor.getForClass(CommonRangeBoundaries.class);\n  final UnaryOperatorInformation rbOperatorInformation=new UnaryOperatorInformation(sourceOutputType,rbTypeInformation);\n  final MapPartitionOperatorBase rbOperatorBase=new MapPartitionOperatorBase(rangeBoundaryBuilder,rbOperatorInformation,RB_NAME);\n  final MapPartitionNode rbNode=new MapPartitionNode(rbOperatorBase);\n  final Channel rbChannel=new Channel(sicPlanNode,TempMode.NONE);\n  rbChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);\n  final SingleInputPlanNode rbPlanNode=new SingleInputPlanNode(rbNode,RB_NAME,rbChannel,DriverStrategy.MAP_PARTITION);\n  rbNode.setParallelism(1);\n  rbPlanNode.setParallelism(1);\n  rbPlanNode.initProperties(new GlobalProperties(),new LocalProperties());\n  rbPlanNode.setCosts(defaultZeroCosts);\n  rbChannel.setTarget(rbPlanNode);\n  sicPlanNode.addOutgoingChannel(rbChannel);\n  this.plan.getAllNodes().add(rbPlanNode);\n  final AssignRangeIndex assignRangeIndex=new AssignRangeIndex(comparator);\n  final TypeInformation<Tuple2> ariOutputTypeInformation=new TupleTypeInfo<>(BasicTypeInfo.INT_TYPE_INFO,sourceOutputType);\n  final UnaryOperatorInformation ariOperatorInformation=new UnaryOperatorInformation(sourceOutputType,ariOutputTypeInformation);\n  final MapPartitionOperatorBase ariOperatorBase=new MapPartitionOperatorBase(assignRangeIndex,ariOperatorInformation,ARI_NAME);\n  final MapPartitionNode ariNode=new MapPartitionNode(ariOperatorBase);\n  final Channel ariChannel=new Channel(sourceNode,TempMode.NONE);\n  ariChannel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.BATCH);\n  final SingleInputPlanNode ariPlanNode=new SingleInputPlanNode(ariNode,ARI_NAME,ariChannel,DriverStrategy.MAP_PARTITION);\n  ariNode.setParallelism(sourceParallelism);\n  ariPlanNode.setParallelism(sourceParallelism);\n  ariPlanNode.initProperties(new GlobalProperties(),new LocalProperties());\n  ariPlanNode.setCosts(defaultZeroCosts);\n  ariChannel.setTarget(ariPlanNode);\n  this.plan.getAllNodes().add(ariPlanNode);\n  sourceNewOutputChannels.add(ariChannel);\n  final NamedChannel broadcastChannel=new NamedChannel(\"RangeBoundaries\",rbPlanNode);\n  broadcastChannel.setShipStrategy(ShipStrategyType.BROADCAST,DataExchangeMode.PIPELINED);\n  broadcastChannel.setTarget(ariPlanNode);\n  List<NamedChannel> broadcastChannels=new ArrayList<>(1);\n  broadcastChannels.add(broadcastChannel);\n  ariPlanNode.setBroadcastInputs(broadcastChannels);\n  final Channel partChannel=new Channel(ariPlanNode,TempMode.NONE);\n  final FieldList keys=new FieldList(0);\n  partChannel.setShipStrategy(ShipStrategyType.PARTITION_CUSTOM,keys,idPartitioner,DataExchangeMode.PIPELINED);\n  ariPlanNode.addOutgoingChannel(partChannel);\n  final RemoveRangeIndex partitionIDRemoveWrapper=new RemoveRangeIndex();\n  final UnaryOperatorInformation prOperatorInformation=new UnaryOperatorInformation(ariOutputTypeInformation,sourceOutputType);\n  final MapOperatorBase prOperatorBase=new MapOperatorBase(partitionIDRemoveWrapper,prOperatorInformation,PR_NAME);\n  final MapNode prRemoverNode=new MapNode(prOperatorBase);\n  final SingleInputPlanNode prPlanNode=new SingleInputPlanNode(prRemoverNode,PR_NAME,partChannel,DriverStrategy.MAP);\n  partChannel.setTarget(prPlanNode);\n  prRemoverNode.setParallelism(targetParallelism);\n  prPlanNode.setParallelism(targetParallelism);\n  GlobalProperties globalProperties=new GlobalProperties();\n  globalProperties.setRangePartitioned(new Ordering(0,null,Order.ASCENDING));\n  prPlanNode.initProperties(globalProperties,new LocalProperties());\n  prPlanNode.setCosts(defaultZeroCosts);\n  this.plan.getAllNodes().add(prPlanNode);\n  channel.setSource(prPlanNode);\n  channel.setShipStrategy(ShipStrategyType.FORWARD,DataExchangeMode.PIPELINED);\n  prPlanNode.addOutgoingChannel(channel);\n  return sourceNewOutputChannels;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 893,
      "astHeight" : 9
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 90,
        "startLineNumber" : 184,
        "startColumnNumber" : 53,
        "endLineNumber" : 185,
        "endColumnNumber" : 70
      },
      "nodeContext" : "rbTypeInformation=TypeExtractor.getForClass(CommonRangeBoundaries.class)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 3,
    "type" : "org.apache.flink.api.common.typeinfo.TypeInformation<org.apache.flink.api.common.distributions.CommonRangeBoundaries>"
  } ],
  "positionList" : [ {
    "charLength" : 54,
    "startLineNumber" : 185,
    "startColumnNumber" : 16,
    "endLineNumber" : 185,
    "endColumnNumber" : 70
  } ],
  "layoutRelationDataList" : [ ]
}