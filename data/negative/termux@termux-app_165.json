{
  "id" : 165,
  "expression" : "1",
  "projectName" : "termux@termux-app",
  "commitID" : "c6d6a6363730a1bb49aef4c94ebabc9e4f01606b",
  "filePath" : "app/src/main/java/com/termux/terminal/TerminalEmulator.java",
  "occurrences" : 37,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 480,
      "startColumnNumber" : 47,
      "endLineNumber" : 480,
      "endColumnNumber" : 48
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 480,
        "startColumnNumber" : 34,
        "endLineNumber" : 480,
        "endColumnNumber" : 48
      },
      "nodeContext" : "mCursorRow - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 480,
        "startColumnNumber" : 20,
        "endLineNumber" : 480,
        "endColumnNumber" : 48
      },
      "nodeContext" : "previousRow=mCursorRow - 1",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 480,
        "startColumnNumber" : 16,
        "endLineNumber" : 480,
        "endColumnNumber" : 49
      },
      "nodeContext" : "int previousRow=mCursorRow - 1;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 348,
        "startLineNumber" : 478,
        "startColumnNumber" : 43,
        "endLineNumber" : 485,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  int previousRow=mCursorRow - 1;\n  if (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n    mScreen.clearLineWrap(previousRow);\n    setCursorRowCol(previousRow,mRightMargin - 1);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 30,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 478,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (mLeftMargin == mCursorCol) {\n  int previousRow=mCursorRow - 1;\n  if (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n    mScreen.clearLineWrap(previousRow);\n    setCursorRowCol(previousRow,mRightMargin - 1);\n  }\n}\n else {\n  setCursorCol(mCursorCol - 1);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 480,
        "startColumnNumber" : 16,
        "endLineNumber" : 480,
        "endColumnNumber" : 49
      },
      "nodeContext" : "int previousRow=mCursorRow - 1;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 483,
      "startColumnNumber" : 64,
      "endLineNumber" : 483,
      "endColumnNumber" : 65
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 16,
        "startLineNumber" : 483,
        "startColumnNumber" : 49,
        "endLineNumber" : 483,
        "endColumnNumber" : 65
      },
      "nodeContext" : "mRightMargin - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 483,
        "startColumnNumber" : 20,
        "endLineNumber" : 483,
        "endColumnNumber" : 66
      },
      "nodeContext" : "setCursorRowCol(previousRow,mRightMargin - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 483,
        "startColumnNumber" : 20,
        "endLineNumber" : 483,
        "endColumnNumber" : 67
      },
      "nodeContext" : "setCursorRowCol(previousRow,mRightMargin - 1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 143,
        "startLineNumber" : 481,
        "startColumnNumber" : 74,
        "endLineNumber" : 484,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 201,
        "startLineNumber" : 481,
        "startColumnNumber" : 16,
        "endLineNumber" : 484,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 22,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 348,
        "startLineNumber" : 478,
        "startColumnNumber" : 43,
        "endLineNumber" : 485,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  int previousRow=mCursorRow - 1;\n  if (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n    mScreen.clearLineWrap(previousRow);\n    setCursorRowCol(previousRow,mRightMargin - 1);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 30,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 478,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (mLeftMargin == mCursorCol) {\n  int previousRow=mCursorRow - 1;\n  if (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n    mScreen.clearLineWrap(previousRow);\n    setCursorRowCol(previousRow,mRightMargin - 1);\n  }\n}\n else {\n  setCursorCol(mCursorCol - 1);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 483,
        "startColumnNumber" : 20,
        "endLineNumber" : 483,
        "endColumnNumber" : 67
      },
      "nodeContext" : "setCursorRowCol(previousRow,mRightMargin - 1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 486,
      "startColumnNumber" : 42,
      "endLineNumber" : 486,
      "endColumnNumber" : 43
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 486,
        "startColumnNumber" : 29,
        "endLineNumber" : 486,
        "endColumnNumber" : 43
      },
      "nodeContext" : "mCursorCol - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 486,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 44
      },
      "nodeContext" : "setCursorCol(mCursorCol - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 486,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 45
      },
      "nodeContext" : "setCursorCol(mCursorCol - 1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 61,
        "startLineNumber" : 485,
        "startColumnNumber" : 19,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  setCursorCol(mCursorCol - 1);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 7,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 446,
        "startLineNumber" : 478,
        "startColumnNumber" : 12,
        "endLineNumber" : 487,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (mLeftMargin == mCursorCol) {\n  int previousRow=mCursorRow - 1;\n  if (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n    mScreen.clearLineWrap(previousRow);\n    setCursorRowCol(previousRow,mRightMargin - 1);\n  }\n}\n else {\n  setCursorCol(mCursorCol - 1);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 486,
        "startColumnNumber" : 16,
        "endLineNumber" : 486,
        "endColumnNumber" : 45
      },
      "nodeContext" : "setCursorCol(mCursorCol - 1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 497,
      "startColumnNumber" : 37,
      "endLineNumber" : 497,
      "endColumnNumber" : 38
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 497,
        "startColumnNumber" : 25,
        "endLineNumber" : 497,
        "endColumnNumber" : 39
      },
      "nodeContext" : "nextTabStop(1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 27,
        "startLineNumber" : 497,
        "startColumnNumber" : 12,
        "endLineNumber" : 497,
        "endColumnNumber" : 39
      },
      "nodeContext" : "mCursorCol=nextTabStop(1)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 497,
        "startColumnNumber" : 12,
        "endLineNumber" : 497,
        "endColumnNumber" : 40
      },
      "nodeContext" : "mCursorCol=nextTabStop(1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 497,
        "startColumnNumber" : 12,
        "endLineNumber" : 497,
        "endColumnNumber" : 40
      },
      "nodeContext" : "mCursorCol=nextTabStop(1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 583,
      "startColumnNumber" : 40,
      "endLineNumber" : 583,
      "endColumnNumber" : 41
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 583,
        "startColumnNumber" : 30,
        "endLineNumber" : 583,
        "endColumnNumber" : 48
      },
      "nodeContext" : "getArg(0,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 583,
        "startColumnNumber" : 30,
        "endLineNumber" : 583,
        "endColumnNumber" : 52
      },
      "nodeContext" : "getArg(0,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 583,
        "startColumnNumber" : 30,
        "endLineNumber" : 583,
        "endColumnNumber" : 73
      },
      "nodeContext" : "getArg(0,1,true) - 1 + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 583,
        "startColumnNumber" : 21,
        "endLineNumber" : 583,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 583,
        "startColumnNumber" : 9,
        "endLineNumber" : 583,
        "endColumnNumber" : 81
      },
      "nodeContext" : "topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 583,
        "startColumnNumber" : 5,
        "endLineNumber" : 583,
        "endColumnNumber" : 82
      },
      "nodeContext" : "int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 583,
        "startColumnNumber" : 5,
        "endLineNumber" : 583,
        "endColumnNumber" : 82
      },
      "nodeContext" : "int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 583,
      "startColumnNumber" : 51,
      "endLineNumber" : 583,
      "endColumnNumber" : 52
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 583,
        "startColumnNumber" : 30,
        "endLineNumber" : 583,
        "endColumnNumber" : 52
      },
      "nodeContext" : "getArg(0,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 583,
        "startColumnNumber" : 30,
        "endLineNumber" : 583,
        "endColumnNumber" : 73
      },
      "nodeContext" : "getArg(0,1,true) - 1 + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 583,
        "startColumnNumber" : 21,
        "endLineNumber" : 583,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 583,
        "startColumnNumber" : 9,
        "endLineNumber" : 583,
        "endColumnNumber" : 81
      },
      "nodeContext" : "topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 583,
        "startColumnNumber" : 5,
        "endLineNumber" : 583,
        "endColumnNumber" : 82
      },
      "nodeContext" : "int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 583,
        "startColumnNumber" : 5,
        "endLineNumber" : 583,
        "endColumnNumber" : 82
      },
      "nodeContext" : "int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 584,
      "startColumnNumber" : 38,
      "endLineNumber" : 584,
      "endColumnNumber" : 39
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 49
      },
      "nodeContext" : "getArg(1,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 53
      },
      "nodeContext" : "getArg(1,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 75
      },
      "nodeContext" : "getArg(1,1,true) - 1 + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 584,
        "startColumnNumber" : 22,
        "endLineNumber" : 584,
        "endColumnNumber" : 86
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 584,
        "startColumnNumber" : 9,
        "endLineNumber" : 584,
        "endColumnNumber" : 86
      },
      "nodeContext" : "leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 584,
        "startColumnNumber" : 5,
        "endLineNumber" : 584,
        "endColumnNumber" : 87
      },
      "nodeContext" : "int leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 584,
        "startColumnNumber" : 5,
        "endLineNumber" : 584,
        "endColumnNumber" : 87
      },
      "nodeContext" : "int leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 584,
      "startColumnNumber" : 41,
      "endLineNumber" : 584,
      "endColumnNumber" : 42
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 49
      },
      "nodeContext" : "getArg(1,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 53
      },
      "nodeContext" : "getArg(1,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 75
      },
      "nodeContext" : "getArg(1,1,true) - 1 + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 584,
        "startColumnNumber" : 22,
        "endLineNumber" : 584,
        "endColumnNumber" : 86
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 584,
        "startColumnNumber" : 9,
        "endLineNumber" : 584,
        "endColumnNumber" : 86
      },
      "nodeContext" : "leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 584,
        "startColumnNumber" : 5,
        "endLineNumber" : 584,
        "endColumnNumber" : 87
      },
      "nodeContext" : "int leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 584,
        "startColumnNumber" : 5,
        "endLineNumber" : 584,
        "endColumnNumber" : 87
      },
      "nodeContext" : "int leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 584,
      "startColumnNumber" : 52,
      "endLineNumber" : 584,
      "endColumnNumber" : 53
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 53
      },
      "nodeContext" : "getArg(1,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 75
      },
      "nodeContext" : "getArg(1,1,true) - 1 + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 584,
        "startColumnNumber" : 22,
        "endLineNumber" : 584,
        "endColumnNumber" : 86
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 584,
        "startColumnNumber" : 9,
        "endLineNumber" : 584,
        "endColumnNumber" : 86
      },
      "nodeContext" : "leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 584,
        "startColumnNumber" : 5,
        "endLineNumber" : 584,
        "endColumnNumber" : 87
      },
      "nodeContext" : "int leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 584,
        "startColumnNumber" : 5,
        "endLineNumber" : 584,
        "endColumnNumber" : 87
      },
      "nodeContext" : "int leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 589,
      "startColumnNumber" : 46,
      "endLineNumber" : 589,
      "endColumnNumber" : 47
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 589,
        "startColumnNumber" : 36,
        "endLineNumber" : 589,
        "endColumnNumber" : 54
      },
      "nodeContext" : "getArg(5,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 589,
        "startColumnNumber" : 36,
        "endLineNumber" : 589,
        "endColumnNumber" : 58
      },
      "nodeContext" : "getArg(5,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 589,
        "startColumnNumber" : 36,
        "endLineNumber" : 589,
        "endColumnNumber" : 79
      },
      "nodeContext" : "getArg(5,1,true) - 1 + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 589,
        "startColumnNumber" : 27,
        "endLineNumber" : 589,
        "endColumnNumber" : 87
      },
      "nodeContext" : "Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 78,
        "startLineNumber" : 589,
        "startColumnNumber" : 9,
        "endLineNumber" : 589,
        "endColumnNumber" : 87
      },
      "nodeContext" : "destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 589,
        "startColumnNumber" : 5,
        "endLineNumber" : 589,
        "endColumnNumber" : 88
      },
      "nodeContext" : "int destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 589,
        "startColumnNumber" : 5,
        "endLineNumber" : 589,
        "endColumnNumber" : 88
      },
      "nodeContext" : "int destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 589,
      "startColumnNumber" : 57,
      "endLineNumber" : 589,
      "endColumnNumber" : 58
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 589,
        "startColumnNumber" : 36,
        "endLineNumber" : 589,
        "endColumnNumber" : 58
      },
      "nodeContext" : "getArg(5,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 589,
        "startColumnNumber" : 36,
        "endLineNumber" : 589,
        "endColumnNumber" : 79
      },
      "nodeContext" : "getArg(5,1,true) - 1 + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 589,
        "startColumnNumber" : 27,
        "endLineNumber" : 589,
        "endColumnNumber" : 87
      },
      "nodeContext" : "Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 78,
        "startLineNumber" : 589,
        "startColumnNumber" : 9,
        "endLineNumber" : 589,
        "endColumnNumber" : 87
      },
      "nodeContext" : "destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 589,
        "startColumnNumber" : 5,
        "endLineNumber" : 589,
        "endColumnNumber" : 88
      },
      "nodeContext" : "int destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 589,
        "startColumnNumber" : 5,
        "endLineNumber" : 589,
        "endColumnNumber" : 88
      },
      "nodeContext" : "int destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 590,
      "startColumnNumber" : 46,
      "endLineNumber" : 590,
      "endColumnNumber" : 47
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 590,
        "startColumnNumber" : 36,
        "endLineNumber" : 590,
        "endColumnNumber" : 54
      },
      "nodeContext" : "getArg(6,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 590,
        "startColumnNumber" : 36,
        "endLineNumber" : 590,
        "endColumnNumber" : 58
      },
      "nodeContext" : "getArg(6,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 590,
        "startColumnNumber" : 36,
        "endLineNumber" : 590,
        "endColumnNumber" : 80
      },
      "nodeContext" : "getArg(6,1,true) - 1 + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 590,
        "startColumnNumber" : 27,
        "endLineNumber" : 590,
        "endColumnNumber" : 91
      },
      "nodeContext" : "Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 590,
        "startColumnNumber" : 9,
        "endLineNumber" : 590,
        "endColumnNumber" : 91
      },
      "nodeContext" : "destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 590,
        "startColumnNumber" : 5,
        "endLineNumber" : 590,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 590,
        "startColumnNumber" : 5,
        "endLineNumber" : 590,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 590,
      "startColumnNumber" : 57,
      "endLineNumber" : 590,
      "endColumnNumber" : 58
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 590,
        "startColumnNumber" : 36,
        "endLineNumber" : 590,
        "endColumnNumber" : 58
      },
      "nodeContext" : "getArg(6,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 590,
        "startColumnNumber" : 36,
        "endLineNumber" : 590,
        "endColumnNumber" : 80
      },
      "nodeContext" : "getArg(6,1,true) - 1 + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 590,
        "startColumnNumber" : 27,
        "endLineNumber" : 590,
        "endColumnNumber" : 91
      },
      "nodeContext" : "Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 590,
        "startColumnNumber" : 9,
        "endLineNumber" : 590,
        "endColumnNumber" : 91
      },
      "nodeContext" : "destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 590,
        "startColumnNumber" : 5,
        "endLineNumber" : 590,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 590,
        "startColumnNumber" : 5,
        "endLineNumber" : 590,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 607,
      "startColumnNumber" : 54,
      "endLineNumber" : 607,
      "endColumnNumber" : 55
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 2,
        "startLineNumber" : 607,
        "startColumnNumber" : 53,
        "endLineNumber" : 607,
        "endColumnNumber" : 55
      },
      "nodeContext" : "-1",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 2,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,elseExpression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 607,
        "startColumnNumber" : 34,
        "endLineNumber" : 607,
        "endColumnNumber" : 62
      },
      "nodeContext" : "getArg(argIndex++,-1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 607,
        "startColumnNumber" : 20,
        "endLineNumber" : 607,
        "endColumnNumber" : 62
      },
      "nodeContext" : "erase ? ' ' : getArg(argIndex++,-1,true)",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 607,
        "startColumnNumber" : 9,
        "endLineNumber" : 607,
        "endColumnNumber" : 62
      },
      "nodeContext" : "fillChar=erase ? ' ' : getArg(argIndex++,-1,true)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 607,
        "startColumnNumber" : 5,
        "endLineNumber" : 607,
        "endColumnNumber" : 63
      },
      "nodeContext" : "int fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 607,
        "startColumnNumber" : 5,
        "endLineNumber" : 607,
        "endColumnNumber" : 63
      },
      "nodeContext" : "int fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 613,
      "startColumnNumber" : 44,
      "endLineNumber" : 613,
      "endColumnNumber" : 45
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 27,
        "startLineNumber" : 613,
        "startColumnNumber" : 25,
        "endLineNumber" : 613,
        "endColumnNumber" : 52
      },
      "nodeContext" : "getArg(argIndex++,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 613,
        "startColumnNumber" : 25,
        "endLineNumber" : 613,
        "endColumnNumber" : 73
      },
      "nodeContext" : "getArg(argIndex++,1,true) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 613,
        "startColumnNumber" : 16,
        "endLineNumber" : 613,
        "endColumnNumber" : 101
      },
      "nodeContext" : "Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 91,
        "startLineNumber" : 613,
        "startColumnNumber" : 10,
        "endLineNumber" : 613,
        "endColumnNumber" : 101
      },
      "nodeContext" : "top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 613,
        "startColumnNumber" : 6,
        "endLineNumber" : 613,
        "endColumnNumber" : 102
      },
      "nodeContext" : "int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 613,
        "startColumnNumber" : 6,
        "endLineNumber" : 613,
        "endColumnNumber" : 102
      },
      "nodeContext" : "int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 613,
      "startColumnNumber" : 99,
      "endLineNumber" : 613,
      "endColumnNumber" : 100
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 613,
        "startColumnNumber" : 75,
        "endLineNumber" : 613,
        "endColumnNumber" : 100
      },
      "nodeContext" : "effectiveBottomMargin + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 613,
        "startColumnNumber" : 16,
        "endLineNumber" : 613,
        "endColumnNumber" : 101
      },
      "nodeContext" : "Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 91,
        "startLineNumber" : 613,
        "startColumnNumber" : 10,
        "endLineNumber" : 613,
        "endColumnNumber" : 101
      },
      "nodeContext" : "top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 613,
        "startColumnNumber" : 6,
        "endLineNumber" : 613,
        "endColumnNumber" : 102
      },
      "nodeContext" : "int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 613,
        "startColumnNumber" : 6,
        "endLineNumber" : 613,
        "endColumnNumber" : 102
      },
      "nodeContext" : "int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 614,
      "startColumnNumber" : 45,
      "endLineNumber" : 614,
      "endColumnNumber" : 46
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 27,
        "startLineNumber" : 614,
        "startColumnNumber" : 26,
        "endLineNumber" : 614,
        "endColumnNumber" : 53
      },
      "nodeContext" : "getArg(argIndex++,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 614,
        "startColumnNumber" : 26,
        "endLineNumber" : 614,
        "endColumnNumber" : 75
      },
      "nodeContext" : "getArg(argIndex++,1,true) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 614,
        "startColumnNumber" : 17,
        "endLineNumber" : 614,
        "endColumnNumber" : 102
      },
      "nodeContext" : "Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 92,
        "startLineNumber" : 614,
        "startColumnNumber" : 10,
        "endLineNumber" : 614,
        "endColumnNumber" : 102
      },
      "nodeContext" : "left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 97,
        "startLineNumber" : 614,
        "startColumnNumber" : 6,
        "endLineNumber" : 614,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 97,
        "startLineNumber" : 614,
        "startColumnNumber" : 6,
        "endLineNumber" : 614,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 614,
      "startColumnNumber" : 100,
      "endLineNumber" : 614,
      "endColumnNumber" : 101
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 24,
        "startLineNumber" : 614,
        "startColumnNumber" : 77,
        "endLineNumber" : 614,
        "endColumnNumber" : 101
      },
      "nodeContext" : "effectiveRightMargin + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 614,
        "startColumnNumber" : 17,
        "endLineNumber" : 614,
        "endColumnNumber" : 102
      },
      "nodeContext" : "Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 92,
        "startLineNumber" : 614,
        "startColumnNumber" : 10,
        "endLineNumber" : 614,
        "endColumnNumber" : 102
      },
      "nodeContext" : "left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 97,
        "startLineNumber" : 614,
        "startColumnNumber" : 6,
        "endLineNumber" : 614,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 97,
        "startLineNumber" : 614,
        "startColumnNumber" : 6,
        "endLineNumber" : 614,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 618,
      "startColumnNumber" : 27,
      "endLineNumber" : 618,
      "endColumnNumber" : 28
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 7,
        "startLineNumber" : 618,
        "startColumnNumber" : 21,
        "endLineNumber" : 618,
        "endColumnNumber" : 28
      },
      "nodeContext" : "top - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationExpression,fragments]",
      "nodePosition" : {
        "charLength" : 13,
        "startLineNumber" : 618,
        "startColumnNumber" : 15,
        "endLineNumber" : 618,
        "endColumnNumber" : 28
      },
      "nodeContext" : "row=top - 1",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 618,
        "startColumnNumber" : 11,
        "endLineNumber" : 618,
        "endColumnNumber" : 28
      },
      "nodeContext" : "int row=top - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 332,
        "startLineNumber" : 618,
        "startColumnNumber" : 6,
        "endLineNumber" : 621,
        "endColumnNumber" : 106
      },
      "nodeContext" : "for (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 60,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 618,
        "startColumnNumber" : 11,
        "endLineNumber" : 618,
        "endColumnNumber" : 28
      },
      "nodeContext" : "int row=top - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 619,
      "startColumnNumber" : 29,
      "endLineNumber" : 619,
      "endColumnNumber" : 30
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 8,
        "startLineNumber" : 619,
        "startColumnNumber" : 22,
        "endLineNumber" : 619,
        "endColumnNumber" : 30
      },
      "nodeContext" : "left - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationExpression,fragments]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 619,
        "startColumnNumber" : 16,
        "endLineNumber" : 619,
        "endColumnNumber" : 30
      },
      "nodeContext" : "col=left - 1",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 619,
        "startColumnNumber" : 12,
        "endLineNumber" : 619,
        "endColumnNumber" : 30
      },
      "nodeContext" : "int col=left - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 280,
        "startLineNumber" : 619,
        "startColumnNumber" : 7,
        "endLineNumber" : 621,
        "endColumnNumber" : 106
      },
      "nodeContext" : "for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 47,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 332,
        "startLineNumber" : 618,
        "startColumnNumber" : 6,
        "endLineNumber" : 621,
        "endColumnNumber" : 106
      },
      "nodeContext" : "for (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 60,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 619,
        "startColumnNumber" : 12,
        "endLineNumber" : 619,
        "endColumnNumber" : 30
      },
      "nodeContext" : "int col=left - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 630,
      "startColumnNumber" : 34,
      "endLineNumber" : 630,
      "endColumnNumber" : 35
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 630,
        "startColumnNumber" : 24,
        "endLineNumber" : 630,
        "endColumnNumber" : 42
      },
      "nodeContext" : "getArg(0,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 630,
        "startColumnNumber" : 24,
        "endLineNumber" : 630,
        "endColumnNumber" : 46
      },
      "nodeContext" : "getArg(0,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 630,
        "startColumnNumber" : 15,
        "endLineNumber" : 630,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1,effectiveBottomMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 630,
        "startColumnNumber" : 15,
        "endLineNumber" : 630,
        "endColumnNumber" : 91
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 630,
        "startColumnNumber" : 9,
        "endLineNumber" : 630,
        "endColumnNumber" : 91
      },
      "nodeContext" : "top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 630,
        "startColumnNumber" : 5,
        "endLineNumber" : 630,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 630,
        "startColumnNumber" : 5,
        "endLineNumber" : 630,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 630,
      "startColumnNumber" : 45,
      "endLineNumber" : 630,
      "endColumnNumber" : 46
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 630,
        "startColumnNumber" : 24,
        "endLineNumber" : 630,
        "endColumnNumber" : 46
      },
      "nodeContext" : "getArg(0,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 630,
        "startColumnNumber" : 15,
        "endLineNumber" : 630,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1,effectiveBottomMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 630,
        "startColumnNumber" : 15,
        "endLineNumber" : 630,
        "endColumnNumber" : 91
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 630,
        "startColumnNumber" : 9,
        "endLineNumber" : 630,
        "endColumnNumber" : 91
      },
      "nodeContext" : "top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 630,
        "startColumnNumber" : 5,
        "endLineNumber" : 630,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 630,
        "startColumnNumber" : 5,
        "endLineNumber" : 630,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 631,
      "startColumnNumber" : 32,
      "endLineNumber" : 631,
      "endColumnNumber" : 33
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 631,
        "startColumnNumber" : 25,
        "endLineNumber" : 631,
        "endColumnNumber" : 43
      },
      "nodeContext" : "getArg(1,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 631,
        "startColumnNumber" : 25,
        "endLineNumber" : 631,
        "endColumnNumber" : 47
      },
      "nodeContext" : "getArg(1,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 631,
        "startColumnNumber" : 16,
        "endLineNumber" : 631,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1,effectiveRightMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 631,
        "startColumnNumber" : 16,
        "endLineNumber" : 631,
        "endColumnNumber" : 92
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 631,
        "startColumnNumber" : 9,
        "endLineNumber" : 631,
        "endColumnNumber" : 92
      },
      "nodeContext" : "left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 631,
        "startColumnNumber" : 5,
        "endLineNumber" : 631,
        "endColumnNumber" : 93
      },
      "nodeContext" : "int left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 631,
        "startColumnNumber" : 5,
        "endLineNumber" : 631,
        "endColumnNumber" : 93
      },
      "nodeContext" : "int left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 631,
      "startColumnNumber" : 35,
      "endLineNumber" : 631,
      "endColumnNumber" : 36
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 631,
        "startColumnNumber" : 25,
        "endLineNumber" : 631,
        "endColumnNumber" : 43
      },
      "nodeContext" : "getArg(1,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 631,
        "startColumnNumber" : 25,
        "endLineNumber" : 631,
        "endColumnNumber" : 47
      },
      "nodeContext" : "getArg(1,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 631,
        "startColumnNumber" : 16,
        "endLineNumber" : 631,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1,effectiveRightMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 631,
        "startColumnNumber" : 16,
        "endLineNumber" : 631,
        "endColumnNumber" : 92
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 631,
        "startColumnNumber" : 9,
        "endLineNumber" : 631,
        "endColumnNumber" : 92
      },
      "nodeContext" : "left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 631,
        "startColumnNumber" : 5,
        "endLineNumber" : 631,
        "endColumnNumber" : 93
      },
      "nodeContext" : "int left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 631,
        "startColumnNumber" : 5,
        "endLineNumber" : 631,
        "endColumnNumber" : 93
      },
      "nodeContext" : "int left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 631,
      "startColumnNumber" : 46,
      "endLineNumber" : 631,
      "endColumnNumber" : 47
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 631,
        "startColumnNumber" : 25,
        "endLineNumber" : 631,
        "endColumnNumber" : 47
      },
      "nodeContext" : "getArg(1,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 631,
        "startColumnNumber" : 16,
        "endLineNumber" : 631,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1,effectiveRightMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 631,
        "startColumnNumber" : 16,
        "endLineNumber" : 631,
        "endColumnNumber" : 92
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 631,
        "startColumnNumber" : 9,
        "endLineNumber" : 631,
        "endColumnNumber" : 92
      },
      "nodeContext" : "left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 631,
        "startColumnNumber" : 5,
        "endLineNumber" : 631,
        "endColumnNumber" : 93
      },
      "nodeContext" : "int left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 631,
        "startColumnNumber" : 5,
        "endLineNumber" : 631,
        "endColumnNumber" : 93
      },
      "nodeContext" : "int left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 632,
      "startColumnNumber" : 52,
      "endLineNumber" : 632,
      "endColumnNumber" : 53
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 632,
        "startColumnNumber" : 27,
        "endLineNumber" : 632,
        "endColumnNumber" : 53
      },
      "nodeContext" : "getArg(2,mRows,true) + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 632,
        "startColumnNumber" : 9,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 632,
      "startColumnNumber" : 79,
      "endLineNumber" : 632,
      "endColumnNumber" : 80
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 632,
        "startColumnNumber" : 55,
        "endLineNumber" : 632,
        "endColumnNumber" : 80
      },
      "nodeContext" : "effectiveBottomMargin - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 632,
        "startColumnNumber" : 9,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 633,
      "startColumnNumber" : 54,
      "endLineNumber" : 633,
      "endColumnNumber" : 55
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 633,
        "startColumnNumber" : 26,
        "endLineNumber" : 633,
        "endColumnNumber" : 55
      },
      "nodeContext" : "getArg(3,mColumns,true) + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 65,
        "startLineNumber" : 633,
        "startColumnNumber" : 17,
        "endLineNumber" : 633,
        "endColumnNumber" : 82
      },
      "nodeContext" : "Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 633,
        "startColumnNumber" : 17,
        "endLineNumber" : 633,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 95,
        "startLineNumber" : 633,
        "startColumnNumber" : 9,
        "endLineNumber" : 633,
        "endColumnNumber" : 104
      },
      "nodeContext" : "right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 100,
        "startLineNumber" : 633,
        "startColumnNumber" : 5,
        "endLineNumber" : 633,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 100,
        "startLineNumber" : 633,
        "startColumnNumber" : 5,
        "endLineNumber" : 633,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 633,
      "startColumnNumber" : 80,
      "endLineNumber" : 633,
      "endColumnNumber" : 81
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 24,
        "startLineNumber" : 633,
        "startColumnNumber" : 57,
        "endLineNumber" : 633,
        "endColumnNumber" : 81
      },
      "nodeContext" : "effectiveRightMargin - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 65,
        "startLineNumber" : 633,
        "startColumnNumber" : 17,
        "endLineNumber" : 633,
        "endColumnNumber" : 82
      },
      "nodeContext" : "Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 633,
        "startColumnNumber" : 17,
        "endLineNumber" : 633,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 95,
        "startLineNumber" : 633,
        "startColumnNumber" : 9,
        "endLineNumber" : 633,
        "endColumnNumber" : 104
      },
      "nodeContext" : "right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 100,
        "startLineNumber" : 633,
        "startColumnNumber" : 5,
        "endLineNumber" : 633,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 100,
        "startLineNumber" : 633,
        "startColumnNumber" : 5,
        "endLineNumber" : 633,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 644,
      "startColumnNumber" : 12,
      "endLineNumber" : 644,
      "endColumnNumber" : 13
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 7,
        "startLineNumber" : 644,
        "startColumnNumber" : 7,
        "endLineNumber" : 644,
        "endColumnNumber" : 14
      },
      "nodeContext" : "case 1:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 2,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1258,
        "startLineNumber" : 638,
        "startColumnNumber" : 7,
        "endLineNumber" : 672,
        "endColumnNumber" : 8
      },
      "nodeContext" : "switch (getArg(i,0,false)) {\ncase 0:  bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 121,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 7,
        "startLineNumber" : 644,
        "startColumnNumber" : 7,
        "endLineNumber" : 644,
        "endColumnNumber" : 14
      },
      "nodeContext" : "case 1:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 2,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 695,
      "startColumnNumber" : 23,
      "endLineNumber" : 695,
      "endColumnNumber" : 24
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 8,
        "startLineNumber" : 695,
        "startColumnNumber" : 16,
        "endLineNumber" : 695,
        "endColumnNumber" : 24
      },
      "nodeContext" : "arg == 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 172,
        "startLineNumber" : 695,
        "startColumnNumber" : 12,
        "endLineNumber" : 700,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (arg == 1) {\n  mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 320,
        "startLineNumber" : 692,
        "startColumnNumber" : 5,
        "endLineNumber" : 700,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (arg == 0 || arg == 2) {\n  mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\n  mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 32,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 410,
        "startLineNumber" : 689,
        "startColumnNumber" : 18,
        "endLineNumber" : 701,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int arg=getArg0(0);\n  if (arg == 0 || arg == 2) {\n    mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else   if (arg == 1) {\n    mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else {\n    unknownSequence(b);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 40,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 462,
        "startLineNumber" : 689,
        "startColumnNumber" : 4,
        "endLineNumber" : 703,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'q') {\n  int arg=getArg0(0);\n  if (arg == 0 || arg == 2) {\n    mEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else   if (arg == 1) {\n    mEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n  }\n else {\n    unknownSequence(b);\n  }\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 49,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 8,
        "startLineNumber" : 695,
        "startColumnNumber" : 16,
        "endLineNumber" : 695,
        "endColumnNumber" : 24
      },
      "nodeContext" : "arg == 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 708,
      "startColumnNumber" : 44,
      "endLineNumber" : 708,
      "endColumnNumber" : 45
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 10,
        "startLineNumber" : 708,
        "startColumnNumber" : 36,
        "endLineNumber" : 708,
        "endColumnNumber" : 46
      },
      "nodeContext" : "getArg0(1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 708,
        "startColumnNumber" : 27,
        "endLineNumber" : 708,
        "endColumnNumber" : 67
      },
      "nodeContext" : "Math.min(getArg0(1),columnsAfterCursor)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 708,
        "startColumnNumber" : 9,
        "endLineNumber" : 708,
        "endColumnNumber" : 67
      },
      "nodeContext" : "columnsToInsert=Math.min(getArg0(1),columnsAfterCursor)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 708,
        "startColumnNumber" : 5,
        "endLineNumber" : 708,
        "endColumnNumber" : 68
      },
      "nodeContext" : "int columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 406,
        "startLineNumber" : 706,
        "startColumnNumber" : 18,
        "endLineNumber" : 712,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int columnsAfterCursor=mRightMargin - mCursorCol;\n  int columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\n  int columnsToMove=columnsAfterCursor - columnsToInsert;\n  mScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\n  blockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 45,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 900,
        "startLineNumber" : 706,
        "startColumnNumber" : 4,
        "endLineNumber" : 720,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == '}') {\n  int columnsAfterCursor=mRightMargin - mCursorCol;\n  int columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\n  int columnsToMove=columnsAfterCursor - columnsToInsert;\n  mScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\n  blockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\n  int columnsAfterCursor=mRightMargin - mCursorCol;\n  int columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\n  int columnsToMove=columnsAfterCursor - columnsToDelete;\n  mScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\n  blockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 105,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 708,
        "startColumnNumber" : 5,
        "endLineNumber" : 708,
        "endColumnNumber" : 68
      },
      "nodeContext" : "int columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 714,
      "startColumnNumber" : 44,
      "endLineNumber" : 714,
      "endColumnNumber" : 45
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 10,
        "startLineNumber" : 714,
        "startColumnNumber" : 36,
        "endLineNumber" : 714,
        "endColumnNumber" : 46
      },
      "nodeContext" : "getArg0(1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 714,
        "startColumnNumber" : 27,
        "endLineNumber" : 714,
        "endColumnNumber" : 67
      },
      "nodeContext" : "Math.min(getArg0(1),columnsAfterCursor)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 714,
        "startColumnNumber" : 9,
        "endLineNumber" : 714,
        "endColumnNumber" : 67
      },
      "nodeContext" : "columnsToDelete=Math.min(getArg0(1),columnsAfterCursor)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 714,
        "startColumnNumber" : 5,
        "endLineNumber" : 714,
        "endColumnNumber" : 68
      },
      "nodeContext" : "int columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 422,
        "startLineNumber" : 712,
        "startColumnNumber" : 25,
        "endLineNumber" : 718,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int columnsAfterCursor=mRightMargin - mCursorCol;\n  int columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\n  int columnsToMove=columnsAfterCursor - columnsToDelete;\n  mScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\n  blockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 47,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 474,
        "startLineNumber" : 712,
        "startColumnNumber" : 11,
        "endLineNumber" : 720,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == '~') {\n  int columnsAfterCursor=mRightMargin - mCursorCol;\n  int columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\n  int columnsToMove=columnsAfterCursor - columnsToDelete;\n  mScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\n  blockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 56,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 900,
        "startLineNumber" : 706,
        "startColumnNumber" : 4,
        "endLineNumber" : 720,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == '}') {\n  int columnsAfterCursor=mRightMargin - mCursorCol;\n  int columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\n  int columnsToMove=columnsAfterCursor - columnsToInsert;\n  mScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\n  blockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\n  int columnsAfterCursor=mRightMargin - mCursorCol;\n  int columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\n  int columnsToMove=columnsAfterCursor - columnsToDelete;\n  mScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\n  blockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 105,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 714,
        "startColumnNumber" : 5,
        "endLineNumber" : 714,
        "endColumnNumber" : 68
      },
      "nodeContext" : "int columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 741,
      "startColumnNumber" : 40,
      "endLineNumber" : 741,
      "endColumnNumber" : 41
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 741,
        "startColumnNumber" : 14,
        "endLineNumber" : 741,
        "endColumnNumber" : 45
      },
      "nodeContext" : "(mScreen == mAltBuffer) ? 1 : 2",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 741,
        "startColumnNumber" : 6,
        "endLineNumber" : 741,
        "endColumnNumber" : 45
      },
      "nodeContext" : "value=(mScreen == mAltBuffer) ? 1 : 2",
      "nodeType" : "Assignment",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 741,
        "startColumnNumber" : 6,
        "endLineNumber" : 741,
        "endColumnNumber" : 46
      },
      "nodeContext" : "value=(mScreen == mAltBuffer) ? 1 : 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 106,
        "startLineNumber" : 739,
        "startColumnNumber" : 53,
        "endLineNumber" : 742,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  value=(mScreen == mAltBuffer) ? 1 : 2;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 11,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 529,
        "startLineNumber" : 739,
        "startColumnNumber" : 5,
        "endLineNumber" : 750,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mode == 47 || mode == 1047 || mode == 1049) {\n  value=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\n  int internalBit=mapDecSetBitToInternalBit(mode);\n  if (internalBit == -1) {\n    value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n  }\n else {\n    Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n    value=0;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 706,
        "startLineNumber" : 735,
        "startColumnNumber" : 18,
        "endLineNumber" : 752,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 86,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 735,
        "startColumnNumber" : 4,
        "endLineNumber" : 754,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'p') {\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 95,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 741,
        "startColumnNumber" : 6,
        "endLineNumber" : 741,
        "endColumnNumber" : 46
      },
      "nodeContext" : "value=(mScreen == mAltBuffer) ? 1 : 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 744,
      "startColumnNumber" : 26,
      "endLineNumber" : 744,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 2,
        "startLineNumber" : 744,
        "startColumnNumber" : 25,
        "endLineNumber" : 744,
        "endColumnNumber" : 27
      },
      "nodeContext" : "-1",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 2,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 744,
        "startColumnNumber" : 10,
        "endLineNumber" : 744,
        "endColumnNumber" : 27
      },
      "nodeContext" : "internalBit == -1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 297,
        "startLineNumber" : 744,
        "startColumnNumber" : 6,
        "endLineNumber" : 749,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (internalBit == -1) {\n  value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\n  Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n  value=0;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 30,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 369,
        "startLineNumber" : 742,
        "startColumnNumber" : 12,
        "endLineNumber" : 750,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int internalBit=mapDecSetBitToInternalBit(mode);\n  if (internalBit == -1) {\n    value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n  }\n else {\n    Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n    value=0;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 38,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 529,
        "startLineNumber" : 739,
        "startColumnNumber" : 5,
        "endLineNumber" : 750,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mode == 47 || mode == 1047 || mode == 1049) {\n  value=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\n  int internalBit=mapDecSetBitToInternalBit(mode);\n  if (internalBit == -1) {\n    value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n  }\n else {\n    Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n    value=0;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 706,
        "startLineNumber" : 735,
        "startColumnNumber" : 18,
        "endLineNumber" : 752,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 86,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 735,
        "startColumnNumber" : 4,
        "endLineNumber" : 754,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'p') {\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 95,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 744,
        "startColumnNumber" : 10,
        "endLineNumber" : 744,
        "endColumnNumber" : 27
      },
      "nodeContext" : "internalBit == -1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 745,
      "startColumnNumber" : 53,
      "endLineNumber" : 745,
      "endColumnNumber" : 54
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 745,
        "startColumnNumber" : 15,
        "endLineNumber" : 745,
        "endColumnNumber" : 58
      },
      "nodeContext" : "isDecsetInternalBitSet(internalBit) ? 1 : 2",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 745,
        "startColumnNumber" : 7,
        "endLineNumber" : 745,
        "endColumnNumber" : 58
      },
      "nodeContext" : "value=isDecsetInternalBitSet(internalBit) ? 1 : 2",
      "nodeType" : "Assignment",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 745,
        "startColumnNumber" : 7,
        "endLineNumber" : 745,
        "endColumnNumber" : 59
      },
      "nodeContext" : "value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 744,
        "startColumnNumber" : 29,
        "endLineNumber" : 746,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 10,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 297,
        "startLineNumber" : 744,
        "startColumnNumber" : 6,
        "endLineNumber" : 749,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (internalBit == -1) {\n  value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\n  Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n  value=0;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 30,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 369,
        "startLineNumber" : 742,
        "startColumnNumber" : 12,
        "endLineNumber" : 750,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int internalBit=mapDecSetBitToInternalBit(mode);\n  if (internalBit == -1) {\n    value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n  }\n else {\n    Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n    value=0;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 38,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 529,
        "startLineNumber" : 739,
        "startColumnNumber" : 5,
        "endLineNumber" : 750,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mode == 47 || mode == 1047 || mode == 1049) {\n  value=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\n  int internalBit=mapDecSetBitToInternalBit(mode);\n  if (internalBit == -1) {\n    value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n  }\n else {\n    Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n    value=0;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 706,
        "startLineNumber" : 735,
        "startColumnNumber" : 18,
        "endLineNumber" : 752,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 86,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 735,
        "startColumnNumber" : 4,
        "endLineNumber" : 754,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (b == 'p') {\n  int mode=getArg0(0);\n  int value;\n  if (mode == 47 || mode == 1047 || mode == 1049) {\n    value=(mScreen == mAltBuffer) ? 1 : 2;\n  }\n else {\n    int internalBit=mapDecSetBitToInternalBit(mode);\n    if (internalBit == -1) {\n      value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n    }\n else {\n      Log.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\n      value=0;\n    }\n  }\n  mSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\n  unknownSequence(b);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 95,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 745,
        "startColumnNumber" : 7,
        "endLineNumber" : 745,
        "endColumnNumber" : 59
      },
      "nodeContext" : "value=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 762,
      "startColumnNumber" : 10,
      "endLineNumber" : 762,
      "endColumnNumber" : 11
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 7,
        "startLineNumber" : 762,
        "startColumnNumber" : 5,
        "endLineNumber" : 762,
        "endColumnNumber" : 12
      },
      "nodeContext" : "case 1:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 2,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 441,
        "startLineNumber" : 760,
        "startColumnNumber" : 5,
        "endLineNumber" : 774,
        "endColumnNumber" : 6
      },
      "nodeContext" : "switch (arg) {\ncase 0:case 1:case 2:  mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 31,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 698,
        "startLineNumber" : 758,
        "startColumnNumber" : 4,
        "endLineNumber" : 782,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:    mCursorStyle=CURSOR_STYLE_BLOCK;\n  break;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 46,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 7,
        "startLineNumber" : 762,
        "startColumnNumber" : 5,
        "endLineNumber" : 762,
        "endColumnNumber" : 12
      },
      "nodeContext" : "case 1:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 2,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 1,
    "startLineNumber" : 480,
    "startColumnNumber" : 47,
    "endLineNumber" : 480,
    "endColumnNumber" : 48
  }, {
    "charLength" : 1,
    "startLineNumber" : 483,
    "startColumnNumber" : 64,
    "endLineNumber" : 483,
    "endColumnNumber" : 65
  }, {
    "charLength" : 1,
    "startLineNumber" : 486,
    "startColumnNumber" : 42,
    "endLineNumber" : 486,
    "endColumnNumber" : 43
  }, {
    "charLength" : 1,
    "startLineNumber" : 497,
    "startColumnNumber" : 37,
    "endLineNumber" : 497,
    "endColumnNumber" : 38
  }, {
    "charLength" : 1,
    "startLineNumber" : 583,
    "startColumnNumber" : 40,
    "endLineNumber" : 583,
    "endColumnNumber" : 41
  }, {
    "charLength" : 1,
    "startLineNumber" : 583,
    "startColumnNumber" : 51,
    "endLineNumber" : 583,
    "endColumnNumber" : 52
  }, {
    "charLength" : 1,
    "startLineNumber" : 584,
    "startColumnNumber" : 38,
    "endLineNumber" : 584,
    "endColumnNumber" : 39
  }, {
    "charLength" : 1,
    "startLineNumber" : 584,
    "startColumnNumber" : 41,
    "endLineNumber" : 584,
    "endColumnNumber" : 42
  }, {
    "charLength" : 1,
    "startLineNumber" : 584,
    "startColumnNumber" : 52,
    "endLineNumber" : 584,
    "endColumnNumber" : 53
  }, {
    "charLength" : 1,
    "startLineNumber" : 589,
    "startColumnNumber" : 46,
    "endLineNumber" : 589,
    "endColumnNumber" : 47
  }, {
    "charLength" : 1,
    "startLineNumber" : 589,
    "startColumnNumber" : 57,
    "endLineNumber" : 589,
    "endColumnNumber" : 58
  }, {
    "charLength" : 1,
    "startLineNumber" : 590,
    "startColumnNumber" : 46,
    "endLineNumber" : 590,
    "endColumnNumber" : 47
  }, {
    "charLength" : 1,
    "startLineNumber" : 590,
    "startColumnNumber" : 57,
    "endLineNumber" : 590,
    "endColumnNumber" : 58
  }, {
    "charLength" : 1,
    "startLineNumber" : 607,
    "startColumnNumber" : 54,
    "endLineNumber" : 607,
    "endColumnNumber" : 55
  }, {
    "charLength" : 1,
    "startLineNumber" : 613,
    "startColumnNumber" : 44,
    "endLineNumber" : 613,
    "endColumnNumber" : 45
  }, {
    "charLength" : 1,
    "startLineNumber" : 613,
    "startColumnNumber" : 99,
    "endLineNumber" : 613,
    "endColumnNumber" : 100
  }, {
    "charLength" : 1,
    "startLineNumber" : 614,
    "startColumnNumber" : 45,
    "endLineNumber" : 614,
    "endColumnNumber" : 46
  }, {
    "charLength" : 1,
    "startLineNumber" : 614,
    "startColumnNumber" : 100,
    "endLineNumber" : 614,
    "endColumnNumber" : 101
  }, {
    "charLength" : 1,
    "startLineNumber" : 618,
    "startColumnNumber" : 27,
    "endLineNumber" : 618,
    "endColumnNumber" : 28
  }, {
    "charLength" : 1,
    "startLineNumber" : 619,
    "startColumnNumber" : 29,
    "endLineNumber" : 619,
    "endColumnNumber" : 30
  }, {
    "charLength" : 1,
    "startLineNumber" : 630,
    "startColumnNumber" : 34,
    "endLineNumber" : 630,
    "endColumnNumber" : 35
  }, {
    "charLength" : 1,
    "startLineNumber" : 630,
    "startColumnNumber" : 45,
    "endLineNumber" : 630,
    "endColumnNumber" : 46
  }, {
    "charLength" : 1,
    "startLineNumber" : 631,
    "startColumnNumber" : 32,
    "endLineNumber" : 631,
    "endColumnNumber" : 33
  }, {
    "charLength" : 1,
    "startLineNumber" : 631,
    "startColumnNumber" : 35,
    "endLineNumber" : 631,
    "endColumnNumber" : 36
  }, {
    "charLength" : 1,
    "startLineNumber" : 631,
    "startColumnNumber" : 46,
    "endLineNumber" : 631,
    "endColumnNumber" : 47
  }, {
    "charLength" : 1,
    "startLineNumber" : 632,
    "startColumnNumber" : 52,
    "endLineNumber" : 632,
    "endColumnNumber" : 53
  }, {
    "charLength" : 1,
    "startLineNumber" : 632,
    "startColumnNumber" : 79,
    "endLineNumber" : 632,
    "endColumnNumber" : 80
  }, {
    "charLength" : 1,
    "startLineNumber" : 633,
    "startColumnNumber" : 54,
    "endLineNumber" : 633,
    "endColumnNumber" : 55
  }, {
    "charLength" : 1,
    "startLineNumber" : 633,
    "startColumnNumber" : 80,
    "endLineNumber" : 633,
    "endColumnNumber" : 81
  }, {
    "charLength" : 1,
    "startLineNumber" : 644,
    "startColumnNumber" : 12,
    "endLineNumber" : 644,
    "endColumnNumber" : 13
  }, {
    "charLength" : 1,
    "startLineNumber" : 695,
    "startColumnNumber" : 23,
    "endLineNumber" : 695,
    "endColumnNumber" : 24
  }, {
    "charLength" : 1,
    "startLineNumber" : 708,
    "startColumnNumber" : 44,
    "endLineNumber" : 708,
    "endColumnNumber" : 45
  }, {
    "charLength" : 1,
    "startLineNumber" : 714,
    "startColumnNumber" : 44,
    "endLineNumber" : 714,
    "endColumnNumber" : 45
  }, {
    "charLength" : 1,
    "startLineNumber" : 741,
    "startColumnNumber" : 40,
    "endLineNumber" : 741,
    "endColumnNumber" : 41
  }, {
    "charLength" : 1,
    "startLineNumber" : 744,
    "startColumnNumber" : 26,
    "endLineNumber" : 744,
    "endColumnNumber" : 27
  }, {
    "charLength" : 1,
    "startLineNumber" : 745,
    "startColumnNumber" : 53,
    "endLineNumber" : 745,
    "endColumnNumber" : 54
  }, {
    "charLength" : 1,
    "startLineNumber" : 762,
    "startColumnNumber" : 10,
    "endLineNumber" : 762,
    "endColumnNumber" : 11
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 30,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 31,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 32,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 33,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 34,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 35,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 36,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 18,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 19,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 24,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 25,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 26,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 27,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 28,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 29,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 30,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 31,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 32,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 33,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 34,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 35,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 36,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 14,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 15,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 16,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 17,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 18,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 19,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 20,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 21,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 22,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 23,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 24,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 25,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 26,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 27,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 28,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 29,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 30,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 31,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 32,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 33,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 34,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 35,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 36,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 1
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 4,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 4,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 4,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 4,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 4,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 4,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 0
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 0
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 1
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 0
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 1
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 0
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 0
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 0
  }, {
    "firstKey" : 10,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 11,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 11,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 11,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 11,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 12,
    "layout" : 1
  }, {
    "firstKey" : 11,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 12,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 12,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 12,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 12,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 12,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 11,
    "layout" : 0
  }, {
    "firstKey" : 12,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 13,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 15,
    "layout" : 2
  }, {
    "firstKey" : 14,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 14,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 14,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 14,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 14,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 24,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 25,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 26,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 27,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 28,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 29,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 30,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 31,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 32,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 33,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 34,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 35,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 36,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 14,
    "layout" : 1
  }, {
    "firstKey" : 15,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 15,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 15,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 15,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 15,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 15,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 15,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 16,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 16,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 16,
    "secondKey" : 17,
    "layout" : 2
  }, {
    "firstKey" : 16,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 16,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 16,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 24,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 25,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 26,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 27,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 28,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 29,
    "layout" : 7
  }, {
    "firstKey" : 16,
    "secondKey" : 30,
    "layout" : 8
  }, {
    "firstKey" : 16,
    "secondKey" : 31,
    "layout" : 8
  }, {
    "firstKey" : 16,
    "secondKey" : 32,
    "layout" : 8
  }, {
    "firstKey" : 16,
    "secondKey" : 33,
    "layout" : 8
  }, {
    "firstKey" : 16,
    "secondKey" : 34,
    "layout" : 8
  }, {
    "firstKey" : 16,
    "secondKey" : 35,
    "layout" : 8
  }, {
    "firstKey" : 16,
    "secondKey" : 36,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 17,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 17,
    "secondKey" : 16,
    "layout" : 1
  }, {
    "firstKey" : 17,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 17,
    "secondKey" : 19,
    "layout" : 4
  }, {
    "firstKey" : 17,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 17,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 17,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 17,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 17,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 17,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 17,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 17,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 18,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 18,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 18,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 18,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 18,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 18,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 18,
    "secondKey" : 17,
    "layout" : 4
  }, {
    "firstKey" : 18,
    "secondKey" : 19,
    "layout" : 3
  }, {
    "firstKey" : 18,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 19,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 19,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 19,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 19,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 19,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 19,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 19,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 19,
    "secondKey" : 18,
    "layout" : 4
  }, {
    "firstKey" : 19,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 24,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 25,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 26,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 27,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 28,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 29,
    "layout" : 7
  }, {
    "firstKey" : 19,
    "secondKey" : 30,
    "layout" : 8
  }, {
    "firstKey" : 19,
    "secondKey" : 31,
    "layout" : 8
  }, {
    "firstKey" : 19,
    "secondKey" : 32,
    "layout" : 8
  }, {
    "firstKey" : 19,
    "secondKey" : 33,
    "layout" : 8
  }, {
    "firstKey" : 19,
    "secondKey" : 34,
    "layout" : 8
  }, {
    "firstKey" : 19,
    "secondKey" : 35,
    "layout" : 8
  }, {
    "firstKey" : 19,
    "secondKey" : 36,
    "layout" : 8
  }, {
    "firstKey" : 20,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 20,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 20,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 20,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 20,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 21,
    "layout" : 1
  }, {
    "firstKey" : 20,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 20,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 20,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 20,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 20,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 20,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 20,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 20,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 21,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 21,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 21,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 21,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 21,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 20,
    "layout" : 0
  }, {
    "firstKey" : 21,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 21,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 21,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 21,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 21,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 21,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 21,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 21,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 22,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 22,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 22,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 22,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 23,
    "layout" : 0
  }, {
    "firstKey" : 22,
    "secondKey" : 24,
    "layout" : 1
  }, {
    "firstKey" : 22,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 22,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 22,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 22,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 22,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 22,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 22,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 22,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 23,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 23,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 23,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 23,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 23,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 22,
    "layout" : 0
  }, {
    "firstKey" : 23,
    "secondKey" : 24,
    "layout" : 1
  }, {
    "firstKey" : 23,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 23,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 23,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 23,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 23,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 23,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 23,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 23,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 24,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 24,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 24,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 24,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 24,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 22,
    "layout" : 0
  }, {
    "firstKey" : 24,
    "secondKey" : 23,
    "layout" : 0
  }, {
    "firstKey" : 24,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 24,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 24,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 24,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 24,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 24,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 24,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 24,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 25,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 25,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 26,
    "layout" : 1
  }, {
    "firstKey" : 25,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 25,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 25,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 25,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 25,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 25,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 25,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 25,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 26,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 26,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 26,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 26,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 25,
    "layout" : 1
  }, {
    "firstKey" : 26,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 26,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 26,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 27,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 27,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 28,
    "layout" : 1
  }, {
    "firstKey" : 27,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 27,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 27,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 27,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 27,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 27,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 27,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 27,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 28,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 28,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 28,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 28,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 28,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 27,
    "layout" : 1
  }, {
    "firstKey" : 28,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 28,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 28,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 28,
    "secondKey" : 32,
    "layout" : 6
  }, {
    "firstKey" : 28,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 28,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 28,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 28,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 29,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 29,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 29,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 29,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 29,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 29,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 29,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 29,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 30,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 30,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 30,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 30,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 30,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 14,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 15,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 16,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 17,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 19,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 20,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 21,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 22,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 23,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 24,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 25,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 26,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 27,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 28,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 29,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 31,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 32,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 33,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 34,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 35,
    "layout" : 5
  }, {
    "firstKey" : 30,
    "secondKey" : 36,
    "layout" : 5
  }, {
    "firstKey" : 31,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 31,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 31,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 31,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 31,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 19,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 20,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 21,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 22,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 23,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 24,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 25,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 26,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 27,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 28,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 29,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 30,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 32,
    "layout" : 5
  }, {
    "firstKey" : 31,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 34,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 35,
    "layout" : 6
  }, {
    "firstKey" : 31,
    "secondKey" : 36,
    "layout" : 6
  }, {
    "firstKey" : 32,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 32,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 18,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 19,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 24,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 25,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 26,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 27,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 28,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 29,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 31,
    "layout" : 6
  }, {
    "firstKey" : 32,
    "secondKey" : 33,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 34,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 35,
    "layout" : 7
  }, {
    "firstKey" : 32,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 33,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 33,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 33,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 33,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 18,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 19,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 24,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 25,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 26,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 27,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 28,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 29,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 33,
    "secondKey" : 34,
    "layout" : 4
  }, {
    "firstKey" : 33,
    "secondKey" : 35,
    "layout" : 4
  }, {
    "firstKey" : 33,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 34,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 34,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 34,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 34,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 18,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 19,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 20,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 21,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 22,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 23,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 24,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 25,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 26,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 27,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 28,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 29,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 30,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 31,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 32,
    "layout" : 7
  }, {
    "firstKey" : 34,
    "secondKey" : 33,
    "layout" : 4
  }, {
    "firstKey" : 34,
    "secondKey" : 35,
    "layout" : 2
  }, {
    "firstKey" : 34,
    "secondKey" : 36,
    "layout" : 7
  }, {
    "firstKey" : 35,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 35,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 35,
    "secondKey" : 2,
    "layout" : 10
  }, {
    "firstKey" : 35,
    "secondKey" : 3,
    "layout" : 10
  }, {
    "firstKey" : 35,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 11,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 12,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 13,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 14,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 15,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 16,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 17,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 18,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 19,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 20,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 21,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 22,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 23,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 24,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 25,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 26,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 27,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 28,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 29,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 30,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 31,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 32,
    "layout" : 9
  }, {
    "firstKey" : 35,
    "secondKey" : 33,
    "layout" : 6
  }, {
    "firstKey" : 35,
    "secondKey" : 34,
    "layout" : 4
  }, {
    "firstKey" : 35,
    "secondKey" : 36,
    "layout" : 9
  }, {
    "firstKey" : 36,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 36,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 36,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 36,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 36,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 14,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 15,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 16,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 17,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 18,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 19,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 20,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 21,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 22,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 23,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 24,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 25,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 26,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 27,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 28,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 29,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 30,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 31,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 32,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 33,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 34,
    "layout" : 3
  }, {
    "firstKey" : 36,
    "secondKey" : 35,
    "layout" : 3
  } ]
}