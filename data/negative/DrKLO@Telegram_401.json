{
  "id" : 401,
  "expression" : "System",
  "projectName" : "DrKLO@Telegram",
  "commitID" : "51aa4141a41a811e87b829f587753f0b20158a9b",
  "filePath" : "TMessagesProj/src/main/java/org/telegram/messenger/ConnectionsManager.java",
  "occurrences" : 6,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "System",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 1910,
      "startColumnNumber" : 41,
      "endLineNumber" : 1910,
      "endColumnNumber" : 47
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 1910,
        "startColumnNumber" : 41,
        "endLineNumber" : 1910,
        "endColumnNumber" : 67
      },
      "nodeContext" : "System.currentTimeMillis()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 1910,
        "startColumnNumber" : 41,
        "endLineNumber" : 1910,
        "endColumnNumber" : 74
      },
      "nodeContext" : "System.currentTimeMillis() / 1000",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CastExpression,expression]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 1910,
        "startColumnNumber" : 40,
        "endLineNumber" : 1910,
        "endColumnNumber" : 75
      },
      "nodeContext" : "(System.currentTimeMillis() / 1000)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 1910,
        "startColumnNumber" : 35,
        "endLineNumber" : 1910,
        "endColumnNumber" : 75
      },
      "nodeContext" : "(int)(System.currentTimeMillis() / 1000)",
      "nodeType" : "CastExpression",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 1910,
        "startColumnNumber" : 35,
        "endLineNumber" : 1910,
        "endColumnNumber" : 82
      },
      "nodeContext" : "(int)(System.currentTimeMillis() / 1000) - time",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 10,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 1910,
        "startColumnNumber" : 24,
        "endLineNumber" : 1910,
        "endColumnNumber" : 82
      },
      "nodeContext" : "pingTime=(int)(System.currentTimeMillis() / 1000) - time",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 12,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 1910,
        "startColumnNumber" : 20,
        "endLineNumber" : 1910,
        "endColumnNumber" : 83
      },
      "nodeContext" : "int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 687,
        "startLineNumber" : 1908,
        "startColumnNumber" : 35,
        "endLineNumber" : 1922,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int time=pingIdToDate.get(pid);\n  int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n  if (Math.abs(pingTime) < 10) {\n    currentPingTime=(pingTime + currentPingTime) / 2;\n    if (messageId != 0) {\n      long timeMessage=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n  }\n  itemsToDelete.add(pid);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 80,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 793,
        "startLineNumber" : 1908,
        "startColumnNumber" : 16,
        "endLineNumber" : 1924,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (pid == pingId) {\n  int time=pingIdToDate.get(pid);\n  int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n  if (Math.abs(pingTime) < 10) {\n    currentPingTime=(pingTime + currentPingTime) / 2;\n    if (messageId != 0) {\n      long timeMessage=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n  }\n  itemsToDelete.add(pid);\n}\n else if (pid < pingId) {\n  itemsToDelete.add(pid);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 94,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 825,
        "startLineNumber" : 1907,
        "startColumnNumber" : 51,
        "endLineNumber" : 1925,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  if (pid == pingId) {\n    int time=pingIdToDate.get(pid);\n    int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n    if (Math.abs(pingTime) < 10) {\n      currentPingTime=(pingTime + currentPingTime) / 2;\n      if (messageId != 0) {\n        long timeMessage=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n    }\n    itemsToDelete.add(pid);\n  }\n else   if (pid < pingId) {\n    itemsToDelete.add(pid);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 95,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 864,
        "startLineNumber" : 1907,
        "startColumnNumber" : 12,
        "endLineNumber" : 1925,
        "endColumnNumber" : 13
      },
      "nodeContext" : "for (Long pid : pingIdToDate.keySet()) {\n  if (pid == pingId) {\n    int time=pingIdToDate.get(pid);\n    int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n    if (Math.abs(pingTime) < 10) {\n      currentPingTime=(pingTime + currentPingTime) / 2;\n      if (messageId != 0) {\n        long timeMessage=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n    }\n    itemsToDelete.add(pid);\n  }\n else   if (pid < pingId) {\n    itemsToDelete.add(pid);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 103,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1154,
        "startLineNumber" : 1902,
        "startColumnNumber" : 53,
        "endLineNumber" : 1929,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 150,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 19081,
        "startLineNumber" : 1902,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1908,
      "astHeight" : 31
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 20361,
        "startLineNumber" : 1878,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2020,
      "astHeight" : 32
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 22534,
        "startLineNumber" : 1839,
        "startColumnNumber" : 8,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_new_session_created) {\n  TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n  ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n  if (arr == null) {\n    arr=new ArrayList<Long>();\n    processedSessionChanges.put(sessionId,arr);\n  }\n  if (!arr.contains(newSession.unique_id)) {\n    FileLog.d(\"tmessages\",\"New session:\");\n    FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n    FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n    FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n    long serverSalt=newSession.server_salt;\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=serverSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    for (    RPCRequest request : runningRequests) {\n      Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n      if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.runningStartTime=0;\n        request.runningMinStartTime=0;\n        request.transportChannelToken=0;\n      }\n    }\n    saveSession();\n    if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n      MessagesController.getInstance().getDifference();\n    }\n    arr.add(newSession.unique_id);\n  }\n}\n else if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2280,
      "astHeight" : 33
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 22747,
        "startLineNumber" : 1832,
        "startColumnNumber" : 178,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2303,
      "astHeight" : 34
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 22921,
        "startLineNumber" : 1832,
        "startColumnNumber" : 4,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "void processMessage(TLObject message,long messageId,int messageSeqNo,long messageSalt,TcpConnection connection,long sessionId,long innerMsgId,long containerMessageId){\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 2332,
      "astHeight" : 35
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 1910,
        "startColumnNumber" : 20,
        "endLineNumber" : 1910,
        "endColumnNumber" : 83
      },
      "nodeContext" : "int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 8
    },
    "tokenLength" : 1,
    "type" : "java.lang.System"
  }, {
    "nodeContext" : "System",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 1917,
      "startColumnNumber" : 47,
      "endLineNumber" : 1917,
      "endColumnNumber" : 53
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 1917,
        "startColumnNumber" : 47,
        "endLineNumber" : 1917,
        "endColumnNumber" : 73
      },
      "nodeContext" : "System.currentTimeMillis()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 1917,
        "startColumnNumber" : 33,
        "endLineNumber" : 1917,
        "endColumnNumber" : 73
      },
      "nodeContext" : "currentTime=System.currentTimeMillis()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 1917,
        "startColumnNumber" : 28,
        "endLineNumber" : 1917,
        "endColumnNumber" : 74
      },
      "nodeContext" : "long currentTime=System.currentTimeMillis();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 290,
        "startLineNumber" : 1915,
        "startColumnNumber" : 44,
        "endLineNumber" : 1919,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  long timeMessage=getTimeFromMsgId(messageId);\n  long currentTime=System.currentTimeMillis();\n  timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 31,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 310,
        "startLineNumber" : 1915,
        "startColumnNumber" : 24,
        "endLineNumber" : 1919,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (messageId != 0) {\n  long timeMessage=getTimeFromMsgId(messageId);\n  long currentTime=System.currentTimeMillis();\n  timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 35,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 435,
        "startLineNumber" : 1912,
        "startColumnNumber" : 49,
        "endLineNumber" : 1920,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  currentPingTime=(pingTime + currentPingTime) / 2;\n  if (messageId != 0) {\n    long timeMessage=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 45,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 464,
        "startLineNumber" : 1912,
        "startColumnNumber" : 20,
        "endLineNumber" : 1920,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (Math.abs(pingTime) < 10) {\n  currentPingTime=(pingTime + currentPingTime) / 2;\n  if (messageId != 0) {\n    long timeMessage=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 52,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 687,
        "startLineNumber" : 1908,
        "startColumnNumber" : 35,
        "endLineNumber" : 1922,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int time=pingIdToDate.get(pid);\n  int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n  if (Math.abs(pingTime) < 10) {\n    currentPingTime=(pingTime + currentPingTime) / 2;\n    if (messageId != 0) {\n      long timeMessage=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n  }\n  itemsToDelete.add(pid);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 80,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 793,
        "startLineNumber" : 1908,
        "startColumnNumber" : 16,
        "endLineNumber" : 1924,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (pid == pingId) {\n  int time=pingIdToDate.get(pid);\n  int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n  if (Math.abs(pingTime) < 10) {\n    currentPingTime=(pingTime + currentPingTime) / 2;\n    if (messageId != 0) {\n      long timeMessage=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n  }\n  itemsToDelete.add(pid);\n}\n else if (pid < pingId) {\n  itemsToDelete.add(pid);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 94,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 825,
        "startLineNumber" : 1907,
        "startColumnNumber" : 51,
        "endLineNumber" : 1925,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  if (pid == pingId) {\n    int time=pingIdToDate.get(pid);\n    int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n    if (Math.abs(pingTime) < 10) {\n      currentPingTime=(pingTime + currentPingTime) / 2;\n      if (messageId != 0) {\n        long timeMessage=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n    }\n    itemsToDelete.add(pid);\n  }\n else   if (pid < pingId) {\n    itemsToDelete.add(pid);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 95,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 864,
        "startLineNumber" : 1907,
        "startColumnNumber" : 12,
        "endLineNumber" : 1925,
        "endColumnNumber" : 13
      },
      "nodeContext" : "for (Long pid : pingIdToDate.keySet()) {\n  if (pid == pingId) {\n    int time=pingIdToDate.get(pid);\n    int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n    if (Math.abs(pingTime) < 10) {\n      currentPingTime=(pingTime + currentPingTime) / 2;\n      if (messageId != 0) {\n        long timeMessage=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n    }\n    itemsToDelete.add(pid);\n  }\n else   if (pid < pingId) {\n    itemsToDelete.add(pid);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 103,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1154,
        "startLineNumber" : 1902,
        "startColumnNumber" : 53,
        "endLineNumber" : 1929,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 150,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 19081,
        "startLineNumber" : 1902,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1908,
      "astHeight" : 31
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 20361,
        "startLineNumber" : 1878,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2020,
      "astHeight" : 32
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 22534,
        "startLineNumber" : 1839,
        "startColumnNumber" : 8,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_new_session_created) {\n  TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n  ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n  if (arr == null) {\n    arr=new ArrayList<Long>();\n    processedSessionChanges.put(sessionId,arr);\n  }\n  if (!arr.contains(newSession.unique_id)) {\n    FileLog.d(\"tmessages\",\"New session:\");\n    FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n    FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n    FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n    long serverSalt=newSession.server_salt;\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=serverSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    for (    RPCRequest request : runningRequests) {\n      Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n      if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.runningStartTime=0;\n        request.runningMinStartTime=0;\n        request.transportChannelToken=0;\n      }\n    }\n    saveSession();\n    if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n      MessagesController.getInstance().getDifference();\n    }\n    arr.add(newSession.unique_id);\n  }\n}\n else if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2280,
      "astHeight" : 33
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 22747,
        "startLineNumber" : 1832,
        "startColumnNumber" : 178,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2303,
      "astHeight" : 34
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 22921,
        "startLineNumber" : 1832,
        "startColumnNumber" : 4,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "void processMessage(TLObject message,long messageId,int messageSeqNo,long messageSalt,TcpConnection connection,long sessionId,long innerMsgId,long containerMessageId){\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 2332,
      "astHeight" : 35
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 1917,
        "startColumnNumber" : 28,
        "endLineNumber" : 1917,
        "endColumnNumber" : 74
      },
      "nodeContext" : "long currentTime=System.currentTimeMillis();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.System"
  }, {
    "nodeContext" : "System",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 2025,
      "startColumnNumber" : 36,
      "endLineNumber" : 2025,
      "endColumnNumber" : 42
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 11,
        "startLineNumber" : 2025,
        "startColumnNumber" : 36,
        "endLineNumber" : 2025,
        "endColumnNumber" : 47
      },
      "nodeContext" : "System.gc()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 12,
        "startLineNumber" : 2025,
        "startColumnNumber" : 36,
        "endLineNumber" : 2025,
        "endColumnNumber" : 48
      },
      "nodeContext" : "System.gc();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 196,
        "startLineNumber" : 2024,
        "startColumnNumber" : 57,
        "endLineNumber" : 2027,
        "endColumnNumber" : 33
      },
      "nodeContext" : "{\n  System.gc();\n  uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 221,
        "startLineNumber" : 2024,
        "startColumnNumber" : 32,
        "endLineNumber" : 2027,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (uncomressed == null) {\n  System.gc();\n  uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 21,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 795,
        "startLineNumber" : 2021,
        "startColumnNumber" : 88,
        "endLineNumber" : 2032,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n  TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n  if (uncomressed == null) {\n    System.gc();\n    uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n  }\n  if (uncomressed == null) {\n    throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n  }\n  resultContainer.result=uncomressed;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 71,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 855,
        "startLineNumber" : 2021,
        "startColumnNumber" : 28,
        "endLineNumber" : 2032,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n  TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n  if (uncomressed == null) {\n    System.gc();\n    uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n  }\n  if (uncomressed == null) {\n    throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n  }\n  resultContainer.result=uncomressed;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 80,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7592,
        "startLineNumber" : 2019,
        "startColumnNumber" : 61,
        "endLineNumber" : 2132,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  TLRPC.TL_error implicitError=null;\n  if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n    TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n    if (uncomressed == null) {\n      System.gc();\n      uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n    }\n    if (uncomressed == null) {\n      throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n    }\n    resultContainer.result=uncomressed;\n  }\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n    if (errorCode == 500 || errorCode < 0) {\n      if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n        if (request.serverFailureCount < 1) {\n          discardResponse=true;\n          request.runningMinStartTime=request.runningStartTime + 1;\n        }\n      }\n else {\n        discardResponse=true;\n        int delay=Math.min(1,request.serverFailureCount * 2);\n        request.runningMinStartTime=request.runningStartTime + delay;\n        request.confirmed=false;\n      }\n      request.serverFailureCount++;\n    }\n else     if (errorCode == 420) {\n      if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n        double waitTime=2.0;\n        if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n          String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            waitTime=val;\n          }\n        }\n        waitTime=Math.min(30,waitTime);\n        discardResponse=true;\n        request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n        request.confirmed=false;\n      }\n    }\n    implicitError=new TLRPC.TL_error();\n    implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n    implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n  }\n else   if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n    if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n      if (request.rawRequest == null) {\n        FileLog.e(\"tmessages\",\"rawRequest is null\");\n      }\n else {\n        FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n      }\n      implicitError=new TLRPC.TL_error();\n      implicitError.code=-1000;\n    }\n  }\n  if (!discardResponse) {\n    if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n      isError=true;\n      request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n    }\n else {\n      request.completionBlock.run(resultContainer.result,null);\n    }\n  }\n  if (implicitError != null && implicitError.code == 401) {\n    isError=true;\n    if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n      if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n        if (UserConfig.clientActivated) {\n          UserConfig.clearConfig();\n          Utilities.RunOnUIThread(new Runnable(){\n            @Override public void run(){\n              NotificationCenter.getInstance().postNotificationName(1234);\n            }\n          }\n);\n        }\n      }\n    }\n else {\n      datacenter.authorized=false;\n      saveSession();\n      discardResponse=true;\n      if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n        retryRequestsFromDatacenter=datacenter.datacenterId;\n        retryRequestsClass=request.flags;\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 658,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7629,
        "startLineNumber" : 2019,
        "startColumnNumber" : 24,
        "endLineNumber" : 2132,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (request.completionBlock != null) {\n  TLRPC.TL_error implicitError=null;\n  if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n    TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n    if (uncomressed == null) {\n      System.gc();\n      uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n    }\n    if (uncomressed == null) {\n      throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n    }\n    resultContainer.result=uncomressed;\n  }\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n    if (errorCode == 500 || errorCode < 0) {\n      if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n        if (request.serverFailureCount < 1) {\n          discardResponse=true;\n          request.runningMinStartTime=request.runningStartTime + 1;\n        }\n      }\n else {\n        discardResponse=true;\n        int delay=Math.min(1,request.serverFailureCount * 2);\n        request.runningMinStartTime=request.runningStartTime + delay;\n        request.confirmed=false;\n      }\n      request.serverFailureCount++;\n    }\n else     if (errorCode == 420) {\n      if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n        double waitTime=2.0;\n        if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n          String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            waitTime=val;\n          }\n        }\n        waitTime=Math.min(30,waitTime);\n        discardResponse=true;\n        request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n        request.confirmed=false;\n      }\n    }\n    implicitError=new TLRPC.TL_error();\n    implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n    implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n  }\n else   if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n    if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n      if (request.rawRequest == null) {\n        FileLog.e(\"tmessages\",\"rawRequest is null\");\n      }\n else {\n        FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n      }\n      implicitError=new TLRPC.TL_error();\n      implicitError.code=-1000;\n    }\n  }\n  if (!discardResponse) {\n    if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n      isError=true;\n      request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n    }\n else {\n      request.completionBlock.run(resultContainer.result,null);\n    }\n  }\n  if (implicitError != null && implicitError.code == 401) {\n    isError=true;\n    if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n      if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n        if (UserConfig.clientActivated) {\n          UserConfig.clearConfig();\n          Utilities.RunOnUIThread(new Runnable(){\n            @Override public void run(){\n              NotificationCenter.getInstance().postNotificationName(1234);\n            }\n          }\n);\n        }\n      }\n    }\n else {\n      datacenter.authorized=false;\n      saveSession();\n      discardResponse=true;\n      if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n        retryRequestsFromDatacenter=datacenter.datacenterId;\n        retryRequestsClass=request.flags;\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 664,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 8793,
        "startLineNumber" : 2014,
        "startColumnNumber" : 64,
        "endLineNumber" : 2151,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  found=true;\n  boolean discardResponse=false;\n  boolean isError=false;\n  if (request.completionBlock != null) {\n    TLRPC.TL_error implicitError=null;\n    if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n      TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n      TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n      if (uncomressed == null) {\n        System.gc();\n        uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n      }\n      if (uncomressed == null) {\n        throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n      }\n      resultContainer.result=uncomressed;\n    }\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n      if (errorCode == 500 || errorCode < 0) {\n        if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n          if (request.serverFailureCount < 1) {\n            discardResponse=true;\n            request.runningMinStartTime=request.runningStartTime + 1;\n          }\n        }\n else {\n          discardResponse=true;\n          int delay=Math.min(1,request.serverFailureCount * 2);\n          request.runningMinStartTime=request.runningStartTime + delay;\n          request.confirmed=false;\n        }\n        request.serverFailureCount++;\n      }\n else       if (errorCode == 420) {\n        if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n          double waitTime=2.0;\n          if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n            String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              waitTime=val;\n            }\n          }\n          waitTime=Math.min(30,waitTime);\n          discardResponse=true;\n          request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n          request.confirmed=false;\n        }\n      }\n      implicitError=new TLRPC.TL_error();\n      implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n      implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n    }\n else     if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n      if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n        if (request.rawRequest == null) {\n          FileLog.e(\"tmessages\",\"rawRequest is null\");\n        }\n else {\n          FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n        }\n        implicitError=new TLRPC.TL_error();\n        implicitError.code=-1000;\n      }\n    }\n    if (!discardResponse) {\n      if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n        isError=true;\n        request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n      }\n else {\n        request.completionBlock.run(resultContainer.result,null);\n      }\n    }\n    if (implicitError != null && implicitError.code == 401) {\n      isError=true;\n      if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n        if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n          if (UserConfig.clientActivated) {\n            UserConfig.clearConfig();\n            Utilities.RunOnUIThread(new Runnable(){\n              @Override public void run(){\n                NotificationCenter.getInstance().postNotificationName(1234);\n              }\n            }\n);\n          }\n        }\n      }\n else {\n        datacenter.authorized=false;\n        saveSession();\n        discardResponse=true;\n        if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n          retryRequestsFromDatacenter=datacenter.datacenterId;\n          retryRequestsClass=request.flags;\n        }\n      }\n    }\n  }\n  if (!discardResponse) {\n    if (request.initRequest && !isError) {\n      if (datacenter.lastInitVersion != currentAppVersion) {\n        datacenter.lastInitVersion=currentAppVersion;\n        saveSession();\n        FileLog.e(\"tmessages\",\"init connection completed\");\n      }\n else {\n        FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n      }\n    }\n    rpcCompleted(resultMid);\n  }\n else {\n    request.runningMessageId=0;\n    request.runningMessageSeqNo=0;\n    request.transportChannelToken=0;\n  }\n  break;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 744,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8837,
        "startLineNumber" : 2014,
        "startColumnNumber" : 20,
        "endLineNumber" : 2151,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (request.respondsToMessageId(resultMid)) {\n  found=true;\n  boolean discardResponse=false;\n  boolean isError=false;\n  if (request.completionBlock != null) {\n    TLRPC.TL_error implicitError=null;\n    if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n      TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n      TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n      if (uncomressed == null) {\n        System.gc();\n        uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n      }\n      if (uncomressed == null) {\n        throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n      }\n      resultContainer.result=uncomressed;\n    }\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n      if (errorCode == 500 || errorCode < 0) {\n        if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n          if (request.serverFailureCount < 1) {\n            discardResponse=true;\n            request.runningMinStartTime=request.runningStartTime + 1;\n          }\n        }\n else {\n          discardResponse=true;\n          int delay=Math.min(1,request.serverFailureCount * 2);\n          request.runningMinStartTime=request.runningStartTime + delay;\n          request.confirmed=false;\n        }\n        request.serverFailureCount++;\n      }\n else       if (errorCode == 420) {\n        if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n          double waitTime=2.0;\n          if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n            String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              waitTime=val;\n            }\n          }\n          waitTime=Math.min(30,waitTime);\n          discardResponse=true;\n          request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n          request.confirmed=false;\n        }\n      }\n      implicitError=new TLRPC.TL_error();\n      implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n      implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n    }\n else     if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n      if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n        if (request.rawRequest == null) {\n          FileLog.e(\"tmessages\",\"rawRequest is null\");\n        }\n else {\n          FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n        }\n        implicitError=new TLRPC.TL_error();\n        implicitError.code=-1000;\n      }\n    }\n    if (!discardResponse) {\n      if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n        isError=true;\n        request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n      }\n else {\n        request.completionBlock.run(resultContainer.result,null);\n      }\n    }\n    if (implicitError != null && implicitError.code == 401) {\n      isError=true;\n      if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n        if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n          if (UserConfig.clientActivated) {\n            UserConfig.clearConfig();\n            Utilities.RunOnUIThread(new Runnable(){\n              @Override public void run(){\n                NotificationCenter.getInstance().postNotificationName(1234);\n              }\n            }\n);\n          }\n        }\n      }\n else {\n        datacenter.authorized=false;\n        saveSession();\n        discardResponse=true;\n        if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n          retryRequestsFromDatacenter=datacenter.datacenterId;\n          retryRequestsClass=request.flags;\n        }\n      }\n    }\n  }\n  if (!discardResponse) {\n    if (request.initRequest && !isError) {\n      if (datacenter.lastInitVersion != currentAppVersion) {\n        datacenter.lastInitVersion=currentAppVersion;\n        saveSession();\n        FileLog.e(\"tmessages\",\"init connection completed\");\n      }\n else {\n        FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n      }\n    }\n    rpcCompleted(resultMid);\n  }\n else {\n    request.runningMessageId=0;\n    request.runningMessageSeqNo=0;\n    request.transportChannelToken=0;\n  }\n  break;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 749,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 8877,
        "startLineNumber" : 2013,
        "startColumnNumber" : 59,
        "endLineNumber" : 2152,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  if (request.respondsToMessageId(resultMid)) {\n    found=true;\n    boolean discardResponse=false;\n    boolean isError=false;\n    if (request.completionBlock != null) {\n      TLRPC.TL_error implicitError=null;\n      if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n        TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n        TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n        if (uncomressed == null) {\n          System.gc();\n          uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n        }\n        if (uncomressed == null) {\n          throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n        }\n        resultContainer.result=uncomressed;\n      }\n      if (resultContainer.result instanceof TLRPC.RpcError) {\n        String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n        FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n        int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n        if (errorCode == 500 || errorCode < 0) {\n          if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n            if (request.serverFailureCount < 1) {\n              discardResponse=true;\n              request.runningMinStartTime=request.runningStartTime + 1;\n            }\n          }\n else {\n            discardResponse=true;\n            int delay=Math.min(1,request.serverFailureCount * 2);\n            request.runningMinStartTime=request.runningStartTime + delay;\n            request.confirmed=false;\n          }\n          request.serverFailureCount++;\n        }\n else         if (errorCode == 420) {\n          if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n            double waitTime=2.0;\n            if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n              String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n              Pattern pattern=Pattern.compile(\"[0-9]+\");\n              Matcher matcher=pattern.matcher(errorMsg);\n              if (matcher.find()) {\n                errorMsg=matcher.group(0);\n              }\n              Integer val;\n              try {\n                val=Integer.parseInt(errorMsg);\n              }\n catch (              Exception e) {\n                val=null;\n              }\n              if (val != null) {\n                waitTime=val;\n              }\n            }\n            waitTime=Math.min(30,waitTime);\n            discardResponse=true;\n            request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n            request.confirmed=false;\n          }\n        }\n        implicitError=new TLRPC.TL_error();\n        implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n        implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n      }\n else       if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n        if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n          if (request.rawRequest == null) {\n            FileLog.e(\"tmessages\",\"rawRequest is null\");\n          }\n else {\n            FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n          }\n          implicitError=new TLRPC.TL_error();\n          implicitError.code=-1000;\n        }\n      }\n      if (!discardResponse) {\n        if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n          isError=true;\n          request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n        }\n else {\n          request.completionBlock.run(resultContainer.result,null);\n        }\n      }\n      if (implicitError != null && implicitError.code == 401) {\n        isError=true;\n        if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n          if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n            if (UserConfig.clientActivated) {\n              UserConfig.clearConfig();\n              Utilities.RunOnUIThread(new Runnable(){\n                @Override public void run(){\n                  NotificationCenter.getInstance().postNotificationName(1234);\n                }\n              }\n);\n            }\n          }\n        }\n else {\n          datacenter.authorized=false;\n          saveSession();\n          discardResponse=true;\n          if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n            retryRequestsFromDatacenter=datacenter.datacenterId;\n            retryRequestsClass=request.flags;\n          }\n        }\n      }\n    }\n    if (!discardResponse) {\n      if (request.initRequest && !isError) {\n        if (datacenter.lastInitVersion != currentAppVersion) {\n          datacenter.lastInitVersion=currentAppVersion;\n          saveSession();\n          FileLog.e(\"tmessages\",\"init connection completed\");\n        }\n else {\n          FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n        }\n      }\n      rpcCompleted(resultMid);\n    }\n else {\n      request.runningMessageId=0;\n      request.runningMessageSeqNo=0;\n      request.transportChannelToken=0;\n    }\n    break;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 750,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8920,
        "startLineNumber" : 2013,
        "startColumnNumber" : 16,
        "endLineNumber" : 2152,
        "endColumnNumber" : 17
      },
      "nodeContext" : "for (RPCRequest request : runningRequests) {\n  if (request.respondsToMessageId(resultMid)) {\n    found=true;\n    boolean discardResponse=false;\n    boolean isError=false;\n    if (request.completionBlock != null) {\n      TLRPC.TL_error implicitError=null;\n      if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n        TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n        TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n        if (uncomressed == null) {\n          System.gc();\n          uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n        }\n        if (uncomressed == null) {\n          throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n        }\n        resultContainer.result=uncomressed;\n      }\n      if (resultContainer.result instanceof TLRPC.RpcError) {\n        String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n        FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n        int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n        if (errorCode == 500 || errorCode < 0) {\n          if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n            if (request.serverFailureCount < 1) {\n              discardResponse=true;\n              request.runningMinStartTime=request.runningStartTime + 1;\n            }\n          }\n else {\n            discardResponse=true;\n            int delay=Math.min(1,request.serverFailureCount * 2);\n            request.runningMinStartTime=request.runningStartTime + delay;\n            request.confirmed=false;\n          }\n          request.serverFailureCount++;\n        }\n else         if (errorCode == 420) {\n          if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n            double waitTime=2.0;\n            if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n              String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n              Pattern pattern=Pattern.compile(\"[0-9]+\");\n              Matcher matcher=pattern.matcher(errorMsg);\n              if (matcher.find()) {\n                errorMsg=matcher.group(0);\n              }\n              Integer val;\n              try {\n                val=Integer.parseInt(errorMsg);\n              }\n catch (              Exception e) {\n                val=null;\n              }\n              if (val != null) {\n                waitTime=val;\n              }\n            }\n            waitTime=Math.min(30,waitTime);\n            discardResponse=true;\n            request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n            request.confirmed=false;\n          }\n        }\n        implicitError=new TLRPC.TL_error();\n        implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n        implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n      }\n else       if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n        if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n          if (request.rawRequest == null) {\n            FileLog.e(\"tmessages\",\"rawRequest is null\");\n          }\n else {\n            FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n          }\n          implicitError=new TLRPC.TL_error();\n          implicitError.code=-1000;\n        }\n      }\n      if (!discardResponse) {\n        if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n          isError=true;\n          request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n        }\n else {\n          request.completionBlock.run(resultContainer.result,null);\n        }\n      }\n      if (implicitError != null && implicitError.code == 401) {\n        isError=true;\n        if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n          if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n            if (UserConfig.clientActivated) {\n              UserConfig.clearConfig();\n              Utilities.RunOnUIThread(new Runnable(){\n                @Override public void run(){\n                  NotificationCenter.getInstance().postNotificationName(1234);\n                }\n              }\n);\n            }\n          }\n        }\n else {\n          datacenter.authorized=false;\n          saveSession();\n          discardResponse=true;\n          if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n            retryRequestsFromDatacenter=datacenter.datacenterId;\n            retryRequestsClass=request.flags;\n          }\n        }\n      }\n    }\n    if (!discardResponse) {\n      if (request.initRequest && !isError) {\n        if (datacenter.lastInitVersion != currentAppVersion) {\n          datacenter.lastInitVersion=currentAppVersion;\n          saveSession();\n          FileLog.e(\"tmessages\",\"init connection completed\");\n        }\n else {\n          FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n        }\n      }\n      rpcCompleted(resultMid);\n    }\n else {\n      request.runningMessageId=0;\n      request.runningMessageSeqNo=0;\n      request.transportChannelToken=0;\n    }\n    break;\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 756,
      "astHeight" : 24
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 9275,
        "startLineNumber" : 2010,
        "startColumnNumber" : 31,
        "endLineNumber" : 2162,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  boolean found=false;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(resultMid)) {\n      found=true;\n      boolean discardResponse=false;\n      boolean isError=false;\n      if (request.completionBlock != null) {\n        TLRPC.TL_error implicitError=null;\n        if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n          TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n          TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n          if (uncomressed == null) {\n            System.gc();\n            uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n          }\n          if (uncomressed == null) {\n            throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n          }\n          resultContainer.result=uncomressed;\n        }\n        if (resultContainer.result instanceof TLRPC.RpcError) {\n          String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n          FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n          int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n          if (errorCode == 500 || errorCode < 0) {\n            if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n              if (request.serverFailureCount < 1) {\n                discardResponse=true;\n                request.runningMinStartTime=request.runningStartTime + 1;\n              }\n            }\n else {\n              discardResponse=true;\n              int delay=Math.min(1,request.serverFailureCount * 2);\n              request.runningMinStartTime=request.runningStartTime + delay;\n              request.confirmed=false;\n            }\n            request.serverFailureCount++;\n          }\n else           if (errorCode == 420) {\n            if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n              double waitTime=2.0;\n              if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                Pattern pattern=Pattern.compile(\"[0-9]+\");\n                Matcher matcher=pattern.matcher(errorMsg);\n                if (matcher.find()) {\n                  errorMsg=matcher.group(0);\n                }\n                Integer val;\n                try {\n                  val=Integer.parseInt(errorMsg);\n                }\n catch (                Exception e) {\n                  val=null;\n                }\n                if (val != null) {\n                  waitTime=val;\n                }\n              }\n              waitTime=Math.min(30,waitTime);\n              discardResponse=true;\n              request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n              request.confirmed=false;\n            }\n          }\n          implicitError=new TLRPC.TL_error();\n          implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n          implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n        }\n else         if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n          if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n            if (request.rawRequest == null) {\n              FileLog.e(\"tmessages\",\"rawRequest is null\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=-1000;\n          }\n        }\n        if (!discardResponse) {\n          if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n            isError=true;\n            request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n          }\n else {\n            request.completionBlock.run(resultContainer.result,null);\n          }\n        }\n        if (implicitError != null && implicitError.code == 401) {\n          isError=true;\n          if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n            if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n              if (UserConfig.clientActivated) {\n                UserConfig.clearConfig();\n                Utilities.RunOnUIThread(new Runnable(){\n                  @Override public void run(){\n                    NotificationCenter.getInstance().postNotificationName(1234);\n                  }\n                }\n);\n              }\n            }\n          }\n else {\n            datacenter.authorized=false;\n            saveSession();\n            discardResponse=true;\n            if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n              retryRequestsFromDatacenter=datacenter.datacenterId;\n              retryRequestsClass=request.flags;\n            }\n          }\n        }\n      }\n      if (!discardResponse) {\n        if (request.initRequest && !isError) {\n          if (datacenter.lastInitVersion != currentAppVersion) {\n            datacenter.lastInitVersion=currentAppVersion;\n            saveSession();\n            FileLog.e(\"tmessages\",\"init connection completed\");\n          }\n else {\n            FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n          }\n        }\n        rpcCompleted(resultMid);\n      }\n else {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.transportChannelToken=0;\n      }\n      break;\n    }\n  }\n  resultContainer.freeResources();\n  if (!found) {\n    FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n    rpcCompleted(resultMid);\n  }\n  messagesConfirmed(resultMid);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 784,
      "astHeight" : 25
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 9294,
        "startLineNumber" : 2010,
        "startColumnNumber" : 12,
        "endLineNumber" : 2162,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (!ignoreResult) {\n  boolean found=false;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(resultMid)) {\n      found=true;\n      boolean discardResponse=false;\n      boolean isError=false;\n      if (request.completionBlock != null) {\n        TLRPC.TL_error implicitError=null;\n        if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n          TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n          TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n          if (uncomressed == null) {\n            System.gc();\n            uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n          }\n          if (uncomressed == null) {\n            throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n          }\n          resultContainer.result=uncomressed;\n        }\n        if (resultContainer.result instanceof TLRPC.RpcError) {\n          String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n          FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n          int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n          if (errorCode == 500 || errorCode < 0) {\n            if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n              if (request.serverFailureCount < 1) {\n                discardResponse=true;\n                request.runningMinStartTime=request.runningStartTime + 1;\n              }\n            }\n else {\n              discardResponse=true;\n              int delay=Math.min(1,request.serverFailureCount * 2);\n              request.runningMinStartTime=request.runningStartTime + delay;\n              request.confirmed=false;\n            }\n            request.serverFailureCount++;\n          }\n else           if (errorCode == 420) {\n            if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n              double waitTime=2.0;\n              if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                Pattern pattern=Pattern.compile(\"[0-9]+\");\n                Matcher matcher=pattern.matcher(errorMsg);\n                if (matcher.find()) {\n                  errorMsg=matcher.group(0);\n                }\n                Integer val;\n                try {\n                  val=Integer.parseInt(errorMsg);\n                }\n catch (                Exception e) {\n                  val=null;\n                }\n                if (val != null) {\n                  waitTime=val;\n                }\n              }\n              waitTime=Math.min(30,waitTime);\n              discardResponse=true;\n              request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n              request.confirmed=false;\n            }\n          }\n          implicitError=new TLRPC.TL_error();\n          implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n          implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n        }\n else         if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n          if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n            if (request.rawRequest == null) {\n              FileLog.e(\"tmessages\",\"rawRequest is null\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=-1000;\n          }\n        }\n        if (!discardResponse) {\n          if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n            isError=true;\n            request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n          }\n else {\n            request.completionBlock.run(resultContainer.result,null);\n          }\n        }\n        if (implicitError != null && implicitError.code == 401) {\n          isError=true;\n          if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n            if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n              if (UserConfig.clientActivated) {\n                UserConfig.clearConfig();\n                Utilities.RunOnUIThread(new Runnable(){\n                  @Override public void run(){\n                    NotificationCenter.getInstance().postNotificationName(1234);\n                  }\n                }\n);\n              }\n            }\n          }\n else {\n            datacenter.authorized=false;\n            saveSession();\n            discardResponse=true;\n            if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n              retryRequestsFromDatacenter=datacenter.datacenterId;\n              retryRequestsClass=request.flags;\n            }\n          }\n        }\n      }\n      if (!discardResponse) {\n        if (request.initRequest && !isError) {\n          if (datacenter.lastInitVersion != currentAppVersion) {\n            datacenter.lastInitVersion=currentAppVersion;\n            saveSession();\n            FileLog.e(\"tmessages\",\"init connection completed\");\n          }\n else {\n            FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n          }\n        }\n        rpcCompleted(resultMid);\n      }\n else {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.transportChannelToken=0;\n      }\n      break;\n    }\n  }\n  resultContainer.freeResources();\n  if (!found) {\n    FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n    rpcCompleted(resultMid);\n  }\n  messagesConfirmed(resultMid);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 787,
      "astHeight" : 26
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 11910,
        "startLineNumber" : 1958,
        "startColumnNumber" : 59,
        "endLineNumber" : 2169,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1050,
      "astHeight" : 27
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 16541,
        "startLineNumber" : 1958,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1595,
      "astHeight" : 28
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 17208,
        "startLineNumber" : 1946,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1682,
      "astHeight" : 29
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 17883,
        "startLineNumber" : 1929,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1751,
      "astHeight" : 30
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 19081,
        "startLineNumber" : 1902,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1908,
      "astHeight" : 31
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 20361,
        "startLineNumber" : 1878,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2020,
      "astHeight" : 32
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 22534,
        "startLineNumber" : 1839,
        "startColumnNumber" : 8,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_new_session_created) {\n  TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n  ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n  if (arr == null) {\n    arr=new ArrayList<Long>();\n    processedSessionChanges.put(sessionId,arr);\n  }\n  if (!arr.contains(newSession.unique_id)) {\n    FileLog.d(\"tmessages\",\"New session:\");\n    FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n    FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n    FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n    long serverSalt=newSession.server_salt;\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=serverSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    for (    RPCRequest request : runningRequests) {\n      Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n      if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.runningStartTime=0;\n        request.runningMinStartTime=0;\n        request.transportChannelToken=0;\n      }\n    }\n    saveSession();\n    if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n      MessagesController.getInstance().getDifference();\n    }\n    arr.add(newSession.unique_id);\n  }\n}\n else if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2280,
      "astHeight" : 33
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 22747,
        "startLineNumber" : 1832,
        "startColumnNumber" : 178,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2303,
      "astHeight" : 34
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 22921,
        "startLineNumber" : 1832,
        "startColumnNumber" : 4,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "void processMessage(TLObject message,long messageId,int messageSeqNo,long messageSalt,TcpConnection connection,long sessionId,long innerMsgId,long containerMessageId){\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 2332,
      "astHeight" : 35
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 12,
        "startLineNumber" : 2025,
        "startColumnNumber" : 36,
        "endLineNumber" : 2025,
        "endColumnNumber" : 48
      },
      "nodeContext" : "System.gc();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 4,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.System"
  }, {
    "nodeContext" : "System",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 2079,
      "startColumnNumber" : 76,
      "endLineNumber" : 2079,
      "endColumnNumber" : 82
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 2079,
        "startColumnNumber" : 76,
        "endLineNumber" : 2079,
        "endColumnNumber" : 102
      },
      "nodeContext" : "System.currentTimeMillis()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 2079,
        "startColumnNumber" : 76,
        "endLineNumber" : 2079,
        "endColumnNumber" : 109
      },
      "nodeContext" : "System.currentTimeMillis() / 1000",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 2079,
        "startColumnNumber" : 76,
        "endLineNumber" : 2079,
        "endColumnNumber" : 120
      },
      "nodeContext" : "System.currentTimeMillis() / 1000 + waitTime",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CastExpression,expression]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 2079,
        "startColumnNumber" : 75,
        "endLineNumber" : 2079,
        "endColumnNumber" : 121
      },
      "nodeContext" : "(System.currentTimeMillis() / 1000 + waitTime)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 2079,
        "startColumnNumber" : 70,
        "endLineNumber" : 2079,
        "endColumnNumber" : 121
      },
      "nodeContext" : "(int)(System.currentTimeMillis() / 1000 + waitTime)",
      "nodeType" : "CastExpression",
      "astNodeNumber" : 10,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 2079,
        "startColumnNumber" : 40,
        "endLineNumber" : 2079,
        "endColumnNumber" : 121
      },
      "nodeContext" : "request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 14,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 2079,
        "startColumnNumber" : 40,
        "endLineNumber" : 2079,
        "endColumnNumber" : 122
      },
      "nodeContext" : "request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 15,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1568,
        "startLineNumber" : 2053,
        "startColumnNumber" : 109,
        "endLineNumber" : 2081,
        "endColumnNumber" : 37
      },
      "nodeContext" : "{\n  double waitTime=2.0;\n  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n    Pattern pattern=Pattern.compile(\"[0-9]+\");\n    Matcher matcher=pattern.matcher(errorMsg);\n    if (matcher.find()) {\n      errorMsg=matcher.group(0);\n    }\n    Integer val;\n    try {\n      val=Integer.parseInt(errorMsg);\n    }\n catch (    Exception e) {\n      val=null;\n    }\n    if (val != null) {\n      waitTime=val;\n    }\n  }\n  waitTime=Math.min(30,waitTime);\n  discardResponse=true;\n  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n  request.confirmed=false;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 118,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1641,
        "startLineNumber" : 2053,
        "startColumnNumber" : 36,
        "endLineNumber" : 2081,
        "endColumnNumber" : 37
      },
      "nodeContext" : "if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n  double waitTime=2.0;\n  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n    Pattern pattern=Pattern.compile(\"[0-9]+\");\n    Matcher matcher=pattern.matcher(errorMsg);\n    if (matcher.find()) {\n      errorMsg=matcher.group(0);\n    }\n    Integer val;\n    try {\n      val=Integer.parseInt(errorMsg);\n    }\n catch (    Exception e) {\n      val=null;\n    }\n    if (val != null) {\n      waitTime=val;\n    }\n  }\n  waitTime=Math.min(30,waitTime);\n  discardResponse=true;\n  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n  request.confirmed=false;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 129,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 2052,
        "startColumnNumber" : 61,
        "endLineNumber" : 2082,
        "endColumnNumber" : 33
      },
      "nodeContext" : "{\n  if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n    double waitTime=2.0;\n    if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n      String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n      Pattern pattern=Pattern.compile(\"[0-9]+\");\n      Matcher matcher=pattern.matcher(errorMsg);\n      if (matcher.find()) {\n        errorMsg=matcher.group(0);\n      }\n      Integer val;\n      try {\n        val=Integer.parseInt(errorMsg);\n      }\n catch (      Exception e) {\n        val=null;\n      }\n      if (val != null) {\n        waitTime=val;\n      }\n    }\n    waitTime=Math.min(30,waitTime);\n    discardResponse=true;\n    request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n    request.confirmed=false;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 130,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 1735,
        "startLineNumber" : 2052,
        "startColumnNumber" : 39,
        "endLineNumber" : 2082,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (errorCode == 420) {\n  if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n    double waitTime=2.0;\n    if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n      String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n      Pattern pattern=Pattern.compile(\"[0-9]+\");\n      Matcher matcher=pattern.matcher(errorMsg);\n      if (matcher.find()) {\n        errorMsg=matcher.group(0);\n      }\n      Integer val;\n      try {\n        val=Integer.parseInt(errorMsg);\n      }\n catch (      Exception e) {\n        val=null;\n      }\n      if (val != null) {\n        waitTime=val;\n      }\n    }\n    waitTime=Math.min(30,waitTime);\n    discardResponse=true;\n    request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n    request.confirmed=false;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 134,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2699,
        "startLineNumber" : 2039,
        "startColumnNumber" : 32,
        "endLineNumber" : 2082,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (errorCode == 500 || errorCode < 0) {\n  if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n    if (request.serverFailureCount < 1) {\n      discardResponse=true;\n      request.runningMinStartTime=request.runningStartTime + 1;\n    }\n  }\n else {\n    discardResponse=true;\n    int delay=Math.min(1,request.serverFailureCount * 2);\n    request.runningMinStartTime=request.runningStartTime + delay;\n    request.confirmed=false;\n  }\n  request.serverFailureCount++;\n}\n else if (errorCode == 420) {\n  if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n    double waitTime=2.0;\n    if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n      String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n      Pattern pattern=Pattern.compile(\"[0-9]+\");\n      Matcher matcher=pattern.matcher(errorMsg);\n      if (matcher.find()) {\n        errorMsg=matcher.group(0);\n      }\n      Integer val;\n      try {\n        val=Integer.parseInt(errorMsg);\n      }\n catch (      Exception e) {\n        val=null;\n      }\n      if (val != null) {\n        waitTime=val;\n      }\n    }\n    waitTime=Math.min(30,waitTime);\n    discardResponse=true;\n    request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n    request.confirmed=false;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 215,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 3429,
        "startLineNumber" : 2033,
        "startColumnNumber" : 82,
        "endLineNumber" : 2087,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n  FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n  int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n  if (errorCode == 500 || errorCode < 0) {\n    if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n      if (request.serverFailureCount < 1) {\n        discardResponse=true;\n        request.runningMinStartTime=request.runningStartTime + 1;\n      }\n    }\n else {\n      discardResponse=true;\n      int delay=Math.min(1,request.serverFailureCount * 2);\n      request.runningMinStartTime=request.runningStartTime + delay;\n      request.confirmed=false;\n    }\n    request.serverFailureCount++;\n  }\n else   if (errorCode == 420) {\n    if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n      double waitTime=2.0;\n      if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n        String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n        Pattern pattern=Pattern.compile(\"[0-9]+\");\n        Matcher matcher=pattern.matcher(errorMsg);\n        if (matcher.find()) {\n          errorMsg=matcher.group(0);\n        }\n        Integer val;\n        try {\n          val=Integer.parseInt(errorMsg);\n        }\n catch (        Exception e) {\n          val=null;\n        }\n        if (val != null) {\n          waitTime=val;\n        }\n      }\n      waitTime=Math.min(30,waitTime);\n      discardResponse=true;\n      request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n      request.confirmed=false;\n    }\n  }\n  implicitError=new TLRPC.TL_error();\n  implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n  implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 308,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4337,
        "startLineNumber" : 2033,
        "startColumnNumber" : 28,
        "endLineNumber" : 2097,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (resultContainer.result instanceof TLRPC.RpcError) {\n  String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n  FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n  int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n  if (errorCode == 500 || errorCode < 0) {\n    if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n      if (request.serverFailureCount < 1) {\n        discardResponse=true;\n        request.runningMinStartTime=request.runningStartTime + 1;\n      }\n    }\n else {\n      discardResponse=true;\n      int delay=Math.min(1,request.serverFailureCount * 2);\n      request.runningMinStartTime=request.runningStartTime + delay;\n      request.confirmed=false;\n    }\n    request.serverFailureCount++;\n  }\n else   if (errorCode == 420) {\n    if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n      double waitTime=2.0;\n      if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n        String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n        Pattern pattern=Pattern.compile(\"[0-9]+\");\n        Matcher matcher=pattern.matcher(errorMsg);\n        if (matcher.find()) {\n          errorMsg=matcher.group(0);\n        }\n        Integer val;\n        try {\n          val=Integer.parseInt(errorMsg);\n        }\n catch (        Exception e) {\n          val=null;\n        }\n        if (val != null) {\n          waitTime=val;\n        }\n      }\n      waitTime=Math.min(30,waitTime);\n      discardResponse=true;\n      request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n      request.confirmed=false;\n    }\n  }\n  implicitError=new TLRPC.TL_error();\n  implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n  implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n}\n else if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n  if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n    if (request.rawRequest == null) {\n      FileLog.e(\"tmessages\",\"rawRequest is null\");\n    }\n else {\n      FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n    }\n    implicitError=new TLRPC.TL_error();\n    implicitError.code=-1000;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 396,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7592,
        "startLineNumber" : 2019,
        "startColumnNumber" : 61,
        "endLineNumber" : 2132,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  TLRPC.TL_error implicitError=null;\n  if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n    TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n    if (uncomressed == null) {\n      System.gc();\n      uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n    }\n    if (uncomressed == null) {\n      throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n    }\n    resultContainer.result=uncomressed;\n  }\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n    if (errorCode == 500 || errorCode < 0) {\n      if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n        if (request.serverFailureCount < 1) {\n          discardResponse=true;\n          request.runningMinStartTime=request.runningStartTime + 1;\n        }\n      }\n else {\n        discardResponse=true;\n        int delay=Math.min(1,request.serverFailureCount * 2);\n        request.runningMinStartTime=request.runningStartTime + delay;\n        request.confirmed=false;\n      }\n      request.serverFailureCount++;\n    }\n else     if (errorCode == 420) {\n      if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n        double waitTime=2.0;\n        if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n          String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            waitTime=val;\n          }\n        }\n        waitTime=Math.min(30,waitTime);\n        discardResponse=true;\n        request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n        request.confirmed=false;\n      }\n    }\n    implicitError=new TLRPC.TL_error();\n    implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n    implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n  }\n else   if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n    if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n      if (request.rawRequest == null) {\n        FileLog.e(\"tmessages\",\"rawRequest is null\");\n      }\n else {\n        FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n      }\n      implicitError=new TLRPC.TL_error();\n      implicitError.code=-1000;\n    }\n  }\n  if (!discardResponse) {\n    if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n      isError=true;\n      request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n    }\n else {\n      request.completionBlock.run(resultContainer.result,null);\n    }\n  }\n  if (implicitError != null && implicitError.code == 401) {\n    isError=true;\n    if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n      if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n        if (UserConfig.clientActivated) {\n          UserConfig.clearConfig();\n          Utilities.RunOnUIThread(new Runnable(){\n            @Override public void run(){\n              NotificationCenter.getInstance().postNotificationName(1234);\n            }\n          }\n);\n        }\n      }\n    }\n else {\n      datacenter.authorized=false;\n      saveSession();\n      discardResponse=true;\n      if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n        retryRequestsFromDatacenter=datacenter.datacenterId;\n        retryRequestsClass=request.flags;\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 658,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7629,
        "startLineNumber" : 2019,
        "startColumnNumber" : 24,
        "endLineNumber" : 2132,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (request.completionBlock != null) {\n  TLRPC.TL_error implicitError=null;\n  if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n    TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n    if (uncomressed == null) {\n      System.gc();\n      uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n    }\n    if (uncomressed == null) {\n      throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n    }\n    resultContainer.result=uncomressed;\n  }\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n    if (errorCode == 500 || errorCode < 0) {\n      if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n        if (request.serverFailureCount < 1) {\n          discardResponse=true;\n          request.runningMinStartTime=request.runningStartTime + 1;\n        }\n      }\n else {\n        discardResponse=true;\n        int delay=Math.min(1,request.serverFailureCount * 2);\n        request.runningMinStartTime=request.runningStartTime + delay;\n        request.confirmed=false;\n      }\n      request.serverFailureCount++;\n    }\n else     if (errorCode == 420) {\n      if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n        double waitTime=2.0;\n        if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n          String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            waitTime=val;\n          }\n        }\n        waitTime=Math.min(30,waitTime);\n        discardResponse=true;\n        request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n        request.confirmed=false;\n      }\n    }\n    implicitError=new TLRPC.TL_error();\n    implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n    implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n  }\n else   if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n    if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n      if (request.rawRequest == null) {\n        FileLog.e(\"tmessages\",\"rawRequest is null\");\n      }\n else {\n        FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n      }\n      implicitError=new TLRPC.TL_error();\n      implicitError.code=-1000;\n    }\n  }\n  if (!discardResponse) {\n    if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n      isError=true;\n      request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n    }\n else {\n      request.completionBlock.run(resultContainer.result,null);\n    }\n  }\n  if (implicitError != null && implicitError.code == 401) {\n    isError=true;\n    if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n      if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n        if (UserConfig.clientActivated) {\n          UserConfig.clearConfig();\n          Utilities.RunOnUIThread(new Runnable(){\n            @Override public void run(){\n              NotificationCenter.getInstance().postNotificationName(1234);\n            }\n          }\n);\n        }\n      }\n    }\n else {\n      datacenter.authorized=false;\n      saveSession();\n      discardResponse=true;\n      if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n        retryRequestsFromDatacenter=datacenter.datacenterId;\n        retryRequestsClass=request.flags;\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 664,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 8793,
        "startLineNumber" : 2014,
        "startColumnNumber" : 64,
        "endLineNumber" : 2151,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  found=true;\n  boolean discardResponse=false;\n  boolean isError=false;\n  if (request.completionBlock != null) {\n    TLRPC.TL_error implicitError=null;\n    if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n      TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n      TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n      if (uncomressed == null) {\n        System.gc();\n        uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n      }\n      if (uncomressed == null) {\n        throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n      }\n      resultContainer.result=uncomressed;\n    }\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n      if (errorCode == 500 || errorCode < 0) {\n        if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n          if (request.serverFailureCount < 1) {\n            discardResponse=true;\n            request.runningMinStartTime=request.runningStartTime + 1;\n          }\n        }\n else {\n          discardResponse=true;\n          int delay=Math.min(1,request.serverFailureCount * 2);\n          request.runningMinStartTime=request.runningStartTime + delay;\n          request.confirmed=false;\n        }\n        request.serverFailureCount++;\n      }\n else       if (errorCode == 420) {\n        if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n          double waitTime=2.0;\n          if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n            String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              waitTime=val;\n            }\n          }\n          waitTime=Math.min(30,waitTime);\n          discardResponse=true;\n          request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n          request.confirmed=false;\n        }\n      }\n      implicitError=new TLRPC.TL_error();\n      implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n      implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n    }\n else     if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n      if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n        if (request.rawRequest == null) {\n          FileLog.e(\"tmessages\",\"rawRequest is null\");\n        }\n else {\n          FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n        }\n        implicitError=new TLRPC.TL_error();\n        implicitError.code=-1000;\n      }\n    }\n    if (!discardResponse) {\n      if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n        isError=true;\n        request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n      }\n else {\n        request.completionBlock.run(resultContainer.result,null);\n      }\n    }\n    if (implicitError != null && implicitError.code == 401) {\n      isError=true;\n      if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n        if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n          if (UserConfig.clientActivated) {\n            UserConfig.clearConfig();\n            Utilities.RunOnUIThread(new Runnable(){\n              @Override public void run(){\n                NotificationCenter.getInstance().postNotificationName(1234);\n              }\n            }\n);\n          }\n        }\n      }\n else {\n        datacenter.authorized=false;\n        saveSession();\n        discardResponse=true;\n        if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n          retryRequestsFromDatacenter=datacenter.datacenterId;\n          retryRequestsClass=request.flags;\n        }\n      }\n    }\n  }\n  if (!discardResponse) {\n    if (request.initRequest && !isError) {\n      if (datacenter.lastInitVersion != currentAppVersion) {\n        datacenter.lastInitVersion=currentAppVersion;\n        saveSession();\n        FileLog.e(\"tmessages\",\"init connection completed\");\n      }\n else {\n        FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n      }\n    }\n    rpcCompleted(resultMid);\n  }\n else {\n    request.runningMessageId=0;\n    request.runningMessageSeqNo=0;\n    request.transportChannelToken=0;\n  }\n  break;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 744,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8837,
        "startLineNumber" : 2014,
        "startColumnNumber" : 20,
        "endLineNumber" : 2151,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (request.respondsToMessageId(resultMid)) {\n  found=true;\n  boolean discardResponse=false;\n  boolean isError=false;\n  if (request.completionBlock != null) {\n    TLRPC.TL_error implicitError=null;\n    if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n      TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n      TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n      if (uncomressed == null) {\n        System.gc();\n        uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n      }\n      if (uncomressed == null) {\n        throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n      }\n      resultContainer.result=uncomressed;\n    }\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n      if (errorCode == 500 || errorCode < 0) {\n        if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n          if (request.serverFailureCount < 1) {\n            discardResponse=true;\n            request.runningMinStartTime=request.runningStartTime + 1;\n          }\n        }\n else {\n          discardResponse=true;\n          int delay=Math.min(1,request.serverFailureCount * 2);\n          request.runningMinStartTime=request.runningStartTime + delay;\n          request.confirmed=false;\n        }\n        request.serverFailureCount++;\n      }\n else       if (errorCode == 420) {\n        if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n          double waitTime=2.0;\n          if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n            String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              waitTime=val;\n            }\n          }\n          waitTime=Math.min(30,waitTime);\n          discardResponse=true;\n          request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n          request.confirmed=false;\n        }\n      }\n      implicitError=new TLRPC.TL_error();\n      implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n      implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n    }\n else     if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n      if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n        if (request.rawRequest == null) {\n          FileLog.e(\"tmessages\",\"rawRequest is null\");\n        }\n else {\n          FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n        }\n        implicitError=new TLRPC.TL_error();\n        implicitError.code=-1000;\n      }\n    }\n    if (!discardResponse) {\n      if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n        isError=true;\n        request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n      }\n else {\n        request.completionBlock.run(resultContainer.result,null);\n      }\n    }\n    if (implicitError != null && implicitError.code == 401) {\n      isError=true;\n      if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n        if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n          if (UserConfig.clientActivated) {\n            UserConfig.clearConfig();\n            Utilities.RunOnUIThread(new Runnable(){\n              @Override public void run(){\n                NotificationCenter.getInstance().postNotificationName(1234);\n              }\n            }\n);\n          }\n        }\n      }\n else {\n        datacenter.authorized=false;\n        saveSession();\n        discardResponse=true;\n        if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n          retryRequestsFromDatacenter=datacenter.datacenterId;\n          retryRequestsClass=request.flags;\n        }\n      }\n    }\n  }\n  if (!discardResponse) {\n    if (request.initRequest && !isError) {\n      if (datacenter.lastInitVersion != currentAppVersion) {\n        datacenter.lastInitVersion=currentAppVersion;\n        saveSession();\n        FileLog.e(\"tmessages\",\"init connection completed\");\n      }\n else {\n        FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n      }\n    }\n    rpcCompleted(resultMid);\n  }\n else {\n    request.runningMessageId=0;\n    request.runningMessageSeqNo=0;\n    request.transportChannelToken=0;\n  }\n  break;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 749,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 8877,
        "startLineNumber" : 2013,
        "startColumnNumber" : 59,
        "endLineNumber" : 2152,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  if (request.respondsToMessageId(resultMid)) {\n    found=true;\n    boolean discardResponse=false;\n    boolean isError=false;\n    if (request.completionBlock != null) {\n      TLRPC.TL_error implicitError=null;\n      if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n        TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n        TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n        if (uncomressed == null) {\n          System.gc();\n          uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n        }\n        if (uncomressed == null) {\n          throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n        }\n        resultContainer.result=uncomressed;\n      }\n      if (resultContainer.result instanceof TLRPC.RpcError) {\n        String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n        FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n        int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n        if (errorCode == 500 || errorCode < 0) {\n          if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n            if (request.serverFailureCount < 1) {\n              discardResponse=true;\n              request.runningMinStartTime=request.runningStartTime + 1;\n            }\n          }\n else {\n            discardResponse=true;\n            int delay=Math.min(1,request.serverFailureCount * 2);\n            request.runningMinStartTime=request.runningStartTime + delay;\n            request.confirmed=false;\n          }\n          request.serverFailureCount++;\n        }\n else         if (errorCode == 420) {\n          if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n            double waitTime=2.0;\n            if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n              String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n              Pattern pattern=Pattern.compile(\"[0-9]+\");\n              Matcher matcher=pattern.matcher(errorMsg);\n              if (matcher.find()) {\n                errorMsg=matcher.group(0);\n              }\n              Integer val;\n              try {\n                val=Integer.parseInt(errorMsg);\n              }\n catch (              Exception e) {\n                val=null;\n              }\n              if (val != null) {\n                waitTime=val;\n              }\n            }\n            waitTime=Math.min(30,waitTime);\n            discardResponse=true;\n            request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n            request.confirmed=false;\n          }\n        }\n        implicitError=new TLRPC.TL_error();\n        implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n        implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n      }\n else       if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n        if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n          if (request.rawRequest == null) {\n            FileLog.e(\"tmessages\",\"rawRequest is null\");\n          }\n else {\n            FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n          }\n          implicitError=new TLRPC.TL_error();\n          implicitError.code=-1000;\n        }\n      }\n      if (!discardResponse) {\n        if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n          isError=true;\n          request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n        }\n else {\n          request.completionBlock.run(resultContainer.result,null);\n        }\n      }\n      if (implicitError != null && implicitError.code == 401) {\n        isError=true;\n        if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n          if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n            if (UserConfig.clientActivated) {\n              UserConfig.clearConfig();\n              Utilities.RunOnUIThread(new Runnable(){\n                @Override public void run(){\n                  NotificationCenter.getInstance().postNotificationName(1234);\n                }\n              }\n);\n            }\n          }\n        }\n else {\n          datacenter.authorized=false;\n          saveSession();\n          discardResponse=true;\n          if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n            retryRequestsFromDatacenter=datacenter.datacenterId;\n            retryRequestsClass=request.flags;\n          }\n        }\n      }\n    }\n    if (!discardResponse) {\n      if (request.initRequest && !isError) {\n        if (datacenter.lastInitVersion != currentAppVersion) {\n          datacenter.lastInitVersion=currentAppVersion;\n          saveSession();\n          FileLog.e(\"tmessages\",\"init connection completed\");\n        }\n else {\n          FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n        }\n      }\n      rpcCompleted(resultMid);\n    }\n else {\n      request.runningMessageId=0;\n      request.runningMessageSeqNo=0;\n      request.transportChannelToken=0;\n    }\n    break;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 750,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8920,
        "startLineNumber" : 2013,
        "startColumnNumber" : 16,
        "endLineNumber" : 2152,
        "endColumnNumber" : 17
      },
      "nodeContext" : "for (RPCRequest request : runningRequests) {\n  if (request.respondsToMessageId(resultMid)) {\n    found=true;\n    boolean discardResponse=false;\n    boolean isError=false;\n    if (request.completionBlock != null) {\n      TLRPC.TL_error implicitError=null;\n      if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n        TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n        TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n        if (uncomressed == null) {\n          System.gc();\n          uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n        }\n        if (uncomressed == null) {\n          throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n        }\n        resultContainer.result=uncomressed;\n      }\n      if (resultContainer.result instanceof TLRPC.RpcError) {\n        String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n        FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n        int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n        if (errorCode == 500 || errorCode < 0) {\n          if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n            if (request.serverFailureCount < 1) {\n              discardResponse=true;\n              request.runningMinStartTime=request.runningStartTime + 1;\n            }\n          }\n else {\n            discardResponse=true;\n            int delay=Math.min(1,request.serverFailureCount * 2);\n            request.runningMinStartTime=request.runningStartTime + delay;\n            request.confirmed=false;\n          }\n          request.serverFailureCount++;\n        }\n else         if (errorCode == 420) {\n          if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n            double waitTime=2.0;\n            if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n              String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n              Pattern pattern=Pattern.compile(\"[0-9]+\");\n              Matcher matcher=pattern.matcher(errorMsg);\n              if (matcher.find()) {\n                errorMsg=matcher.group(0);\n              }\n              Integer val;\n              try {\n                val=Integer.parseInt(errorMsg);\n              }\n catch (              Exception e) {\n                val=null;\n              }\n              if (val != null) {\n                waitTime=val;\n              }\n            }\n            waitTime=Math.min(30,waitTime);\n            discardResponse=true;\n            request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n            request.confirmed=false;\n          }\n        }\n        implicitError=new TLRPC.TL_error();\n        implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n        implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n      }\n else       if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n        if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n          if (request.rawRequest == null) {\n            FileLog.e(\"tmessages\",\"rawRequest is null\");\n          }\n else {\n            FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n          }\n          implicitError=new TLRPC.TL_error();\n          implicitError.code=-1000;\n        }\n      }\n      if (!discardResponse) {\n        if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n          isError=true;\n          request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n        }\n else {\n          request.completionBlock.run(resultContainer.result,null);\n        }\n      }\n      if (implicitError != null && implicitError.code == 401) {\n        isError=true;\n        if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n          if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n            if (UserConfig.clientActivated) {\n              UserConfig.clearConfig();\n              Utilities.RunOnUIThread(new Runnable(){\n                @Override public void run(){\n                  NotificationCenter.getInstance().postNotificationName(1234);\n                }\n              }\n);\n            }\n          }\n        }\n else {\n          datacenter.authorized=false;\n          saveSession();\n          discardResponse=true;\n          if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n            retryRequestsFromDatacenter=datacenter.datacenterId;\n            retryRequestsClass=request.flags;\n          }\n        }\n      }\n    }\n    if (!discardResponse) {\n      if (request.initRequest && !isError) {\n        if (datacenter.lastInitVersion != currentAppVersion) {\n          datacenter.lastInitVersion=currentAppVersion;\n          saveSession();\n          FileLog.e(\"tmessages\",\"init connection completed\");\n        }\n else {\n          FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n        }\n      }\n      rpcCompleted(resultMid);\n    }\n else {\n      request.runningMessageId=0;\n      request.runningMessageSeqNo=0;\n      request.transportChannelToken=0;\n    }\n    break;\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 756,
      "astHeight" : 24
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 9275,
        "startLineNumber" : 2010,
        "startColumnNumber" : 31,
        "endLineNumber" : 2162,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  boolean found=false;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(resultMid)) {\n      found=true;\n      boolean discardResponse=false;\n      boolean isError=false;\n      if (request.completionBlock != null) {\n        TLRPC.TL_error implicitError=null;\n        if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n          TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n          TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n          if (uncomressed == null) {\n            System.gc();\n            uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n          }\n          if (uncomressed == null) {\n            throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n          }\n          resultContainer.result=uncomressed;\n        }\n        if (resultContainer.result instanceof TLRPC.RpcError) {\n          String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n          FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n          int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n          if (errorCode == 500 || errorCode < 0) {\n            if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n              if (request.serverFailureCount < 1) {\n                discardResponse=true;\n                request.runningMinStartTime=request.runningStartTime + 1;\n              }\n            }\n else {\n              discardResponse=true;\n              int delay=Math.min(1,request.serverFailureCount * 2);\n              request.runningMinStartTime=request.runningStartTime + delay;\n              request.confirmed=false;\n            }\n            request.serverFailureCount++;\n          }\n else           if (errorCode == 420) {\n            if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n              double waitTime=2.0;\n              if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                Pattern pattern=Pattern.compile(\"[0-9]+\");\n                Matcher matcher=pattern.matcher(errorMsg);\n                if (matcher.find()) {\n                  errorMsg=matcher.group(0);\n                }\n                Integer val;\n                try {\n                  val=Integer.parseInt(errorMsg);\n                }\n catch (                Exception e) {\n                  val=null;\n                }\n                if (val != null) {\n                  waitTime=val;\n                }\n              }\n              waitTime=Math.min(30,waitTime);\n              discardResponse=true;\n              request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n              request.confirmed=false;\n            }\n          }\n          implicitError=new TLRPC.TL_error();\n          implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n          implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n        }\n else         if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n          if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n            if (request.rawRequest == null) {\n              FileLog.e(\"tmessages\",\"rawRequest is null\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=-1000;\n          }\n        }\n        if (!discardResponse) {\n          if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n            isError=true;\n            request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n          }\n else {\n            request.completionBlock.run(resultContainer.result,null);\n          }\n        }\n        if (implicitError != null && implicitError.code == 401) {\n          isError=true;\n          if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n            if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n              if (UserConfig.clientActivated) {\n                UserConfig.clearConfig();\n                Utilities.RunOnUIThread(new Runnable(){\n                  @Override public void run(){\n                    NotificationCenter.getInstance().postNotificationName(1234);\n                  }\n                }\n);\n              }\n            }\n          }\n else {\n            datacenter.authorized=false;\n            saveSession();\n            discardResponse=true;\n            if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n              retryRequestsFromDatacenter=datacenter.datacenterId;\n              retryRequestsClass=request.flags;\n            }\n          }\n        }\n      }\n      if (!discardResponse) {\n        if (request.initRequest && !isError) {\n          if (datacenter.lastInitVersion != currentAppVersion) {\n            datacenter.lastInitVersion=currentAppVersion;\n            saveSession();\n            FileLog.e(\"tmessages\",\"init connection completed\");\n          }\n else {\n            FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n          }\n        }\n        rpcCompleted(resultMid);\n      }\n else {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.transportChannelToken=0;\n      }\n      break;\n    }\n  }\n  resultContainer.freeResources();\n  if (!found) {\n    FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n    rpcCompleted(resultMid);\n  }\n  messagesConfirmed(resultMid);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 784,
      "astHeight" : 25
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 9294,
        "startLineNumber" : 2010,
        "startColumnNumber" : 12,
        "endLineNumber" : 2162,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (!ignoreResult) {\n  boolean found=false;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(resultMid)) {\n      found=true;\n      boolean discardResponse=false;\n      boolean isError=false;\n      if (request.completionBlock != null) {\n        TLRPC.TL_error implicitError=null;\n        if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n          TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n          TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n          if (uncomressed == null) {\n            System.gc();\n            uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n          }\n          if (uncomressed == null) {\n            throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n          }\n          resultContainer.result=uncomressed;\n        }\n        if (resultContainer.result instanceof TLRPC.RpcError) {\n          String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n          FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n          int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n          if (errorCode == 500 || errorCode < 0) {\n            if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n              if (request.serverFailureCount < 1) {\n                discardResponse=true;\n                request.runningMinStartTime=request.runningStartTime + 1;\n              }\n            }\n else {\n              discardResponse=true;\n              int delay=Math.min(1,request.serverFailureCount * 2);\n              request.runningMinStartTime=request.runningStartTime + delay;\n              request.confirmed=false;\n            }\n            request.serverFailureCount++;\n          }\n else           if (errorCode == 420) {\n            if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n              double waitTime=2.0;\n              if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                Pattern pattern=Pattern.compile(\"[0-9]+\");\n                Matcher matcher=pattern.matcher(errorMsg);\n                if (matcher.find()) {\n                  errorMsg=matcher.group(0);\n                }\n                Integer val;\n                try {\n                  val=Integer.parseInt(errorMsg);\n                }\n catch (                Exception e) {\n                  val=null;\n                }\n                if (val != null) {\n                  waitTime=val;\n                }\n              }\n              waitTime=Math.min(30,waitTime);\n              discardResponse=true;\n              request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n              request.confirmed=false;\n            }\n          }\n          implicitError=new TLRPC.TL_error();\n          implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n          implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n        }\n else         if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n          if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n            if (request.rawRequest == null) {\n              FileLog.e(\"tmessages\",\"rawRequest is null\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=-1000;\n          }\n        }\n        if (!discardResponse) {\n          if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n            isError=true;\n            request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n          }\n else {\n            request.completionBlock.run(resultContainer.result,null);\n          }\n        }\n        if (implicitError != null && implicitError.code == 401) {\n          isError=true;\n          if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n            if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n              if (UserConfig.clientActivated) {\n                UserConfig.clearConfig();\n                Utilities.RunOnUIThread(new Runnable(){\n                  @Override public void run(){\n                    NotificationCenter.getInstance().postNotificationName(1234);\n                  }\n                }\n);\n              }\n            }\n          }\n else {\n            datacenter.authorized=false;\n            saveSession();\n            discardResponse=true;\n            if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n              retryRequestsFromDatacenter=datacenter.datacenterId;\n              retryRequestsClass=request.flags;\n            }\n          }\n        }\n      }\n      if (!discardResponse) {\n        if (request.initRequest && !isError) {\n          if (datacenter.lastInitVersion != currentAppVersion) {\n            datacenter.lastInitVersion=currentAppVersion;\n            saveSession();\n            FileLog.e(\"tmessages\",\"init connection completed\");\n          }\n else {\n            FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n          }\n        }\n        rpcCompleted(resultMid);\n      }\n else {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.transportChannelToken=0;\n      }\n      break;\n    }\n  }\n  resultContainer.freeResources();\n  if (!found) {\n    FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n    rpcCompleted(resultMid);\n  }\n  messagesConfirmed(resultMid);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 787,
      "astHeight" : 26
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 11910,
        "startLineNumber" : 1958,
        "startColumnNumber" : 59,
        "endLineNumber" : 2169,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1050,
      "astHeight" : 27
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 16541,
        "startLineNumber" : 1958,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1595,
      "astHeight" : 28
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 17208,
        "startLineNumber" : 1946,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1682,
      "astHeight" : 29
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 17883,
        "startLineNumber" : 1929,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1751,
      "astHeight" : 30
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 19081,
        "startLineNumber" : 1902,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1908,
      "astHeight" : 31
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 20361,
        "startLineNumber" : 1878,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2020,
      "astHeight" : 32
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 22534,
        "startLineNumber" : 1839,
        "startColumnNumber" : 8,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_new_session_created) {\n  TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n  ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n  if (arr == null) {\n    arr=new ArrayList<Long>();\n    processedSessionChanges.put(sessionId,arr);\n  }\n  if (!arr.contains(newSession.unique_id)) {\n    FileLog.d(\"tmessages\",\"New session:\");\n    FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n    FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n    FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n    long serverSalt=newSession.server_salt;\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=serverSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    for (    RPCRequest request : runningRequests) {\n      Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n      if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.runningStartTime=0;\n        request.runningMinStartTime=0;\n        request.transportChannelToken=0;\n      }\n    }\n    saveSession();\n    if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n      MessagesController.getInstance().getDifference();\n    }\n    arr.add(newSession.unique_id);\n  }\n}\n else if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2280,
      "astHeight" : 33
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 22747,
        "startLineNumber" : 1832,
        "startColumnNumber" : 178,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2303,
      "astHeight" : 34
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 22921,
        "startLineNumber" : 1832,
        "startColumnNumber" : 4,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "void processMessage(TLObject message,long messageId,int messageSeqNo,long messageSalt,TcpConnection connection,long sessionId,long innerMsgId,long containerMessageId){\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 2332,
      "astHeight" : 35
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 2079,
        "startColumnNumber" : 40,
        "endLineNumber" : 2079,
        "endColumnNumber" : 122
      },
      "nodeContext" : "request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 15,
      "astHeight" : 8
    },
    "tokenLength" : 1,
    "type" : "java.lang.System"
  }, {
    "nodeContext" : "System",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 2186,
      "startColumnNumber" : 39,
      "endLineNumber" : 2186,
      "endColumnNumber" : 45
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 2186,
        "startColumnNumber" : 39,
        "endLineNumber" : 2186,
        "endColumnNumber" : 65
      },
      "nodeContext" : "System.currentTimeMillis()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 2186,
        "startColumnNumber" : 25,
        "endLineNumber" : 2186,
        "endColumnNumber" : 65
      },
      "nodeContext" : "currentTime=System.currentTimeMillis()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 2186,
        "startColumnNumber" : 20,
        "endLineNumber" : 2186,
        "endColumnNumber" : 66
      },
      "nodeContext" : "long currentTime=System.currentTimeMillis();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 244,
        "startLineNumber" : 2184,
        "startColumnNumber" : 33,
        "endLineNumber" : 2188,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  long time=getTimeFromMsgId(messageId);\n  long currentTime=System.currentTimeMillis();\n  timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 31,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 261,
        "startLineNumber" : 2184,
        "startColumnNumber" : 16,
        "endLineNumber" : 2188,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (realId != 0) {\n  long time=getTimeFromMsgId(messageId);\n  long currentTime=System.currentTimeMillis();\n  timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 35,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 706,
        "startLineNumber" : 2178,
        "startColumnNumber" : 248,
        "endLineNumber" : 2195,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  long realId=messageId != 0 ? messageId : containerMessageId;\n  if (realId == 0) {\n    realId=innerMsgId;\n  }\n  if (realId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n  }\n  recreateSession(datacenter.authSessionId,datacenter);\n  saveSession();\n  lastOutgoingMessageId=0;\n  clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 76,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 942,
        "startLineNumber" : 2178,
        "startColumnNumber" : 12,
        "endLineNumber" : 2195,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n  long realId=messageId != 0 ? messageId : containerMessageId;\n  if (realId == 0) {\n    realId=innerMsgId;\n  }\n  if (realId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n  }\n  recreateSession(datacenter.authSessionId,datacenter);\n  saveSession();\n  lastOutgoingMessageId=0;\n  clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 112,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1178,
        "startLineNumber" : 2173,
        "startColumnNumber" : 69,
        "endLineNumber" : 2196,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 138,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 4465,
        "startLineNumber" : 2173,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 522,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 4521,
        "startLineNumber" : 2171,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 530,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 4581,
        "startLineNumber" : 2169,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 538,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 16541,
        "startLineNumber" : 1958,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1595,
      "astHeight" : 28
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 17208,
        "startLineNumber" : 1946,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1682,
      "astHeight" : 29
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 17883,
        "startLineNumber" : 1929,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1751,
      "astHeight" : 30
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 19081,
        "startLineNumber" : 1902,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1908,
      "astHeight" : 31
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 20361,
        "startLineNumber" : 1878,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2020,
      "astHeight" : 32
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 22534,
        "startLineNumber" : 1839,
        "startColumnNumber" : 8,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_new_session_created) {\n  TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n  ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n  if (arr == null) {\n    arr=new ArrayList<Long>();\n    processedSessionChanges.put(sessionId,arr);\n  }\n  if (!arr.contains(newSession.unique_id)) {\n    FileLog.d(\"tmessages\",\"New session:\");\n    FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n    FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n    FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n    long serverSalt=newSession.server_salt;\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=serverSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    for (    RPCRequest request : runningRequests) {\n      Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n      if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.runningStartTime=0;\n        request.runningMinStartTime=0;\n        request.transportChannelToken=0;\n      }\n    }\n    saveSession();\n    if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n      MessagesController.getInstance().getDifference();\n    }\n    arr.add(newSession.unique_id);\n  }\n}\n else if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2280,
      "astHeight" : 33
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 22747,
        "startLineNumber" : 1832,
        "startColumnNumber" : 178,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2303,
      "astHeight" : 34
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 22921,
        "startLineNumber" : 1832,
        "startColumnNumber" : 4,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "void processMessage(TLObject message,long messageId,int messageSeqNo,long messageSalt,TcpConnection connection,long sessionId,long innerMsgId,long containerMessageId){\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 2332,
      "astHeight" : 35
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 2186,
        "startColumnNumber" : 20,
        "endLineNumber" : 2186,
        "endColumnNumber" : 66
      },
      "nodeContext" : "long currentTime=System.currentTimeMillis();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.System"
  }, {
    "nodeContext" : "System",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 2199,
      "startColumnNumber" : 35,
      "endLineNumber" : 2199,
      "endColumnNumber" : 41
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 2199,
        "startColumnNumber" : 35,
        "endLineNumber" : 2199,
        "endColumnNumber" : 61
      },
      "nodeContext" : "System.currentTimeMillis()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 2199,
        "startColumnNumber" : 21,
        "endLineNumber" : 2199,
        "endColumnNumber" : 61
      },
      "nodeContext" : "currentTime=System.currentTimeMillis()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 2199,
        "startColumnNumber" : 16,
        "endLineNumber" : 2199,
        "endColumnNumber" : 62
      },
      "nodeContext" : "long currentTime=System.currentTimeMillis();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 313,
        "startLineNumber" : 2197,
        "startColumnNumber" : 32,
        "endLineNumber" : 2203,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  long time=getTimeFromMsgId(messageId);\n  long currentTime=System.currentTimeMillis();\n  timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n  lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 39,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 333,
        "startLineNumber" : 2197,
        "startColumnNumber" : 12,
        "endLineNumber" : 2203,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (messageId != 0) {\n  long time=getTimeFromMsgId(messageId);\n  long currentTime=System.currentTimeMillis();\n  timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n  lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 43,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 919,
        "startLineNumber" : 2196,
        "startColumnNumber" : 64,
        "endLineNumber" : 2219,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 108,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3227,
        "startLineNumber" : 2196,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 377,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 4465,
        "startLineNumber" : 2173,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 522,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 4521,
        "startLineNumber" : 2171,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 530,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 4581,
        "startLineNumber" : 2169,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 538,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 16541,
        "startLineNumber" : 1958,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1595,
      "astHeight" : 28
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 17208,
        "startLineNumber" : 1946,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1682,
      "astHeight" : 29
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 17883,
        "startLineNumber" : 1929,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1751,
      "astHeight" : 30
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 19081,
        "startLineNumber" : 1902,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1908,
      "astHeight" : 31
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 20361,
        "startLineNumber" : 1878,
        "startColumnNumber" : 15,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2020,
      "astHeight" : 32
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 22534,
        "startLineNumber" : 1839,
        "startColumnNumber" : 8,
        "endLineNumber" : 2264,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (message instanceof TLRPC.TL_new_session_created) {\n  TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n  ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n  if (arr == null) {\n    arr=new ArrayList<Long>();\n    processedSessionChanges.put(sessionId,arr);\n  }\n  if (!arr.contains(newSession.unique_id)) {\n    FileLog.d(\"tmessages\",\"New session:\");\n    FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n    FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n    FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n    long serverSalt=newSession.server_salt;\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=serverSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    for (    RPCRequest request : runningRequests) {\n      Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n      if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n        request.runningMessageId=0;\n        request.runningMessageSeqNo=0;\n        request.runningStartTime=0;\n        request.runningMinStartTime=0;\n        request.transportChannelToken=0;\n      }\n    }\n    saveSession();\n    if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n      MessagesController.getInstance().getDifference();\n    }\n    arr.add(newSession.unique_id);\n  }\n}\n else if (message instanceof TLRPC.TL_msg_container) {\n  TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n  for (  TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n    long innerMessageId=innerMessage.msg_id;\n    if (innerMessage.seqno % 2 != 0) {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(innerMessageId);\n    }\n    if (isMessageIdProcessed(sessionId,innerMessageId)) {\n      continue;\n    }\n    processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n    addProcessedMessageId(sessionId,innerMessageId);\n  }\n}\n else if (message instanceof TLRPC.TL_pong) {\n  TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n  long pingId=pong.ping_id;\n  ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n  for (  Long pid : pingIdToDate.keySet()) {\n    if (pid == pingId) {\n      int time=pingIdToDate.get(pid);\n      int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n      if (Math.abs(pingTime) < 10) {\n        currentPingTime=(pingTime + currentPingTime) / 2;\n        if (messageId != 0) {\n          long timeMessage=getTimeFromMsgId(messageId);\n          long currentTime=System.currentTimeMillis();\n          timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n        }\n      }\n      itemsToDelete.add(pid);\n    }\n else     if (pid < pingId) {\n      itemsToDelete.add(pid);\n    }\n  }\n  for (  Long pid : itemsToDelete) {\n    pingIdToDate.remove(pid);\n  }\n}\n else if (message instanceof TLRPC.TL_futuresalts) {\n  TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n  long requestMid=futureSalts.req_msg_id;\n  for (  RPCRequest request : runningRequests) {\n    if (request.respondsToMessageId(requestMid)) {\n      if (request.completionBlock != null) {\n        request.completionBlock.run(futureSalts,null);\n      }\n      futureSalts.freeResources();\n      messagesConfirmed(requestMid);\n      rpcCompleted(requestMid);\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.DestroySessionRes) {\n  TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n  ArrayList<Long> lst=new ArrayList<Long>();\n  lst.addAll(sessionsToDestroy);\n  destroyingSessions.remove(res.session_id);\n  for (  long session : lst) {\n    if (session == res.session_id) {\n      sessionsToDestroy.remove(session);\n      FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n      break;\n    }\n  }\n}\n else if (message instanceof TLRPC.TL_rpc_result) {\n  TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n  long resultMid=resultContainer.req_msg_id;\n  boolean ignoreResult=false;\n  FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n  if (resultContainer.result instanceof TLRPC.RpcError) {\n    String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n    FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n    int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n    if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n      ArrayList<String> migrateErrors=new ArrayList<String>();\n      migrateErrors.add(\"NETWORK_MIGRATE_\");\n      migrateErrors.add(\"PHONE_MIGRATE_\");\n      migrateErrors.add(\"USER_MIGRATE_\");\n      for (      String possibleError : migrateErrors) {\n        if (errorMessage.contains(possibleError)) {\n          String errorMsg=errorMessage.replace(possibleError,\"\");\n          Pattern pattern=Pattern.compile(\"[0-9]+\");\n          Matcher matcher=pattern.matcher(errorMsg);\n          if (matcher.find()) {\n            errorMsg=matcher.group(0);\n          }\n          Integer val;\n          try {\n            val=Integer.parseInt(errorMsg);\n          }\n catch (          Exception e) {\n            val=null;\n          }\n          if (val != null) {\n            migrateToDatacenterId=val;\n          }\n else {\n            migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n          }\n        }\n      }\n    }\n    if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n      ignoreResult=true;\n      moveToDatacenter(migrateToDatacenterId);\n    }\n  }\n  int retryRequestsFromDatacenter=-1;\n  int retryRequestsClass=0;\n  if (!ignoreResult) {\n    boolean found=false;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(resultMid)) {\n        found=true;\n        boolean discardResponse=false;\n        boolean isError=false;\n        if (request.completionBlock != null) {\n          TLRPC.TL_error implicitError=null;\n          if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n            TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n            TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            if (uncomressed == null) {\n              System.gc();\n              uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n            }\n            if (uncomressed == null) {\n              throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n            }\n            resultContainer.result=uncomressed;\n          }\n          if (resultContainer.result instanceof TLRPC.RpcError) {\n            String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n            FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n            int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n            if (errorCode == 500 || errorCode < 0) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                if (request.serverFailureCount < 1) {\n                  discardResponse=true;\n                  request.runningMinStartTime=request.runningStartTime + 1;\n                }\n              }\n else {\n                discardResponse=true;\n                int delay=Math.min(1,request.serverFailureCount * 2);\n                request.runningMinStartTime=request.runningStartTime + delay;\n                request.confirmed=false;\n              }\n              request.serverFailureCount++;\n            }\n else             if (errorCode == 420) {\n              if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                double waitTime=2.0;\n                if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                  String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                  Pattern pattern=Pattern.compile(\"[0-9]+\");\n                  Matcher matcher=pattern.matcher(errorMsg);\n                  if (matcher.find()) {\n                    errorMsg=matcher.group(0);\n                  }\n                  Integer val;\n                  try {\n                    val=Integer.parseInt(errorMsg);\n                  }\n catch (                  Exception e) {\n                    val=null;\n                  }\n                  if (val != null) {\n                    waitTime=val;\n                  }\n                }\n                waitTime=Math.min(30,waitTime);\n                discardResponse=true;\n                request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                request.confirmed=false;\n              }\n            }\n            implicitError=new TLRPC.TL_error();\n            implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n            implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n          }\n else           if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n            if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n              if (request.rawRequest == null) {\n                FileLog.e(\"tmessages\",\"rawRequest is null\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=-1000;\n            }\n          }\n          if (!discardResponse) {\n            if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n              isError=true;\n              request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n            }\n else {\n              request.completionBlock.run(resultContainer.result,null);\n            }\n          }\n          if (implicitError != null && implicitError.code == 401) {\n            isError=true;\n            if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n              if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                if (UserConfig.clientActivated) {\n                  UserConfig.clearConfig();\n                  Utilities.RunOnUIThread(new Runnable(){\n                    @Override public void run(){\n                      NotificationCenter.getInstance().postNotificationName(1234);\n                    }\n                  }\n);\n                }\n              }\n            }\n else {\n              datacenter.authorized=false;\n              saveSession();\n              discardResponse=true;\n              if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                retryRequestsFromDatacenter=datacenter.datacenterId;\n                retryRequestsClass=request.flags;\n              }\n            }\n          }\n        }\n        if (!discardResponse) {\n          if (request.initRequest && !isError) {\n            if (datacenter.lastInitVersion != currentAppVersion) {\n              datacenter.lastInitVersion=currentAppVersion;\n              saveSession();\n              FileLog.e(\"tmessages\",\"init connection completed\");\n            }\n else {\n              FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n            }\n          }\n          rpcCompleted(resultMid);\n        }\n else {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.transportChannelToken=0;\n        }\n        break;\n      }\n    }\n    resultContainer.freeResources();\n    if (!found) {\n      FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n      rpcCompleted(resultMid);\n    }\n    messagesConfirmed(resultMid);\n  }\n  if (retryRequestsFromDatacenter >= 0) {\n    processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n  }\n else {\n    processRequestQueue(0,0);\n  }\n}\n else if (message instanceof TLRPC.TL_msgs_ack) {\n}\n else if (message instanceof TLRPC.TL_ping) {\n}\n else if (message instanceof TLRPC.TL_bad_msg_notification) {\n  TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n  FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n  if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n    long realId=messageId != 0 ? messageId : containerMessageId;\n    if (realId == 0) {\n      realId=innerMsgId;\n    }\n    if (realId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    }\n    recreateSession(datacenter.authSessionId,datacenter);\n    saveSession();\n    lastOutgoingMessageId=0;\n    clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n  }\n}\n else if (message instanceof TLRPC.TL_bad_server_salt) {\n  if (messageId != 0) {\n    long time=getTimeFromMsgId(messageId);\n    long currentTime=System.currentTimeMillis();\n    timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n    lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n  }\n  datacenter.clearServerSalts();\n  ServerSalt serverSaltDesc=new ServerSalt();\n  serverSaltDesc.validSince=getCurrentTime();\n  serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n  serverSaltDesc.value=messageSalt;\n  datacenter.addServerSalt(serverSaltDesc);\n  saveSession();\n  refillSaltSet(datacenter);\n  if (datacenter.authKey != null) {\n    processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n  }\n}\n else if (message instanceof TLRPC.MsgDetailedInfo) {\n  TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n  boolean requestResend=false;\n  if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n    long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        requestResend=true;\n        break;\n      }\n    }\n  }\n else {\n    if (!isMessageIdProcessed(sessionId,messageId)) {\n      requestResend=true;\n    }\n  }\n  if (requestResend) {\n    TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n    resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n    NetworkMessage networkMessage=new NetworkMessage();\n    networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n    ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n    arr.add(networkMessage);\n    sendMessagesToTransport(arr,connection,sessionId,false,true);\n  }\n else {\n    ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n    if (set == null) {\n      set=new ArrayList<Long>();\n      messagesIdsForConfirmation.put(sessionId,set);\n    }\n    set.add(detailedInfo.answer_msg_id);\n  }\n}\n else if (message instanceof TLRPC.TL_gzip_packed) {\n  TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n  TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n  processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n}\n else if (message instanceof TLRPC.Updates) {\n  MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n}\n else {\n  FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2280,
      "astHeight" : 33
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 22747,
        "startLineNumber" : 1832,
        "startColumnNumber" : 178,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2303,
      "astHeight" : 34
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 22921,
        "startLineNumber" : 1832,
        "startColumnNumber" : 4,
        "endLineNumber" : 2265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "void processMessage(TLObject message,long messageId,int messageSeqNo,long messageSalt,TcpConnection connection,long sessionId,long innerMsgId,long containerMessageId){\n  if (message == null) {\n    FileLog.e(\"tmessages\",\"message is null\");\n    return;\n  }\n  Datacenter datacenter=datacenterWithId(connection.getDatacenterId());\n  if (message instanceof TLRPC.TL_new_session_created) {\n    TLRPC.TL_new_session_created newSession=(TLRPC.TL_new_session_created)message;\n    ArrayList<Long> arr=processedSessionChanges.get(sessionId);\n    if (arr == null) {\n      arr=new ArrayList<Long>();\n      processedSessionChanges.put(sessionId,arr);\n    }\n    if (!arr.contains(newSession.unique_id)) {\n      FileLog.d(\"tmessages\",\"New session:\");\n      FileLog.d(\"tmessages\",String.format(\"    first message id: %d\",newSession.first_msg_id));\n      FileLog.d(\"tmessages\",String.format(\"    server salt: %d\",newSession.server_salt));\n      FileLog.d(\"tmessages\",String.format(\"    unique id: %d\",newSession.unique_id));\n      long serverSalt=newSession.server_salt;\n      ServerSalt serverSaltDesc=new ServerSalt();\n      serverSaltDesc.validSince=getCurrentTime();\n      serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n      serverSaltDesc.value=serverSalt;\n      datacenter.addServerSalt(serverSaltDesc);\n      for (      RPCRequest request : runningRequests) {\n        Datacenter dcenter=datacenterWithId(request.runningDatacenterId);\n        if (request.runningMessageId < newSession.first_msg_id && (request.flags & connection.transportRequestClass) != 0 && dcenter != null && dcenter.datacenterId == datacenter.datacenterId) {\n          request.runningMessageId=0;\n          request.runningMessageSeqNo=0;\n          request.runningStartTime=0;\n          request.runningMinStartTime=0;\n          request.transportChannelToken=0;\n        }\n      }\n      saveSession();\n      if (sessionId == datacenter.authSessionId && datacenter.datacenterId == currentDatacenterId && UserConfig.clientActivated) {\n        MessagesController.getInstance().getDifference();\n      }\n      arr.add(newSession.unique_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msg_container) {\n    TLRPC.TL_msg_container messageContainer=(TLRPC.TL_msg_container)message;\n    for (    TLRPC.TL_protoMessage innerMessage : messageContainer.messages) {\n      long innerMessageId=innerMessage.msg_id;\n      if (innerMessage.seqno % 2 != 0) {\n        ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n        if (set == null) {\n          set=new ArrayList<Long>();\n          messagesIdsForConfirmation.put(sessionId,set);\n        }\n        set.add(innerMessageId);\n      }\n      if (isMessageIdProcessed(sessionId,innerMessageId)) {\n        continue;\n      }\n      processMessage(innerMessage.body,0,innerMessage.seqno,messageSalt,connection,sessionId,innerMessageId,messageId);\n      addProcessedMessageId(sessionId,innerMessageId);\n    }\n  }\n else   if (message instanceof TLRPC.TL_pong) {\n    TLRPC.TL_pong pong=(TLRPC.TL_pong)message;\n    long pingId=pong.ping_id;\n    ArrayList<Long> itemsToDelete=new ArrayList<Long>();\n    for (    Long pid : pingIdToDate.keySet()) {\n      if (pid == pingId) {\n        int time=pingIdToDate.get(pid);\n        int pingTime=(int)(System.currentTimeMillis() / 1000) - time;\n        if (Math.abs(pingTime) < 10) {\n          currentPingTime=(pingTime + currentPingTime) / 2;\n          if (messageId != 0) {\n            long timeMessage=getTimeFromMsgId(messageId);\n            long currentTime=System.currentTimeMillis();\n            timeDifference=(int)((timeMessage - currentTime) / 1000 - currentPingTime / 2.0);\n          }\n        }\n        itemsToDelete.add(pid);\n      }\n else       if (pid < pingId) {\n        itemsToDelete.add(pid);\n      }\n    }\n    for (    Long pid : itemsToDelete) {\n      pingIdToDate.remove(pid);\n    }\n  }\n else   if (message instanceof TLRPC.TL_futuresalts) {\n    TLRPC.TL_futuresalts futureSalts=(TLRPC.TL_futuresalts)message;\n    long requestMid=futureSalts.req_msg_id;\n    for (    RPCRequest request : runningRequests) {\n      if (request.respondsToMessageId(requestMid)) {\n        if (request.completionBlock != null) {\n          request.completionBlock.run(futureSalts,null);\n        }\n        futureSalts.freeResources();\n        messagesConfirmed(requestMid);\n        rpcCompleted(requestMid);\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.DestroySessionRes) {\n    TLRPC.DestroySessionRes res=(TLRPC.DestroySessionRes)message;\n    ArrayList<Long> lst=new ArrayList<Long>();\n    lst.addAll(sessionsToDestroy);\n    destroyingSessions.remove(res.session_id);\n    for (    long session : lst) {\n      if (session == res.session_id) {\n        sessionsToDestroy.remove(session);\n        FileLog.d(\"tmessages\",String.format(\"Destroyed session %d (%s)\",res.session_id,res instanceof TLRPC.TL_destroy_session_ok ? \"ok\" : \"not found\"));\n        break;\n      }\n    }\n  }\n else   if (message instanceof TLRPC.TL_rpc_result) {\n    TLRPC.TL_rpc_result resultContainer=(TLRPC.TL_rpc_result)message;\n    long resultMid=resultContainer.req_msg_id;\n    boolean ignoreResult=false;\n    FileLog.d(\"tmessages\",\"object in rpc_result is \" + resultContainer.result);\n    if (resultContainer.result instanceof TLRPC.RpcError) {\n      String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n      FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n      int migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n      if (((TLRPC.RpcError)resultContainer.result).error_code == 303) {\n        ArrayList<String> migrateErrors=new ArrayList<String>();\n        migrateErrors.add(\"NETWORK_MIGRATE_\");\n        migrateErrors.add(\"PHONE_MIGRATE_\");\n        migrateErrors.add(\"USER_MIGRATE_\");\n        for (        String possibleError : migrateErrors) {\n          if (errorMessage.contains(possibleError)) {\n            String errorMsg=errorMessage.replace(possibleError,\"\");\n            Pattern pattern=Pattern.compile(\"[0-9]+\");\n            Matcher matcher=pattern.matcher(errorMsg);\n            if (matcher.find()) {\n              errorMsg=matcher.group(0);\n            }\n            Integer val;\n            try {\n              val=Integer.parseInt(errorMsg);\n            }\n catch (            Exception e) {\n              val=null;\n            }\n            if (val != null) {\n              migrateToDatacenterId=val;\n            }\n else {\n              migrateToDatacenterId=DEFAULT_DATACENTER_ID;\n            }\n          }\n        }\n      }\n      if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {\n        ignoreResult=true;\n        moveToDatacenter(migrateToDatacenterId);\n      }\n    }\n    int retryRequestsFromDatacenter=-1;\n    int retryRequestsClass=0;\n    if (!ignoreResult) {\n      boolean found=false;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(resultMid)) {\n          found=true;\n          boolean discardResponse=false;\n          boolean isError=false;\n          if (request.completionBlock != null) {\n            TLRPC.TL_error implicitError=null;\n            if (resultContainer.result instanceof TLRPC.TL_gzip_packed) {\n              TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)resultContainer.result;\n              TLObject uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              if (uncomressed == null) {\n                System.gc();\n                uncomressed=Utilities.decompress(packet.packed_data,request.rawRequest);\n              }\n              if (uncomressed == null) {\n                throw new RuntimeException(\"failed to decomress responce for \" + request.rawRequest);\n              }\n              resultContainer.result=uncomressed;\n            }\n            if (resultContainer.result instanceof TLRPC.RpcError) {\n              String errorMessage=((TLRPC.RpcError)resultContainer.result).error_message;\n              FileLog.e(\"tmessages\",String.format(\"***** RPC error %d: %s\",((TLRPC.RpcError)resultContainer.result).error_code,errorMessage));\n              int errorCode=((TLRPC.RpcError)resultContainer.result).error_code;\n              if (errorCode == 500 || errorCode < 0) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) != 0) {\n                  if (request.serverFailureCount < 1) {\n                    discardResponse=true;\n                    request.runningMinStartTime=request.runningStartTime + 1;\n                  }\n                }\n else {\n                  discardResponse=true;\n                  int delay=Math.min(1,request.serverFailureCount * 2);\n                  request.runningMinStartTime=request.runningStartTime + delay;\n                  request.confirmed=false;\n                }\n                request.serverFailureCount++;\n              }\n else               if (errorCode == 420) {\n                if ((request.flags & RPCRequest.RPCRequestClassFailOnServerErrors) == 0) {\n                  double waitTime=2.0;\n                  if (errorMessage.contains(\"FLOOD_WAIT_\")) {\n                    String errorMsg=errorMessage.replace(\"FLOOD_WAIT_\",\"\");\n                    Pattern pattern=Pattern.compile(\"[0-9]+\");\n                    Matcher matcher=pattern.matcher(errorMsg);\n                    if (matcher.find()) {\n                      errorMsg=matcher.group(0);\n                    }\n                    Integer val;\n                    try {\n                      val=Integer.parseInt(errorMsg);\n                    }\n catch (                    Exception e) {\n                      val=null;\n                    }\n                    if (val != null) {\n                      waitTime=val;\n                    }\n                  }\n                  waitTime=Math.min(30,waitTime);\n                  discardResponse=true;\n                  request.runningMinStartTime=(int)(System.currentTimeMillis() / 1000 + waitTime);\n                  request.confirmed=false;\n                }\n              }\n              implicitError=new TLRPC.TL_error();\n              implicitError.code=((TLRPC.RpcError)resultContainer.result).error_code;\n              implicitError.text=((TLRPC.RpcError)resultContainer.result).error_message;\n            }\n else             if (!(resultContainer.result instanceof TLRPC.TL_error)) {\n              if (request.rawRequest == null || !request.rawRequest.responseClass().isAssignableFrom(resultContainer.result.getClass())) {\n                if (request.rawRequest == null) {\n                  FileLog.e(\"tmessages\",\"rawRequest is null\");\n                }\n else {\n                  FileLog.e(\"tmessages\",\"***** RPC error: invalid response class \" + resultContainer.result + \" (\"+ request.rawRequest.responseClass()+ \" expected)\");\n                }\n                implicitError=new TLRPC.TL_error();\n                implicitError.code=-1000;\n              }\n            }\n            if (!discardResponse) {\n              if (implicitError != null || resultContainer.result instanceof TLRPC.TL_error) {\n                isError=true;\n                request.completionBlock.run(null,implicitError != null ? implicitError : (TLRPC.TL_error)resultContainer.result);\n              }\n else {\n                request.completionBlock.run(resultContainer.result,null);\n              }\n            }\n            if (implicitError != null && implicitError.code == 401) {\n              isError=true;\n              if (datacenter.datacenterId == currentDatacenterId || datacenter.datacenterId == movingToDatacenterId) {\n                if ((request.flags & RPCRequest.RPCRequestClassGeneric) != 0) {\n                  if (UserConfig.clientActivated) {\n                    UserConfig.clearConfig();\n                    Utilities.RunOnUIThread(new Runnable(){\n                      @Override public void run(){\n                        NotificationCenter.getInstance().postNotificationName(1234);\n                      }\n                    }\n);\n                  }\n                }\n              }\n else {\n                datacenter.authorized=false;\n                saveSession();\n                discardResponse=true;\n                if ((request.flags & RPCRequest.RPCRequestClassDownloadMedia) != 0 || (request.flags & RPCRequest.RPCRequestClassUploadMedia) != 0) {\n                  retryRequestsFromDatacenter=datacenter.datacenterId;\n                  retryRequestsClass=request.flags;\n                }\n              }\n            }\n          }\n          if (!discardResponse) {\n            if (request.initRequest && !isError) {\n              if (datacenter.lastInitVersion != currentAppVersion) {\n                datacenter.lastInitVersion=currentAppVersion;\n                saveSession();\n                FileLog.e(\"tmessages\",\"init connection completed\");\n              }\n else {\n                FileLog.e(\"tmessages\",\"rpc is init, but init connection already completed\");\n              }\n            }\n            rpcCompleted(resultMid);\n          }\n else {\n            request.runningMessageId=0;\n            request.runningMessageSeqNo=0;\n            request.transportChannelToken=0;\n          }\n          break;\n        }\n      }\n      resultContainer.freeResources();\n      if (!found) {\n        FileLog.d(\"tmessages\",\"Response received, but request wasn't found.\");\n        rpcCompleted(resultMid);\n      }\n      messagesConfirmed(resultMid);\n    }\n    if (retryRequestsFromDatacenter >= 0) {\n      processRequestQueue(retryRequestsClass,retryRequestsFromDatacenter);\n    }\n else {\n      processRequestQueue(0,0);\n    }\n  }\n else   if (message instanceof TLRPC.TL_msgs_ack) {\n  }\n else   if (message instanceof TLRPC.TL_ping) {\n  }\n else   if (message instanceof TLRPC.TL_bad_msg_notification) {\n    TLRPC.TL_bad_msg_notification badMsgNotification=(TLRPC.TL_bad_msg_notification)message;\n    FileLog.e(\"tmessages\",String.format(\"***** Bad message: %d\",badMsgNotification.error_code));\n    if (badMsgNotification.error_code == 16 || badMsgNotification.error_code == 17 || badMsgNotification.error_code == 19 || badMsgNotification.error_code == 32 || badMsgNotification.error_code == 33 || badMsgNotification.error_code == 64) {\n      long realId=messageId != 0 ? messageId : containerMessageId;\n      if (realId == 0) {\n        realId=innerMsgId;\n      }\n      if (realId != 0) {\n        long time=getTimeFromMsgId(messageId);\n        long currentTime=System.currentTimeMillis();\n        timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      }\n      recreateSession(datacenter.authSessionId,datacenter);\n      saveSession();\n      lastOutgoingMessageId=0;\n      clearRequestsForRequestClass(connection.transportRequestClass,datacenter);\n    }\n  }\n else   if (message instanceof TLRPC.TL_bad_server_salt) {\n    if (messageId != 0) {\n      long time=getTimeFromMsgId(messageId);\n      long currentTime=System.currentTimeMillis();\n      timeDifference=(int)((time - currentTime) / 1000 - currentPingTime / 2.0);\n      lastOutgoingMessageId=Math.max(messageId,lastOutgoingMessageId);\n    }\n    datacenter.clearServerSalts();\n    ServerSalt serverSaltDesc=new ServerSalt();\n    serverSaltDesc.validSince=getCurrentTime();\n    serverSaltDesc.validUntil=getCurrentTime() + 30 * 60;\n    serverSaltDesc.value=messageSalt;\n    datacenter.addServerSalt(serverSaltDesc);\n    saveSession();\n    refillSaltSet(datacenter);\n    if (datacenter.authKey != null) {\n      processRequestQueue(RPCRequest.RPCRequestClassTransportMask,datacenter.datacenterId);\n    }\n  }\n else   if (message instanceof TLRPC.MsgDetailedInfo) {\n    TLRPC.MsgDetailedInfo detailedInfo=(TLRPC.MsgDetailedInfo)message;\n    boolean requestResend=false;\n    if (detailedInfo instanceof TLRPC.TL_msg_detailed_info) {\n      long requestMid=((TLRPC.TL_msg_detailed_info)detailedInfo).msg_id;\n      for (      RPCRequest request : runningRequests) {\n        if (request.respondsToMessageId(requestMid)) {\n          requestResend=true;\n          break;\n        }\n      }\n    }\n else {\n      if (!isMessageIdProcessed(sessionId,messageId)) {\n        requestResend=true;\n      }\n    }\n    if (requestResend) {\n      TLRPC.TL_msg_resend_req resendReq=new TLRPC.TL_msg_resend_req();\n      resendReq.msg_ids.add(detailedInfo.answer_msg_id);\n      NetworkMessage networkMessage=new NetworkMessage();\n      networkMessage.protoMessage=wrapMessage(resendReq,sessionId,false);\n      ArrayList<NetworkMessage> arr=new ArrayList<NetworkMessage>();\n      arr.add(networkMessage);\n      sendMessagesToTransport(arr,connection,sessionId,false,true);\n    }\n else {\n      ArrayList<Long> set=messagesIdsForConfirmation.get(sessionId);\n      if (set == null) {\n        set=new ArrayList<Long>();\n        messagesIdsForConfirmation.put(sessionId,set);\n      }\n      set.add(detailedInfo.answer_msg_id);\n    }\n  }\n else   if (message instanceof TLRPC.TL_gzip_packed) {\n    TLRPC.TL_gzip_packed packet=(TLRPC.TL_gzip_packed)message;\n    TLObject result=Utilities.decompress(packet.packed_data,getRequestWithMessageId(messageId));\n    processMessage(result,messageId,messageSeqNo,messageSalt,connection,sessionId,innerMsgId,containerMessageId);\n  }\n else   if (message instanceof TLRPC.Updates) {\n    MessagesController.getInstance().processUpdates((TLRPC.Updates)message,false);\n  }\n else {\n    FileLog.e(\"tmessages\",\"***** Error: unknown message class \" + message);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 2332,
      "astHeight" : 35
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 2199,
        "startColumnNumber" : 16,
        "endLineNumber" : 2199,
        "endColumnNumber" : 62
      },
      "nodeContext" : "long currentTime=System.currentTimeMillis();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.System"
  } ],
  "positionList" : [ {
    "charLength" : 6,
    "startLineNumber" : 1910,
    "startColumnNumber" : 41,
    "endLineNumber" : 1910,
    "endColumnNumber" : 47
  }, {
    "charLength" : 6,
    "startLineNumber" : 1917,
    "startColumnNumber" : 47,
    "endLineNumber" : 1917,
    "endColumnNumber" : 53
  }, {
    "charLength" : 6,
    "startLineNumber" : 2025,
    "startColumnNumber" : 36,
    "endLineNumber" : 2025,
    "endColumnNumber" : 42
  }, {
    "charLength" : 6,
    "startLineNumber" : 2079,
    "startColumnNumber" : 76,
    "endLineNumber" : 2079,
    "endColumnNumber" : 82
  }, {
    "charLength" : 6,
    "startLineNumber" : 2186,
    "startColumnNumber" : 39,
    "endLineNumber" : 2186,
    "endColumnNumber" : 45
  }, {
    "charLength" : 6,
    "startLineNumber" : 2199,
    "startColumnNumber" : 35,
    "endLineNumber" : 2199,
    "endColumnNumber" : 41
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 12
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 12
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 12
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 12
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 12
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 12
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 12
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 12
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 18
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 18
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 15
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 15
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 26
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 26
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 14
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 23
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 23
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 14
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 14
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 11
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 11
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 13
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 13
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 7
  } ]
}