{
  "id" : 116,
  "expression" : "traceIds.length == 0",
  "projectName" : "openzipkin@zipkin",
  "commitID" : "f02a993656f506277ca83737ddf494ed45fde4b3",
  "filePath" : "/zipkin-storage/cassandra/src/main/java/zipkin/cassandra/CassandraSpanStore.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "traceIds.length == 0",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 20,
      "startLineNumber" : 408,
      "startColumnNumber" : 8,
      "endLineNumber" : 408,
      "endColumnNumber" : 28
    },
    "astNodeNumber" : 5,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 105,
        "startLineNumber" : 408,
        "startColumnNumber" : 4,
        "endLineNumber" : 410,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (traceIds.length == 0) {\n  return immediateFuture(Collections.<Long,List<Span>>emptyMap());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 20,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 1249,
        "startLineNumber" : 406,
        "startColumnNumber" : 89,
        "endLineNumber" : 444,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  checkNotNull(traceIds,\"traceIds\");\n  if (traceIds.length == 0) {\n    return immediateFuture(Collections.<Long,List<Span>>emptyMap());\n  }\n  try {\n    BoundStatement bound=selectTraces.bind().setList(\"trace_id\",Arrays.asList(traceIds)).setInt(\"limit_\",limit);\n    bound.setFetchSize(Integer.MAX_VALUE);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(debugSelectTraces(traceIds,limit));\n    }\n    return transform(session.executeAsync(bound),new Function<ResultSet,Map<Long,List<Span>>>(){\n      @Override public Map<Long,List<Span>> apply(      ResultSet input){\n        Map<Long,List<Span>> spans=new LinkedHashMap<>();\n        for (        Row row : input) {\n          long traceId=row.getLong(\"trace_id\");\n          if (!spans.containsKey(traceId)) {\n            spans.put(traceId,new ArrayList<Span>());\n          }\n          spans.get(traceId).add(Codec.THRIFT.readSpan(row.getBytes(\"span\")));\n        }\n        return spans;\n      }\n    }\n);\n  }\n catch (  RuntimeException ex) {\n    LOG.error(\"failed \" + debugSelectTraces(traceIds,limit),ex);\n    return immediateFailedFuture(ex);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 200,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 1683,
        "startLineNumber" : 400,
        "startColumnNumber" : 2,
        "endLineNumber" : 444,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Get the available trace information from the storage system. Spans in trace should be sorted by the first annotation timestamp in that span. First event should be first in the spans list. <p> The return list will contain only spans that have been found, thus the return list may not match the provided list of ids.\n */\nListenableFuture<Map<Long,List<Span>>> getSpansByTraceIds(Long[] traceIds,int limit){\n  checkNotNull(traceIds,\"traceIds\");\n  if (traceIds.length == 0) {\n    return immediateFuture(Collections.<Long,List<Span>>emptyMap());\n  }\n  try {\n    BoundStatement bound=selectTraces.bind().setList(\"trace_id\",Arrays.asList(traceIds)).setInt(\"limit_\",limit);\n    bound.setFetchSize(Integer.MAX_VALUE);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(debugSelectTraces(traceIds,limit));\n    }\n    return transform(session.executeAsync(bound),new Function<ResultSet,Map<Long,List<Span>>>(){\n      @Override public Map<Long,List<Span>> apply(      ResultSet input){\n        Map<Long,List<Span>> spans=new LinkedHashMap<>();\n        for (        Row row : input) {\n          long traceId=row.getLong(\"trace_id\");\n          if (!spans.containsKey(traceId)) {\n            spans.put(traceId,new ArrayList<Span>());\n          }\n          spans.get(traceId).add(Codec.THRIFT.readSpan(row.getBytes(\"span\")));\n        }\n        return spans;\n      }\n    }\n);\n  }\n catch (  RuntimeException ex) {\n    LOG.error(\"failed \" + debugSelectTraces(traceIds,limit),ex);\n    return immediateFailedFuture(ex);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 225,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 105,
        "startLineNumber" : 408,
        "startColumnNumber" : 4,
        "endLineNumber" : 410,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (traceIds.length == 0) {\n  return immediateFuture(Collections.<Long,List<Span>>emptyMap());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 20,
      "astHeight" : 8
    },
    "tokenLength" : 4,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 20,
    "startLineNumber" : 408,
    "startColumnNumber" : 8,
    "endLineNumber" : 408,
    "endColumnNumber" : 28
  } ],
  "layoutRelationDataList" : [ ]
}