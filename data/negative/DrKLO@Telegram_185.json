{
  "id" : 185,
  "expression" : "numOutputBuffers",
  "projectName" : "DrKLO@Telegram",
  "commitID" : "11fbfb1329df700b203e1852a71c4c11b5ab12f4",
  "filePath" : "/TMessagesProj/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "numOutputBuffers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 16,
      "startLineNumber" : 77,
      "startColumnNumber" : 74,
      "endLineNumber" : 77,
      "endColumnNumber" : 90
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SuperConstructorInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 77,
        "startColumnNumber" : 51,
        "endLineNumber" : 77,
        "endColumnNumber" : 91
      },
      "nodeContext" : "new SimpleOutputBuffer[numOutputBuffers]",
      "nodeType" : "ArrayCreation",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 89,
        "startLineNumber" : 77,
        "startColumnNumber" : 4,
        "endLineNumber" : 77,
        "endColumnNumber" : 93
      },
      "nodeContext" : "super(new DecoderInputBuffer[numInputBuffers],new SimpleOutputBuffer[numOutputBuffers]);\n",
      "nodeType" : "SuperConstructorInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 2533,
        "startLineNumber" : 76,
        "startColumnNumber" : 34,
        "endLineNumber" : 134,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  super(new DecoderInputBuffer[numInputBuffers],new SimpleOutputBuffer[numOutputBuffers]);\n  this.exoMediaCrypto=exoMediaCrypto;\n  if (exoMediaCrypto != null && !OpusLibrary.opusIsSecureDecodeSupported()) {\n    throw new OpusDecoderException(\"Opus decoder does not support secure decode.\");\n  }\n  byte[] headerBytes=initializationData.get(0);\n  if (headerBytes.length < 19) {\n    throw new OpusDecoderException(\"Header size is too small.\");\n  }\n  channelCount=headerBytes[9] & 0xFF;\n  if (channelCount > 8) {\n    throw new OpusDecoderException(\"Invalid channel count: \" + channelCount);\n  }\n  int preskip=readUnsignedLittleEndian16(headerBytes,10);\n  int gain=readSignedLittleEndian16(headerBytes,16);\n  byte[] streamMap=new byte[8];\n  int numStreams;\n  int numCoupled;\n  if (headerBytes[18] == 0) {\n    if (channelCount > 2) {\n      throw new OpusDecoderException(\"Invalid Header, missing stream map.\");\n    }\n    numStreams=1;\n    numCoupled=(channelCount == 2) ? 1 : 0;\n    streamMap[0]=0;\n    streamMap[1]=1;\n  }\n else {\n    if (headerBytes.length < 21 + channelCount) {\n      throw new OpusDecoderException(\"Header size is too small.\");\n    }\n    numStreams=headerBytes[19] & 0xFF;\n    numCoupled=headerBytes[20] & 0xFF;\n    System.arraycopy(headerBytes,21,streamMap,0,channelCount);\n  }\n  if (initializationData.size() == 3) {\n    if (initializationData.get(1).length != 8 || initializationData.get(2).length != 8) {\n      throw new OpusDecoderException(\"Invalid Codec Delay or Seek Preroll\");\n    }\n    long codecDelayNs=ByteBuffer.wrap(initializationData.get(1)).order(ByteOrder.nativeOrder()).getLong();\n    long seekPreRollNs=ByteBuffer.wrap(initializationData.get(2)).order(ByteOrder.nativeOrder()).getLong();\n    headerSkipSamples=nsToSamples(codecDelayNs);\n    headerSeekPreRollSamples=nsToSamples(seekPreRollNs);\n  }\n else {\n    headerSkipSamples=preskip;\n    headerSeekPreRollSamples=DEFAULT_SEEK_PRE_ROLL_SAMPLES;\n  }\n  nativeDecoderContext=opusInit(SAMPLE_RATE,channelCount,numStreams,numCoupled,gain,streamMap);\n  if (nativeDecoderContext == 0) {\n    throw new OpusDecoderException(\"Failed to initialize decoder\");\n  }\n  setInitialInputBufferSize(initialInputBufferSize);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 308,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3566,
        "startLineNumber" : 57,
        "startColumnNumber" : 2,
        "endLineNumber" : 134,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Creates an Opus decoder.\n * @param numInputBuffers The number of input buffers.\n * @param numOutputBuffers The number of output buffers.\n * @param initialInputBufferSize The initial size of each input buffer.\n * @param initializationData Codec-specific initialization data. The first element must contain anopus header. Optionally, the list may contain two additional buffers, which must contain the encoder delay and seek pre roll values in nanoseconds, encoded as longs.\n * @param exoMediaCrypto The {@link ExoMediaCrypto} object required for decoding encryptedcontent. Maybe null and can be ignored if decoder does not handle encrypted content.\n * @throws OpusDecoderException Thrown if an exception occurs when initializing the decoder.\n */\npublic OpusDecoder(int numInputBuffers,int numOutputBuffers,int initialInputBufferSize,List<byte[]> initializationData,@Nullable ExoMediaCrypto exoMediaCrypto) throws OpusDecoderException {\n  super(new DecoderInputBuffer[numInputBuffers],new SimpleOutputBuffer[numOutputBuffers]);\n  this.exoMediaCrypto=exoMediaCrypto;\n  if (exoMediaCrypto != null && !OpusLibrary.opusIsSecureDecodeSupported()) {\n    throw new OpusDecoderException(\"Opus decoder does not support secure decode.\");\n  }\n  byte[] headerBytes=initializationData.get(0);\n  if (headerBytes.length < 19) {\n    throw new OpusDecoderException(\"Header size is too small.\");\n  }\n  channelCount=headerBytes[9] & 0xFF;\n  if (channelCount > 8) {\n    throw new OpusDecoderException(\"Invalid channel count: \" + channelCount);\n  }\n  int preskip=readUnsignedLittleEndian16(headerBytes,10);\n  int gain=readSignedLittleEndian16(headerBytes,16);\n  byte[] streamMap=new byte[8];\n  int numStreams;\n  int numCoupled;\n  if (headerBytes[18] == 0) {\n    if (channelCount > 2) {\n      throw new OpusDecoderException(\"Invalid Header, missing stream map.\");\n    }\n    numStreams=1;\n    numCoupled=(channelCount == 2) ? 1 : 0;\n    streamMap[0]=0;\n    streamMap[1]=1;\n  }\n else {\n    if (headerBytes.length < 21 + channelCount) {\n      throw new OpusDecoderException(\"Header size is too small.\");\n    }\n    numStreams=headerBytes[19] & 0xFF;\n    numCoupled=headerBytes[20] & 0xFF;\n    System.arraycopy(headerBytes,21,streamMap,0,channelCount);\n  }\n  if (initializationData.size() == 3) {\n    if (initializationData.get(1).length != 8 || initializationData.get(2).length != 8) {\n      throw new OpusDecoderException(\"Invalid Codec Delay or Seek Preroll\");\n    }\n    long codecDelayNs=ByteBuffer.wrap(initializationData.get(1)).order(ByteOrder.nativeOrder()).getLong();\n    long seekPreRollNs=ByteBuffer.wrap(initializationData.get(2)).order(ByteOrder.nativeOrder()).getLong();\n    headerSkipSamples=nsToSamples(codecDelayNs);\n    headerSeekPreRollSamples=nsToSamples(seekPreRollNs);\n  }\n else {\n    headerSkipSamples=preskip;\n    headerSeekPreRollSamples=DEFAULT_SEEK_PRE_ROLL_SAMPLES;\n  }\n  nativeDecoderContext=opusInit(SAMPLE_RATE,channelCount,numStreams,numCoupled,gain,streamMap);\n  if (nativeDecoderContext == 0) {\n    throw new OpusDecoderException(\"Failed to initialize decoder\");\n  }\n  setInitialInputBufferSize(initialInputBufferSize);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 337,
      "astHeight" : 11
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 89,
        "startLineNumber" : 77,
        "startColumnNumber" : 4,
        "endLineNumber" : 77,
        "endColumnNumber" : 93
      },
      "nodeContext" : "super(new DecoderInputBuffer[numInputBuffers],new SimpleOutputBuffer[numOutputBuffers]);\n",
      "nodeType" : "SuperConstructorInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 16,
    "startLineNumber" : 77,
    "startColumnNumber" : 74,
    "endLineNumber" : 77,
    "endColumnNumber" : 90
  } ],
  "layoutRelationDataList" : [ ]
}