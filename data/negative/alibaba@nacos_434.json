{
  "id" : 434,
  "expression" : "Loggers",
  "projectName" : "alibaba@nacos",
  "commitID" : "4e7346db1d6657ffe07c96bebd2d348229c2812f",
  "filePath" : "core/src/main/java/com/alibaba/nacos/core/remote/ConnectionManager.java",
  "occurrences" : 13,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 289,
      "startColumnNumber" : 20,
      "endLineNumber" : 289,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 289,
        "startColumnNumber" : 20,
        "endLineNumber" : 289,
        "endColumnNumber" : 41
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 289,
        "startColumnNumber" : 20,
        "endLineNumber" : 289,
        "endColumnNumber" : 77
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Connection check task start\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 289,
        "startColumnNumber" : 20,
        "endLineNumber" : 289,
        "endColumnNumber" : 78
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 289,
        "startColumnNumber" : 20,
        "endLineNumber" : 289,
        "endColumnNumber" : 78
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 297,
      "startColumnNumber" : 20,
      "endLineNumber" : 297,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 297,
        "startColumnNumber" : 20,
        "endLineNumber" : 297,
        "endColumnNumber" : 41
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 354,
        "startLineNumber" : 297,
        "startColumnNumber" : 20,
        "endLineNumber" : 300,
        "endColumnNumber" : 107
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 20,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 355,
        "startLineNumber" : 297,
        "startColumnNumber" : 20,
        "endLineNumber" : 300,
        "endColumnNumber" : 108
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 21,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 297,
        "startColumnNumber" : 20,
        "endLineNumber" : 297,
        "endColumnNumber" : 41
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 332,
      "startColumnNumber" : 20,
      "endLineNumber" : 332,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 332,
        "startColumnNumber" : 20,
        "endLineNumber" : 332,
        "endColumnNumber" : 41
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 136,
        "startLineNumber" : 332,
        "startColumnNumber" : 20,
        "endLineNumber" : 333,
        "endColumnNumber" : 114
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 9,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 137,
        "startLineNumber" : 332,
        "startColumnNumber" : 20,
        "endLineNumber" : 333,
        "endColumnNumber" : 115
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 332,
        "startColumnNumber" : 20,
        "endLineNumber" : 332,
        "endColumnNumber" : 41
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 336,
      "startColumnNumber" : 24,
      "endLineNumber" : 336,
      "endColumnNumber" : 31
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 336,
        "startColumnNumber" : 24,
        "endLineNumber" : 336,
        "endColumnNumber" : 45
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 67,
        "startLineNumber" : 336,
        "startColumnNumber" : 24,
        "endLineNumber" : 336,
        "endColumnNumber" : 91
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 336,
        "startColumnNumber" : 24,
        "endLineNumber" : 336,
        "endColumnNumber" : 92
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 116,
        "startLineNumber" : 335,
        "startColumnNumber" : 47,
        "endLineNumber" : 337,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 143,
        "startLineNumber" : 335,
        "startColumnNumber" : 20,
        "endLineNumber" : 337,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (expelForIp.size() > 0) {\n  Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 336,
        "startColumnNumber" : 24,
        "endLineNumber" : 336,
        "endColumnNumber" : 92
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 385,
      "startColumnNumber" : 32,
      "endLineNumber" : 385,
      "endColumnNumber" : 39
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 385,
        "startColumnNumber" : 32,
        "endLineNumber" : 385,
        "endColumnNumber" : 53
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 352,
        "startLineNumber" : 385,
        "startColumnNumber" : 32,
        "endLineNumber" : 388,
        "endColumnNumber" : 84
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 353,
        "startLineNumber" : 385,
        "startColumnNumber" : 32,
        "endLineNumber" : 388,
        "endColumnNumber" : 85
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 14,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 756,
        "startLineNumber" : 380,
        "startColumnNumber" : 52,
        "endLineNumber" : 389,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n  connectResetRequest.setServerIp(serverIp);\n  connectResetRequest.setServerPort(serverPort);\n  connection.asyncRequest(connectResetRequest,null);\n  Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 39,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 780,
        "startLineNumber" : 380,
        "startColumnNumber" : 28,
        "endLineNumber" : 389,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (connection != null) {\n  ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n  connectResetRequest.setServerIp(serverIp);\n  connectResetRequest.setServerPort(serverPort);\n  connection.asyncRequest(connectResetRequest,null);\n  Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 43,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 950,
        "startLineNumber" : 378,
        "startColumnNumber" : 28,
        "endLineNumber" : 391,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Connection connection=getConnection(expelledClientId);\n  if (connection != null) {\n    ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n    connectResetRequest.setServerIp(serverIp);\n    connectResetRequest.setServerPort(serverPort);\n    connection.asyncRequest(connectResetRequest,null);\n    Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 52,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1249,
        "startLineNumber" : 378,
        "startColumnNumber" : 24,
        "endLineNumber" : 395,
        "endColumnNumber" : 25
      },
      "nodeContext" : "try {\n  Connection connection=getConnection(expelledClientId);\n  if (connection != null) {\n    ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n    connectResetRequest.setServerIp(serverIp);\n    connectResetRequest.setServerPort(serverPort);\n    connection.asyncRequest(connectResetRequest,null);\n    Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n  }\n}\n catch (ConnectionAlreadyClosedException e) {\n  unregister(expelledClientId);\n}\ncatch (Exception e) {\n  Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 78,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1297,
        "startLineNumber" : 377,
        "startColumnNumber" : 64,
        "endLineNumber" : 396,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  try {\n    Connection connection=getConnection(expelledClientId);\n    if (connection != null) {\n      ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n      connectResetRequest.setServerIp(serverIp);\n      connectResetRequest.setServerPort(serverPort);\n      connection.asyncRequest(connectResetRequest,null);\n      Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n    }\n  }\n catch (  ConnectionAlreadyClosedException e) {\n    unregister(expelledClientId);\n  }\ncatch (  Exception e) {\n    Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 79,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1341,
        "startLineNumber" : 377,
        "startColumnNumber" : 20,
        "endLineNumber" : 396,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (String expelledClientId : expelClient) {\n  try {\n    Connection connection=getConnection(expelledClientId);\n    if (connection != null) {\n      ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n      connectResetRequest.setServerIp(serverIp);\n      connectResetRequest.setServerPort(serverPort);\n      connection.asyncRequest(connectResetRequest,null);\n      Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n    }\n  }\n catch (  ConnectionAlreadyClosedException e) {\n    unregister(expelledClientId);\n  }\ncatch (  Exception e) {\n    Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 85,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 385,
        "startColumnNumber" : 32,
        "endLineNumber" : 385,
        "endColumnNumber" : 53
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 394,
      "startColumnNumber" : 28,
      "endLineNumber" : 394,
      "endColumnNumber" : 35
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 394,
        "startColumnNumber" : 28,
        "endLineNumber" : 394,
        "endColumnNumber" : 49
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 394,
        "startColumnNumber" : 28,
        "endLineNumber" : 394,
        "endColumnNumber" : 116
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 89,
        "startLineNumber" : 394,
        "startColumnNumber" : 28,
        "endLineNumber" : 394,
        "endColumnNumber" : 117
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CatchClause,body]",
      "nodePosition" : {
        "charLength" : 145,
        "startLineNumber" : 393,
        "startColumnNumber" : 46,
        "endLineNumber" : 395,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,catchClauses]",
      "nodePosition" : {
        "charLength" : 165,
        "startLineNumber" : 393,
        "startColumnNumber" : 26,
        "endLineNumber" : 395,
        "endColumnNumber" : 25
      },
      "nodeContext" : "catch (Exception e) {\n  Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n}\n",
      "nodeType" : "CatchClause",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1249,
        "startLineNumber" : 378,
        "startColumnNumber" : 24,
        "endLineNumber" : 395,
        "endColumnNumber" : 25
      },
      "nodeContext" : "try {\n  Connection connection=getConnection(expelledClientId);\n  if (connection != null) {\n    ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n    connectResetRequest.setServerIp(serverIp);\n    connectResetRequest.setServerPort(serverPort);\n    connection.asyncRequest(connectResetRequest,null);\n    Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n  }\n}\n catch (ConnectionAlreadyClosedException e) {\n  unregister(expelledClientId);\n}\ncatch (Exception e) {\n  Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 78,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1297,
        "startLineNumber" : 377,
        "startColumnNumber" : 64,
        "endLineNumber" : 396,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  try {\n    Connection connection=getConnection(expelledClientId);\n    if (connection != null) {\n      ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n      connectResetRequest.setServerIp(serverIp);\n      connectResetRequest.setServerPort(serverPort);\n      connection.asyncRequest(connectResetRequest,null);\n      Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n    }\n  }\n catch (  ConnectionAlreadyClosedException e) {\n    unregister(expelledClientId);\n  }\ncatch (  Exception e) {\n    Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 79,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1341,
        "startLineNumber" : 377,
        "startColumnNumber" : 20,
        "endLineNumber" : 396,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (String expelledClientId : expelClient) {\n  try {\n    Connection connection=getConnection(expelledClientId);\n    if (connection != null) {\n      ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n      connectResetRequest.setServerIp(serverIp);\n      connectResetRequest.setServerPort(serverPort);\n      connection.asyncRequest(connectResetRequest,null);\n      Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n    }\n  }\n catch (  ConnectionAlreadyClosedException e) {\n    unregister(expelledClientId);\n  }\ncatch (  Exception e) {\n    Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 85,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 89,
        "startLineNumber" : 394,
        "startColumnNumber" : 28,
        "endLineNumber" : 394,
        "endColumnNumber" : 117
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 399,
      "startColumnNumber" : 20,
      "endLineNumber" : 399,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 399,
        "startColumnNumber" : 20,
        "endLineNumber" : 399,
        "endColumnNumber" : 41
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 399,
        "startColumnNumber" : 20,
        "endLineNumber" : 399,
        "endColumnNumber" : 107
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 9,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 399,
        "startColumnNumber" : 20,
        "endLineNumber" : 399,
        "endColumnNumber" : 108
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 399,
        "startColumnNumber" : 20,
        "endLineNumber" : 399,
        "endColumnNumber" : 108
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 434,
      "startColumnNumber" : 36,
      "endLineNumber" : 434,
      "endColumnNumber" : 43
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 434,
        "startColumnNumber" : 36,
        "endLineNumber" : 434,
        "endColumnNumber" : 57
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 131,
        "startLineNumber" : 434,
        "startColumnNumber" : 36,
        "endLineNumber" : 435,
        "endColumnNumber" : 109
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 132,
        "startLineNumber" : 434,
        "startColumnNumber" : 36,
        "endLineNumber" : 435,
        "endColumnNumber" : 110
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1846,
        "startLineNumber" : 406,
        "startColumnNumber" : 56,
        "endLineNumber" : 436,
        "endColumnNumber" : 33
      },
      "nodeContext" : "{\n  ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n  connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n    @Override public Executor getExecutor(){\n      return null;\n    }\n    @Override public long getTimeout(){\n      return 1000L;\n    }\n    @Override public void onResponse(    Response response){\n      latch.countDown();\n      if (response != null && response.isSuccess()) {\n        connection.freshActiveTime();\n        successConnections.add(outDateConnectionId);\n      }\n    }\n    @Override public void onException(    Throwable e){\n      latch.countDown();\n    }\n  }\n);\n  Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 93,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1966,
        "startLineNumber" : 406,
        "startColumnNumber" : 32,
        "endLineNumber" : 438,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (connection != null) {\n  ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n  connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n    @Override public Executor getExecutor(){\n      return null;\n    }\n    @Override public long getTimeout(){\n      return 1000L;\n    }\n    @Override public void onResponse(    Response response){\n      latch.countDown();\n      if (response != null && response.isSuccess()) {\n        connection.freshActiveTime();\n        successConnections.add(outDateConnectionId);\n      }\n    }\n    @Override public void onException(    Throwable e){\n      latch.countDown();\n    }\n  }\n);\n  Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n}\n else {\n  latch.countDown();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 102,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 2155,
        "startLineNumber" : 404,
        "startColumnNumber" : 32,
        "endLineNumber" : 440,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Connection connection=getConnection(outDateConnectionId);\n  if (connection != null) {\n    ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n    connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n      @Override public Executor getExecutor(){\n        return null;\n      }\n      @Override public long getTimeout(){\n        return 1000L;\n      }\n      @Override public void onResponse(      Response response){\n        latch.countDown();\n        if (response != null && response.isSuccess()) {\n          connection.freshActiveTime();\n          successConnections.add(outDateConnectionId);\n        }\n      }\n      @Override public void onException(      Throwable e){\n        latch.countDown();\n      }\n    }\n);\n    Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n  }\n else {\n    latch.countDown();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 111,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2627,
        "startLineNumber" : 404,
        "startColumnNumber" : 28,
        "endLineNumber" : 447,
        "endColumnNumber" : 29
      },
      "nodeContext" : "try {\n  Connection connection=getConnection(outDateConnectionId);\n  if (connection != null) {\n    ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n    connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n      @Override public Executor getExecutor(){\n        return null;\n      }\n      @Override public long getTimeout(){\n        return 1000L;\n      }\n      @Override public void onResponse(      Response response){\n        latch.countDown();\n        if (response != null && response.isSuccess()) {\n          connection.freshActiveTime();\n          successConnections.add(outDateConnectionId);\n        }\n      }\n      @Override public void onException(      Throwable e){\n        latch.countDown();\n      }\n    }\n);\n    Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n  }\n else {\n    latch.countDown();\n  }\n}\n catch (ConnectionAlreadyClosedException e) {\n  latch.countDown();\n}\ncatch (Exception e) {\n  Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n  latch.countDown();\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 141,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 2683,
        "startLineNumber" : 403,
        "startColumnNumber" : 79,
        "endLineNumber" : 448,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  try {\n    Connection connection=getConnection(outDateConnectionId);\n    if (connection != null) {\n      ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n      connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n        @Override public Executor getExecutor(){\n          return null;\n        }\n        @Override public long getTimeout(){\n          return 1000L;\n        }\n        @Override public void onResponse(        Response response){\n          latch.countDown();\n          if (response != null && response.isSuccess()) {\n            connection.freshActiveTime();\n            successConnections.add(outDateConnectionId);\n          }\n        }\n        @Override public void onException(        Throwable e){\n          latch.countDown();\n        }\n      }\n);\n      Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n    }\n else {\n      latch.countDown();\n    }\n  }\n catch (  ConnectionAlreadyClosedException e) {\n    latch.countDown();\n  }\ncatch (  Exception e) {\n    Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n    latch.countDown();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 142,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2738,
        "startLineNumber" : 403,
        "startColumnNumber" : 24,
        "endLineNumber" : 448,
        "endColumnNumber" : 25
      },
      "nodeContext" : "for (String outDateConnectionId : outDatedConnections) {\n  try {\n    Connection connection=getConnection(outDateConnectionId);\n    if (connection != null) {\n      ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n      connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n        @Override public Executor getExecutor(){\n          return null;\n        }\n        @Override public long getTimeout(){\n          return 1000L;\n        }\n        @Override public void onResponse(        Response response){\n          latch.countDown();\n          if (response != null && response.isSuccess()) {\n            connection.freshActiveTime();\n            successConnections.add(outDateConnectionId);\n          }\n        }\n        @Override public void onException(        Throwable e){\n          latch.countDown();\n        }\n      }\n);\n      Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n    }\n else {\n      latch.countDown();\n    }\n  }\n catch (  ConnectionAlreadyClosedException e) {\n    latch.countDown();\n  }\ncatch (  Exception e) {\n    Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n    latch.countDown();\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 148,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 3688,
        "startLineNumber" : 400,
        "startColumnNumber" : 73,
        "endLineNumber" : 461,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Set<String> successConnections=new HashSet<>();\n  final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    try {\n      Connection connection=getConnection(outDateConnectionId);\n      if (connection != null) {\n        ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n        connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n          @Override public Executor getExecutor(){\n            return null;\n          }\n          @Override public long getTimeout(){\n            return 1000L;\n          }\n          @Override public void onResponse(          Response response){\n            latch.countDown();\n            if (response != null && response.isSuccess()) {\n              connection.freshActiveTime();\n              successConnections.add(outDateConnectionId);\n            }\n          }\n          @Override public void onException(          Throwable e){\n            latch.countDown();\n          }\n        }\n);\n        Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n      }\n else {\n        latch.countDown();\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      latch.countDown();\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n      latch.countDown();\n    }\n  }\n  latch.await(3000L,TimeUnit.MILLISECONDS);\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    if (!successConnections.contains(outDateConnectionId)) {\n      Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n      unregister(outDateConnectionId);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 217,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3741,
        "startLineNumber" : 400,
        "startColumnNumber" : 20,
        "endLineNumber" : 461,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n  Set<String> successConnections=new HashSet<>();\n  final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    try {\n      Connection connection=getConnection(outDateConnectionId);\n      if (connection != null) {\n        ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n        connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n          @Override public Executor getExecutor(){\n            return null;\n          }\n          @Override public long getTimeout(){\n            return 1000L;\n          }\n          @Override public void onResponse(          Response response){\n            latch.countDown();\n            if (response != null && response.isSuccess()) {\n              connection.freshActiveTime();\n              successConnections.add(outDateConnectionId);\n            }\n          }\n          @Override public void onException(          Throwable e){\n            latch.countDown();\n          }\n        }\n);\n        Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n      }\n else {\n        latch.countDown();\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      latch.countDown();\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n      latch.countDown();\n    }\n  }\n  latch.await(3000L,TimeUnit.MILLISECONDS);\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    if (!successConnections.contains(outDateConnectionId)) {\n      Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n      unregister(outDateConnectionId);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 222,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 434,
        "startColumnNumber" : 36,
        "endLineNumber" : 434,
        "endColumnNumber" : 57
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 443,
      "startColumnNumber" : 32,
      "endLineNumber" : 443,
      "endColumnNumber" : 39
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 443,
        "startColumnNumber" : 32,
        "endLineNumber" : 443,
        "endColumnNumber" : 53
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 205,
        "startLineNumber" : 443,
        "startColumnNumber" : 32,
        "endLineNumber" : 445,
        "endColumnNumber" : 71
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 206,
        "startLineNumber" : 443,
        "startColumnNumber" : 32,
        "endLineNumber" : 445,
        "endColumnNumber" : 72
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CatchClause,body]",
      "nodePosition" : {
        "charLength" : 321,
        "startLineNumber" : 442,
        "startColumnNumber" : 50,
        "endLineNumber" : 447,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n  latch.countDown();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,catchClauses]",
      "nodePosition" : {
        "charLength" : 341,
        "startLineNumber" : 442,
        "startColumnNumber" : 30,
        "endLineNumber" : 447,
        "endColumnNumber" : 29
      },
      "nodeContext" : "catch (Exception e) {\n  Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n  latch.countDown();\n}\n",
      "nodeType" : "CatchClause",
      "astNodeNumber" : 19,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2627,
        "startLineNumber" : 404,
        "startColumnNumber" : 28,
        "endLineNumber" : 447,
        "endColumnNumber" : 29
      },
      "nodeContext" : "try {\n  Connection connection=getConnection(outDateConnectionId);\n  if (connection != null) {\n    ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n    connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n      @Override public Executor getExecutor(){\n        return null;\n      }\n      @Override public long getTimeout(){\n        return 1000L;\n      }\n      @Override public void onResponse(      Response response){\n        latch.countDown();\n        if (response != null && response.isSuccess()) {\n          connection.freshActiveTime();\n          successConnections.add(outDateConnectionId);\n        }\n      }\n      @Override public void onException(      Throwable e){\n        latch.countDown();\n      }\n    }\n);\n    Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n  }\n else {\n    latch.countDown();\n  }\n}\n catch (ConnectionAlreadyClosedException e) {\n  latch.countDown();\n}\ncatch (Exception e) {\n  Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n  latch.countDown();\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 141,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 2683,
        "startLineNumber" : 403,
        "startColumnNumber" : 79,
        "endLineNumber" : 448,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  try {\n    Connection connection=getConnection(outDateConnectionId);\n    if (connection != null) {\n      ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n      connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n        @Override public Executor getExecutor(){\n          return null;\n        }\n        @Override public long getTimeout(){\n          return 1000L;\n        }\n        @Override public void onResponse(        Response response){\n          latch.countDown();\n          if (response != null && response.isSuccess()) {\n            connection.freshActiveTime();\n            successConnections.add(outDateConnectionId);\n          }\n        }\n        @Override public void onException(        Throwable e){\n          latch.countDown();\n        }\n      }\n);\n      Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n    }\n else {\n      latch.countDown();\n    }\n  }\n catch (  ConnectionAlreadyClosedException e) {\n    latch.countDown();\n  }\ncatch (  Exception e) {\n    Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n    latch.countDown();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 142,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2738,
        "startLineNumber" : 403,
        "startColumnNumber" : 24,
        "endLineNumber" : 448,
        "endColumnNumber" : 25
      },
      "nodeContext" : "for (String outDateConnectionId : outDatedConnections) {\n  try {\n    Connection connection=getConnection(outDateConnectionId);\n    if (connection != null) {\n      ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n      connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n        @Override public Executor getExecutor(){\n          return null;\n        }\n        @Override public long getTimeout(){\n          return 1000L;\n        }\n        @Override public void onResponse(        Response response){\n          latch.countDown();\n          if (response != null && response.isSuccess()) {\n            connection.freshActiveTime();\n            successConnections.add(outDateConnectionId);\n          }\n        }\n        @Override public void onException(        Throwable e){\n          latch.countDown();\n        }\n      }\n);\n      Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n    }\n else {\n      latch.countDown();\n    }\n  }\n catch (  ConnectionAlreadyClosedException e) {\n    latch.countDown();\n  }\ncatch (  Exception e) {\n    Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n    latch.countDown();\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 148,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 3688,
        "startLineNumber" : 400,
        "startColumnNumber" : 73,
        "endLineNumber" : 461,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Set<String> successConnections=new HashSet<>();\n  final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    try {\n      Connection connection=getConnection(outDateConnectionId);\n      if (connection != null) {\n        ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n        connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n          @Override public Executor getExecutor(){\n            return null;\n          }\n          @Override public long getTimeout(){\n            return 1000L;\n          }\n          @Override public void onResponse(          Response response){\n            latch.countDown();\n            if (response != null && response.isSuccess()) {\n              connection.freshActiveTime();\n              successConnections.add(outDateConnectionId);\n            }\n          }\n          @Override public void onException(          Throwable e){\n            latch.countDown();\n          }\n        }\n);\n        Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n      }\n else {\n        latch.countDown();\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      latch.countDown();\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n      latch.countDown();\n    }\n  }\n  latch.await(3000L,TimeUnit.MILLISECONDS);\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    if (!successConnections.contains(outDateConnectionId)) {\n      Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n      unregister(outDateConnectionId);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 217,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3741,
        "startLineNumber" : 400,
        "startColumnNumber" : 20,
        "endLineNumber" : 461,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n  Set<String> successConnections=new HashSet<>();\n  final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    try {\n      Connection connection=getConnection(outDateConnectionId);\n      if (connection != null) {\n        ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n        connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n          @Override public Executor getExecutor(){\n            return null;\n          }\n          @Override public long getTimeout(){\n            return 1000L;\n          }\n          @Override public void onResponse(          Response response){\n            latch.countDown();\n            if (response != null && response.isSuccess()) {\n              connection.freshActiveTime();\n              successConnections.add(outDateConnectionId);\n            }\n          }\n          @Override public void onException(          Throwable e){\n            latch.countDown();\n          }\n        }\n);\n        Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n      }\n else {\n        latch.countDown();\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      latch.countDown();\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n      latch.countDown();\n    }\n  }\n  latch.await(3000L,TimeUnit.MILLISECONDS);\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    if (!successConnections.contains(outDateConnectionId)) {\n      Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n      unregister(outDateConnectionId);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 222,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 443,
        "startColumnNumber" : 32,
        "endLineNumber" : 443,
        "endColumnNumber" : 53
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 451,
      "startColumnNumber" : 24,
      "endLineNumber" : 451,
      "endColumnNumber" : 31
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 451,
        "startColumnNumber" : 24,
        "endLineNumber" : 451,
        "endColumnNumber" : 45
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 132,
        "startLineNumber" : 451,
        "startColumnNumber" : 24,
        "endLineNumber" : 452,
        "endColumnNumber" : 110
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 9,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 133,
        "startLineNumber" : 451,
        "startColumnNumber" : 24,
        "endLineNumber" : 452,
        "endColumnNumber" : 111
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 3688,
        "startLineNumber" : 400,
        "startColumnNumber" : 73,
        "endLineNumber" : 461,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Set<String> successConnections=new HashSet<>();\n  final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    try {\n      Connection connection=getConnection(outDateConnectionId);\n      if (connection != null) {\n        ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n        connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n          @Override public Executor getExecutor(){\n            return null;\n          }\n          @Override public long getTimeout(){\n            return 1000L;\n          }\n          @Override public void onResponse(          Response response){\n            latch.countDown();\n            if (response != null && response.isSuccess()) {\n              connection.freshActiveTime();\n              successConnections.add(outDateConnectionId);\n            }\n          }\n          @Override public void onException(          Throwable e){\n            latch.countDown();\n          }\n        }\n);\n        Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n      }\n else {\n        latch.countDown();\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      latch.countDown();\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n      latch.countDown();\n    }\n  }\n  latch.await(3000L,TimeUnit.MILLISECONDS);\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    if (!successConnections.contains(outDateConnectionId)) {\n      Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n      unregister(outDateConnectionId);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 217,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3741,
        "startLineNumber" : 400,
        "startColumnNumber" : 20,
        "endLineNumber" : 461,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n  Set<String> successConnections=new HashSet<>();\n  final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    try {\n      Connection connection=getConnection(outDateConnectionId);\n      if (connection != null) {\n        ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n        connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n          @Override public Executor getExecutor(){\n            return null;\n          }\n          @Override public long getTimeout(){\n            return 1000L;\n          }\n          @Override public void onResponse(          Response response){\n            latch.countDown();\n            if (response != null && response.isSuccess()) {\n              connection.freshActiveTime();\n              successConnections.add(outDateConnectionId);\n            }\n          }\n          @Override public void onException(          Throwable e){\n            latch.countDown();\n          }\n        }\n);\n        Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n      }\n else {\n        latch.countDown();\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      latch.countDown();\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n      latch.countDown();\n    }\n  }\n  latch.await(3000L,TimeUnit.MILLISECONDS);\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    if (!successConnections.contains(outDateConnectionId)) {\n      Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n      unregister(outDateConnectionId);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 222,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 451,
        "startColumnNumber" : 24,
        "endLineNumber" : 451,
        "endColumnNumber" : 45
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 456,
      "startColumnNumber" : 32,
      "endLineNumber" : 456,
      "endColumnNumber" : 39
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 456,
        "startColumnNumber" : 32,
        "endLineNumber" : 456,
        "endColumnNumber" : 53
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 131,
        "startLineNumber" : 456,
        "startColumnNumber" : 32,
        "endLineNumber" : 457,
        "endColumnNumber" : 109
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 132,
        "startLineNumber" : 456,
        "startColumnNumber" : 32,
        "endLineNumber" : 457,
        "endColumnNumber" : 110
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 261,
        "startLineNumber" : 455,
        "startColumnNumber" : 83,
        "endLineNumber" : 459,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n  unregister(outDateConnectionId);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 316,
        "startLineNumber" : 455,
        "startColumnNumber" : 28,
        "endLineNumber" : 459,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (!successConnections.contains(outDateConnectionId)) {\n  Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n  unregister(outDateConnectionId);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 19,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 372,
        "startLineNumber" : 454,
        "startColumnNumber" : 79,
        "endLineNumber" : 460,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (!successConnections.contains(outDateConnectionId)) {\n    Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n    unregister(outDateConnectionId);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 20,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 427,
        "startLineNumber" : 454,
        "startColumnNumber" : 24,
        "endLineNumber" : 460,
        "endColumnNumber" : 25
      },
      "nodeContext" : "for (String outDateConnectionId : outDatedConnections) {\n  if (!successConnections.contains(outDateConnectionId)) {\n    Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n    unregister(outDateConnectionId);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 26,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 3688,
        "startLineNumber" : 400,
        "startColumnNumber" : 73,
        "endLineNumber" : 461,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Set<String> successConnections=new HashSet<>();\n  final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    try {\n      Connection connection=getConnection(outDateConnectionId);\n      if (connection != null) {\n        ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n        connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n          @Override public Executor getExecutor(){\n            return null;\n          }\n          @Override public long getTimeout(){\n            return 1000L;\n          }\n          @Override public void onResponse(          Response response){\n            latch.countDown();\n            if (response != null && response.isSuccess()) {\n              connection.freshActiveTime();\n              successConnections.add(outDateConnectionId);\n            }\n          }\n          @Override public void onException(          Throwable e){\n            latch.countDown();\n          }\n        }\n);\n        Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n      }\n else {\n        latch.countDown();\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      latch.countDown();\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n      latch.countDown();\n    }\n  }\n  latch.await(3000L,TimeUnit.MILLISECONDS);\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    if (!successConnections.contains(outDateConnectionId)) {\n      Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n      unregister(outDateConnectionId);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 217,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3741,
        "startLineNumber" : 400,
        "startColumnNumber" : 20,
        "endLineNumber" : 461,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n  Set<String> successConnections=new HashSet<>();\n  final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    try {\n      Connection connection=getConnection(outDateConnectionId);\n      if (connection != null) {\n        ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n        connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n          @Override public Executor getExecutor(){\n            return null;\n          }\n          @Override public long getTimeout(){\n            return 1000L;\n          }\n          @Override public void onResponse(          Response response){\n            latch.countDown();\n            if (response != null && response.isSuccess()) {\n              connection.freshActiveTime();\n              successConnections.add(outDateConnectionId);\n            }\n          }\n          @Override public void onException(          Throwable e){\n            latch.countDown();\n          }\n        }\n);\n        Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n      }\n else {\n        latch.countDown();\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      latch.countDown();\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n      latch.countDown();\n    }\n  }\n  latch.await(3000L,TimeUnit.MILLISECONDS);\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n  for (  String outDateConnectionId : outDatedConnections) {\n    if (!successConnections.contains(outDateConnectionId)) {\n      Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n      unregister(outDateConnectionId);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 222,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 456,
        "startColumnNumber" : 32,
        "endLineNumber" : 456,
        "endColumnNumber" : 53
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 470,
      "startColumnNumber" : 20,
      "endLineNumber" : 470,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 470,
        "startColumnNumber" : 20,
        "endLineNumber" : 470,
        "endColumnNumber" : 41
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 470,
        "startColumnNumber" : 20,
        "endLineNumber" : 470,
        "endColumnNumber" : 75
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Connection check task end\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 470,
        "startColumnNumber" : 20,
        "endLineNumber" : 470,
        "endColumnNumber" : 76
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 470,
        "startColumnNumber" : 20,
        "endLineNumber" : 470,
        "endColumnNumber" : 76
      },
      "nodeContext" : "Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  }, {
    "nodeContext" : "Loggers",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 473,
      "startColumnNumber" : 20,
      "endLineNumber" : 473,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 473,
        "startColumnNumber" : 20,
        "endLineNumber" : 473,
        "endColumnNumber" : 34
      },
      "nodeContext" : "Loggers.REMOTE",
      "nodeType" : "QualifiedName",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 67,
        "startLineNumber" : 473,
        "startColumnNumber" : 20,
        "endLineNumber" : 473,
        "endColumnNumber" : 87
      },
      "nodeContext" : "Loggers.REMOTE.error(\"Error occurs during connection check... \",e)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 473,
        "startColumnNumber" : 20,
        "endLineNumber" : 473,
        "endColumnNumber" : 88
      },
      "nodeContext" : "Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CatchClause,body]",
      "nodePosition" : {
        "charLength" : 108,
        "startLineNumber" : 472,
        "startColumnNumber" : 38,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,catchClauses]",
      "nodePosition" : {
        "charLength" : 128,
        "startLineNumber" : 472,
        "startColumnNumber" : 18,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "CatchClause",
      "astNodeNumber" : 14,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 473,
        "startColumnNumber" : 20,
        "endLineNumber" : 473,
        "endColumnNumber" : 88
      },
      "nodeContext" : "Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.utils.Loggers"
  } ],
  "positionList" : [ {
    "charLength" : 7,
    "startLineNumber" : 289,
    "startColumnNumber" : 20,
    "endLineNumber" : 289,
    "endColumnNumber" : 27
  }, {
    "charLength" : 7,
    "startLineNumber" : 297,
    "startColumnNumber" : 20,
    "endLineNumber" : 297,
    "endColumnNumber" : 27
  }, {
    "charLength" : 7,
    "startLineNumber" : 332,
    "startColumnNumber" : 20,
    "endLineNumber" : 332,
    "endColumnNumber" : 27
  }, {
    "charLength" : 7,
    "startLineNumber" : 336,
    "startColumnNumber" : 24,
    "endLineNumber" : 336,
    "endColumnNumber" : 31
  }, {
    "charLength" : 7,
    "startLineNumber" : 385,
    "startColumnNumber" : 32,
    "endLineNumber" : 385,
    "endColumnNumber" : 39
  }, {
    "charLength" : 7,
    "startLineNumber" : 394,
    "startColumnNumber" : 28,
    "endLineNumber" : 394,
    "endColumnNumber" : 35
  }, {
    "charLength" : 7,
    "startLineNumber" : 399,
    "startColumnNumber" : 20,
    "endLineNumber" : 399,
    "endColumnNumber" : 27
  }, {
    "charLength" : 7,
    "startLineNumber" : 434,
    "startColumnNumber" : 36,
    "endLineNumber" : 434,
    "endColumnNumber" : 43
  }, {
    "charLength" : 7,
    "startLineNumber" : 443,
    "startColumnNumber" : 32,
    "endLineNumber" : 443,
    "endColumnNumber" : 39
  }, {
    "charLength" : 7,
    "startLineNumber" : 451,
    "startColumnNumber" : 24,
    "endLineNumber" : 451,
    "endColumnNumber" : 31
  }, {
    "charLength" : 7,
    "startLineNumber" : 456,
    "startColumnNumber" : 32,
    "endLineNumber" : 456,
    "endColumnNumber" : 39
  }, {
    "charLength" : 7,
    "startLineNumber" : 470,
    "startColumnNumber" : 20,
    "endLineNumber" : 470,
    "endColumnNumber" : 27
  }, {
    "charLength" : 7,
    "startLineNumber" : 473,
    "startColumnNumber" : 20,
    "endLineNumber" : 473,
    "endColumnNumber" : 27
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 11,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 12,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 12,
    "layout" : 9
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 7,
    "secondKey" : 11,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 12,
    "layout" : 12
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 11,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 12,
    "layout" : 11
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 11,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 12,
    "layout" : 10
  }, {
    "firstKey" : 11,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 12,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 11,
    "layout" : 5
  } ]
}