{
  "id" : 171,
  "expression" : "Opcodes.AGET_BOOLEAN",
  "projectName" : "Tencent@tinker",
  "commitID" : "df9e1d29420d53a650ab73569d828a22e3cfe728",
  "filePath" : "/third-party/aosp-dexutils/src/main/java/com/tencent/tinker/android/dx/instruction/InstructionReader.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "Opcodes.AGET_BOOLEAN",
    "nodeType" : "QualifiedName",
    "nodePosition" : {
      "charLength" : 20,
      "startLineNumber" : 302,
      "startColumnNumber" : 21,
      "endLineNumber" : 302,
      "endColumnNumber" : 41
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 302,
        "startColumnNumber" : 16,
        "endLineNumber" : 302,
        "endColumnNumber" : 42
      },
      "nodeContext" : "case Opcodes.AGET_BOOLEAN:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 25496,
        "startLineNumber" : 42,
        "startColumnNumber" : 12,
        "endLineNumber" : 562,
        "endColumnNumber" : 13
      },
      "nodeContext" : "switch (opcodeForSwitch) {\ncase Opcodes.SPECIAL_FORMAT:{\n    iv.visitZeroRegisterInsn(currentAddress,opcodeUnit,0,InstructionCodec.INDEX_TYPE_NONE,0,0L);\n    break;\n  }\ncase Opcodes.GOTO:{\n  int opcode=InstructionCodec.byte0(opcodeUnit);\n  int target=(byte)InstructionCodec.byte1(opcodeUnit);\n  iv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L);\n  break;\n}\ncase Opcodes.NOP:case Opcodes.RETURN_VOID:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal);\nbreak;\n}\ncase Opcodes.CONST_4:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint literal=(InstructionCodec.nibble3(opcodeUnit) << 28) >> 28;\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.MOVE_RESULT:case Opcodes.MOVE_RESULT_WIDE:case Opcodes.MOVE_RESULT_OBJECT:case Opcodes.MOVE_EXCEPTION:case Opcodes.RETURN:case Opcodes.RETURN_WIDE:case Opcodes.RETURN_OBJECT:case Opcodes.MONITOR_ENTER:case Opcodes.MONITOR_EXIT:case Opcodes.THROW:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a);\nbreak;\n}\ncase Opcodes.MOVE:case Opcodes.MOVE_WIDE:case Opcodes.MOVE_OBJECT:case Opcodes.ARRAY_LENGTH:case Opcodes.NEG_INT:case Opcodes.NOT_INT:case Opcodes.NEG_LONG:case Opcodes.NOT_LONG:case Opcodes.NEG_FLOAT:case Opcodes.NEG_DOUBLE:case Opcodes.INT_TO_LONG:case Opcodes.INT_TO_FLOAT:case Opcodes.INT_TO_DOUBLE:case Opcodes.LONG_TO_INT:case Opcodes.LONG_TO_FLOAT:case Opcodes.LONG_TO_DOUBLE:case Opcodes.FLOAT_TO_INT:case Opcodes.FLOAT_TO_LONG:case Opcodes.FLOAT_TO_DOUBLE:case Opcodes.DOUBLE_TO_INT:case Opcodes.DOUBLE_TO_LONG:case Opcodes.DOUBLE_TO_FLOAT:case Opcodes.INT_TO_BYTE:case Opcodes.INT_TO_CHAR:case Opcodes.INT_TO_SHORT:case Opcodes.ADD_INT_2ADDR:case Opcodes.SUB_INT_2ADDR:case Opcodes.MUL_INT_2ADDR:case Opcodes.DIV_INT_2ADDR:case Opcodes.REM_INT_2ADDR:case Opcodes.AND_INT_2ADDR:case Opcodes.OR_INT_2ADDR:case Opcodes.XOR_INT_2ADDR:case Opcodes.SHL_INT_2ADDR:case Opcodes.SHR_INT_2ADDR:case Opcodes.USHR_INT_2ADDR:case Opcodes.ADD_LONG_2ADDR:case Opcodes.SUB_LONG_2ADDR:case Opcodes.MUL_LONG_2ADDR:case Opcodes.DIV_LONG_2ADDR:case Opcodes.REM_LONG_2ADDR:case Opcodes.AND_LONG_2ADDR:case Opcodes.OR_LONG_2ADDR:case Opcodes.XOR_LONG_2ADDR:case Opcodes.SHL_LONG_2ADDR:case Opcodes.SHR_LONG_2ADDR:case Opcodes.USHR_LONG_2ADDR:case Opcodes.ADD_FLOAT_2ADDR:case Opcodes.SUB_FLOAT_2ADDR:case Opcodes.MUL_FLOAT_2ADDR:case Opcodes.DIV_FLOAT_2ADDR:case Opcodes.REM_FLOAT_2ADDR:case Opcodes.ADD_DOUBLE_2ADDR:case Opcodes.SUB_DOUBLE_2ADDR:case Opcodes.MUL_DOUBLE_2ADDR:case Opcodes.DIV_DOUBLE_2ADDR:case Opcodes.REM_DOUBLE_2ADDR:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.GOTO_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING:case Opcodes.CONST_CLASS:case Opcodes.CHECK_CAST:case Opcodes.NEW_INSTANCE:case Opcodes.SGET:case Opcodes.SGET_WIDE:case Opcodes.SGET_OBJECT:case Opcodes.SGET_BOOLEAN:case Opcodes.SGET_BYTE:case Opcodes.SGET_CHAR:case Opcodes.SGET_SHORT:case Opcodes.SPUT:case Opcodes.SPUT_WIDE:case Opcodes.SPUT_OBJECT:case Opcodes.SPUT_BOOLEAN:case Opcodes.SPUT_BYTE:case Opcodes.SPUT_CHAR:case Opcodes.SPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST_HIGH16:case Opcodes.CONST_WIDE_HIGH16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=(short)codeIn.read();\nliteral<<=(opcode == Opcodes.CONST_HIGH16) ? 16 : 48;\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.CONST_16:case Opcodes.CONST_WIDE_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.IF_EQZ:case Opcodes.IF_NEZ:case Opcodes.IF_LTZ:case Opcodes.IF_GEZ:case Opcodes.IF_GTZ:case Opcodes.IF_LEZ:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT8:case Opcodes.RSUB_INT_LIT8:case Opcodes.MUL_INT_LIT8:case Opcodes.DIV_INT_LIT8:case Opcodes.REM_INT_LIT8:case Opcodes.AND_INT_LIT8:case Opcodes.OR_INT_LIT8:case Opcodes.XOR_INT_LIT8:case Opcodes.SHL_INT_LIT8:case Opcodes.SHR_INT_LIT8:case Opcodes.USHR_INT_LIT8:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint literal=(byte)InstructionCodec.byte1(bc);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.INSTANCE_OF:case Opcodes.NEW_ARRAY:case Opcodes.IGET:case Opcodes.IGET_WIDE:case Opcodes.IGET_OBJECT:case Opcodes.IGET_BOOLEAN:case Opcodes.IGET_BYTE:case Opcodes.IGET_CHAR:case Opcodes.IGET_SHORT:case Opcodes.IPUT:case Opcodes.IPUT_WIDE:case Opcodes.IPUT_OBJECT:case Opcodes.IPUT_BOOLEAN:case Opcodes.IPUT_BYTE:case Opcodes.IPUT_CHAR:case Opcodes.IPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT16:case Opcodes.RSUB_INT:case Opcodes.MUL_INT_LIT16:case Opcodes.DIV_INT_LIT16:case Opcodes.REM_INT_LIT16:case Opcodes.AND_INT_LIT16:case Opcodes.OR_INT_LIT16:case Opcodes.XOR_INT_LIT16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.IF_EQ:case Opcodes.IF_NE:case Opcodes.IF_LT:case Opcodes.IF_GE:case Opcodes.IF_GT:case Opcodes.IF_LE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a,b);\nbreak;\n}\ncase Opcodes.MOVE_FROM16:case Opcodes.MOVE_WIDE_FROM16:case Opcodes.MOVE_OBJECT_FROM16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.CMPL_FLOAT:case Opcodes.CMPG_FLOAT:case Opcodes.CMPL_DOUBLE:case Opcodes.CMPG_DOUBLE:case Opcodes.CMP_LONG:case Opcodes.AGET:case Opcodes.AGET_WIDE:case Opcodes.AGET_OBJECT:case Opcodes.AGET_BOOLEAN:case Opcodes.AGET_BYTE:case Opcodes.AGET_CHAR:case Opcodes.AGET_SHORT:case Opcodes.APUT:case Opcodes.APUT_WIDE:case Opcodes.APUT_OBJECT:case Opcodes.APUT_BOOLEAN:case Opcodes.APUT_BYTE:case Opcodes.APUT_CHAR:case Opcodes.APUT_SHORT:case Opcodes.ADD_INT:case Opcodes.SUB_INT:case Opcodes.MUL_INT:case Opcodes.DIV_INT:case Opcodes.REM_INT:case Opcodes.AND_INT:case Opcodes.OR_INT:case Opcodes.XOR_INT:case Opcodes.SHL_INT:case Opcodes.SHR_INT:case Opcodes.USHR_INT:case Opcodes.ADD_LONG:case Opcodes.SUB_LONG:case Opcodes.MUL_LONG:case Opcodes.DIV_LONG:case Opcodes.REM_LONG:case Opcodes.AND_LONG:case Opcodes.OR_LONG:case Opcodes.XOR_LONG:case Opcodes.SHL_LONG:case Opcodes.SHR_LONG:case Opcodes.USHR_LONG:case Opcodes.ADD_FLOAT:case Opcodes.SUB_FLOAT:case Opcodes.MUL_FLOAT:case Opcodes.DIV_FLOAT:case Opcodes.REM_FLOAT:case Opcodes.ADD_DOUBLE:case Opcodes.SUB_DOUBLE:case Opcodes.MUL_DOUBLE:case Opcodes.DIV_DOUBLE:case Opcodes.REM_DOUBLE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint c=InstructionCodec.byte1(bc);\niv.visitThreeRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b,c);\nbreak;\n}\ncase Opcodes.GOTO_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=codeIn.readInt();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING_JUMBO:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.readInt();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST:case Opcodes.CONST_WIDE_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=codeIn.readInt();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA:case Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=currentAddress + codeIn.readInt();\nswitch (opcode) {\ncase Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\ncodeIn.setBaseAddress(target + 1,currentAddress);\nbreak;\n}\ndefault:{\nbreak;\n}\n}\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,target,0L,a);\nbreak;\n}\ncase Opcodes.MOVE_16:case Opcodes.MOVE_WIDE_16:case Opcodes.MOVE_OBJECT_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint a=codeIn.read();\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY:case Opcodes.INVOKE_VIRTUAL:case Opcodes.INVOKE_SUPER:case Opcodes.INVOKE_DIRECT:case Opcodes.INVOKE_STATIC:case Opcodes.INVOKE_INTERFACE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint e=InstructionCodec.nibble2(opcodeUnit);\nint registerCount=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint abcd=codeIn.read();\nint a=InstructionCodec.nibble0(abcd);\nint b=InstructionCodec.nibble1(abcd);\nint c=InstructionCodec.nibble2(abcd);\nint d=InstructionCodec.nibble3(abcd);\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\nswitch (registerCount) {\ncase 0:{\niv.visitZeroRegisterInsn(currentAddress,opcode,index,indexType,0,0L);\nbreak;\n}\ncase 1:{\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase 2:{\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase 3:{\niv.visitThreeRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c);\nbreak;\n}\ncase 4:{\niv.visitFourRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d);\nbreak;\n}\ncase 5:{\niv.visitFiveRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d,e);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus registerCount: \" + Hex.uNibble(registerCount));\n}\n}\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY_RANGE:case Opcodes.INVOKE_VIRTUAL_RANGE:case Opcodes.INVOKE_SUPER_RANGE:case Opcodes.INVOKE_DIRECT_RANGE:case Opcodes.INVOKE_STATIC_RANGE:case Opcodes.INVOKE_INTERFACE_RANGE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint registerCount=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint a=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitRegisterRangeInsn(currentAddress,opcode,index,indexType,0,0L,a,registerCount);\nbreak;\n}\ncase Opcodes.CONST_WIDE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=codeIn.readLong();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA_PAYLOAD:{\nint elementWidth=codeIn.read();\nint size=codeIn.readInt();\nswitch (elementWidth) {\ncase 1:{\nbyte[] array=new byte[size];\nboolean even=true;\nfor (int i=0, value=0; i < size; ++i, even=!even) {\nif (even) {\nvalue=codeIn.read();\n}\narray[i]=(byte)(value & 0xff);\nvalue>>=8;\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,1);\nbreak;\n}\ncase 2:{\nshort[] array=new short[size];\nfor (int i=0; i < size; i++) {\narray[i]=(short)codeIn.read();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,2);\nbreak;\n}\ncase 4:{\nint[] array=new int[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readInt();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,4);\nbreak;\n}\ncase 8:{\nlong[] array=new long[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readLong();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,8);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus element_width: \" + Hex.u2(elementWidth));\n}\n}\nbreak;\n}\ncase Opcodes.PACKED_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint firstKey=codeIn.readInt();\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitPackedSwitchPayloadInsn(currentAddress,opcodeUnit,firstKey,targets);\nbreak;\n}\ncase Opcodes.SPARSE_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint[] keys=new int[size];\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\nkeys[i]=codeIn.readInt();\n}\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitSparseSwitchPayloadInsn(currentAddress,opcodeUnit,keys,targets);\nbreak;\n}\ndefault:{\nthrow new IllegalStateException(\"Unknown opcode: \" + Hex.u4(opcodeForSwitch));\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 2528,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 25691,
        "startLineNumber" : 38,
        "startColumnNumber" : 33,
        "endLineNumber" : 563,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  int currentAddress=codeIn.cursor();\n  int opcodeUnit=codeIn.read();\n  int opcodeForSwitch=Opcodes.extractOpcodeFromUnit(opcodeUnit);\nswitch (opcodeForSwitch) {\ncase Opcodes.SPECIAL_FORMAT:{\n      iv.visitZeroRegisterInsn(currentAddress,opcodeUnit,0,InstructionCodec.INDEX_TYPE_NONE,0,0L);\n      break;\n    }\ncase Opcodes.GOTO:{\n    int opcode=InstructionCodec.byte0(opcodeUnit);\n    int target=(byte)InstructionCodec.byte1(opcodeUnit);\n    iv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L);\n    break;\n  }\ncase Opcodes.NOP:case Opcodes.RETURN_VOID:{\n  int opcode=InstructionCodec.byte0(opcodeUnit);\n  int literal=InstructionCodec.byte1(opcodeUnit);\n  iv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal);\n  break;\n}\ncase Opcodes.CONST_4:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint literal=(InstructionCodec.nibble3(opcodeUnit) << 28) >> 28;\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.MOVE_RESULT:case Opcodes.MOVE_RESULT_WIDE:case Opcodes.MOVE_RESULT_OBJECT:case Opcodes.MOVE_EXCEPTION:case Opcodes.RETURN:case Opcodes.RETURN_WIDE:case Opcodes.RETURN_OBJECT:case Opcodes.MONITOR_ENTER:case Opcodes.MONITOR_EXIT:case Opcodes.THROW:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a);\nbreak;\n}\ncase Opcodes.MOVE:case Opcodes.MOVE_WIDE:case Opcodes.MOVE_OBJECT:case Opcodes.ARRAY_LENGTH:case Opcodes.NEG_INT:case Opcodes.NOT_INT:case Opcodes.NEG_LONG:case Opcodes.NOT_LONG:case Opcodes.NEG_FLOAT:case Opcodes.NEG_DOUBLE:case Opcodes.INT_TO_LONG:case Opcodes.INT_TO_FLOAT:case Opcodes.INT_TO_DOUBLE:case Opcodes.LONG_TO_INT:case Opcodes.LONG_TO_FLOAT:case Opcodes.LONG_TO_DOUBLE:case Opcodes.FLOAT_TO_INT:case Opcodes.FLOAT_TO_LONG:case Opcodes.FLOAT_TO_DOUBLE:case Opcodes.DOUBLE_TO_INT:case Opcodes.DOUBLE_TO_LONG:case Opcodes.DOUBLE_TO_FLOAT:case Opcodes.INT_TO_BYTE:case Opcodes.INT_TO_CHAR:case Opcodes.INT_TO_SHORT:case Opcodes.ADD_INT_2ADDR:case Opcodes.SUB_INT_2ADDR:case Opcodes.MUL_INT_2ADDR:case Opcodes.DIV_INT_2ADDR:case Opcodes.REM_INT_2ADDR:case Opcodes.AND_INT_2ADDR:case Opcodes.OR_INT_2ADDR:case Opcodes.XOR_INT_2ADDR:case Opcodes.SHL_INT_2ADDR:case Opcodes.SHR_INT_2ADDR:case Opcodes.USHR_INT_2ADDR:case Opcodes.ADD_LONG_2ADDR:case Opcodes.SUB_LONG_2ADDR:case Opcodes.MUL_LONG_2ADDR:case Opcodes.DIV_LONG_2ADDR:case Opcodes.REM_LONG_2ADDR:case Opcodes.AND_LONG_2ADDR:case Opcodes.OR_LONG_2ADDR:case Opcodes.XOR_LONG_2ADDR:case Opcodes.SHL_LONG_2ADDR:case Opcodes.SHR_LONG_2ADDR:case Opcodes.USHR_LONG_2ADDR:case Opcodes.ADD_FLOAT_2ADDR:case Opcodes.SUB_FLOAT_2ADDR:case Opcodes.MUL_FLOAT_2ADDR:case Opcodes.DIV_FLOAT_2ADDR:case Opcodes.REM_FLOAT_2ADDR:case Opcodes.ADD_DOUBLE_2ADDR:case Opcodes.SUB_DOUBLE_2ADDR:case Opcodes.MUL_DOUBLE_2ADDR:case Opcodes.DIV_DOUBLE_2ADDR:case Opcodes.REM_DOUBLE_2ADDR:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.GOTO_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING:case Opcodes.CONST_CLASS:case Opcodes.CHECK_CAST:case Opcodes.NEW_INSTANCE:case Opcodes.SGET:case Opcodes.SGET_WIDE:case Opcodes.SGET_OBJECT:case Opcodes.SGET_BOOLEAN:case Opcodes.SGET_BYTE:case Opcodes.SGET_CHAR:case Opcodes.SGET_SHORT:case Opcodes.SPUT:case Opcodes.SPUT_WIDE:case Opcodes.SPUT_OBJECT:case Opcodes.SPUT_BOOLEAN:case Opcodes.SPUT_BYTE:case Opcodes.SPUT_CHAR:case Opcodes.SPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST_HIGH16:case Opcodes.CONST_WIDE_HIGH16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=(short)codeIn.read();\nliteral<<=(opcode == Opcodes.CONST_HIGH16) ? 16 : 48;\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.CONST_16:case Opcodes.CONST_WIDE_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.IF_EQZ:case Opcodes.IF_NEZ:case Opcodes.IF_LTZ:case Opcodes.IF_GEZ:case Opcodes.IF_GTZ:case Opcodes.IF_LEZ:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT8:case Opcodes.RSUB_INT_LIT8:case Opcodes.MUL_INT_LIT8:case Opcodes.DIV_INT_LIT8:case Opcodes.REM_INT_LIT8:case Opcodes.AND_INT_LIT8:case Opcodes.OR_INT_LIT8:case Opcodes.XOR_INT_LIT8:case Opcodes.SHL_INT_LIT8:case Opcodes.SHR_INT_LIT8:case Opcodes.USHR_INT_LIT8:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint literal=(byte)InstructionCodec.byte1(bc);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.INSTANCE_OF:case Opcodes.NEW_ARRAY:case Opcodes.IGET:case Opcodes.IGET_WIDE:case Opcodes.IGET_OBJECT:case Opcodes.IGET_BOOLEAN:case Opcodes.IGET_BYTE:case Opcodes.IGET_CHAR:case Opcodes.IGET_SHORT:case Opcodes.IPUT:case Opcodes.IPUT_WIDE:case Opcodes.IPUT_OBJECT:case Opcodes.IPUT_BOOLEAN:case Opcodes.IPUT_BYTE:case Opcodes.IPUT_CHAR:case Opcodes.IPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT16:case Opcodes.RSUB_INT:case Opcodes.MUL_INT_LIT16:case Opcodes.DIV_INT_LIT16:case Opcodes.REM_INT_LIT16:case Opcodes.AND_INT_LIT16:case Opcodes.OR_INT_LIT16:case Opcodes.XOR_INT_LIT16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.IF_EQ:case Opcodes.IF_NE:case Opcodes.IF_LT:case Opcodes.IF_GE:case Opcodes.IF_GT:case Opcodes.IF_LE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a,b);\nbreak;\n}\ncase Opcodes.MOVE_FROM16:case Opcodes.MOVE_WIDE_FROM16:case Opcodes.MOVE_OBJECT_FROM16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.CMPL_FLOAT:case Opcodes.CMPG_FLOAT:case Opcodes.CMPL_DOUBLE:case Opcodes.CMPG_DOUBLE:case Opcodes.CMP_LONG:case Opcodes.AGET:case Opcodes.AGET_WIDE:case Opcodes.AGET_OBJECT:case Opcodes.AGET_BOOLEAN:case Opcodes.AGET_BYTE:case Opcodes.AGET_CHAR:case Opcodes.AGET_SHORT:case Opcodes.APUT:case Opcodes.APUT_WIDE:case Opcodes.APUT_OBJECT:case Opcodes.APUT_BOOLEAN:case Opcodes.APUT_BYTE:case Opcodes.APUT_CHAR:case Opcodes.APUT_SHORT:case Opcodes.ADD_INT:case Opcodes.SUB_INT:case Opcodes.MUL_INT:case Opcodes.DIV_INT:case Opcodes.REM_INT:case Opcodes.AND_INT:case Opcodes.OR_INT:case Opcodes.XOR_INT:case Opcodes.SHL_INT:case Opcodes.SHR_INT:case Opcodes.USHR_INT:case Opcodes.ADD_LONG:case Opcodes.SUB_LONG:case Opcodes.MUL_LONG:case Opcodes.DIV_LONG:case Opcodes.REM_LONG:case Opcodes.AND_LONG:case Opcodes.OR_LONG:case Opcodes.XOR_LONG:case Opcodes.SHL_LONG:case Opcodes.SHR_LONG:case Opcodes.USHR_LONG:case Opcodes.ADD_FLOAT:case Opcodes.SUB_FLOAT:case Opcodes.MUL_FLOAT:case Opcodes.DIV_FLOAT:case Opcodes.REM_FLOAT:case Opcodes.ADD_DOUBLE:case Opcodes.SUB_DOUBLE:case Opcodes.MUL_DOUBLE:case Opcodes.DIV_DOUBLE:case Opcodes.REM_DOUBLE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint c=InstructionCodec.byte1(bc);\niv.visitThreeRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b,c);\nbreak;\n}\ncase Opcodes.GOTO_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=codeIn.readInt();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING_JUMBO:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.readInt();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST:case Opcodes.CONST_WIDE_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=codeIn.readInt();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA:case Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=currentAddress + codeIn.readInt();\nswitch (opcode) {\ncase Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\ncodeIn.setBaseAddress(target + 1,currentAddress);\nbreak;\n}\ndefault:{\nbreak;\n}\n}\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,target,0L,a);\nbreak;\n}\ncase Opcodes.MOVE_16:case Opcodes.MOVE_WIDE_16:case Opcodes.MOVE_OBJECT_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint a=codeIn.read();\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY:case Opcodes.INVOKE_VIRTUAL:case Opcodes.INVOKE_SUPER:case Opcodes.INVOKE_DIRECT:case Opcodes.INVOKE_STATIC:case Opcodes.INVOKE_INTERFACE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint e=InstructionCodec.nibble2(opcodeUnit);\nint registerCount=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint abcd=codeIn.read();\nint a=InstructionCodec.nibble0(abcd);\nint b=InstructionCodec.nibble1(abcd);\nint c=InstructionCodec.nibble2(abcd);\nint d=InstructionCodec.nibble3(abcd);\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\nswitch (registerCount) {\ncase 0:{\niv.visitZeroRegisterInsn(currentAddress,opcode,index,indexType,0,0L);\nbreak;\n}\ncase 1:{\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase 2:{\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase 3:{\niv.visitThreeRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c);\nbreak;\n}\ncase 4:{\niv.visitFourRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d);\nbreak;\n}\ncase 5:{\niv.visitFiveRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d,e);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus registerCount: \" + Hex.uNibble(registerCount));\n}\n}\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY_RANGE:case Opcodes.INVOKE_VIRTUAL_RANGE:case Opcodes.INVOKE_SUPER_RANGE:case Opcodes.INVOKE_DIRECT_RANGE:case Opcodes.INVOKE_STATIC_RANGE:case Opcodes.INVOKE_INTERFACE_RANGE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint registerCount=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint a=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitRegisterRangeInsn(currentAddress,opcode,index,indexType,0,0L,a,registerCount);\nbreak;\n}\ncase Opcodes.CONST_WIDE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=codeIn.readLong();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA_PAYLOAD:{\nint elementWidth=codeIn.read();\nint size=codeIn.readInt();\nswitch (elementWidth) {\ncase 1:{\nbyte[] array=new byte[size];\nboolean even=true;\nfor (int i=0, value=0; i < size; ++i, even=!even) {\nif (even) {\nvalue=codeIn.read();\n}\narray[i]=(byte)(value & 0xff);\nvalue>>=8;\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,1);\nbreak;\n}\ncase 2:{\nshort[] array=new short[size];\nfor (int i=0; i < size; i++) {\narray[i]=(short)codeIn.read();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,2);\nbreak;\n}\ncase 4:{\nint[] array=new int[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readInt();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,4);\nbreak;\n}\ncase 8:{\nlong[] array=new long[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readLong();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,8);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus element_width: \" + Hex.u2(elementWidth));\n}\n}\nbreak;\n}\ncase Opcodes.PACKED_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint firstKey=codeIn.readInt();\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitPackedSwitchPayloadInsn(currentAddress,opcodeUnit,firstKey,targets);\nbreak;\n}\ncase Opcodes.SPARSE_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint[] keys=new int[size];\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\nkeys[i]=codeIn.readInt();\n}\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitSparseSwitchPayloadInsn(currentAddress,opcodeUnit,keys,targets);\nbreak;\n}\ndefault:{\nthrow new IllegalStateException(\"Unknown opcode: \" + Hex.u4(opcodeForSwitch));\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2551,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 25716,
        "startLineNumber" : 38,
        "startColumnNumber" : 8,
        "endLineNumber" : 563,
        "endColumnNumber" : 9
      },
      "nodeContext" : "while (codeIn.hasMore()) {\n  int currentAddress=codeIn.cursor();\n  int opcodeUnit=codeIn.read();\n  int opcodeForSwitch=Opcodes.extractOpcodeFromUnit(opcodeUnit);\nswitch (opcodeForSwitch) {\ncase Opcodes.SPECIAL_FORMAT:{\n      iv.visitZeroRegisterInsn(currentAddress,opcodeUnit,0,InstructionCodec.INDEX_TYPE_NONE,0,0L);\n      break;\n    }\ncase Opcodes.GOTO:{\n    int opcode=InstructionCodec.byte0(opcodeUnit);\n    int target=(byte)InstructionCodec.byte1(opcodeUnit);\n    iv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L);\n    break;\n  }\ncase Opcodes.NOP:case Opcodes.RETURN_VOID:{\n  int opcode=InstructionCodec.byte0(opcodeUnit);\n  int literal=InstructionCodec.byte1(opcodeUnit);\n  iv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal);\n  break;\n}\ncase Opcodes.CONST_4:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint literal=(InstructionCodec.nibble3(opcodeUnit) << 28) >> 28;\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.MOVE_RESULT:case Opcodes.MOVE_RESULT_WIDE:case Opcodes.MOVE_RESULT_OBJECT:case Opcodes.MOVE_EXCEPTION:case Opcodes.RETURN:case Opcodes.RETURN_WIDE:case Opcodes.RETURN_OBJECT:case Opcodes.MONITOR_ENTER:case Opcodes.MONITOR_EXIT:case Opcodes.THROW:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a);\nbreak;\n}\ncase Opcodes.MOVE:case Opcodes.MOVE_WIDE:case Opcodes.MOVE_OBJECT:case Opcodes.ARRAY_LENGTH:case Opcodes.NEG_INT:case Opcodes.NOT_INT:case Opcodes.NEG_LONG:case Opcodes.NOT_LONG:case Opcodes.NEG_FLOAT:case Opcodes.NEG_DOUBLE:case Opcodes.INT_TO_LONG:case Opcodes.INT_TO_FLOAT:case Opcodes.INT_TO_DOUBLE:case Opcodes.LONG_TO_INT:case Opcodes.LONG_TO_FLOAT:case Opcodes.LONG_TO_DOUBLE:case Opcodes.FLOAT_TO_INT:case Opcodes.FLOAT_TO_LONG:case Opcodes.FLOAT_TO_DOUBLE:case Opcodes.DOUBLE_TO_INT:case Opcodes.DOUBLE_TO_LONG:case Opcodes.DOUBLE_TO_FLOAT:case Opcodes.INT_TO_BYTE:case Opcodes.INT_TO_CHAR:case Opcodes.INT_TO_SHORT:case Opcodes.ADD_INT_2ADDR:case Opcodes.SUB_INT_2ADDR:case Opcodes.MUL_INT_2ADDR:case Opcodes.DIV_INT_2ADDR:case Opcodes.REM_INT_2ADDR:case Opcodes.AND_INT_2ADDR:case Opcodes.OR_INT_2ADDR:case Opcodes.XOR_INT_2ADDR:case Opcodes.SHL_INT_2ADDR:case Opcodes.SHR_INT_2ADDR:case Opcodes.USHR_INT_2ADDR:case Opcodes.ADD_LONG_2ADDR:case Opcodes.SUB_LONG_2ADDR:case Opcodes.MUL_LONG_2ADDR:case Opcodes.DIV_LONG_2ADDR:case Opcodes.REM_LONG_2ADDR:case Opcodes.AND_LONG_2ADDR:case Opcodes.OR_LONG_2ADDR:case Opcodes.XOR_LONG_2ADDR:case Opcodes.SHL_LONG_2ADDR:case Opcodes.SHR_LONG_2ADDR:case Opcodes.USHR_LONG_2ADDR:case Opcodes.ADD_FLOAT_2ADDR:case Opcodes.SUB_FLOAT_2ADDR:case Opcodes.MUL_FLOAT_2ADDR:case Opcodes.DIV_FLOAT_2ADDR:case Opcodes.REM_FLOAT_2ADDR:case Opcodes.ADD_DOUBLE_2ADDR:case Opcodes.SUB_DOUBLE_2ADDR:case Opcodes.MUL_DOUBLE_2ADDR:case Opcodes.DIV_DOUBLE_2ADDR:case Opcodes.REM_DOUBLE_2ADDR:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.GOTO_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING:case Opcodes.CONST_CLASS:case Opcodes.CHECK_CAST:case Opcodes.NEW_INSTANCE:case Opcodes.SGET:case Opcodes.SGET_WIDE:case Opcodes.SGET_OBJECT:case Opcodes.SGET_BOOLEAN:case Opcodes.SGET_BYTE:case Opcodes.SGET_CHAR:case Opcodes.SGET_SHORT:case Opcodes.SPUT:case Opcodes.SPUT_WIDE:case Opcodes.SPUT_OBJECT:case Opcodes.SPUT_BOOLEAN:case Opcodes.SPUT_BYTE:case Opcodes.SPUT_CHAR:case Opcodes.SPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST_HIGH16:case Opcodes.CONST_WIDE_HIGH16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=(short)codeIn.read();\nliteral<<=(opcode == Opcodes.CONST_HIGH16) ? 16 : 48;\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.CONST_16:case Opcodes.CONST_WIDE_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.IF_EQZ:case Opcodes.IF_NEZ:case Opcodes.IF_LTZ:case Opcodes.IF_GEZ:case Opcodes.IF_GTZ:case Opcodes.IF_LEZ:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT8:case Opcodes.RSUB_INT_LIT8:case Opcodes.MUL_INT_LIT8:case Opcodes.DIV_INT_LIT8:case Opcodes.REM_INT_LIT8:case Opcodes.AND_INT_LIT8:case Opcodes.OR_INT_LIT8:case Opcodes.XOR_INT_LIT8:case Opcodes.SHL_INT_LIT8:case Opcodes.SHR_INT_LIT8:case Opcodes.USHR_INT_LIT8:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint literal=(byte)InstructionCodec.byte1(bc);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.INSTANCE_OF:case Opcodes.NEW_ARRAY:case Opcodes.IGET:case Opcodes.IGET_WIDE:case Opcodes.IGET_OBJECT:case Opcodes.IGET_BOOLEAN:case Opcodes.IGET_BYTE:case Opcodes.IGET_CHAR:case Opcodes.IGET_SHORT:case Opcodes.IPUT:case Opcodes.IPUT_WIDE:case Opcodes.IPUT_OBJECT:case Opcodes.IPUT_BOOLEAN:case Opcodes.IPUT_BYTE:case Opcodes.IPUT_CHAR:case Opcodes.IPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT16:case Opcodes.RSUB_INT:case Opcodes.MUL_INT_LIT16:case Opcodes.DIV_INT_LIT16:case Opcodes.REM_INT_LIT16:case Opcodes.AND_INT_LIT16:case Opcodes.OR_INT_LIT16:case Opcodes.XOR_INT_LIT16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.IF_EQ:case Opcodes.IF_NE:case Opcodes.IF_LT:case Opcodes.IF_GE:case Opcodes.IF_GT:case Opcodes.IF_LE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a,b);\nbreak;\n}\ncase Opcodes.MOVE_FROM16:case Opcodes.MOVE_WIDE_FROM16:case Opcodes.MOVE_OBJECT_FROM16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.CMPL_FLOAT:case Opcodes.CMPG_FLOAT:case Opcodes.CMPL_DOUBLE:case Opcodes.CMPG_DOUBLE:case Opcodes.CMP_LONG:case Opcodes.AGET:case Opcodes.AGET_WIDE:case Opcodes.AGET_OBJECT:case Opcodes.AGET_BOOLEAN:case Opcodes.AGET_BYTE:case Opcodes.AGET_CHAR:case Opcodes.AGET_SHORT:case Opcodes.APUT:case Opcodes.APUT_WIDE:case Opcodes.APUT_OBJECT:case Opcodes.APUT_BOOLEAN:case Opcodes.APUT_BYTE:case Opcodes.APUT_CHAR:case Opcodes.APUT_SHORT:case Opcodes.ADD_INT:case Opcodes.SUB_INT:case Opcodes.MUL_INT:case Opcodes.DIV_INT:case Opcodes.REM_INT:case Opcodes.AND_INT:case Opcodes.OR_INT:case Opcodes.XOR_INT:case Opcodes.SHL_INT:case Opcodes.SHR_INT:case Opcodes.USHR_INT:case Opcodes.ADD_LONG:case Opcodes.SUB_LONG:case Opcodes.MUL_LONG:case Opcodes.DIV_LONG:case Opcodes.REM_LONG:case Opcodes.AND_LONG:case Opcodes.OR_LONG:case Opcodes.XOR_LONG:case Opcodes.SHL_LONG:case Opcodes.SHR_LONG:case Opcodes.USHR_LONG:case Opcodes.ADD_FLOAT:case Opcodes.SUB_FLOAT:case Opcodes.MUL_FLOAT:case Opcodes.DIV_FLOAT:case Opcodes.REM_FLOAT:case Opcodes.ADD_DOUBLE:case Opcodes.SUB_DOUBLE:case Opcodes.MUL_DOUBLE:case Opcodes.DIV_DOUBLE:case Opcodes.REM_DOUBLE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint c=InstructionCodec.byte1(bc);\niv.visitThreeRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b,c);\nbreak;\n}\ncase Opcodes.GOTO_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=codeIn.readInt();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING_JUMBO:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.readInt();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST:case Opcodes.CONST_WIDE_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=codeIn.readInt();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA:case Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=currentAddress + codeIn.readInt();\nswitch (opcode) {\ncase Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\ncodeIn.setBaseAddress(target + 1,currentAddress);\nbreak;\n}\ndefault:{\nbreak;\n}\n}\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,target,0L,a);\nbreak;\n}\ncase Opcodes.MOVE_16:case Opcodes.MOVE_WIDE_16:case Opcodes.MOVE_OBJECT_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint a=codeIn.read();\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY:case Opcodes.INVOKE_VIRTUAL:case Opcodes.INVOKE_SUPER:case Opcodes.INVOKE_DIRECT:case Opcodes.INVOKE_STATIC:case Opcodes.INVOKE_INTERFACE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint e=InstructionCodec.nibble2(opcodeUnit);\nint registerCount=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint abcd=codeIn.read();\nint a=InstructionCodec.nibble0(abcd);\nint b=InstructionCodec.nibble1(abcd);\nint c=InstructionCodec.nibble2(abcd);\nint d=InstructionCodec.nibble3(abcd);\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\nswitch (registerCount) {\ncase 0:{\niv.visitZeroRegisterInsn(currentAddress,opcode,index,indexType,0,0L);\nbreak;\n}\ncase 1:{\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase 2:{\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase 3:{\niv.visitThreeRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c);\nbreak;\n}\ncase 4:{\niv.visitFourRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d);\nbreak;\n}\ncase 5:{\niv.visitFiveRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d,e);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus registerCount: \" + Hex.uNibble(registerCount));\n}\n}\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY_RANGE:case Opcodes.INVOKE_VIRTUAL_RANGE:case Opcodes.INVOKE_SUPER_RANGE:case Opcodes.INVOKE_DIRECT_RANGE:case Opcodes.INVOKE_STATIC_RANGE:case Opcodes.INVOKE_INTERFACE_RANGE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint registerCount=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint a=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitRegisterRangeInsn(currentAddress,opcode,index,indexType,0,0L,a,registerCount);\nbreak;\n}\ncase Opcodes.CONST_WIDE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=codeIn.readLong();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA_PAYLOAD:{\nint elementWidth=codeIn.read();\nint size=codeIn.readInt();\nswitch (elementWidth) {\ncase 1:{\nbyte[] array=new byte[size];\nboolean even=true;\nfor (int i=0, value=0; i < size; ++i, even=!even) {\nif (even) {\nvalue=codeIn.read();\n}\narray[i]=(byte)(value & 0xff);\nvalue>>=8;\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,1);\nbreak;\n}\ncase 2:{\nshort[] array=new short[size];\nfor (int i=0; i < size; i++) {\narray[i]=(short)codeIn.read();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,2);\nbreak;\n}\ncase 4:{\nint[] array=new int[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readInt();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,4);\nbreak;\n}\ncase 8:{\nlong[] array=new long[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readLong();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,8);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus element_width: \" + Hex.u2(elementWidth));\n}\n}\nbreak;\n}\ncase Opcodes.PACKED_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint firstKey=codeIn.readInt();\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitPackedSwitchPayloadInsn(currentAddress,opcodeUnit,firstKey,targets);\nbreak;\n}\ncase Opcodes.SPARSE_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint[] keys=new int[size];\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\nkeys[i]=codeIn.readInt();\n}\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitSparseSwitchPayloadInsn(currentAddress,opcodeUnit,keys,targets);\nbreak;\n}\ndefault:{\nthrow new IllegalStateException(\"Unknown opcode: \" + Hex.u4(opcodeForSwitch));\n}\n}\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 2555,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 25756,
        "startLineNumber" : 36,
        "startColumnNumber" : 66,
        "endLineNumber" : 564,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  codeIn.reset();\n  while (codeIn.hasMore()) {\n    int currentAddress=codeIn.cursor();\n    int opcodeUnit=codeIn.read();\n    int opcodeForSwitch=Opcodes.extractOpcodeFromUnit(opcodeUnit);\nswitch (opcodeForSwitch) {\ncase Opcodes.SPECIAL_FORMAT:{\n        iv.visitZeroRegisterInsn(currentAddress,opcodeUnit,0,InstructionCodec.INDEX_TYPE_NONE,0,0L);\n        break;\n      }\ncase Opcodes.GOTO:{\n      int opcode=InstructionCodec.byte0(opcodeUnit);\n      int target=(byte)InstructionCodec.byte1(opcodeUnit);\n      iv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L);\n      break;\n    }\ncase Opcodes.NOP:case Opcodes.RETURN_VOID:{\n    int opcode=InstructionCodec.byte0(opcodeUnit);\n    int literal=InstructionCodec.byte1(opcodeUnit);\n    iv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal);\n    break;\n  }\ncase Opcodes.CONST_4:{\n  int opcode=InstructionCodec.byte0(opcodeUnit);\n  int a=InstructionCodec.nibble2(opcodeUnit);\n  int literal=(InstructionCodec.nibble3(opcodeUnit) << 28) >> 28;\n  iv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\n  break;\n}\ncase Opcodes.MOVE_RESULT:case Opcodes.MOVE_RESULT_WIDE:case Opcodes.MOVE_RESULT_OBJECT:case Opcodes.MOVE_EXCEPTION:case Opcodes.RETURN:case Opcodes.RETURN_WIDE:case Opcodes.RETURN_OBJECT:case Opcodes.MONITOR_ENTER:case Opcodes.MONITOR_EXIT:case Opcodes.THROW:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a);\nbreak;\n}\ncase Opcodes.MOVE:case Opcodes.MOVE_WIDE:case Opcodes.MOVE_OBJECT:case Opcodes.ARRAY_LENGTH:case Opcodes.NEG_INT:case Opcodes.NOT_INT:case Opcodes.NEG_LONG:case Opcodes.NOT_LONG:case Opcodes.NEG_FLOAT:case Opcodes.NEG_DOUBLE:case Opcodes.INT_TO_LONG:case Opcodes.INT_TO_FLOAT:case Opcodes.INT_TO_DOUBLE:case Opcodes.LONG_TO_INT:case Opcodes.LONG_TO_FLOAT:case Opcodes.LONG_TO_DOUBLE:case Opcodes.FLOAT_TO_INT:case Opcodes.FLOAT_TO_LONG:case Opcodes.FLOAT_TO_DOUBLE:case Opcodes.DOUBLE_TO_INT:case Opcodes.DOUBLE_TO_LONG:case Opcodes.DOUBLE_TO_FLOAT:case Opcodes.INT_TO_BYTE:case Opcodes.INT_TO_CHAR:case Opcodes.INT_TO_SHORT:case Opcodes.ADD_INT_2ADDR:case Opcodes.SUB_INT_2ADDR:case Opcodes.MUL_INT_2ADDR:case Opcodes.DIV_INT_2ADDR:case Opcodes.REM_INT_2ADDR:case Opcodes.AND_INT_2ADDR:case Opcodes.OR_INT_2ADDR:case Opcodes.XOR_INT_2ADDR:case Opcodes.SHL_INT_2ADDR:case Opcodes.SHR_INT_2ADDR:case Opcodes.USHR_INT_2ADDR:case Opcodes.ADD_LONG_2ADDR:case Opcodes.SUB_LONG_2ADDR:case Opcodes.MUL_LONG_2ADDR:case Opcodes.DIV_LONG_2ADDR:case Opcodes.REM_LONG_2ADDR:case Opcodes.AND_LONG_2ADDR:case Opcodes.OR_LONG_2ADDR:case Opcodes.XOR_LONG_2ADDR:case Opcodes.SHL_LONG_2ADDR:case Opcodes.SHR_LONG_2ADDR:case Opcodes.USHR_LONG_2ADDR:case Opcodes.ADD_FLOAT_2ADDR:case Opcodes.SUB_FLOAT_2ADDR:case Opcodes.MUL_FLOAT_2ADDR:case Opcodes.DIV_FLOAT_2ADDR:case Opcodes.REM_FLOAT_2ADDR:case Opcodes.ADD_DOUBLE_2ADDR:case Opcodes.SUB_DOUBLE_2ADDR:case Opcodes.MUL_DOUBLE_2ADDR:case Opcodes.DIV_DOUBLE_2ADDR:case Opcodes.REM_DOUBLE_2ADDR:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.GOTO_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING:case Opcodes.CONST_CLASS:case Opcodes.CHECK_CAST:case Opcodes.NEW_INSTANCE:case Opcodes.SGET:case Opcodes.SGET_WIDE:case Opcodes.SGET_OBJECT:case Opcodes.SGET_BOOLEAN:case Opcodes.SGET_BYTE:case Opcodes.SGET_CHAR:case Opcodes.SGET_SHORT:case Opcodes.SPUT:case Opcodes.SPUT_WIDE:case Opcodes.SPUT_OBJECT:case Opcodes.SPUT_BOOLEAN:case Opcodes.SPUT_BYTE:case Opcodes.SPUT_CHAR:case Opcodes.SPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST_HIGH16:case Opcodes.CONST_WIDE_HIGH16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=(short)codeIn.read();\nliteral<<=(opcode == Opcodes.CONST_HIGH16) ? 16 : 48;\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.CONST_16:case Opcodes.CONST_WIDE_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.IF_EQZ:case Opcodes.IF_NEZ:case Opcodes.IF_LTZ:case Opcodes.IF_GEZ:case Opcodes.IF_GTZ:case Opcodes.IF_LEZ:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT8:case Opcodes.RSUB_INT_LIT8:case Opcodes.MUL_INT_LIT8:case Opcodes.DIV_INT_LIT8:case Opcodes.REM_INT_LIT8:case Opcodes.AND_INT_LIT8:case Opcodes.OR_INT_LIT8:case Opcodes.XOR_INT_LIT8:case Opcodes.SHL_INT_LIT8:case Opcodes.SHR_INT_LIT8:case Opcodes.USHR_INT_LIT8:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint literal=(byte)InstructionCodec.byte1(bc);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.INSTANCE_OF:case Opcodes.NEW_ARRAY:case Opcodes.IGET:case Opcodes.IGET_WIDE:case Opcodes.IGET_OBJECT:case Opcodes.IGET_BOOLEAN:case Opcodes.IGET_BYTE:case Opcodes.IGET_CHAR:case Opcodes.IGET_SHORT:case Opcodes.IPUT:case Opcodes.IPUT_WIDE:case Opcodes.IPUT_OBJECT:case Opcodes.IPUT_BOOLEAN:case Opcodes.IPUT_BYTE:case Opcodes.IPUT_CHAR:case Opcodes.IPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT16:case Opcodes.RSUB_INT:case Opcodes.MUL_INT_LIT16:case Opcodes.DIV_INT_LIT16:case Opcodes.REM_INT_LIT16:case Opcodes.AND_INT_LIT16:case Opcodes.OR_INT_LIT16:case Opcodes.XOR_INT_LIT16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.IF_EQ:case Opcodes.IF_NE:case Opcodes.IF_LT:case Opcodes.IF_GE:case Opcodes.IF_GT:case Opcodes.IF_LE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a,b);\nbreak;\n}\ncase Opcodes.MOVE_FROM16:case Opcodes.MOVE_WIDE_FROM16:case Opcodes.MOVE_OBJECT_FROM16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.CMPL_FLOAT:case Opcodes.CMPG_FLOAT:case Opcodes.CMPL_DOUBLE:case Opcodes.CMPG_DOUBLE:case Opcodes.CMP_LONG:case Opcodes.AGET:case Opcodes.AGET_WIDE:case Opcodes.AGET_OBJECT:case Opcodes.AGET_BOOLEAN:case Opcodes.AGET_BYTE:case Opcodes.AGET_CHAR:case Opcodes.AGET_SHORT:case Opcodes.APUT:case Opcodes.APUT_WIDE:case Opcodes.APUT_OBJECT:case Opcodes.APUT_BOOLEAN:case Opcodes.APUT_BYTE:case Opcodes.APUT_CHAR:case Opcodes.APUT_SHORT:case Opcodes.ADD_INT:case Opcodes.SUB_INT:case Opcodes.MUL_INT:case Opcodes.DIV_INT:case Opcodes.REM_INT:case Opcodes.AND_INT:case Opcodes.OR_INT:case Opcodes.XOR_INT:case Opcodes.SHL_INT:case Opcodes.SHR_INT:case Opcodes.USHR_INT:case Opcodes.ADD_LONG:case Opcodes.SUB_LONG:case Opcodes.MUL_LONG:case Opcodes.DIV_LONG:case Opcodes.REM_LONG:case Opcodes.AND_LONG:case Opcodes.OR_LONG:case Opcodes.XOR_LONG:case Opcodes.SHL_LONG:case Opcodes.SHR_LONG:case Opcodes.USHR_LONG:case Opcodes.ADD_FLOAT:case Opcodes.SUB_FLOAT:case Opcodes.MUL_FLOAT:case Opcodes.DIV_FLOAT:case Opcodes.REM_FLOAT:case Opcodes.ADD_DOUBLE:case Opcodes.SUB_DOUBLE:case Opcodes.MUL_DOUBLE:case Opcodes.DIV_DOUBLE:case Opcodes.REM_DOUBLE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint c=InstructionCodec.byte1(bc);\niv.visitThreeRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b,c);\nbreak;\n}\ncase Opcodes.GOTO_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=codeIn.readInt();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING_JUMBO:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.readInt();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST:case Opcodes.CONST_WIDE_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=codeIn.readInt();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA:case Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=currentAddress + codeIn.readInt();\nswitch (opcode) {\ncase Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\ncodeIn.setBaseAddress(target + 1,currentAddress);\nbreak;\n}\ndefault:{\nbreak;\n}\n}\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,target,0L,a);\nbreak;\n}\ncase Opcodes.MOVE_16:case Opcodes.MOVE_WIDE_16:case Opcodes.MOVE_OBJECT_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint a=codeIn.read();\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY:case Opcodes.INVOKE_VIRTUAL:case Opcodes.INVOKE_SUPER:case Opcodes.INVOKE_DIRECT:case Opcodes.INVOKE_STATIC:case Opcodes.INVOKE_INTERFACE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint e=InstructionCodec.nibble2(opcodeUnit);\nint registerCount=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint abcd=codeIn.read();\nint a=InstructionCodec.nibble0(abcd);\nint b=InstructionCodec.nibble1(abcd);\nint c=InstructionCodec.nibble2(abcd);\nint d=InstructionCodec.nibble3(abcd);\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\nswitch (registerCount) {\ncase 0:{\niv.visitZeroRegisterInsn(currentAddress,opcode,index,indexType,0,0L);\nbreak;\n}\ncase 1:{\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase 2:{\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase 3:{\niv.visitThreeRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c);\nbreak;\n}\ncase 4:{\niv.visitFourRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d);\nbreak;\n}\ncase 5:{\niv.visitFiveRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d,e);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus registerCount: \" + Hex.uNibble(registerCount));\n}\n}\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY_RANGE:case Opcodes.INVOKE_VIRTUAL_RANGE:case Opcodes.INVOKE_SUPER_RANGE:case Opcodes.INVOKE_DIRECT_RANGE:case Opcodes.INVOKE_STATIC_RANGE:case Opcodes.INVOKE_INTERFACE_RANGE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint registerCount=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint a=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitRegisterRangeInsn(currentAddress,opcode,index,indexType,0,0L,a,registerCount);\nbreak;\n}\ncase Opcodes.CONST_WIDE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=codeIn.readLong();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA_PAYLOAD:{\nint elementWidth=codeIn.read();\nint size=codeIn.readInt();\nswitch (elementWidth) {\ncase 1:{\nbyte[] array=new byte[size];\nboolean even=true;\nfor (int i=0, value=0; i < size; ++i, even=!even) {\nif (even) {\nvalue=codeIn.read();\n}\narray[i]=(byte)(value & 0xff);\nvalue>>=8;\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,1);\nbreak;\n}\ncase 2:{\nshort[] array=new short[size];\nfor (int i=0; i < size; i++) {\narray[i]=(short)codeIn.read();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,2);\nbreak;\n}\ncase 4:{\nint[] array=new int[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readInt();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,4);\nbreak;\n}\ncase 8:{\nlong[] array=new long[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readLong();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,8);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus element_width: \" + Hex.u2(elementWidth));\n}\n}\nbreak;\n}\ncase Opcodes.PACKED_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint firstKey=codeIn.readInt();\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitPackedSwitchPayloadInsn(currentAddress,opcodeUnit,firstKey,targets);\nbreak;\n}\ncase Opcodes.SPARSE_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint[] keys=new int[size];\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\nkeys[i]=codeIn.readInt();\n}\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitSparseSwitchPayloadInsn(currentAddress,opcodeUnit,keys,targets);\nbreak;\n}\ndefault:{\nthrow new IllegalStateException(\"Unknown opcode: \" + Hex.u4(opcodeForSwitch));\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2560,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 25818,
        "startLineNumber" : 36,
        "startColumnNumber" : 4,
        "endLineNumber" : 564,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void accept(InstructionVisitor iv) throws EOFException {\n  codeIn.reset();\n  while (codeIn.hasMore()) {\n    int currentAddress=codeIn.cursor();\n    int opcodeUnit=codeIn.read();\n    int opcodeForSwitch=Opcodes.extractOpcodeFromUnit(opcodeUnit);\nswitch (opcodeForSwitch) {\ncase Opcodes.SPECIAL_FORMAT:{\n        iv.visitZeroRegisterInsn(currentAddress,opcodeUnit,0,InstructionCodec.INDEX_TYPE_NONE,0,0L);\n        break;\n      }\ncase Opcodes.GOTO:{\n      int opcode=InstructionCodec.byte0(opcodeUnit);\n      int target=(byte)InstructionCodec.byte1(opcodeUnit);\n      iv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L);\n      break;\n    }\ncase Opcodes.NOP:case Opcodes.RETURN_VOID:{\n    int opcode=InstructionCodec.byte0(opcodeUnit);\n    int literal=InstructionCodec.byte1(opcodeUnit);\n    iv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal);\n    break;\n  }\ncase Opcodes.CONST_4:{\n  int opcode=InstructionCodec.byte0(opcodeUnit);\n  int a=InstructionCodec.nibble2(opcodeUnit);\n  int literal=(InstructionCodec.nibble3(opcodeUnit) << 28) >> 28;\n  iv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\n  break;\n}\ncase Opcodes.MOVE_RESULT:case Opcodes.MOVE_RESULT_WIDE:case Opcodes.MOVE_RESULT_OBJECT:case Opcodes.MOVE_EXCEPTION:case Opcodes.RETURN:case Opcodes.RETURN_WIDE:case Opcodes.RETURN_OBJECT:case Opcodes.MONITOR_ENTER:case Opcodes.MONITOR_EXIT:case Opcodes.THROW:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a);\nbreak;\n}\ncase Opcodes.MOVE:case Opcodes.MOVE_WIDE:case Opcodes.MOVE_OBJECT:case Opcodes.ARRAY_LENGTH:case Opcodes.NEG_INT:case Opcodes.NOT_INT:case Opcodes.NEG_LONG:case Opcodes.NOT_LONG:case Opcodes.NEG_FLOAT:case Opcodes.NEG_DOUBLE:case Opcodes.INT_TO_LONG:case Opcodes.INT_TO_FLOAT:case Opcodes.INT_TO_DOUBLE:case Opcodes.LONG_TO_INT:case Opcodes.LONG_TO_FLOAT:case Opcodes.LONG_TO_DOUBLE:case Opcodes.FLOAT_TO_INT:case Opcodes.FLOAT_TO_LONG:case Opcodes.FLOAT_TO_DOUBLE:case Opcodes.DOUBLE_TO_INT:case Opcodes.DOUBLE_TO_LONG:case Opcodes.DOUBLE_TO_FLOAT:case Opcodes.INT_TO_BYTE:case Opcodes.INT_TO_CHAR:case Opcodes.INT_TO_SHORT:case Opcodes.ADD_INT_2ADDR:case Opcodes.SUB_INT_2ADDR:case Opcodes.MUL_INT_2ADDR:case Opcodes.DIV_INT_2ADDR:case Opcodes.REM_INT_2ADDR:case Opcodes.AND_INT_2ADDR:case Opcodes.OR_INT_2ADDR:case Opcodes.XOR_INT_2ADDR:case Opcodes.SHL_INT_2ADDR:case Opcodes.SHR_INT_2ADDR:case Opcodes.USHR_INT_2ADDR:case Opcodes.ADD_LONG_2ADDR:case Opcodes.SUB_LONG_2ADDR:case Opcodes.MUL_LONG_2ADDR:case Opcodes.DIV_LONG_2ADDR:case Opcodes.REM_LONG_2ADDR:case Opcodes.AND_LONG_2ADDR:case Opcodes.OR_LONG_2ADDR:case Opcodes.XOR_LONG_2ADDR:case Opcodes.SHL_LONG_2ADDR:case Opcodes.SHR_LONG_2ADDR:case Opcodes.USHR_LONG_2ADDR:case Opcodes.ADD_FLOAT_2ADDR:case Opcodes.SUB_FLOAT_2ADDR:case Opcodes.MUL_FLOAT_2ADDR:case Opcodes.DIV_FLOAT_2ADDR:case Opcodes.REM_FLOAT_2ADDR:case Opcodes.ADD_DOUBLE_2ADDR:case Opcodes.SUB_DOUBLE_2ADDR:case Opcodes.MUL_DOUBLE_2ADDR:case Opcodes.DIV_DOUBLE_2ADDR:case Opcodes.REM_DOUBLE_2ADDR:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.GOTO_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING:case Opcodes.CONST_CLASS:case Opcodes.CHECK_CAST:case Opcodes.NEW_INSTANCE:case Opcodes.SGET:case Opcodes.SGET_WIDE:case Opcodes.SGET_OBJECT:case Opcodes.SGET_BOOLEAN:case Opcodes.SGET_BYTE:case Opcodes.SGET_CHAR:case Opcodes.SGET_SHORT:case Opcodes.SPUT:case Opcodes.SPUT_WIDE:case Opcodes.SPUT_OBJECT:case Opcodes.SPUT_BOOLEAN:case Opcodes.SPUT_BYTE:case Opcodes.SPUT_CHAR:case Opcodes.SPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST_HIGH16:case Opcodes.CONST_WIDE_HIGH16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=(short)codeIn.read();\nliteral<<=(opcode == Opcodes.CONST_HIGH16) ? 16 : 48;\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.CONST_16:case Opcodes.CONST_WIDE_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.IF_EQZ:case Opcodes.IF_NEZ:case Opcodes.IF_LTZ:case Opcodes.IF_GEZ:case Opcodes.IF_GTZ:case Opcodes.IF_LEZ:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT8:case Opcodes.RSUB_INT_LIT8:case Opcodes.MUL_INT_LIT8:case Opcodes.DIV_INT_LIT8:case Opcodes.REM_INT_LIT8:case Opcodes.AND_INT_LIT8:case Opcodes.OR_INT_LIT8:case Opcodes.XOR_INT_LIT8:case Opcodes.SHL_INT_LIT8:case Opcodes.SHR_INT_LIT8:case Opcodes.USHR_INT_LIT8:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint literal=(byte)InstructionCodec.byte1(bc);\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.INSTANCE_OF:case Opcodes.NEW_ARRAY:case Opcodes.IGET:case Opcodes.IGET_WIDE:case Opcodes.IGET_OBJECT:case Opcodes.IGET_BOOLEAN:case Opcodes.IGET_BYTE:case Opcodes.IGET_CHAR:case Opcodes.IGET_SHORT:case Opcodes.IPUT:case Opcodes.IPUT_WIDE:case Opcodes.IPUT_OBJECT:case Opcodes.IPUT_BOOLEAN:case Opcodes.IPUT_BYTE:case Opcodes.IPUT_CHAR:case Opcodes.IPUT_SHORT:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase Opcodes.ADD_INT_LIT16:case Opcodes.RSUB_INT:case Opcodes.MUL_INT_LIT16:case Opcodes.DIV_INT_LIT16:case Opcodes.REM_INT_LIT16:case Opcodes.AND_INT_LIT16:case Opcodes.OR_INT_LIT16:case Opcodes.XOR_INT_LIT16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint literal=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.IF_EQ:case Opcodes.IF_NE:case Opcodes.IF_LT:case Opcodes.IF_GE:case Opcodes.IF_GT:case Opcodes.IF_LE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.nibble2(opcodeUnit);\nint b=InstructionCodec.nibble3(opcodeUnit);\nint target=(short)codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,0L,a,b);\nbreak;\n}\ncase Opcodes.MOVE_FROM16:case Opcodes.MOVE_WIDE_FROM16:case Opcodes.MOVE_OBJECT_FROM16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b);\nbreak;\n}\ncase Opcodes.CMPL_FLOAT:case Opcodes.CMPG_FLOAT:case Opcodes.CMPL_DOUBLE:case Opcodes.CMPG_DOUBLE:case Opcodes.CMP_LONG:case Opcodes.AGET:case Opcodes.AGET_WIDE:case Opcodes.AGET_OBJECT:case Opcodes.AGET_BOOLEAN:case Opcodes.AGET_BYTE:case Opcodes.AGET_CHAR:case Opcodes.AGET_SHORT:case Opcodes.APUT:case Opcodes.APUT_WIDE:case Opcodes.APUT_OBJECT:case Opcodes.APUT_BOOLEAN:case Opcodes.APUT_BYTE:case Opcodes.APUT_CHAR:case Opcodes.APUT_SHORT:case Opcodes.ADD_INT:case Opcodes.SUB_INT:case Opcodes.MUL_INT:case Opcodes.DIV_INT:case Opcodes.REM_INT:case Opcodes.AND_INT:case Opcodes.OR_INT:case Opcodes.XOR_INT:case Opcodes.SHL_INT:case Opcodes.SHR_INT:case Opcodes.USHR_INT:case Opcodes.ADD_LONG:case Opcodes.SUB_LONG:case Opcodes.MUL_LONG:case Opcodes.DIV_LONG:case Opcodes.REM_LONG:case Opcodes.AND_LONG:case Opcodes.OR_LONG:case Opcodes.XOR_LONG:case Opcodes.SHL_LONG:case Opcodes.SHR_LONG:case Opcodes.USHR_LONG:case Opcodes.ADD_FLOAT:case Opcodes.SUB_FLOAT:case Opcodes.MUL_FLOAT:case Opcodes.DIV_FLOAT:case Opcodes.REM_FLOAT:case Opcodes.ADD_DOUBLE:case Opcodes.SUB_DOUBLE:case Opcodes.MUL_DOUBLE:case Opcodes.DIV_DOUBLE:case Opcodes.REM_DOUBLE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint bc=codeIn.read();\nint b=InstructionCodec.byte0(bc);\nint c=InstructionCodec.byte1(bc);\niv.visitThreeRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,0L,a,b,c);\nbreak;\n}\ncase Opcodes.GOTO_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint target=codeIn.readInt();\niv.visitZeroRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,currentAddress + target,literal);\nbreak;\n}\ncase Opcodes.CONST_STRING_JUMBO:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.readInt();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase Opcodes.CONST:case Opcodes.CONST_WIDE_32:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint literal=codeIn.readInt();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA:case Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nint target=currentAddress + codeIn.readInt();\nswitch (opcode) {\ncase Opcodes.PACKED_SWITCH:case Opcodes.SPARSE_SWITCH:{\ncodeIn.setBaseAddress(target + 1,currentAddress);\nbreak;\n}\ndefault:{\nbreak;\n}\n}\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,target,0L,a);\nbreak;\n}\ncase Opcodes.MOVE_16:case Opcodes.MOVE_WIDE_16:case Opcodes.MOVE_OBJECT_16:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint literal=InstructionCodec.byte1(opcodeUnit);\nint a=codeIn.read();\nint b=codeIn.read();\niv.visitTwoRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a,b);\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY:case Opcodes.INVOKE_VIRTUAL:case Opcodes.INVOKE_SUPER:case Opcodes.INVOKE_DIRECT:case Opcodes.INVOKE_STATIC:case Opcodes.INVOKE_INTERFACE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint e=InstructionCodec.nibble2(opcodeUnit);\nint registerCount=InstructionCodec.nibble3(opcodeUnit);\nint index=codeIn.read();\nint abcd=codeIn.read();\nint a=InstructionCodec.nibble0(abcd);\nint b=InstructionCodec.nibble1(abcd);\nint c=InstructionCodec.nibble2(abcd);\nint d=InstructionCodec.nibble3(abcd);\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\nswitch (registerCount) {\ncase 0:{\niv.visitZeroRegisterInsn(currentAddress,opcode,index,indexType,0,0L);\nbreak;\n}\ncase 1:{\niv.visitOneRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a);\nbreak;\n}\ncase 2:{\niv.visitTwoRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b);\nbreak;\n}\ncase 3:{\niv.visitThreeRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c);\nbreak;\n}\ncase 4:{\niv.visitFourRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d);\nbreak;\n}\ncase 5:{\niv.visitFiveRegisterInsn(currentAddress,opcode,index,indexType,0,0L,a,b,c,d,e);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus registerCount: \" + Hex.uNibble(registerCount));\n}\n}\nbreak;\n}\ncase Opcodes.FILLED_NEW_ARRAY_RANGE:case Opcodes.INVOKE_VIRTUAL_RANGE:case Opcodes.INVOKE_SUPER_RANGE:case Opcodes.INVOKE_DIRECT_RANGE:case Opcodes.INVOKE_STATIC_RANGE:case Opcodes.INVOKE_INTERFACE_RANGE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint registerCount=InstructionCodec.byte1(opcodeUnit);\nint index=codeIn.read();\nint a=codeIn.read();\nint indexType=InstructionCodec.getInstructionIndexType(opcode);\niv.visitRegisterRangeInsn(currentAddress,opcode,index,indexType,0,0L,a,registerCount);\nbreak;\n}\ncase Opcodes.CONST_WIDE:{\nint opcode=InstructionCodec.byte0(opcodeUnit);\nint a=InstructionCodec.byte1(opcodeUnit);\nlong literal=codeIn.readLong();\niv.visitOneRegisterInsn(currentAddress,opcode,0,InstructionCodec.INDEX_TYPE_NONE,0,literal,a);\nbreak;\n}\ncase Opcodes.FILL_ARRAY_DATA_PAYLOAD:{\nint elementWidth=codeIn.read();\nint size=codeIn.readInt();\nswitch (elementWidth) {\ncase 1:{\nbyte[] array=new byte[size];\nboolean even=true;\nfor (int i=0, value=0; i < size; ++i, even=!even) {\nif (even) {\nvalue=codeIn.read();\n}\narray[i]=(byte)(value & 0xff);\nvalue>>=8;\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,1);\nbreak;\n}\ncase 2:{\nshort[] array=new short[size];\nfor (int i=0; i < size; i++) {\narray[i]=(short)codeIn.read();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,2);\nbreak;\n}\ncase 4:{\nint[] array=new int[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readInt();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,4);\nbreak;\n}\ncase 8:{\nlong[] array=new long[size];\nfor (int i=0; i < size; i++) {\narray[i]=codeIn.readLong();\n}\niv.visitFillArrayDataPayloadInsn(currentAddress,opcodeUnit,array,array.length,8);\nbreak;\n}\ndefault:{\nthrow new DexException(\"bogus element_width: \" + Hex.u2(elementWidth));\n}\n}\nbreak;\n}\ncase Opcodes.PACKED_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint firstKey=codeIn.readInt();\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitPackedSwitchPayloadInsn(currentAddress,opcodeUnit,firstKey,targets);\nbreak;\n}\ncase Opcodes.SPARSE_SWITCH_PAYLOAD:{\nint baseAddress=codeIn.baseAddressForCursor();\nint size=codeIn.read();\nint[] keys=new int[size];\nint[] targets=new int[size];\nfor (int i=0; i < size; i++) {\nkeys[i]=codeIn.readInt();\n}\nfor (int i=0; i < size; i++) {\ntargets[i]=baseAddress + codeIn.readInt();\n}\niv.visitSparseSwitchPayloadInsn(currentAddress,opcodeUnit,keys,targets);\nbreak;\n}\ndefault:{\nthrow new IllegalStateException(\"Unknown opcode: \" + Hex.u4(opcodeForSwitch));\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 2570,
      "astHeight" : 16
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 302,
        "startColumnNumber" : 16,
        "endLineNumber" : 302,
        "endColumnNumber" : 42
      },
      "nodeContext" : "case Opcodes.AGET_BOOLEAN:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 4,
      "astHeight" : 3
    },
    "tokenLength" : 3,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 20,
    "startLineNumber" : 302,
    "startColumnNumber" : 21,
    "endLineNumber" : 302,
    "endColumnNumber" : 41
  } ],
  "layoutRelationDataList" : [ ]
}