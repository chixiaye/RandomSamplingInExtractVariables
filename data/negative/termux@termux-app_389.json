{
  "id" : 389,
  "expression" : "true",
  "projectName" : "termux@termux-app",
  "commitID" : "c6d6a6363730a1bb49aef4c94ebabc9e4f01606b",
  "filePath" : "app/src/main/java/com/termux/terminal/TerminalEmulator.java",
  "occurrences" : 17,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 511,
      "startColumnNumber" : 27,
      "endLineNumber" : 511,
      "endColumnNumber" : 31
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 511,
        "startColumnNumber" : 3,
        "endLineNumber" : 511,
        "endColumnNumber" : 31
      },
      "nodeContext" : "mUseLineDrawingUsesG0=true",
      "nodeType" : "Assignment",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 511,
        "startColumnNumber" : 3,
        "endLineNumber" : 511,
        "endColumnNumber" : 32
      },
      "nodeContext" : "mUseLineDrawingUsesG0=true;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 511,
        "startColumnNumber" : 3,
        "endLineNumber" : 511,
        "endColumnNumber" : 32
      },
      "nodeContext" : "mUseLineDrawingUsesG0=true;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 4,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 583,
      "startColumnNumber" : 43,
      "endLineNumber" : 583,
      "endColumnNumber" : 47
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 583,
        "startColumnNumber" : 30,
        "endLineNumber" : 583,
        "endColumnNumber" : 48
      },
      "nodeContext" : "getArg(0,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 583,
        "startColumnNumber" : 30,
        "endLineNumber" : 583,
        "endColumnNumber" : 52
      },
      "nodeContext" : "getArg(0,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 583,
        "startColumnNumber" : 30,
        "endLineNumber" : 583,
        "endColumnNumber" : 73
      },
      "nodeContext" : "getArg(0,1,true) - 1 + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 583,
        "startColumnNumber" : 21,
        "endLineNumber" : 583,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 583,
        "startColumnNumber" : 9,
        "endLineNumber" : 583,
        "endColumnNumber" : 81
      },
      "nodeContext" : "topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 583,
        "startColumnNumber" : 5,
        "endLineNumber" : 583,
        "endColumnNumber" : 82
      },
      "nodeContext" : "int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 583,
        "startColumnNumber" : 5,
        "endLineNumber" : 583,
        "endColumnNumber" : 82
      },
      "nodeContext" : "int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 584,
      "startColumnNumber" : 44,
      "endLineNumber" : 584,
      "endColumnNumber" : 48
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 49
      },
      "nodeContext" : "getArg(1,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 53
      },
      "nodeContext" : "getArg(1,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 584,
        "startColumnNumber" : 31,
        "endLineNumber" : 584,
        "endColumnNumber" : 75
      },
      "nodeContext" : "getArg(1,1,true) - 1 + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 584,
        "startColumnNumber" : 22,
        "endLineNumber" : 584,
        "endColumnNumber" : 86
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 584,
        "startColumnNumber" : 9,
        "endLineNumber" : 584,
        "endColumnNumber" : 86
      },
      "nodeContext" : "leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 584,
        "startColumnNumber" : 5,
        "endLineNumber" : 584,
        "endColumnNumber" : 87
      },
      "nodeContext" : "int leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 584,
        "startColumnNumber" : 5,
        "endLineNumber" : 584,
        "endColumnNumber" : 87
      },
      "nodeContext" : "int leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 586,
      "startColumnNumber" : 59,
      "endLineNumber" : 586,
      "endColumnNumber" : 63
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 586,
        "startColumnNumber" : 42,
        "endLineNumber" : 586,
        "endColumnNumber" : 64
      },
      "nodeContext" : "getArg(2,mRows,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 586,
        "startColumnNumber" : 42,
        "endLineNumber" : 586,
        "endColumnNumber" : 85
      },
      "nodeContext" : "getArg(2,mRows,true) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 586,
        "startColumnNumber" : 33,
        "endLineNumber" : 586,
        "endColumnNumber" : 97
      },
      "nodeContext" : "Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 586,
        "startColumnNumber" : 24,
        "endLineNumber" : 586,
        "endColumnNumber" : 105
      },
      "nodeContext" : "Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 586,
        "startColumnNumber" : 9,
        "endLineNumber" : 586,
        "endColumnNumber" : 105
      },
      "nodeContext" : "bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 101,
        "startLineNumber" : 586,
        "startColumnNumber" : 5,
        "endLineNumber" : 586,
        "endColumnNumber" : 106
      },
      "nodeContext" : "int bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 101,
        "startLineNumber" : 586,
        "startColumnNumber" : 5,
        "endLineNumber" : 586,
        "endColumnNumber" : 106
      },
      "nodeContext" : "int bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 587,
      "startColumnNumber" : 61,
      "endLineNumber" : 587,
      "endColumnNumber" : 65
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 587,
        "startColumnNumber" : 41,
        "endLineNumber" : 587,
        "endColumnNumber" : 66
      },
      "nodeContext" : "getArg(3,mColumns,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 587,
        "startColumnNumber" : 41,
        "endLineNumber" : 587,
        "endColumnNumber" : 88
      },
      "nodeContext" : "getArg(3,mColumns,true) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 69,
        "startLineNumber" : 587,
        "startColumnNumber" : 32,
        "endLineNumber" : 587,
        "endColumnNumber" : 101
      },
      "nodeContext" : "Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 89,
        "startLineNumber" : 587,
        "startColumnNumber" : 23,
        "endLineNumber" : 587,
        "endColumnNumber" : 112
      },
      "nodeContext" : "Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 103,
        "startLineNumber" : 587,
        "startColumnNumber" : 9,
        "endLineNumber" : 587,
        "endColumnNumber" : 112
      },
      "nodeContext" : "rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 108,
        "startLineNumber" : 587,
        "startColumnNumber" : 5,
        "endLineNumber" : 587,
        "endColumnNumber" : 113
      },
      "nodeContext" : "int rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 108,
        "startLineNumber" : 587,
        "startColumnNumber" : 5,
        "endLineNumber" : 587,
        "endColumnNumber" : 113
      },
      "nodeContext" : "int rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 589,
      "startColumnNumber" : 49,
      "endLineNumber" : 589,
      "endColumnNumber" : 53
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 589,
        "startColumnNumber" : 36,
        "endLineNumber" : 589,
        "endColumnNumber" : 54
      },
      "nodeContext" : "getArg(5,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 589,
        "startColumnNumber" : 36,
        "endLineNumber" : 589,
        "endColumnNumber" : 58
      },
      "nodeContext" : "getArg(5,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 589,
        "startColumnNumber" : 36,
        "endLineNumber" : 589,
        "endColumnNumber" : 79
      },
      "nodeContext" : "getArg(5,1,true) - 1 + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 589,
        "startColumnNumber" : 27,
        "endLineNumber" : 589,
        "endColumnNumber" : 87
      },
      "nodeContext" : "Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 78,
        "startLineNumber" : 589,
        "startColumnNumber" : 9,
        "endLineNumber" : 589,
        "endColumnNumber" : 87
      },
      "nodeContext" : "destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 589,
        "startColumnNumber" : 5,
        "endLineNumber" : 589,
        "endColumnNumber" : 88
      },
      "nodeContext" : "int destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 589,
        "startColumnNumber" : 5,
        "endLineNumber" : 589,
        "endColumnNumber" : 88
      },
      "nodeContext" : "int destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 590,
      "startColumnNumber" : 49,
      "endLineNumber" : 590,
      "endColumnNumber" : 53
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 590,
        "startColumnNumber" : 36,
        "endLineNumber" : 590,
        "endColumnNumber" : 54
      },
      "nodeContext" : "getArg(6,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 590,
        "startColumnNumber" : 36,
        "endLineNumber" : 590,
        "endColumnNumber" : 58
      },
      "nodeContext" : "getArg(6,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 590,
        "startColumnNumber" : 36,
        "endLineNumber" : 590,
        "endColumnNumber" : 80
      },
      "nodeContext" : "getArg(6,1,true) - 1 + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 590,
        "startColumnNumber" : 27,
        "endLineNumber" : 590,
        "endColumnNumber" : 91
      },
      "nodeContext" : "Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 590,
        "startColumnNumber" : 9,
        "endLineNumber" : 590,
        "endColumnNumber" : 91
      },
      "nodeContext" : "destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 590,
        "startColumnNumber" : 5,
        "endLineNumber" : 590,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 590,
        "startColumnNumber" : 5,
        "endLineNumber" : 590,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 607,
      "startColumnNumber" : 57,
      "endLineNumber" : 607,
      "endColumnNumber" : 61
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,elseExpression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 607,
        "startColumnNumber" : 34,
        "endLineNumber" : 607,
        "endColumnNumber" : 62
      },
      "nodeContext" : "getArg(argIndex++,-1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 607,
        "startColumnNumber" : 20,
        "endLineNumber" : 607,
        "endColumnNumber" : 62
      },
      "nodeContext" : "erase ? ' ' : getArg(argIndex++,-1,true)",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 607,
        "startColumnNumber" : 9,
        "endLineNumber" : 607,
        "endColumnNumber" : 62
      },
      "nodeContext" : "fillChar=erase ? ' ' : getArg(argIndex++,-1,true)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 607,
        "startColumnNumber" : 5,
        "endLineNumber" : 607,
        "endColumnNumber" : 63
      },
      "nodeContext" : "int fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 607,
        "startColumnNumber" : 5,
        "endLineNumber" : 607,
        "endColumnNumber" : 63
      },
      "nodeContext" : "int fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 613,
      "startColumnNumber" : 47,
      "endLineNumber" : 613,
      "endColumnNumber" : 51
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 27,
        "startLineNumber" : 613,
        "startColumnNumber" : 25,
        "endLineNumber" : 613,
        "endColumnNumber" : 52
      },
      "nodeContext" : "getArg(argIndex++,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 613,
        "startColumnNumber" : 25,
        "endLineNumber" : 613,
        "endColumnNumber" : 73
      },
      "nodeContext" : "getArg(argIndex++,1,true) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 613,
        "startColumnNumber" : 16,
        "endLineNumber" : 613,
        "endColumnNumber" : 101
      },
      "nodeContext" : "Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 91,
        "startLineNumber" : 613,
        "startColumnNumber" : 10,
        "endLineNumber" : 613,
        "endColumnNumber" : 101
      },
      "nodeContext" : "top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 613,
        "startColumnNumber" : 6,
        "endLineNumber" : 613,
        "endColumnNumber" : 102
      },
      "nodeContext" : "int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 613,
        "startColumnNumber" : 6,
        "endLineNumber" : 613,
        "endColumnNumber" : 102
      },
      "nodeContext" : "int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 614,
      "startColumnNumber" : 48,
      "endLineNumber" : 614,
      "endColumnNumber" : 52
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 27,
        "startLineNumber" : 614,
        "startColumnNumber" : 26,
        "endLineNumber" : 614,
        "endColumnNumber" : 53
      },
      "nodeContext" : "getArg(argIndex++,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 614,
        "startColumnNumber" : 26,
        "endLineNumber" : 614,
        "endColumnNumber" : 75
      },
      "nodeContext" : "getArg(argIndex++,1,true) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 614,
        "startColumnNumber" : 17,
        "endLineNumber" : 614,
        "endColumnNumber" : 102
      },
      "nodeContext" : "Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 92,
        "startLineNumber" : 614,
        "startColumnNumber" : 10,
        "endLineNumber" : 614,
        "endColumnNumber" : 102
      },
      "nodeContext" : "left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 97,
        "startLineNumber" : 614,
        "startColumnNumber" : 6,
        "endLineNumber" : 614,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 97,
        "startLineNumber" : 614,
        "startColumnNumber" : 6,
        "endLineNumber" : 614,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 615,
      "startColumnNumber" : 54,
      "endLineNumber" : 615,
      "endColumnNumber" : 58
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 615,
        "startColumnNumber" : 28,
        "endLineNumber" : 615,
        "endColumnNumber" : 59
      },
      "nodeContext" : "getArg(argIndex++,mRows,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 615,
        "startColumnNumber" : 28,
        "endLineNumber" : 615,
        "endColumnNumber" : 80
      },
      "nodeContext" : "getArg(argIndex++,mRows,true) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 615,
        "startColumnNumber" : 19,
        "endLineNumber" : 615,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 94,
        "startLineNumber" : 615,
        "startColumnNumber" : 10,
        "endLineNumber" : 615,
        "endColumnNumber" : 104
      },
      "nodeContext" : "bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 14,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 99,
        "startLineNumber" : 615,
        "startColumnNumber" : 6,
        "endLineNumber" : 615,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 99,
        "startLineNumber" : 615,
        "startColumnNumber" : 6,
        "endLineNumber" : 615,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 616,
      "startColumnNumber" : 54,
      "endLineNumber" : 616,
      "endColumnNumber" : 58
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 616,
        "startColumnNumber" : 27,
        "endLineNumber" : 616,
        "endColumnNumber" : 59
      },
      "nodeContext" : "getArg(argIndex,mColumns,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 616,
        "startColumnNumber" : 27,
        "endLineNumber" : 616,
        "endColumnNumber" : 81
      },
      "nodeContext" : "getArg(argIndex,mColumns,true) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 86,
        "startLineNumber" : 616,
        "startColumnNumber" : 18,
        "endLineNumber" : 616,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 94,
        "startLineNumber" : 616,
        "startColumnNumber" : 10,
        "endLineNumber" : 616,
        "endColumnNumber" : 104
      },
      "nodeContext" : "right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 99,
        "startLineNumber" : 616,
        "startColumnNumber" : 6,
        "endLineNumber" : 616,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 956,
        "startLineNumber" : 610,
        "startColumnNumber" : 86,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 610,
        "startColumnNumber" : 5,
        "endLineNumber" : 622,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\n  int top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\n  int left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\n  int bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\n  int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n  int style=getStyle();\n  for (int row=top - 1; row < bottom; row++)   for (int col=left - 1; col < right; col++)   if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)   mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 152,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 99,
        "startLineNumber" : 616,
        "startColumnNumber" : 6,
        "endLineNumber" : 616,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 15,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 630,
      "startColumnNumber" : 37,
      "endLineNumber" : 630,
      "endColumnNumber" : 41
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 630,
        "startColumnNumber" : 24,
        "endLineNumber" : 630,
        "endColumnNumber" : 42
      },
      "nodeContext" : "getArg(0,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 630,
        "startColumnNumber" : 24,
        "endLineNumber" : 630,
        "endColumnNumber" : 46
      },
      "nodeContext" : "getArg(0,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 630,
        "startColumnNumber" : 15,
        "endLineNumber" : 630,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1,effectiveBottomMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 630,
        "startColumnNumber" : 15,
        "endLineNumber" : 630,
        "endColumnNumber" : 91
      },
      "nodeContext" : "Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 630,
        "startColumnNumber" : 9,
        "endLineNumber" : 630,
        "endColumnNumber" : 91
      },
      "nodeContext" : "top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 630,
        "startColumnNumber" : 5,
        "endLineNumber" : 630,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 630,
        "startColumnNumber" : 5,
        "endLineNumber" : 630,
        "endColumnNumber" : 92
      },
      "nodeContext" : "int top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 631,
      "startColumnNumber" : 38,
      "endLineNumber" : 631,
      "endColumnNumber" : 42
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 631,
        "startColumnNumber" : 25,
        "endLineNumber" : 631,
        "endColumnNumber" : 43
      },
      "nodeContext" : "getArg(1,1,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 631,
        "startColumnNumber" : 25,
        "endLineNumber" : 631,
        "endColumnNumber" : 47
      },
      "nodeContext" : "getArg(1,1,true) - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 631,
        "startColumnNumber" : 16,
        "endLineNumber" : 631,
        "endColumnNumber" : 70
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1,effectiveRightMargin)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 631,
        "startColumnNumber" : 16,
        "endLineNumber" : 631,
        "endColumnNumber" : 92
      },
      "nodeContext" : "Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 631,
        "startColumnNumber" : 9,
        "endLineNumber" : 631,
        "endColumnNumber" : 92
      },
      "nodeContext" : "left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 631,
        "startColumnNumber" : 5,
        "endLineNumber" : 631,
        "endColumnNumber" : 93
      },
      "nodeContext" : "int left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 631,
        "startColumnNumber" : 5,
        "endLineNumber" : 631,
        "endColumnNumber" : 93
      },
      "nodeContext" : "int left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 632,
      "startColumnNumber" : 44,
      "endLineNumber" : 632,
      "endColumnNumber" : 48
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 632,
        "startColumnNumber" : 27,
        "endLineNumber" : 632,
        "endColumnNumber" : 49
      },
      "nodeContext" : "getArg(2,mRows,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 632,
        "startColumnNumber" : 27,
        "endLineNumber" : 632,
        "endColumnNumber" : 53
      },
      "nodeContext" : "getArg(2,mRows,true) + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 632,
        "startColumnNumber" : 18,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 632,
        "startColumnNumber" : 9,
        "endLineNumber" : 632,
        "endColumnNumber" : 102
      },
      "nodeContext" : "bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 632,
        "startColumnNumber" : 5,
        "endLineNumber" : 632,
        "endColumnNumber" : 103
      },
      "nodeContext" : "int bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 633,
      "startColumnNumber" : 46,
      "endLineNumber" : 633,
      "endColumnNumber" : 50
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 633,
        "startColumnNumber" : 26,
        "endLineNumber" : 633,
        "endColumnNumber" : 51
      },
      "nodeContext" : "getArg(3,mColumns,true)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 633,
        "startColumnNumber" : 26,
        "endLineNumber" : 633,
        "endColumnNumber" : 55
      },
      "nodeContext" : "getArg(3,mColumns,true) + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 65,
        "startLineNumber" : 633,
        "startColumnNumber" : 17,
        "endLineNumber" : 633,
        "endColumnNumber" : 82
      },
      "nodeContext" : "Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 633,
        "startColumnNumber" : 17,
        "endLineNumber" : 633,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 95,
        "startLineNumber" : 633,
        "startColumnNumber" : 9,
        "endLineNumber" : 633,
        "endColumnNumber" : 104
      },
      "nodeContext" : "right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 100,
        "startLineNumber" : 633,
        "startColumnNumber" : 5,
        "endLineNumber" : 633,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 100,
        "startLineNumber" : 633,
        "startColumnNumber" : 5,
        "endLineNumber" : 633,
        "endColumnNumber" : 105
      },
      "nodeContext" : "int right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "boolean"
  }, {
    "nodeContext" : "true",
    "nodeType" : "BooleanLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 637,
      "startColumnNumber" : 28,
      "endLineNumber" : 637,
      "endColumnNumber" : 32
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 637,
        "startColumnNumber" : 15,
        "endLineNumber" : 637,
        "endColumnNumber" : 32
      },
      "nodeContext" : "setOrClear=true",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 637,
        "startColumnNumber" : 7,
        "endLineNumber" : 637,
        "endColumnNumber" : 33
      },
      "nodeContext" : "boolean setOrClear=true;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1713,
        "startLineNumber" : 635,
        "startColumnNumber" : 43,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 155,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1750,
        "startLineNumber" : 635,
        "startColumnNumber" : 6,
        "endLineNumber" : 679,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=4; i <= mArgIndex; i++) {\n  int bits=0;\n  boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:    bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n  if (!reverse)   setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1765,
        "startLineNumber" : 634,
        "startColumnNumber" : 25,
        "endLineNumber" : 680,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 167,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1820,
        "startLineNumber" : 634,
        "startColumnNumber" : 5,
        "endLineNumber" : 682,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (mArgIndex >= 4) {\n  for (int i=4; i <= mArgIndex; i++) {\n    int bits=0;\n    boolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:      bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\n    if (!reverse)     setOrClear=false;\n  break;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 172,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 6536,
        "startLineNumber" : 572,
        "startColumnNumber" : 4,
        "endLineNumber" : 686,
        "endColumnNumber" : 5
      },
      "nodeContext" : "switch (b) {\ncase 'v':  int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 11452,
        "startLineNumber" : 534,
        "startColumnNumber" : 3,
        "endLineNumber" : 796,
        "endColumnNumber" : 4
      },
      "nodeContext" : "switch (mEscapeState) {\ncase ESC_NONE:  if (b >= 32)   emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1126,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14009,
        "startLineNumber" : 468,
        "startColumnNumber" : 2,
        "endLineNumber" : 799,
        "endColumnNumber" : 3
      },
      "nodeContext" : "switch (b) {\ncase 0:  break;\ncase 7:if (mEscapeState == ESC_OSC) doOsc(b);\n else mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\nmScreen.clearLineWrap(previousRow);\nsetCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1283,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14016,
        "startLineNumber" : 467,
        "startColumnNumber" : 37,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1284,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14052,
        "startLineNumber" : 467,
        "startColumnNumber" : 1,
        "endLineNumber" : 800,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void processCodePoint(int b){\nswitch (b) {\ncase 0:    break;\ncase 7:  if (mEscapeState == ESC_OSC)   doOsc(b);\n else   mSession.onBell();\nbreak;\ncase 8:if (mLeftMargin == mCursorCol) {\nint previousRow=mCursorRow - 1;\nif (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {\n  mScreen.clearLineWrap(previousRow);\n  setCursorRowCol(previousRow,mRightMargin - 1);\n}\n}\n else {\nsetCursorCol(mCursorCol - 1);\n}\nbreak;\ncase 9:mCursorCol=nextTabStop(1);\nbreak;\ncase 10:case 11:case 12:doLinefeed();\nbreak;\ncase 13:setCursorCol(mLeftMargin);\nbreak;\ncase 14:mUseLineDrawingUsesG0=false;\nbreak;\ncase 15:mUseLineDrawingUsesG0=true;\nbreak;\ncase 24:case 26:if (mEscapeState != ESC_NONE) {\nmEscapeState=ESC_NONE;\nemitCodePoint(127);\n}\nbreak;\ncase 27:if (mEscapeState == ESC_P) {\nreturn;\n}\n else if (mEscapeState != ESC_OSC) {\nstartEscapeSequence();\n}\n else {\ndoOsc(b);\n}\nbreak;\ndefault:mContinueSequence=false;\nswitch (mEscapeState) {\ncase ESC_NONE:if (b >= 32) emitCodePoint(b);\nbreak;\ncase ESC:doEsc(b);\nbreak;\ncase ESC_POUND:doEscPound(b);\nbreak;\ncase ESC_SELECT_LEFT_PAREN:mUseLineDrawingG0=(b == '0');\nbreak;\ncase ESC_SELECT_RIGHT_PAREN:mUseLineDrawingG1=(b == '0');\nbreak;\ncase ESC_CSI:doCsi(b);\nbreak;\ncase ESC_CSI_EXCLAMATION:if (b == 'p') {\nreset();\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_QUESTIONMARK:doCsiQuestionMark(b);\nbreak;\ncase ESC_CSI_BIGGERTHAN:doCsiBiggerThan(b);\nbreak;\ncase ESC_CSI_DOLLAR:boolean originMode=isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);\nint effectiveTopMargin=originMode ? mTopMargin : 0;\nint effectiveBottomMargin=originMode ? mBottomMargin : mRows;\nint effectiveLeftMargin=originMode ? mLeftMargin : 0;\nint effectiveRightMargin=originMode ? mRightMargin : mColumns;\nswitch (b) {\ncase 'v':int topSource=Math.min(getArg(0,1,true) - 1 + effectiveTopMargin,mRows);\nint leftSource=Math.min(getArg(1,1,true) - 1 + effectiveLeftMargin,mColumns);\nint bottomSource=Math.min(Math.max(getArg(2,mRows,true) + effectiveTopMargin,topSource),mRows);\nint rightSource=Math.min(Math.max(getArg(3,mColumns,true) + effectiveLeftMargin,leftSource),mColumns);\nint destionationTop=Math.min(getArg(5,1,true) - 1 + effectiveTopMargin,mRows);\nint destinationLeft=Math.min(getArg(6,1,true) - 1 + effectiveLeftMargin,mColumns);\nint heightToCopy=Math.min(mRows - destionationTop,bottomSource - topSource);\nint widthToCopy=Math.min(mColumns - destinationLeft,rightSource - leftSource);\nmScreen.blockCopy(leftSource,topSource,widthToCopy,heightToCopy,destinationLeft,destionationTop);\nbreak;\ncase '{':case 'x':case 'z':boolean erase=b != 'x';\nboolean selective=b == '{';\nboolean keepVisualAttributes=erase && selective;\nint argIndex=0;\nint fillChar=erase ? ' ' : getArg(argIndex++,-1,true);\nif ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {\nint top=Math.min(getArg(argIndex++,1,true) + effectiveTopMargin,effectiveBottomMargin + 1);\nint left=Math.min(getArg(argIndex++,1,true) + effectiveLeftMargin,effectiveRightMargin + 1);\nint bottom=Math.min(getArg(argIndex++,mRows,true) + effectiveTopMargin,effectiveBottomMargin);\nint right=Math.min(getArg(argIndex,mColumns,true) + effectiveLeftMargin,effectiveRightMargin);\nint style=getStyle();\nfor (int row=top - 1; row < bottom; row++) for (int col=left - 1; col < right; col++) if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row,col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0) mScreen.setChar(col,row,fillChar,keepVisualAttributes ? mScreen.getStyleAt(row,col) : style);\n}\nbreak;\ncase 'r':case 't':boolean reverse=b == 't';\nint top=Math.min(getArg(0,1,true) - 1,effectiveBottomMargin) + effectiveTopMargin;\nint left=Math.min(getArg(1,1,true) - 1,effectiveRightMargin) + effectiveLeftMargin;\nint bottom=Math.min(getArg(2,mRows,true) + 1,effectiveBottomMargin - 1) + effectiveTopMargin;\nint right=Math.min(getArg(3,mColumns,true) + 1,effectiveRightMargin - 1) + effectiveLeftMargin;\nif (mArgIndex >= 4) {\nfor (int i=4; i <= mArgIndex; i++) {\nint bits=0;\nboolean setOrClear=true;\nswitch (getArg(i,0,false)) {\ncase 0:bits=(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK| TextStyle.CHARACTER_ATTRIBUTE_INVERSE);\nif (!reverse) setOrClear=false;\nbreak;\ncase 1:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nbreak;\ncase 4:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nbreak;\ncase 5:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nbreak;\ncase 7:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nbreak;\ncase 22:bits=TextStyle.CHARACTER_ATTRIBUTE_BOLD;\nsetOrClear=false;\nbreak;\ncase 24:bits=TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;\nsetOrClear=false;\nbreak;\ncase 25:bits=TextStyle.CHARACTER_ATTRIBUTE_BLINK;\nsetOrClear=false;\nbreak;\ncase 27:bits=TextStyle.CHARACTER_ATTRIBUTE_INVERSE;\nsetOrClear=false;\nbreak;\n}\nif (reverse && !setOrClear) {\n}\n else {\nmScreen.setOrClearEffect(bits,setOrClear,reverse,isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),effectiveLeftMargin,effectiveRightMargin,top,left,bottom,right);\n}\n}\n}\n else {\n}\nbreak;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_DOUBLE_QUOTE:if (b == 'q') {\nint arg=getArg0(0);\nif (arg == 0 || arg == 2) {\nmEffect&=~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else if (arg == 1) {\nmEffect|=TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;\n}\n else {\nunknownSequence(b);\n}\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_SINGLE_QUOTE:if (b == '}') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToInsert=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToInsert;\nmScreen.blockCopy(mCursorCol,0,columnsToMove,mRows,mCursorCol + columnsToInsert,0);\nblockClear(mCursorCol,0,columnsToInsert,mRows);\n}\n else if (b == '~') {\nint columnsAfterCursor=mRightMargin - mCursorCol;\nint columnsToDelete=Math.min(getArg0(1),columnsAfterCursor);\nint columnsToMove=columnsAfterCursor - columnsToDelete;\nmScreen.blockCopy(mCursorCol + columnsToDelete,0,columnsToMove,mRows,mCursorCol,0);\nblockClear(mCursorRow + columnsToMove,0,columnsToDelete,mRows);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_PERCENT:Log.i(EmulatorDebug.LOG_TAG,\"Ignoring character set sequence 'ESC % \" + (char)b + \"'\");\nbreak;\ncase ESC_OSC:doOsc(b);\nbreak;\ncase ESC_OSC_ESC:doOscEsc(b);\nbreak;\ncase ESC_P:doDeviceControl(b);\nbreak;\ncase ESC_CSI_QUESTIONMARK_ARG_DOLLAR:if (b == 'p') {\nint mode=getArg0(0);\nint value;\nif (mode == 47 || mode == 1047 || mode == 1049) {\nvalue=(mScreen == mAltBuffer) ? 1 : 2;\n}\n else {\nint internalBit=mapDecSetBitToInternalBit(mode);\nif (internalBit == -1) {\nvalue=isDecsetInternalBitSet(internalBit) ? 1 : 2;\n}\n else {\nLog.e(EmulatorDebug.LOG_TAG,\"Got DECRQM for unrecognized private DEC mode=\" + mode);\nvalue=0;\n}\n}\nmSession.write(String.format(Locale.US,\"\\033[?%d;%d$y\",mode,value));\n}\n else {\nunknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_SPACE:int arg=getArg0(0);\nswitch (b) {\ncase 'q':switch (arg) {\ncase 0:case 1:case 2:mCursorStyle=CURSOR_STYLE_BLOCK;\nbreak;\ncase 3:case 4:mCursorStyle=CURSOR_STYLE_UNDERLINE;\nbreak;\ncase 5:case 6:mCursorStyle=CURSOR_STYLE_BAR;\nbreak;\n}\nbreak;\ncase 't':case 'u':break;\ndefault:unknownSequence(b);\n}\nbreak;\ncase ESC_CSI_ARGS_ASTERIX:int attributeChangeExtent=getArg0(0);\nif (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {\nsetDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE,attributeChangeExtent == 2);\n}\n else {\nunknownSequence(b);\n}\nbreak;\ndefault:unknownSequence(b);\nbreak;\n}\nif (!mContinueSequence) mEscapeState=ESC_NONE;\nbreak;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1291,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 637,
        "startColumnNumber" : 7,
        "endLineNumber" : 637,
        "endColumnNumber" : 33
      },
      "nodeContext" : "boolean setOrClear=true;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 4,
    "startLineNumber" : 511,
    "startColumnNumber" : 27,
    "endLineNumber" : 511,
    "endColumnNumber" : 31
  }, {
    "charLength" : 4,
    "startLineNumber" : 583,
    "startColumnNumber" : 43,
    "endLineNumber" : 583,
    "endColumnNumber" : 47
  }, {
    "charLength" : 4,
    "startLineNumber" : 584,
    "startColumnNumber" : 44,
    "endLineNumber" : 584,
    "endColumnNumber" : 48
  }, {
    "charLength" : 4,
    "startLineNumber" : 586,
    "startColumnNumber" : 59,
    "endLineNumber" : 586,
    "endColumnNumber" : 63
  }, {
    "charLength" : 4,
    "startLineNumber" : 587,
    "startColumnNumber" : 61,
    "endLineNumber" : 587,
    "endColumnNumber" : 65
  }, {
    "charLength" : 4,
    "startLineNumber" : 589,
    "startColumnNumber" : 49,
    "endLineNumber" : 589,
    "endColumnNumber" : 53
  }, {
    "charLength" : 4,
    "startLineNumber" : 590,
    "startColumnNumber" : 49,
    "endLineNumber" : 590,
    "endColumnNumber" : 53
  }, {
    "charLength" : 4,
    "startLineNumber" : 607,
    "startColumnNumber" : 57,
    "endLineNumber" : 607,
    "endColumnNumber" : 61
  }, {
    "charLength" : 4,
    "startLineNumber" : 613,
    "startColumnNumber" : 47,
    "endLineNumber" : 613,
    "endColumnNumber" : 51
  }, {
    "charLength" : 4,
    "startLineNumber" : 614,
    "startColumnNumber" : 48,
    "endLineNumber" : 614,
    "endColumnNumber" : 52
  }, {
    "charLength" : 4,
    "startLineNumber" : 615,
    "startColumnNumber" : 54,
    "endLineNumber" : 615,
    "endColumnNumber" : 58
  }, {
    "charLength" : 4,
    "startLineNumber" : 616,
    "startColumnNumber" : 54,
    "endLineNumber" : 616,
    "endColumnNumber" : 58
  }, {
    "charLength" : 4,
    "startLineNumber" : 630,
    "startColumnNumber" : 37,
    "endLineNumber" : 630,
    "endColumnNumber" : 41
  }, {
    "charLength" : 4,
    "startLineNumber" : 631,
    "startColumnNumber" : 38,
    "endLineNumber" : 631,
    "endColumnNumber" : 42
  }, {
    "charLength" : 4,
    "startLineNumber" : 632,
    "startColumnNumber" : 44,
    "endLineNumber" : 632,
    "endColumnNumber" : 48
  }, {
    "charLength" : 4,
    "startLineNumber" : 633,
    "startColumnNumber" : 46,
    "endLineNumber" : 633,
    "endColumnNumber" : 50
  }, {
    "charLength" : 4,
    "startLineNumber" : 637,
    "startColumnNumber" : 28,
    "endLineNumber" : 637,
    "endColumnNumber" : 32
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 11,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 12,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 13,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 14,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 15,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 16,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 16,
    "layout" : 4
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 11,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 12,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 12,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 13,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 13,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 14,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 14,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 16,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 16,
    "secondKey" : 15,
    "layout" : 6
  } ]
}