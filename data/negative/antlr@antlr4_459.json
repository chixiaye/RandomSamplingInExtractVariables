{
  "id" : 459,
  "expression" : "ReplaceOp.class",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/runtime/Java/src/org/antlr/v4/runtime/TokenStreamRewriter.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "ReplaceOp.class",
    "nodeType" : "TypeLiteral",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 502,
      "startColumnNumber" : 67,
      "endLineNumber" : 502,
      "endColumnNumber" : 82
    },
    "astNodeNumber" : 3,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 502,
        "startColumnNumber" : 44,
        "endLineNumber" : 502,
        "endColumnNumber" : 86
      },
      "nodeContext" : "getKindOfOps(rewrites,ReplaceOp.class,i)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 502,
        "startColumnNumber" : 29,
        "endLineNumber" : 502,
        "endColumnNumber" : 86
      },
      "nodeContext" : "prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 502,
        "startColumnNumber" : 3,
        "endLineNumber" : 502,
        "endColumnNumber" : 87
      },
      "nodeContext" : "List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1982,
        "startLineNumber" : 482,
        "startColumnNumber" : 44,
        "endLineNumber" : 525,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RewriteOperation op=rewrites.get(i);\n  if (op == null)   continue;\n  if (!(op instanceof ReplaceOp))   continue;\n  ReplaceOp rop=(ReplaceOp)rewrites.get(i);\n  List<? extends InsertBeforeOp> inserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n  for (  InsertBeforeOp iop : inserts) {\n    if (iop.index == rop.index) {\n      rewrites.set(iop.instructionIndex,null);\n      rop.text=iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n    }\n else     if (iop.index > rop.index && iop.index <= rop.lastIndex) {\n      rewrites.set(iop.instructionIndex,null);\n    }\n  }\n  List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n  for (  ReplaceOp prevRop : prevReplaces) {\n    if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n      rewrites.set(prevRop.instructionIndex,null);\n      continue;\n    }\n    boolean disjoint=prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n    if (prevRop.text == null && rop.text == null && !disjoint) {\n      rewrites.set(prevRop.instructionIndex,null);\n      rop.index=Math.min(prevRop.index,rop.index);\n      rop.lastIndex=Math.max(prevRop.lastIndex,rop.lastIndex);\n      System.out.println(\"new rop \" + rop);\n    }\n else     if (!disjoint) {\n      throw new IllegalArgumentException(\"replace op boundaries of \" + rop + \" overlap with previous \"+ prevRop);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 266,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2024,
        "startLineNumber" : 482,
        "startColumnNumber" : 2,
        "endLineNumber" : 525,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int i=0; i < rewrites.size(); i++) {\n  RewriteOperation op=rewrites.get(i);\n  if (op == null)   continue;\n  if (!(op instanceof ReplaceOp))   continue;\n  ReplaceOp rop=(ReplaceOp)rewrites.get(i);\n  List<? extends InsertBeforeOp> inserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n  for (  InsertBeforeOp iop : inserts) {\n    if (iop.index == rop.index) {\n      rewrites.set(iop.instructionIndex,null);\n      rop.text=iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n    }\n else     if (iop.index > rop.index && iop.index <= rop.lastIndex) {\n      rewrites.set(iop.instructionIndex,null);\n    }\n  }\n  List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n  for (  ReplaceOp prevRop : prevReplaces) {\n    if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n      rewrites.set(prevRop.instructionIndex,null);\n      continue;\n    }\n    boolean disjoint=prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n    if (prevRop.text == null && rop.text == null && !disjoint) {\n      rewrites.set(prevRop.instructionIndex,null);\n      rop.index=Math.min(prevRop.index,rop.index);\n      rop.lastIndex=Math.max(prevRop.lastIndex,rop.lastIndex);\n      System.out.println(\"new rop \" + rop);\n    }\n else     if (!disjoint) {\n      throw new IllegalArgumentException(\"replace op boundaries of \" + rop + \" overlap with previous \"+ prevRop);\n    }\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 279,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4147,
        "startLineNumber" : 478,
        "startColumnNumber" : 107,
        "endLineNumber" : 575,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (!(op instanceof ReplaceOp))     continue;\n    ReplaceOp rop=(ReplaceOp)rewrites.get(i);\n    List<? extends InsertBeforeOp> inserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n    for (    InsertBeforeOp iop : inserts) {\n      if (iop.index == rop.index) {\n        rewrites.set(iop.instructionIndex,null);\n        rop.text=iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n      }\n else       if (iop.index > rop.index && iop.index <= rop.lastIndex) {\n        rewrites.set(iop.instructionIndex,null);\n      }\n    }\n    List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n    for (    ReplaceOp prevRop : prevReplaces) {\n      if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n        rewrites.set(prevRop.instructionIndex,null);\n        continue;\n      }\n      boolean disjoint=prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n      if (prevRop.text == null && rop.text == null && !disjoint) {\n        rewrites.set(prevRop.instructionIndex,null);\n        rop.index=Math.min(prevRop.index,rop.index);\n        rop.lastIndex=Math.max(prevRop.lastIndex,rop.lastIndex);\n        System.out.println(\"new rop \" + rop);\n      }\n else       if (!disjoint) {\n        throw new IllegalArgumentException(\"replace op boundaries of \" + rop + \" overlap with previous \"+ prevRop);\n      }\n    }\n  }\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (!(op instanceof InsertBeforeOp))     continue;\n    InsertBeforeOp iop=(InsertBeforeOp)rewrites.get(i);\n    List<? extends InsertBeforeOp> prevInserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n    for (    InsertBeforeOp prevIop : prevInserts) {\n      if (prevIop.index == iop.index) {\n        if (InsertAfterOp.class.isInstance(prevIop)) {\n          iop.text=catOpText(prevIop.text,iop.text);\n          rewrites.set(prevIop.instructionIndex,null);\n        }\n else         if (InsertBeforeOp.class.isInstance(prevIop)) {\n          iop.text=catOpText(iop.text,prevIop.text);\n          rewrites.set(prevIop.instructionIndex,null);\n        }\n      }\n    }\n    List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n    for (    ReplaceOp rop : prevReplaces) {\n      if (iop.index == rop.index) {\n        rop.text=catOpText(iop.text,rop.text);\n        rewrites.set(i,null);\n        continue;\n      }\n      if (iop.index >= rop.index && iop.index <= rop.lastIndex) {\n        throw new IllegalArgumentException(\"insert op \" + iop + \" within boundaries of previous \"+ rop);\n      }\n    }\n  }\n  Map<Integer,RewriteOperation> m=new HashMap<Integer,RewriteOperation>();\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (m.get(op.index) != null) {\n      throw new Error(\"should only be one op per index\");\n    }\n    m.put(op.index,op);\n  }\n  return m;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 567,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6417,
        "startLineNumber" : 429,
        "startColumnNumber" : 1,
        "endLineNumber" : 575,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * We need to combine operations and report invalid operations (like overlapping replaces that are not completed nested). Inserts to same index need to be combined etc...  Here are the cases: I.i.u I.j.v\t\t\t\t\t\t\t\tleave alone, nonoverlapping I.i.u I.i.v\t\t\t\t\t\t\t\tcombine: Iivu R.i-j.u R.x-y.v\t| i-j in x-y\t\t\tdelete first R R.i-j.u R.i-j.v\t\t\t\t\t\t\tdelete first R R.i-j.u R.x-y.v\t| x-y in i-j\t\t\tERROR R.i-j.u R.x-y.v\t| boundaries overlap\tERROR Delete special case of replace (text==null): D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right) I.i.u R.x-y.v | i in (x+1)-y\t\t\tdelete I (since insert before we're not deleting i) I.i.u R.x-y.v | i not in (x+1)-y\t\tleave alone, nonoverlapping R.x-y.v I.i.u | i in x-y\t\t\t\tERROR R.x-y.v I.x.u \t\t\t\t\t\t\tR.x-y.uv (combine, delete I) R.x-y.v I.i.u | i not in x-y\t\t\tleave alone, nonoverlapping I.i.u = insert u before op @ index i R.x-y.u = replace x-y indexed tokens with u First we need to examine replaces. For any replace op: 1. wipe out any insertions before op within that range. 2. Drop any replace op before that is contained completely within that range. 3. Throw exception upon boundary overlap with any previous replace. Then we can deal with inserts: 1. for any inserts to same index, combine even if not adjacent. 2. for any prior replace with same left boundary, combine this insert with replace and delete this replace. 3. throw exception if index in same range as previous replace Don't actually delete; make op null in list. Easier to walk list. Later we can throw as we add to index &rarr; op map. Note that I.2 R.2-2 will wipe out I.2 even though, technically, the inserted stuff would be before the replace range. But, if you add tokens in front of a method body '{' and then delete the method body, I think the stuff before the '{' you added should disappear too. Return a map from token index to operation.\n */\nprotected Map<Integer,RewriteOperation> reduceToSingleOperationPerIndex(List<RewriteOperation> rewrites){\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (!(op instanceof ReplaceOp))     continue;\n    ReplaceOp rop=(ReplaceOp)rewrites.get(i);\n    List<? extends InsertBeforeOp> inserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n    for (    InsertBeforeOp iop : inserts) {\n      if (iop.index == rop.index) {\n        rewrites.set(iop.instructionIndex,null);\n        rop.text=iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n      }\n else       if (iop.index > rop.index && iop.index <= rop.lastIndex) {\n        rewrites.set(iop.instructionIndex,null);\n      }\n    }\n    List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n    for (    ReplaceOp prevRop : prevReplaces) {\n      if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n        rewrites.set(prevRop.instructionIndex,null);\n        continue;\n      }\n      boolean disjoint=prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n      if (prevRop.text == null && rop.text == null && !disjoint) {\n        rewrites.set(prevRop.instructionIndex,null);\n        rop.index=Math.min(prevRop.index,rop.index);\n        rop.lastIndex=Math.max(prevRop.lastIndex,rop.lastIndex);\n        System.out.println(\"new rop \" + rop);\n      }\n else       if (!disjoint) {\n        throw new IllegalArgumentException(\"replace op boundaries of \" + rop + \" overlap with previous \"+ prevRop);\n      }\n    }\n  }\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (!(op instanceof InsertBeforeOp))     continue;\n    InsertBeforeOp iop=(InsertBeforeOp)rewrites.get(i);\n    List<? extends InsertBeforeOp> prevInserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n    for (    InsertBeforeOp prevIop : prevInserts) {\n      if (prevIop.index == iop.index) {\n        if (InsertAfterOp.class.isInstance(prevIop)) {\n          iop.text=catOpText(prevIop.text,iop.text);\n          rewrites.set(prevIop.instructionIndex,null);\n        }\n else         if (InsertBeforeOp.class.isInstance(prevIop)) {\n          iop.text=catOpText(iop.text,prevIop.text);\n          rewrites.set(prevIop.instructionIndex,null);\n        }\n      }\n    }\n    List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n    for (    ReplaceOp rop : prevReplaces) {\n      if (iop.index == rop.index) {\n        rop.text=catOpText(iop.text,rop.text);\n        rewrites.set(i,null);\n        continue;\n      }\n      if (iop.index >= rop.index && iop.index <= rop.lastIndex) {\n        throw new IllegalArgumentException(\"insert op \" + iop + \" within boundaries of previous \"+ rop);\n      }\n    }\n  }\n  Map<Integer,RewriteOperation> m=new HashMap<Integer,RewriteOperation>();\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (m.get(op.index) != null) {\n      throw new Error(\"should only be one op per index\");\n    }\n    m.put(op.index,op);\n  }\n  return m;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 585,
      "astHeight" : 16
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 502,
        "startColumnNumber" : 3,
        "endLineNumber" : 502,
        "endColumnNumber" : 87
      },
      "nodeContext" : "List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<org.antlr.v4.runtime.TokenStreamRewriter.ReplaceOp>"
  }, {
    "nodeContext" : "ReplaceOp.class",
    "nodeType" : "TypeLiteral",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 551,
      "startColumnNumber" : 67,
      "endLineNumber" : 551,
      "endColumnNumber" : 82
    },
    "astNodeNumber" : 3,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 551,
        "startColumnNumber" : 44,
        "endLineNumber" : 551,
        "endColumnNumber" : 86
      },
      "nodeContext" : "getKindOfOps(rewrites,ReplaceOp.class,i)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 551,
        "startColumnNumber" : 29,
        "endLineNumber" : 551,
        "endColumnNumber" : 86
      },
      "nodeContext" : "prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 551,
        "startColumnNumber" : 3,
        "endLineNumber" : 551,
        "endColumnNumber" : 87
      },
      "nodeContext" : "List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1517,
        "startLineNumber" : 528,
        "startColumnNumber" : 44,
        "endLineNumber" : 562,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RewriteOperation op=rewrites.get(i);\n  if (op == null)   continue;\n  if (!(op instanceof InsertBeforeOp))   continue;\n  InsertBeforeOp iop=(InsertBeforeOp)rewrites.get(i);\n  List<? extends InsertBeforeOp> prevInserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n  for (  InsertBeforeOp prevIop : prevInserts) {\n    if (prevIop.index == iop.index) {\n      if (InsertAfterOp.class.isInstance(prevIop)) {\n        iop.text=catOpText(prevIop.text,iop.text);\n        rewrites.set(prevIop.instructionIndex,null);\n      }\n else       if (InsertBeforeOp.class.isInstance(prevIop)) {\n        iop.text=catOpText(iop.text,prevIop.text);\n        rewrites.set(prevIop.instructionIndex,null);\n      }\n    }\n  }\n  List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n  for (  ReplaceOp rop : prevReplaces) {\n    if (iop.index == rop.index) {\n      rop.text=catOpText(iop.text,rop.text);\n      rewrites.set(i,null);\n      continue;\n    }\n    if (iop.index >= rop.index && iop.index <= rop.lastIndex) {\n      throw new IllegalArgumentException(\"insert op \" + iop + \" within boundaries of previous \"+ rop);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 203,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1559,
        "startLineNumber" : 528,
        "startColumnNumber" : 2,
        "endLineNumber" : 562,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int i=0; i < rewrites.size(); i++) {\n  RewriteOperation op=rewrites.get(i);\n  if (op == null)   continue;\n  if (!(op instanceof InsertBeforeOp))   continue;\n  InsertBeforeOp iop=(InsertBeforeOp)rewrites.get(i);\n  List<? extends InsertBeforeOp> prevInserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n  for (  InsertBeforeOp prevIop : prevInserts) {\n    if (prevIop.index == iop.index) {\n      if (InsertAfterOp.class.isInstance(prevIop)) {\n        iop.text=catOpText(prevIop.text,iop.text);\n        rewrites.set(prevIop.instructionIndex,null);\n      }\n else       if (InsertBeforeOp.class.isInstance(prevIop)) {\n        iop.text=catOpText(iop.text,prevIop.text);\n        rewrites.set(prevIop.instructionIndex,null);\n      }\n    }\n  }\n  List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n  for (  ReplaceOp rop : prevReplaces) {\n    if (iop.index == rop.index) {\n      rop.text=catOpText(iop.text,rop.text);\n      rewrites.set(i,null);\n      continue;\n    }\n    if (iop.index >= rop.index && iop.index <= rop.lastIndex) {\n      throw new IllegalArgumentException(\"insert op \" + iop + \" within boundaries of previous \"+ rop);\n    }\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 216,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4147,
        "startLineNumber" : 478,
        "startColumnNumber" : 107,
        "endLineNumber" : 575,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (!(op instanceof ReplaceOp))     continue;\n    ReplaceOp rop=(ReplaceOp)rewrites.get(i);\n    List<? extends InsertBeforeOp> inserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n    for (    InsertBeforeOp iop : inserts) {\n      if (iop.index == rop.index) {\n        rewrites.set(iop.instructionIndex,null);\n        rop.text=iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n      }\n else       if (iop.index > rop.index && iop.index <= rop.lastIndex) {\n        rewrites.set(iop.instructionIndex,null);\n      }\n    }\n    List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n    for (    ReplaceOp prevRop : prevReplaces) {\n      if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n        rewrites.set(prevRop.instructionIndex,null);\n        continue;\n      }\n      boolean disjoint=prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n      if (prevRop.text == null && rop.text == null && !disjoint) {\n        rewrites.set(prevRop.instructionIndex,null);\n        rop.index=Math.min(prevRop.index,rop.index);\n        rop.lastIndex=Math.max(prevRop.lastIndex,rop.lastIndex);\n        System.out.println(\"new rop \" + rop);\n      }\n else       if (!disjoint) {\n        throw new IllegalArgumentException(\"replace op boundaries of \" + rop + \" overlap with previous \"+ prevRop);\n      }\n    }\n  }\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (!(op instanceof InsertBeforeOp))     continue;\n    InsertBeforeOp iop=(InsertBeforeOp)rewrites.get(i);\n    List<? extends InsertBeforeOp> prevInserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n    for (    InsertBeforeOp prevIop : prevInserts) {\n      if (prevIop.index == iop.index) {\n        if (InsertAfterOp.class.isInstance(prevIop)) {\n          iop.text=catOpText(prevIop.text,iop.text);\n          rewrites.set(prevIop.instructionIndex,null);\n        }\n else         if (InsertBeforeOp.class.isInstance(prevIop)) {\n          iop.text=catOpText(iop.text,prevIop.text);\n          rewrites.set(prevIop.instructionIndex,null);\n        }\n      }\n    }\n    List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n    for (    ReplaceOp rop : prevReplaces) {\n      if (iop.index == rop.index) {\n        rop.text=catOpText(iop.text,rop.text);\n        rewrites.set(i,null);\n        continue;\n      }\n      if (iop.index >= rop.index && iop.index <= rop.lastIndex) {\n        throw new IllegalArgumentException(\"insert op \" + iop + \" within boundaries of previous \"+ rop);\n      }\n    }\n  }\n  Map<Integer,RewriteOperation> m=new HashMap<Integer,RewriteOperation>();\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (m.get(op.index) != null) {\n      throw new Error(\"should only be one op per index\");\n    }\n    m.put(op.index,op);\n  }\n  return m;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 567,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6417,
        "startLineNumber" : 429,
        "startColumnNumber" : 1,
        "endLineNumber" : 575,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * We need to combine operations and report invalid operations (like overlapping replaces that are not completed nested). Inserts to same index need to be combined etc...  Here are the cases: I.i.u I.j.v\t\t\t\t\t\t\t\tleave alone, nonoverlapping I.i.u I.i.v\t\t\t\t\t\t\t\tcombine: Iivu R.i-j.u R.x-y.v\t| i-j in x-y\t\t\tdelete first R R.i-j.u R.i-j.v\t\t\t\t\t\t\tdelete first R R.i-j.u R.x-y.v\t| x-y in i-j\t\t\tERROR R.i-j.u R.x-y.v\t| boundaries overlap\tERROR Delete special case of replace (text==null): D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right) I.i.u R.x-y.v | i in (x+1)-y\t\t\tdelete I (since insert before we're not deleting i) I.i.u R.x-y.v | i not in (x+1)-y\t\tleave alone, nonoverlapping R.x-y.v I.i.u | i in x-y\t\t\t\tERROR R.x-y.v I.x.u \t\t\t\t\t\t\tR.x-y.uv (combine, delete I) R.x-y.v I.i.u | i not in x-y\t\t\tleave alone, nonoverlapping I.i.u = insert u before op @ index i R.x-y.u = replace x-y indexed tokens with u First we need to examine replaces. For any replace op: 1. wipe out any insertions before op within that range. 2. Drop any replace op before that is contained completely within that range. 3. Throw exception upon boundary overlap with any previous replace. Then we can deal with inserts: 1. for any inserts to same index, combine even if not adjacent. 2. for any prior replace with same left boundary, combine this insert with replace and delete this replace. 3. throw exception if index in same range as previous replace Don't actually delete; make op null in list. Easier to walk list. Later we can throw as we add to index &rarr; op map. Note that I.2 R.2-2 will wipe out I.2 even though, technically, the inserted stuff would be before the replace range. But, if you add tokens in front of a method body '{' and then delete the method body, I think the stuff before the '{' you added should disappear too. Return a map from token index to operation.\n */\nprotected Map<Integer,RewriteOperation> reduceToSingleOperationPerIndex(List<RewriteOperation> rewrites){\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (!(op instanceof ReplaceOp))     continue;\n    ReplaceOp rop=(ReplaceOp)rewrites.get(i);\n    List<? extends InsertBeforeOp> inserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n    for (    InsertBeforeOp iop : inserts) {\n      if (iop.index == rop.index) {\n        rewrites.set(iop.instructionIndex,null);\n        rop.text=iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n      }\n else       if (iop.index > rop.index && iop.index <= rop.lastIndex) {\n        rewrites.set(iop.instructionIndex,null);\n      }\n    }\n    List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n    for (    ReplaceOp prevRop : prevReplaces) {\n      if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n        rewrites.set(prevRop.instructionIndex,null);\n        continue;\n      }\n      boolean disjoint=prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n      if (prevRop.text == null && rop.text == null && !disjoint) {\n        rewrites.set(prevRop.instructionIndex,null);\n        rop.index=Math.min(prevRop.index,rop.index);\n        rop.lastIndex=Math.max(prevRop.lastIndex,rop.lastIndex);\n        System.out.println(\"new rop \" + rop);\n      }\n else       if (!disjoint) {\n        throw new IllegalArgumentException(\"replace op boundaries of \" + rop + \" overlap with previous \"+ prevRop);\n      }\n    }\n  }\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (!(op instanceof InsertBeforeOp))     continue;\n    InsertBeforeOp iop=(InsertBeforeOp)rewrites.get(i);\n    List<? extends InsertBeforeOp> prevInserts=getKindOfOps(rewrites,InsertBeforeOp.class,i);\n    for (    InsertBeforeOp prevIop : prevInserts) {\n      if (prevIop.index == iop.index) {\n        if (InsertAfterOp.class.isInstance(prevIop)) {\n          iop.text=catOpText(prevIop.text,iop.text);\n          rewrites.set(prevIop.instructionIndex,null);\n        }\n else         if (InsertBeforeOp.class.isInstance(prevIop)) {\n          iop.text=catOpText(iop.text,prevIop.text);\n          rewrites.set(prevIop.instructionIndex,null);\n        }\n      }\n    }\n    List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n    for (    ReplaceOp rop : prevReplaces) {\n      if (iop.index == rop.index) {\n        rop.text=catOpText(iop.text,rop.text);\n        rewrites.set(i,null);\n        continue;\n      }\n      if (iop.index >= rop.index && iop.index <= rop.lastIndex) {\n        throw new IllegalArgumentException(\"insert op \" + iop + \" within boundaries of previous \"+ rop);\n      }\n    }\n  }\n  Map<Integer,RewriteOperation> m=new HashMap<Integer,RewriteOperation>();\n  for (int i=0; i < rewrites.size(); i++) {\n    RewriteOperation op=rewrites.get(i);\n    if (op == null)     continue;\n    if (m.get(op.index) != null) {\n      throw new Error(\"should only be one op per index\");\n    }\n    m.put(op.index,op);\n  }\n  return m;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 585,
      "astHeight" : 16
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 551,
        "startColumnNumber" : 3,
        "endLineNumber" : 551,
        "endColumnNumber" : 87
      },
      "nodeContext" : "List<? extends ReplaceOp> prevReplaces=getKindOfOps(rewrites,ReplaceOp.class,i);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<org.antlr.v4.runtime.TokenStreamRewriter.ReplaceOp>"
  } ],
  "positionList" : [ {
    "charLength" : 15,
    "startLineNumber" : 502,
    "startColumnNumber" : 67,
    "endLineNumber" : 502,
    "endColumnNumber" : 82
  }, {
    "charLength" : 15,
    "startLineNumber" : 551,
    "startColumnNumber" : 67,
    "endLineNumber" : 551,
    "endColumnNumber" : 82
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 5
  } ]
}