{
  "id" : 246,
  "expression" : "keyAge",
  "projectName" : "signalapp@Signal-Android",
  "commitID" : "7e91132e7ed62a58b5f347de252ab1eda3f43b90",
  "filePath" : "/app/src/main/java/org/thoughtcrime/securesms/messages/GroupSendUtil.java",
  "occurrences" : 3,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "keyAge",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 224,
      "startColumnNumber" : 33,
      "endLineNumber" : 224,
      "endColumnNumber" : 39
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 224,
        "startColumnNumber" : 33,
        "endLineNumber" : 224,
        "endColumnNumber" : 53
      },
      "nodeContext" : "keyAge > MAX_KEY_AGE",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 224,
        "startColumnNumber" : 10,
        "endLineNumber" : 224,
        "endColumnNumber" : 53
      },
      "nodeContext" : "keyCreateTime != -1 && keyAge > MAX_KEY_AGE",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 237,
        "startLineNumber" : 224,
        "startColumnNumber" : 6,
        "endLineNumber" : 227,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n  Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n  SenderKeyUtil.rotateOurKey(context,distributionId);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 33,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2372,
        "startLineNumber" : 219,
        "startColumnNumber" : 56,
        "endLineNumber" : 259,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n    if (relatedMessageId != null) {\n      SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidRegistrationIdException e) {\n    Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 279,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2917,
        "startLineNumber" : 219,
        "startColumnNumber" : 4,
        "endLineNumber" : 265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (senderKeyTargets.size() > 0 && groupId != null) {\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n    if (relatedMessageId != null) {\n      SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidRegistrationIdException e) {\n    Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n else if (relatedMessageId != null) {\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyShared(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyEncrypted(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyMessageSent(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeySyncSent(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 339,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 9226,
        "startLineNumber" : 162,
        "startColumnNumber" : 2,
        "endLineNumber" : 327,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  Set<Recipient> unregisteredTargets=allTargets.stream().filter(Recipient::isUnregistered).collect(Collectors.toSet());\n  List<Recipient> registeredTargets=allTargets.stream().filter(r -> !unregisteredTargets.contains(r)).collect(Collectors.toList());\n  RecipientData recipients=new RecipientData(context,registeredTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : registeredTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyStarted(relatedMessageId.getId());\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n      if (relatedMessageId != null) {\n        SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidRegistrationIdException e) {\n      Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyShared(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyEncrypted(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeySyncSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onLegacyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onLegacySyncFinished(relatedMessageId.getId());\n  }\n  if (unregisteredTargets.size() > 0) {\n    Log.w(TAG,\"There are \" + unregisteredTargets.size() + \" unregistered targets. Including failure results.\");\n    List<SendMessageResult> unregisteredResults=unregisteredTargets.stream().filter(Recipient::hasUuid).map(t -> SendMessageResult.unregisteredFailure(new SignalServiceAddress(t.requireUuid(),t.getE164().orNull()))).collect(Collectors.toList());\n    if (unregisteredResults.size() < unregisteredTargets.size()) {\n      Log.w(TAG,\"There are \" + (unregisteredTargets.size() - unregisteredResults.size()) + \" targets that have no UUID! Cannot report a failure for them.\");\n    }\n    allResults.addAll(unregisteredResults);\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1069,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 10384,
        "startLineNumber" : 146,
        "startColumnNumber" : 2,
        "endLineNumber" : 327,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@Nullable MessageId relatedMessageId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  Set<Recipient> unregisteredTargets=allTargets.stream().filter(Recipient::isUnregistered).collect(Collectors.toSet());\n  List<Recipient> registeredTargets=allTargets.stream().filter(r -> !unregisteredTargets.contains(r)).collect(Collectors.toList());\n  RecipientData recipients=new RecipientData(context,registeredTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : registeredTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyStarted(relatedMessageId.getId());\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n      if (relatedMessageId != null) {\n        SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidRegistrationIdException e) {\n      Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyShared(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyEncrypted(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeySyncSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onLegacyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onLegacySyncFinished(relatedMessageId.getId());\n  }\n  if (unregisteredTargets.size() > 0) {\n    Log.w(TAG,\"There are \" + unregisteredTargets.size() + \" unregistered targets. Including failure results.\");\n    List<SendMessageResult> unregisteredResults=unregisteredTargets.stream().filter(Recipient::hasUuid).map(t -> SendMessageResult.unregisteredFailure(new SignalServiceAddress(t.requireUuid(),t.getE164().orNull()))).collect(Collectors.toList());\n    if (unregisteredResults.size() < unregisteredTargets.size()) {\n      Log.w(TAG,\"There are \" + (unregisteredTargets.size() - unregisteredResults.size()) + \" targets that have no UUID! Cannot report a failure for them.\");\n    }\n    allResults.addAll(unregisteredResults);\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1129,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 224,
        "startColumnNumber" : 10,
        "endLineNumber" : 224,
        "endColumnNumber" : 53
      },
      "nodeContext" : "keyCreateTime != -1 && keyAge > MAX_KEY_AGE",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "keyAge",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 225,
      "startColumnNumber" : 32,
      "endLineNumber" : 225,
      "endColumnNumber" : 38
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 8,
        "startLineNumber" : 225,
        "startColumnNumber" : 31,
        "endLineNumber" : 225,
        "endColumnNumber" : 39
      },
      "nodeContext" : "(keyAge)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 2,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 225,
        "startColumnNumber" : 19,
        "endLineNumber" : 225,
        "endColumnNumber" : 115
      },
      "nodeContext" : "\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\"",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 108,
        "startLineNumber" : 225,
        "startColumnNumber" : 8,
        "endLineNumber" : 225,
        "endColumnNumber" : 116
      },
      "nodeContext" : "Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 16,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 109,
        "startLineNumber" : 225,
        "startColumnNumber" : 8,
        "endLineNumber" : 225,
        "endColumnNumber" : 117
      },
      "nodeContext" : "Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 188,
        "startLineNumber" : 224,
        "startColumnNumber" : 55,
        "endLineNumber" : 227,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n  SenderKeyUtil.rotateOurKey(context,distributionId);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 24,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 237,
        "startLineNumber" : 224,
        "startColumnNumber" : 6,
        "endLineNumber" : 227,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n  Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n  SenderKeyUtil.rotateOurKey(context,distributionId);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 33,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2372,
        "startLineNumber" : 219,
        "startColumnNumber" : 56,
        "endLineNumber" : 259,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n    if (relatedMessageId != null) {\n      SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidRegistrationIdException e) {\n    Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 279,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2917,
        "startLineNumber" : 219,
        "startColumnNumber" : 4,
        "endLineNumber" : 265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (senderKeyTargets.size() > 0 && groupId != null) {\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n    if (relatedMessageId != null) {\n      SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidRegistrationIdException e) {\n    Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n else if (relatedMessageId != null) {\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyShared(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyEncrypted(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyMessageSent(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeySyncSent(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 339,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 9226,
        "startLineNumber" : 162,
        "startColumnNumber" : 2,
        "endLineNumber" : 327,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  Set<Recipient> unregisteredTargets=allTargets.stream().filter(Recipient::isUnregistered).collect(Collectors.toSet());\n  List<Recipient> registeredTargets=allTargets.stream().filter(r -> !unregisteredTargets.contains(r)).collect(Collectors.toList());\n  RecipientData recipients=new RecipientData(context,registeredTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : registeredTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyStarted(relatedMessageId.getId());\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n      if (relatedMessageId != null) {\n        SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidRegistrationIdException e) {\n      Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyShared(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyEncrypted(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeySyncSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onLegacyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onLegacySyncFinished(relatedMessageId.getId());\n  }\n  if (unregisteredTargets.size() > 0) {\n    Log.w(TAG,\"There are \" + unregisteredTargets.size() + \" unregistered targets. Including failure results.\");\n    List<SendMessageResult> unregisteredResults=unregisteredTargets.stream().filter(Recipient::hasUuid).map(t -> SendMessageResult.unregisteredFailure(new SignalServiceAddress(t.requireUuid(),t.getE164().orNull()))).collect(Collectors.toList());\n    if (unregisteredResults.size() < unregisteredTargets.size()) {\n      Log.w(TAG,\"There are \" + (unregisteredTargets.size() - unregisteredResults.size()) + \" targets that have no UUID! Cannot report a failure for them.\");\n    }\n    allResults.addAll(unregisteredResults);\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1069,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 10384,
        "startLineNumber" : 146,
        "startColumnNumber" : 2,
        "endLineNumber" : 327,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@Nullable MessageId relatedMessageId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  Set<Recipient> unregisteredTargets=allTargets.stream().filter(Recipient::isUnregistered).collect(Collectors.toSet());\n  List<Recipient> registeredTargets=allTargets.stream().filter(r -> !unregisteredTargets.contains(r)).collect(Collectors.toList());\n  RecipientData recipients=new RecipientData(context,registeredTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : registeredTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyStarted(relatedMessageId.getId());\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n      if (relatedMessageId != null) {\n        SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidRegistrationIdException e) {\n      Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyShared(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyEncrypted(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeySyncSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onLegacyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onLegacySyncFinished(relatedMessageId.getId());\n  }\n  if (unregisteredTargets.size() > 0) {\n    Log.w(TAG,\"There are \" + unregisteredTargets.size() + \" unregistered targets. Including failure results.\");\n    List<SendMessageResult> unregisteredResults=unregisteredTargets.stream().filter(Recipient::hasUuid).map(t -> SendMessageResult.unregisteredFailure(new SignalServiceAddress(t.requireUuid(),t.getE164().orNull()))).collect(Collectors.toList());\n    if (unregisteredResults.size() < unregisteredTargets.size()) {\n      Log.w(TAG,\"There are \" + (unregisteredTargets.size() - unregisteredResults.size()) + \" targets that have no UUID! Cannot report a failure for them.\");\n    }\n    allResults.addAll(unregisteredResults);\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1129,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 109,
        "startLineNumber" : 225,
        "startColumnNumber" : 8,
        "endLineNumber" : 225,
        "endColumnNumber" : 117
      },
      "nodeContext" : "Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "keyAge",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 225,
      "startColumnNumber" : 86,
      "endLineNumber" : 225,
      "endColumnNumber" : 92
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.InfixExpression,extendedOperands]",
      "nodePosition" : {
        "charLength" : 36,
        "startLineNumber" : 225,
        "startColumnNumber" : 57,
        "endLineNumber" : 225,
        "endColumnNumber" : 93
      },
      "nodeContext" : "TimeUnit.MILLISECONDS.toDays(keyAge)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 225,
        "startColumnNumber" : 19,
        "endLineNumber" : 225,
        "endColumnNumber" : 115
      },
      "nodeContext" : "\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\"",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 108,
        "startLineNumber" : 225,
        "startColumnNumber" : 8,
        "endLineNumber" : 225,
        "endColumnNumber" : 116
      },
      "nodeContext" : "Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 16,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 109,
        "startLineNumber" : 225,
        "startColumnNumber" : 8,
        "endLineNumber" : 225,
        "endColumnNumber" : 117
      },
      "nodeContext" : "Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 188,
        "startLineNumber" : 224,
        "startColumnNumber" : 55,
        "endLineNumber" : 227,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n  SenderKeyUtil.rotateOurKey(context,distributionId);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 24,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 237,
        "startLineNumber" : 224,
        "startColumnNumber" : 6,
        "endLineNumber" : 227,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n  Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n  SenderKeyUtil.rotateOurKey(context,distributionId);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 33,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2372,
        "startLineNumber" : 219,
        "startColumnNumber" : 56,
        "endLineNumber" : 259,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n    if (relatedMessageId != null) {\n      SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidRegistrationIdException e) {\n    Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 279,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2917,
        "startLineNumber" : 219,
        "startColumnNumber" : 4,
        "endLineNumber" : 265,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (senderKeyTargets.size() > 0 && groupId != null) {\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n    if (relatedMessageId != null) {\n      SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidRegistrationIdException e) {\n    Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n else if (relatedMessageId != null) {\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyShared(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyEncrypted(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyMessageSent(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeySyncSent(relatedMessageId.getId());\n  SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 339,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 9226,
        "startLineNumber" : 162,
        "startColumnNumber" : 2,
        "endLineNumber" : 327,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  Set<Recipient> unregisteredTargets=allTargets.stream().filter(Recipient::isUnregistered).collect(Collectors.toSet());\n  List<Recipient> registeredTargets=allTargets.stream().filter(r -> !unregisteredTargets.contains(r)).collect(Collectors.toList());\n  RecipientData recipients=new RecipientData(context,registeredTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : registeredTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyStarted(relatedMessageId.getId());\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n      if (relatedMessageId != null) {\n        SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidRegistrationIdException e) {\n      Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyShared(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyEncrypted(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeySyncSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onLegacyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onLegacySyncFinished(relatedMessageId.getId());\n  }\n  if (unregisteredTargets.size() > 0) {\n    Log.w(TAG,\"There are \" + unregisteredTargets.size() + \" unregistered targets. Including failure results.\");\n    List<SendMessageResult> unregisteredResults=unregisteredTargets.stream().filter(Recipient::hasUuid).map(t -> SendMessageResult.unregisteredFailure(new SignalServiceAddress(t.requireUuid(),t.getE164().orNull()))).collect(Collectors.toList());\n    if (unregisteredResults.size() < unregisteredTargets.size()) {\n      Log.w(TAG,\"There are \" + (unregisteredTargets.size() - unregisteredResults.size()) + \" targets that have no UUID! Cannot report a failure for them.\");\n    }\n    allResults.addAll(unregisteredResults);\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1069,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 10384,
        "startLineNumber" : 146,
        "startColumnNumber" : 2,
        "endLineNumber" : 327,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@Nullable MessageId relatedMessageId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  Set<Recipient> unregisteredTargets=allTargets.stream().filter(Recipient::isUnregistered).collect(Collectors.toSet());\n  List<Recipient> registeredTargets=allTargets.stream().filter(r -> !unregisteredTargets.contains(r)).collect(Collectors.toList());\n  RecipientData recipients=new RecipientData(context,registeredTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : registeredTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyStarted(relatedMessageId.getId());\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n      if (relatedMessageId != null) {\n        SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidRegistrationIdException e) {\n      Log.w(TAG,\"Invalid registrationId. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyShared(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyEncrypted(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeySyncSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onSenderKeyMslInserted(relatedMessageId.getId());\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n else   if (relatedMessageId != null) {\n    SignalLocalMetrics.GroupMessageSend.onLegacyMessageSent(relatedMessageId.getId());\n    SignalLocalMetrics.GroupMessageSend.onLegacySyncFinished(relatedMessageId.getId());\n  }\n  if (unregisteredTargets.size() > 0) {\n    Log.w(TAG,\"There are \" + unregisteredTargets.size() + \" unregistered targets. Including failure results.\");\n    List<SendMessageResult> unregisteredResults=unregisteredTargets.stream().filter(Recipient::hasUuid).map(t -> SendMessageResult.unregisteredFailure(new SignalServiceAddress(t.requireUuid(),t.getE164().orNull()))).collect(Collectors.toList());\n    if (unregisteredResults.size() < unregisteredTargets.size()) {\n      Log.w(TAG,\"There are \" + (unregisteredTargets.size() - unregisteredResults.size()) + \" targets that have no UUID! Cannot report a failure for them.\");\n    }\n    allResults.addAll(unregisteredResults);\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1129,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 109,
        "startLineNumber" : 225,
        "startColumnNumber" : 8,
        "endLineNumber" : 225,
        "endColumnNumber" : 117
      },
      "nodeContext" : "Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "long"
  } ],
  "positionList" : [ {
    "charLength" : 6,
    "startLineNumber" : 224,
    "startColumnNumber" : 33,
    "endLineNumber" : 224,
    "endColumnNumber" : 39
  }, {
    "charLength" : 6,
    "startLineNumber" : 225,
    "startColumnNumber" : 32,
    "endLineNumber" : 225,
    "endColumnNumber" : 38
  }, {
    "charLength" : 6,
    "startLineNumber" : 225,
    "startColumnNumber" : 86,
    "endLineNumber" : 225,
    "endColumnNumber" : 92
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 1
  } ]
}