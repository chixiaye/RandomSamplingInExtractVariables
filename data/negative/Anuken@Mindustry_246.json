{
  "id" : 246,
  "expression" : "\"}\\n\"",
  "projectName" : "Anuken@Mindustry",
  "commitID" : "a7188c48845dd423fc9b58bc6bcf6797f6d25b46",
  "filePath" : "/annotations/src/main/java/mindustry/annotations/entity/EntityProcess.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "\"}\\n\"",
    "nodeType" : "StringLiteral",
    "nodePosition" : {
      "charLength" : 5,
      "startLineNumber" : 519,
      "startColumnNumber" : 56,
      "endLineNumber" : 519,
      "endColumnNumber" : 61
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 23,
        "startLineNumber" : 519,
        "startColumnNumber" : 39,
        "endLineNumber" : 519,
        "endColumnNumber" : 62
      },
      "nodeContext" : "mbuilder.addCode(\"}\\n\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 24,
        "startLineNumber" : 519,
        "startColumnNumber" : 39,
        "endLineNumber" : 519,
        "endColumnNumber" : 63
      },
      "nodeContext" : "mbuilder.addCode(\"}\\n\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 519,
        "startColumnNumber" : 24,
        "endLineNumber" : 519,
        "endColumnNumber" : 63
      },
      "nodeContext" : "if (writeBlock) mbuilder.addCode(\"}\\n\");\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1430,
        "startLineNumber" : 490,
        "startColumnNumber" : 51,
        "endLineNumber" : 520,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  String descStr=elem.descString();\n  if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))   continue;\n  String str=methodBlocks.get(descStr);\n  String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n  if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n    continue;\n  }\n  if (writeBlock) {\n    str=str.replace(\"return;\",\"break \" + blockName + \";\");\n    mbuilder.addCode(blockName + \": {\\n\");\n  }\n  str=str.substring(2,str.length() - 1);\n  mbuilder.addCode(str);\n  if (writeBlock)   mbuilder.addCode(\"}\\n\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 127,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1461,
        "startLineNumber" : 490,
        "startColumnNumber" : 20,
        "endLineNumber" : 520,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Smethod elem : entry.value) {\n  String descStr=elem.descString();\n  if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))   continue;\n  String str=methodBlocks.get(descStr);\n  String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n  if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n    continue;\n  }\n  if (writeBlock) {\n    str=str.replace(\"return;\",\"break \" + blockName + \";\");\n    mbuilder.addCode(blockName + \": {\\n\");\n  }\n  str=str.substring(2,str.length() - 1);\n  mbuilder.addCode(str);\n  if (writeBlock)   mbuilder.addCode(\"}\\n\");\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 135,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 8054,
        "startLineNumber" : 389,
        "startColumnNumber" : 74,
        "endLineNumber" : 529,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  if (entry.value.contains(m -> m.has(Replace.class))) {\n    if (entry.value.count(m -> m.has(Replace.class)) > 1) {\n      err(\"Type \" + type + \" has multiple components replacing method \"+ entry.key+ \".\");\n    }\n    Smethod base=entry.value.find(m -> m.has(Replace.class));\n    entry.value.clear();\n    entry.value.add(base);\n  }\n  if (entry.value.count(m -> !m.isAny(Modifier.NATIVE,Modifier.ABSTRACT) && !m.isVoid()) > 1) {\n    err(\"Type \" + type + \" has multiple components implementing non-void method \"+ entry.key+ \".\");\n  }\n  entry.value.sort(Structs.comps(Structs.comparingFloat(m -> m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0),Structs.comparing(Selement::name)));\n  Smethod first=entry.value.first();\n  if (first.has(InternalImpl.class)) {\n    continue;\n  }\n  MethodSpec.Builder mbuilder=MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);\n  if (entry.value.contains(s -> s.has(CallSuper.class)))   mbuilder.addAnnotation(CallSuper.class);\n  if (first.is(Modifier.STATIC))   mbuilder.addModifiers(Modifier.STATIC);\n  mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));\n  mbuilder.returns(first.retn());\n  mbuilder.addExceptions(first.thrownt());\n  for (  Svar var : first.params()) {\n    mbuilder.addParameter(var.tname(),var.name());\n  }\n  boolean writeBlock=first.ret().toString().equals(\"void\") && entry.value.size > 1;\n  if ((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) && entry.value.size == 1 && !entry.value.first().has(InternalImpl.class)) {\n    err(entry.value.first().up().getSimpleName() + \"#\" + entry.value.first()+ \" is an abstract method and must be implemented in some component\",type);\n  }\n  if (first.name().equals(\"add\") || first.name().equals(\"remove\")) {\n    mbuilder.addStatement(\"if(added == $L) return\",first.name().equals(\"add\"));\n    for (    GroupDefinition def : groups) {\n      mbuilder.addStatement(\"Groups.$L.$L(this)\",def.name,first.name());\n    }\n  }\n  if (hasIO) {\n    if ((first.name().equals(\"read\") || first.name().equals(\"write\"))) {\n      io.write(mbuilder,first.name().equals(\"write\"));\n    }\n    if ((first.name().equals(\"readSync\") || first.name().equals(\"writeSync\"))) {\n      io.writeSync(mbuilder,first.name().equals(\"writeSync\"),syncedFields,allFields);\n    }\n    if ((first.name().equals(\"readSyncManual\") || first.name().equals(\"writeSyncManual\"))) {\n      io.writeSyncManual(mbuilder,first.name().equals(\"writeSyncManual\"),syncedFields);\n    }\n    if (first.name().equals(\"interpolate\")) {\n      io.writeInterpolate(mbuilder,syncedFields);\n    }\n    if (first.name().equals(\"snapSync\")) {\n      mbuilder.addStatement(\"updateSpacing = 16\");\n      mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n      for (      Svar field : syncedFields) {\n        mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name() + EntityIO.targetSuf);\n        mbuilder.addStatement(\"$L = $L\",field.name(),field.name() + EntityIO.targetSuf);\n      }\n    }\n    if (first.name().equals(\"snapInterpolation\")) {\n      mbuilder.addStatement(\"updateSpacing = 16\");\n      mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n      for (      Svar field : syncedFields) {\n        mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name());\n        mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.targetSuf,field.name());\n      }\n    }\n  }\n  for (  Smethod elem : entry.value) {\n    String descStr=elem.descString();\n    if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))     continue;\n    String str=methodBlocks.get(descStr);\n    String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n    if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n      continue;\n    }\n    if (writeBlock) {\n      str=str.replace(\"return;\",\"break \" + blockName + \";\");\n      mbuilder.addCode(blockName + \": {\\n\");\n    }\n    str=str.substring(2,str.length() - 1);\n    mbuilder.addCode(str);\n    if (writeBlock)     mbuilder.addCode(\"}\\n\");\n  }\n  if (first.name().equals(\"remove\") && ann.pooled()) {\n    mbuilder.addStatement(\"mindustry.gen.Groups.queueFree(($T)this)\",Poolable.class);\n  }\n  builder.addMethod(mbuilder.build());\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 793,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8112,
        "startLineNumber" : 389,
        "startColumnNumber" : 16,
        "endLineNumber" : 529,
        "endColumnNumber" : 17
      },
      "nodeContext" : "for (ObjectMap.Entry<String,Seq<Smethod>> entry : methods) {\n  if (entry.value.contains(m -> m.has(Replace.class))) {\n    if (entry.value.count(m -> m.has(Replace.class)) > 1) {\n      err(\"Type \" + type + \" has multiple components replacing method \"+ entry.key+ \".\");\n    }\n    Smethod base=entry.value.find(m -> m.has(Replace.class));\n    entry.value.clear();\n    entry.value.add(base);\n  }\n  if (entry.value.count(m -> !m.isAny(Modifier.NATIVE,Modifier.ABSTRACT) && !m.isVoid()) > 1) {\n    err(\"Type \" + type + \" has multiple components implementing non-void method \"+ entry.key+ \".\");\n  }\n  entry.value.sort(Structs.comps(Structs.comparingFloat(m -> m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0),Structs.comparing(Selement::name)));\n  Smethod first=entry.value.first();\n  if (first.has(InternalImpl.class)) {\n    continue;\n  }\n  MethodSpec.Builder mbuilder=MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);\n  if (entry.value.contains(s -> s.has(CallSuper.class)))   mbuilder.addAnnotation(CallSuper.class);\n  if (first.is(Modifier.STATIC))   mbuilder.addModifiers(Modifier.STATIC);\n  mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));\n  mbuilder.returns(first.retn());\n  mbuilder.addExceptions(first.thrownt());\n  for (  Svar var : first.params()) {\n    mbuilder.addParameter(var.tname(),var.name());\n  }\n  boolean writeBlock=first.ret().toString().equals(\"void\") && entry.value.size > 1;\n  if ((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) && entry.value.size == 1 && !entry.value.first().has(InternalImpl.class)) {\n    err(entry.value.first().up().getSimpleName() + \"#\" + entry.value.first()+ \" is an abstract method and must be implemented in some component\",type);\n  }\n  if (first.name().equals(\"add\") || first.name().equals(\"remove\")) {\n    mbuilder.addStatement(\"if(added == $L) return\",first.name().equals(\"add\"));\n    for (    GroupDefinition def : groups) {\n      mbuilder.addStatement(\"Groups.$L.$L(this)\",def.name,first.name());\n    }\n  }\n  if (hasIO) {\n    if ((first.name().equals(\"read\") || first.name().equals(\"write\"))) {\n      io.write(mbuilder,first.name().equals(\"write\"));\n    }\n    if ((first.name().equals(\"readSync\") || first.name().equals(\"writeSync\"))) {\n      io.writeSync(mbuilder,first.name().equals(\"writeSync\"),syncedFields,allFields);\n    }\n    if ((first.name().equals(\"readSyncManual\") || first.name().equals(\"writeSyncManual\"))) {\n      io.writeSyncManual(mbuilder,first.name().equals(\"writeSyncManual\"),syncedFields);\n    }\n    if (first.name().equals(\"interpolate\")) {\n      io.writeInterpolate(mbuilder,syncedFields);\n    }\n    if (first.name().equals(\"snapSync\")) {\n      mbuilder.addStatement(\"updateSpacing = 16\");\n      mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n      for (      Svar field : syncedFields) {\n        mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name() + EntityIO.targetSuf);\n        mbuilder.addStatement(\"$L = $L\",field.name(),field.name() + EntityIO.targetSuf);\n      }\n    }\n    if (first.name().equals(\"snapInterpolation\")) {\n      mbuilder.addStatement(\"updateSpacing = 16\");\n      mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n      for (      Svar field : syncedFields) {\n        mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name());\n        mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.targetSuf,field.name());\n      }\n    }\n  }\n  for (  Smethod elem : entry.value) {\n    String descStr=elem.descString();\n    if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))     continue;\n    String str=methodBlocks.get(descStr);\n    String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n    if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n      continue;\n    }\n    if (writeBlock) {\n      str=str.replace(\"return;\",\"break \" + blockName + \";\");\n      mbuilder.addCode(blockName + \": {\\n\");\n    }\n    str=str.substring(2,str.length() - 1);\n    mbuilder.addCode(str);\n    if (writeBlock)     mbuilder.addCode(\"}\\n\");\n  }\n  if (first.name().equals(\"remove\") && ann.pooled()) {\n    mbuilder.addStatement(\"mindustry.gen.Groups.queueFree(($T)this)\",Poolable.class);\n  }\n  builder.addMethod(mbuilder.build());\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 809,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 17783,
        "startLineNumber" : 241,
        "startColumnNumber" : 43,
        "endLineNumber" : 564,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  EntityDef ann=type.annotation(EntityDef.class);\n  Seq<Stype> components=allComponents(type);\n  Seq<GroupDefinition> groups=groupDefs.select(g -> (!g.components.isEmpty() && !g.components.contains(s -> !components.contains(s))) || g.manualInclusions.contains(type));\n  ObjectMap<String,Seq<Smethod>> methods=new ObjectMap<>();\n  ObjectMap<FieldSpec,Svar> specVariables=new ObjectMap<>();\n  ObjectSet<String> usedFields=new ObjectSet<>();\n  Seq<Stype> baseClasses=components.select(s -> s.annotation(Component.class).base());\n  if (baseClasses.size > 2) {\n    err(\"No entity may have more than 2 base classes. Base classes: \" + baseClasses,type);\n  }\n  Stype baseClassType=baseClasses.any() ? baseClasses.first() : null;\n  @Nullable TypeName baseClass=baseClasses.any() ? tname(packageName + \".\" + baseName(baseClassType)) : null;\n  boolean typeIsBase=baseClassType != null && type.has(Component.class) && type.annotation(Component.class).base();\n  if (type.isType() && (!type.name().endsWith(\"Def\") && !type.name().endsWith(\"Comp\"))) {\n    err(\"All entity def names must end with 'Def'/'Comp'\",type.e);\n  }\n  String name=type.isType() ? type.name().replace(\"Def\",\"\").replace(\"Comp\",\"\") : createName(type);\n  if (!typeIsBase && baseClass != null && name.equals(baseName(baseClassType))) {\n    name+=\"Entity\";\n  }\n  if (ann.legacy()) {\n    name+=\"Legacy\" + Strings.capitalize(type.name());\n  }\n  if (usedNames.containsKey(name)) {\n    extraNames.get(usedNames.get(name),ObjectSet::new).add(type.name());\n    continue;\n  }\n  usedNames.put(name,type);\n  extraNames.get(type,ObjectSet::new).add(name);\n  if (!type.isType()) {\n    extraNames.get(type,ObjectSet::new).add(type.name());\n  }\n  TypeSpec.Builder builder=TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC);\n  builder.addMethod(MethodSpec.methodBuilder(\"serialize\").addModifiers(Modifier.PUBLIC).returns(boolean.class).addStatement(\"return \" + ann.serialize()).build());\n  Seq<Svar> syncedFields=new Seq<>();\n  Seq<Svar> allFields=new Seq<>();\n  Seq<FieldSpec> allFieldSpecs=new Seq<>();\n  boolean isSync=components.contains(s -> s.name().contains(\"Sync\"));\n  for (  Stype comp : components) {\n    boolean isShadowed=baseClass != null && !typeIsBase && baseClassDeps.get(baseClassType).contains(comp);\n    Seq<Svar> fields=comp.fields().select(f -> !f.has(Import.class));\n    for (    Svar f : fields) {\n      if (!usedFields.add(f.name())) {\n        err(\"Field '\" + f.name() + \"' of component '\"+ comp.name()+ \"' redefines a field in entity '\"+ type.name()+ \"'\");\n        continue;\n      }\n      FieldSpec.Builder fbuilder=FieldSpec.builder(f.tname(),f.name());\n      if (f.is(Modifier.STATIC)) {\n        fbuilder.addModifiers(Modifier.STATIC);\n        if (f.is(Modifier.FINAL))         fbuilder.addModifiers(Modifier.FINAL);\n      }\n      if (f.is(Modifier.TRANSIENT)) {\n        fbuilder.addModifiers(Modifier.TRANSIENT);\n      }\n      if (varInitializers.containsKey(f.descString())) {\n        fbuilder.initializer(varInitializers.get(f.descString()));\n      }\n      fbuilder.addModifiers(f.has(ReadOnly.class) ? Modifier.PROTECTED : Modifier.PUBLIC);\n      fbuilder.addAnnotations(f.annotations().map(AnnotationSpec::get));\n      FieldSpec spec=fbuilder.build();\n      boolean isVisible=!f.is(Modifier.STATIC) && !f.is(Modifier.PRIVATE) && !f.has(ReadOnly.class);\n      if (!isShadowed || !isVisible) {\n        builder.addField(spec);\n      }\n      specVariables.put(spec,f);\n      allFieldSpecs.add(spec);\n      allFields.add(f);\n      if (f.has(SyncField.class) && isSync) {\n        if (!f.tname().toString().equals(\"float\"))         err(\"All SyncFields must be of type float\",f);\n        syncedFields.add(f);\n        builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.targetSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n        builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.lastSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n      }\n    }\n    for (    Smethod elem : comp.methods()) {\n      methods.get(elem.toString(),Seq::new).add(elem);\n    }\n  }\n  syncedFields.sortComparing(Selement::name);\n  builder.addMethod(MethodSpec.methodBuilder(\"toString\").addAnnotation(Override.class).returns(String.class).addModifiers(Modifier.PUBLIC).addStatement(\"return $S + $L\",name + \"#\",\"id\").build());\n  EntityIO io=new EntityIO(type.name(),builder,allFieldSpecs,serializer,rootDirectory.child(\"annotations/src/main/resources/revisions\").child(type.name()));\n  boolean hasIO=ann.genio() && (components.contains(s -> s.name().contains(\"Sync\")) || ann.serialize());\n  for (  ObjectMap.Entry<String,Seq<Smethod>> entry : methods) {\n    if (entry.value.contains(m -> m.has(Replace.class))) {\n      if (entry.value.count(m -> m.has(Replace.class)) > 1) {\n        err(\"Type \" + type + \" has multiple components replacing method \"+ entry.key+ \".\");\n      }\n      Smethod base=entry.value.find(m -> m.has(Replace.class));\n      entry.value.clear();\n      entry.value.add(base);\n    }\n    if (entry.value.count(m -> !m.isAny(Modifier.NATIVE,Modifier.ABSTRACT) && !m.isVoid()) > 1) {\n      err(\"Type \" + type + \" has multiple components implementing non-void method \"+ entry.key+ \".\");\n    }\n    entry.value.sort(Structs.comps(Structs.comparingFloat(m -> m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0),Structs.comparing(Selement::name)));\n    Smethod first=entry.value.first();\n    if (first.has(InternalImpl.class)) {\n      continue;\n    }\n    MethodSpec.Builder mbuilder=MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);\n    if (entry.value.contains(s -> s.has(CallSuper.class)))     mbuilder.addAnnotation(CallSuper.class);\n    if (first.is(Modifier.STATIC))     mbuilder.addModifiers(Modifier.STATIC);\n    mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));\n    mbuilder.returns(first.retn());\n    mbuilder.addExceptions(first.thrownt());\n    for (    Svar var : first.params()) {\n      mbuilder.addParameter(var.tname(),var.name());\n    }\n    boolean writeBlock=first.ret().toString().equals(\"void\") && entry.value.size > 1;\n    if ((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) && entry.value.size == 1 && !entry.value.first().has(InternalImpl.class)) {\n      err(entry.value.first().up().getSimpleName() + \"#\" + entry.value.first()+ \" is an abstract method and must be implemented in some component\",type);\n    }\n    if (first.name().equals(\"add\") || first.name().equals(\"remove\")) {\n      mbuilder.addStatement(\"if(added == $L) return\",first.name().equals(\"add\"));\n      for (      GroupDefinition def : groups) {\n        mbuilder.addStatement(\"Groups.$L.$L(this)\",def.name,first.name());\n      }\n    }\n    if (hasIO) {\n      if ((first.name().equals(\"read\") || first.name().equals(\"write\"))) {\n        io.write(mbuilder,first.name().equals(\"write\"));\n      }\n      if ((first.name().equals(\"readSync\") || first.name().equals(\"writeSync\"))) {\n        io.writeSync(mbuilder,first.name().equals(\"writeSync\"),syncedFields,allFields);\n      }\n      if ((first.name().equals(\"readSyncManual\") || first.name().equals(\"writeSyncManual\"))) {\n        io.writeSyncManual(mbuilder,first.name().equals(\"writeSyncManual\"),syncedFields);\n      }\n      if (first.name().equals(\"interpolate\")) {\n        io.writeInterpolate(mbuilder,syncedFields);\n      }\n      if (first.name().equals(\"snapSync\")) {\n        mbuilder.addStatement(\"updateSpacing = 16\");\n        mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n        for (        Svar field : syncedFields) {\n          mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name() + EntityIO.targetSuf);\n          mbuilder.addStatement(\"$L = $L\",field.name(),field.name() + EntityIO.targetSuf);\n        }\n      }\n      if (first.name().equals(\"snapInterpolation\")) {\n        mbuilder.addStatement(\"updateSpacing = 16\");\n        mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n        for (        Svar field : syncedFields) {\n          mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name());\n          mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.targetSuf,field.name());\n        }\n      }\n    }\n    for (    Smethod elem : entry.value) {\n      String descStr=elem.descString();\n      if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))       continue;\n      String str=methodBlocks.get(descStr);\n      String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n      if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n        continue;\n      }\n      if (writeBlock) {\n        str=str.replace(\"return;\",\"break \" + blockName + \";\");\n        mbuilder.addCode(blockName + \": {\\n\");\n      }\n      str=str.substring(2,str.length() - 1);\n      mbuilder.addCode(str);\n      if (writeBlock)       mbuilder.addCode(\"}\\n\");\n    }\n    if (first.name().equals(\"remove\") && ann.pooled()) {\n      mbuilder.addStatement(\"mindustry.gen.Groups.queueFree(($T)this)\",Poolable.class);\n    }\n    builder.addMethod(mbuilder.build());\n  }\n  if (ann.pooled()) {\n    builder.addSuperinterface(Poolable.class);\n    MethodSpec.Builder resetBuilder=MethodSpec.methodBuilder(\"reset\").addModifiers(Modifier.PUBLIC);\n    for (    FieldSpec spec : allFieldSpecs) {\n      @Nullable Svar variable=specVariables.get(spec);\n      if (variable != null && variable.isAny(Modifier.STATIC,Modifier.FINAL))       continue;\n      String desc=variable.descString();\n      if (spec.type.isPrimitive()) {\n        resetBuilder.addStatement(\"$L = $L\",spec.name,variable != null && varInitializers.containsKey(desc) ? varInitializers.get(desc) : getDefault(spec.type.toString()));\n      }\n else {\n        if (!varInitializers.containsKey(desc)) {\n          resetBuilder.addStatement(\"$L = null\",spec.name);\n        }\n      }\n    }\n    builder.addMethod(resetBuilder.build());\n  }\n  builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PROTECTED).build());\n  builder.addMethod(MethodSpec.methodBuilder(\"create\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(tname(packageName + \".\" + name)).addStatement(ann.pooled() ? \"return Pools.obtain($L.class, \" + name + \"::new)\" : \"return new $L()\",name).build());\n  definitions.add(new EntityDefinition(packageName + \".\" + name,builder,type,typeIsBase ? null : baseClass,components,groups,allFieldSpecs));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1891,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 17814,
        "startLineNumber" : 241,
        "startColumnNumber" : 12,
        "endLineNumber" : 564,
        "endColumnNumber" : 13
      },
      "nodeContext" : "for (Selement<?> type : allDefs) {\n  EntityDef ann=type.annotation(EntityDef.class);\n  Seq<Stype> components=allComponents(type);\n  Seq<GroupDefinition> groups=groupDefs.select(g -> (!g.components.isEmpty() && !g.components.contains(s -> !components.contains(s))) || g.manualInclusions.contains(type));\n  ObjectMap<String,Seq<Smethod>> methods=new ObjectMap<>();\n  ObjectMap<FieldSpec,Svar> specVariables=new ObjectMap<>();\n  ObjectSet<String> usedFields=new ObjectSet<>();\n  Seq<Stype> baseClasses=components.select(s -> s.annotation(Component.class).base());\n  if (baseClasses.size > 2) {\n    err(\"No entity may have more than 2 base classes. Base classes: \" + baseClasses,type);\n  }\n  Stype baseClassType=baseClasses.any() ? baseClasses.first() : null;\n  @Nullable TypeName baseClass=baseClasses.any() ? tname(packageName + \".\" + baseName(baseClassType)) : null;\n  boolean typeIsBase=baseClassType != null && type.has(Component.class) && type.annotation(Component.class).base();\n  if (type.isType() && (!type.name().endsWith(\"Def\") && !type.name().endsWith(\"Comp\"))) {\n    err(\"All entity def names must end with 'Def'/'Comp'\",type.e);\n  }\n  String name=type.isType() ? type.name().replace(\"Def\",\"\").replace(\"Comp\",\"\") : createName(type);\n  if (!typeIsBase && baseClass != null && name.equals(baseName(baseClassType))) {\n    name+=\"Entity\";\n  }\n  if (ann.legacy()) {\n    name+=\"Legacy\" + Strings.capitalize(type.name());\n  }\n  if (usedNames.containsKey(name)) {\n    extraNames.get(usedNames.get(name),ObjectSet::new).add(type.name());\n    continue;\n  }\n  usedNames.put(name,type);\n  extraNames.get(type,ObjectSet::new).add(name);\n  if (!type.isType()) {\n    extraNames.get(type,ObjectSet::new).add(type.name());\n  }\n  TypeSpec.Builder builder=TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC);\n  builder.addMethod(MethodSpec.methodBuilder(\"serialize\").addModifiers(Modifier.PUBLIC).returns(boolean.class).addStatement(\"return \" + ann.serialize()).build());\n  Seq<Svar> syncedFields=new Seq<>();\n  Seq<Svar> allFields=new Seq<>();\n  Seq<FieldSpec> allFieldSpecs=new Seq<>();\n  boolean isSync=components.contains(s -> s.name().contains(\"Sync\"));\n  for (  Stype comp : components) {\n    boolean isShadowed=baseClass != null && !typeIsBase && baseClassDeps.get(baseClassType).contains(comp);\n    Seq<Svar> fields=comp.fields().select(f -> !f.has(Import.class));\n    for (    Svar f : fields) {\n      if (!usedFields.add(f.name())) {\n        err(\"Field '\" + f.name() + \"' of component '\"+ comp.name()+ \"' redefines a field in entity '\"+ type.name()+ \"'\");\n        continue;\n      }\n      FieldSpec.Builder fbuilder=FieldSpec.builder(f.tname(),f.name());\n      if (f.is(Modifier.STATIC)) {\n        fbuilder.addModifiers(Modifier.STATIC);\n        if (f.is(Modifier.FINAL))         fbuilder.addModifiers(Modifier.FINAL);\n      }\n      if (f.is(Modifier.TRANSIENT)) {\n        fbuilder.addModifiers(Modifier.TRANSIENT);\n      }\n      if (varInitializers.containsKey(f.descString())) {\n        fbuilder.initializer(varInitializers.get(f.descString()));\n      }\n      fbuilder.addModifiers(f.has(ReadOnly.class) ? Modifier.PROTECTED : Modifier.PUBLIC);\n      fbuilder.addAnnotations(f.annotations().map(AnnotationSpec::get));\n      FieldSpec spec=fbuilder.build();\n      boolean isVisible=!f.is(Modifier.STATIC) && !f.is(Modifier.PRIVATE) && !f.has(ReadOnly.class);\n      if (!isShadowed || !isVisible) {\n        builder.addField(spec);\n      }\n      specVariables.put(spec,f);\n      allFieldSpecs.add(spec);\n      allFields.add(f);\n      if (f.has(SyncField.class) && isSync) {\n        if (!f.tname().toString().equals(\"float\"))         err(\"All SyncFields must be of type float\",f);\n        syncedFields.add(f);\n        builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.targetSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n        builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.lastSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n      }\n    }\n    for (    Smethod elem : comp.methods()) {\n      methods.get(elem.toString(),Seq::new).add(elem);\n    }\n  }\n  syncedFields.sortComparing(Selement::name);\n  builder.addMethod(MethodSpec.methodBuilder(\"toString\").addAnnotation(Override.class).returns(String.class).addModifiers(Modifier.PUBLIC).addStatement(\"return $S + $L\",name + \"#\",\"id\").build());\n  EntityIO io=new EntityIO(type.name(),builder,allFieldSpecs,serializer,rootDirectory.child(\"annotations/src/main/resources/revisions\").child(type.name()));\n  boolean hasIO=ann.genio() && (components.contains(s -> s.name().contains(\"Sync\")) || ann.serialize());\n  for (  ObjectMap.Entry<String,Seq<Smethod>> entry : methods) {\n    if (entry.value.contains(m -> m.has(Replace.class))) {\n      if (entry.value.count(m -> m.has(Replace.class)) > 1) {\n        err(\"Type \" + type + \" has multiple components replacing method \"+ entry.key+ \".\");\n      }\n      Smethod base=entry.value.find(m -> m.has(Replace.class));\n      entry.value.clear();\n      entry.value.add(base);\n    }\n    if (entry.value.count(m -> !m.isAny(Modifier.NATIVE,Modifier.ABSTRACT) && !m.isVoid()) > 1) {\n      err(\"Type \" + type + \" has multiple components implementing non-void method \"+ entry.key+ \".\");\n    }\n    entry.value.sort(Structs.comps(Structs.comparingFloat(m -> m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0),Structs.comparing(Selement::name)));\n    Smethod first=entry.value.first();\n    if (first.has(InternalImpl.class)) {\n      continue;\n    }\n    MethodSpec.Builder mbuilder=MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);\n    if (entry.value.contains(s -> s.has(CallSuper.class)))     mbuilder.addAnnotation(CallSuper.class);\n    if (first.is(Modifier.STATIC))     mbuilder.addModifiers(Modifier.STATIC);\n    mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));\n    mbuilder.returns(first.retn());\n    mbuilder.addExceptions(first.thrownt());\n    for (    Svar var : first.params()) {\n      mbuilder.addParameter(var.tname(),var.name());\n    }\n    boolean writeBlock=first.ret().toString().equals(\"void\") && entry.value.size > 1;\n    if ((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) && entry.value.size == 1 && !entry.value.first().has(InternalImpl.class)) {\n      err(entry.value.first().up().getSimpleName() + \"#\" + entry.value.first()+ \" is an abstract method and must be implemented in some component\",type);\n    }\n    if (first.name().equals(\"add\") || first.name().equals(\"remove\")) {\n      mbuilder.addStatement(\"if(added == $L) return\",first.name().equals(\"add\"));\n      for (      GroupDefinition def : groups) {\n        mbuilder.addStatement(\"Groups.$L.$L(this)\",def.name,first.name());\n      }\n    }\n    if (hasIO) {\n      if ((first.name().equals(\"read\") || first.name().equals(\"write\"))) {\n        io.write(mbuilder,first.name().equals(\"write\"));\n      }\n      if ((first.name().equals(\"readSync\") || first.name().equals(\"writeSync\"))) {\n        io.writeSync(mbuilder,first.name().equals(\"writeSync\"),syncedFields,allFields);\n      }\n      if ((first.name().equals(\"readSyncManual\") || first.name().equals(\"writeSyncManual\"))) {\n        io.writeSyncManual(mbuilder,first.name().equals(\"writeSyncManual\"),syncedFields);\n      }\n      if (first.name().equals(\"interpolate\")) {\n        io.writeInterpolate(mbuilder,syncedFields);\n      }\n      if (first.name().equals(\"snapSync\")) {\n        mbuilder.addStatement(\"updateSpacing = 16\");\n        mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n        for (        Svar field : syncedFields) {\n          mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name() + EntityIO.targetSuf);\n          mbuilder.addStatement(\"$L = $L\",field.name(),field.name() + EntityIO.targetSuf);\n        }\n      }\n      if (first.name().equals(\"snapInterpolation\")) {\n        mbuilder.addStatement(\"updateSpacing = 16\");\n        mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n        for (        Svar field : syncedFields) {\n          mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name());\n          mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.targetSuf,field.name());\n        }\n      }\n    }\n    for (    Smethod elem : entry.value) {\n      String descStr=elem.descString();\n      if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))       continue;\n      String str=methodBlocks.get(descStr);\n      String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n      if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n        continue;\n      }\n      if (writeBlock) {\n        str=str.replace(\"return;\",\"break \" + blockName + \";\");\n        mbuilder.addCode(blockName + \": {\\n\");\n      }\n      str=str.substring(2,str.length() - 1);\n      mbuilder.addCode(str);\n      if (writeBlock)       mbuilder.addCode(\"}\\n\");\n    }\n    if (first.name().equals(\"remove\") && ann.pooled()) {\n      mbuilder.addStatement(\"mindustry.gen.Groups.queueFree(($T)this)\",Poolable.class);\n    }\n    builder.addMethod(mbuilder.build());\n  }\n  if (ann.pooled()) {\n    builder.addSuperinterface(Poolable.class);\n    MethodSpec.Builder resetBuilder=MethodSpec.methodBuilder(\"reset\").addModifiers(Modifier.PUBLIC);\n    for (    FieldSpec spec : allFieldSpecs) {\n      @Nullable Svar variable=specVariables.get(spec);\n      if (variable != null && variable.isAny(Modifier.STATIC,Modifier.FINAL))       continue;\n      String desc=variable.descString();\n      if (spec.type.isPrimitive()) {\n        resetBuilder.addStatement(\"$L = $L\",spec.name,variable != null && varInitializers.containsKey(desc) ? varInitializers.get(desc) : getDefault(spec.type.toString()));\n      }\n else {\n        if (!varInitializers.containsKey(desc)) {\n          resetBuilder.addStatement(\"$L = null\",spec.name);\n        }\n      }\n    }\n    builder.addMethod(resetBuilder.build());\n  }\n  builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PROTECTED).build());\n  builder.addMethod(MethodSpec.methodBuilder(\"create\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(tname(packageName + \".\" + name)).addStatement(ann.pooled() ? \"return Pools.obtain($L.class, \" + name + \"::new)\" : \"return new $L()\",name).build());\n  definitions.add(new EntityDefinition(packageName + \".\" + name,builder,type,typeIsBase ? null : baseClass,components,groups,allFieldSpecs));\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 1899,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 25820,
        "startLineNumber" : 216,
        "startColumnNumber" : 28,
        "endLineNumber" : 698,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  for (  Selement<?> group : allGroups) {\n    GroupDef an=group.annotation(GroupDef.class);\n    Seq<Stype> types=types(an,GroupDef::value).map(stype -> {\n      Stype result=interfaceToComp(stype);\n      if (result == null)       throw new IllegalArgumentException(\"Interface \" + stype + \" does not have an associated component!\");\n      return result;\n    }\n);\n    Stype repr=types.first();\n    String groupType=repr.annotation(Component.class).base() ? baseName(repr) : interfaceName(repr);\n    boolean collides=an.collide();\n    groupDefs.add(new GroupDefinition(group.name().startsWith(\"g\") ? group.name().substring(1) : group.name(),ClassName.bestGuess(packageName + \".\" + groupType),types,an.spatial(),an.mapping(),collides));\n  }\n  ObjectMap<String,Selement> usedNames=new ObjectMap<>();\n  ObjectMap<Selement,ObjectSet<String>> extraNames=new ObjectMap<>();\n  for (  Selement<?> type : allDefs) {\n    EntityDef ann=type.annotation(EntityDef.class);\n    Seq<Stype> components=allComponents(type);\n    Seq<GroupDefinition> groups=groupDefs.select(g -> (!g.components.isEmpty() && !g.components.contains(s -> !components.contains(s))) || g.manualInclusions.contains(type));\n    ObjectMap<String,Seq<Smethod>> methods=new ObjectMap<>();\n    ObjectMap<FieldSpec,Svar> specVariables=new ObjectMap<>();\n    ObjectSet<String> usedFields=new ObjectSet<>();\n    Seq<Stype> baseClasses=components.select(s -> s.annotation(Component.class).base());\n    if (baseClasses.size > 2) {\n      err(\"No entity may have more than 2 base classes. Base classes: \" + baseClasses,type);\n    }\n    Stype baseClassType=baseClasses.any() ? baseClasses.first() : null;\n    @Nullable TypeName baseClass=baseClasses.any() ? tname(packageName + \".\" + baseName(baseClassType)) : null;\n    boolean typeIsBase=baseClassType != null && type.has(Component.class) && type.annotation(Component.class).base();\n    if (type.isType() && (!type.name().endsWith(\"Def\") && !type.name().endsWith(\"Comp\"))) {\n      err(\"All entity def names must end with 'Def'/'Comp'\",type.e);\n    }\n    String name=type.isType() ? type.name().replace(\"Def\",\"\").replace(\"Comp\",\"\") : createName(type);\n    if (!typeIsBase && baseClass != null && name.equals(baseName(baseClassType))) {\n      name+=\"Entity\";\n    }\n    if (ann.legacy()) {\n      name+=\"Legacy\" + Strings.capitalize(type.name());\n    }\n    if (usedNames.containsKey(name)) {\n      extraNames.get(usedNames.get(name),ObjectSet::new).add(type.name());\n      continue;\n    }\n    usedNames.put(name,type);\n    extraNames.get(type,ObjectSet::new).add(name);\n    if (!type.isType()) {\n      extraNames.get(type,ObjectSet::new).add(type.name());\n    }\n    TypeSpec.Builder builder=TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC);\n    builder.addMethod(MethodSpec.methodBuilder(\"serialize\").addModifiers(Modifier.PUBLIC).returns(boolean.class).addStatement(\"return \" + ann.serialize()).build());\n    Seq<Svar> syncedFields=new Seq<>();\n    Seq<Svar> allFields=new Seq<>();\n    Seq<FieldSpec> allFieldSpecs=new Seq<>();\n    boolean isSync=components.contains(s -> s.name().contains(\"Sync\"));\n    for (    Stype comp : components) {\n      boolean isShadowed=baseClass != null && !typeIsBase && baseClassDeps.get(baseClassType).contains(comp);\n      Seq<Svar> fields=comp.fields().select(f -> !f.has(Import.class));\n      for (      Svar f : fields) {\n        if (!usedFields.add(f.name())) {\n          err(\"Field '\" + f.name() + \"' of component '\"+ comp.name()+ \"' redefines a field in entity '\"+ type.name()+ \"'\");\n          continue;\n        }\n        FieldSpec.Builder fbuilder=FieldSpec.builder(f.tname(),f.name());\n        if (f.is(Modifier.STATIC)) {\n          fbuilder.addModifiers(Modifier.STATIC);\n          if (f.is(Modifier.FINAL))           fbuilder.addModifiers(Modifier.FINAL);\n        }\n        if (f.is(Modifier.TRANSIENT)) {\n          fbuilder.addModifiers(Modifier.TRANSIENT);\n        }\n        if (varInitializers.containsKey(f.descString())) {\n          fbuilder.initializer(varInitializers.get(f.descString()));\n        }\n        fbuilder.addModifiers(f.has(ReadOnly.class) ? Modifier.PROTECTED : Modifier.PUBLIC);\n        fbuilder.addAnnotations(f.annotations().map(AnnotationSpec::get));\n        FieldSpec spec=fbuilder.build();\n        boolean isVisible=!f.is(Modifier.STATIC) && !f.is(Modifier.PRIVATE) && !f.has(ReadOnly.class);\n        if (!isShadowed || !isVisible) {\n          builder.addField(spec);\n        }\n        specVariables.put(spec,f);\n        allFieldSpecs.add(spec);\n        allFields.add(f);\n        if (f.has(SyncField.class) && isSync) {\n          if (!f.tname().toString().equals(\"float\"))           err(\"All SyncFields must be of type float\",f);\n          syncedFields.add(f);\n          builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.targetSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n          builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.lastSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n        }\n      }\n      for (      Smethod elem : comp.methods()) {\n        methods.get(elem.toString(),Seq::new).add(elem);\n      }\n    }\n    syncedFields.sortComparing(Selement::name);\n    builder.addMethod(MethodSpec.methodBuilder(\"toString\").addAnnotation(Override.class).returns(String.class).addModifiers(Modifier.PUBLIC).addStatement(\"return $S + $L\",name + \"#\",\"id\").build());\n    EntityIO io=new EntityIO(type.name(),builder,allFieldSpecs,serializer,rootDirectory.child(\"annotations/src/main/resources/revisions\").child(type.name()));\n    boolean hasIO=ann.genio() && (components.contains(s -> s.name().contains(\"Sync\")) || ann.serialize());\n    for (    ObjectMap.Entry<String,Seq<Smethod>> entry : methods) {\n      if (entry.value.contains(m -> m.has(Replace.class))) {\n        if (entry.value.count(m -> m.has(Replace.class)) > 1) {\n          err(\"Type \" + type + \" has multiple components replacing method \"+ entry.key+ \".\");\n        }\n        Smethod base=entry.value.find(m -> m.has(Replace.class));\n        entry.value.clear();\n        entry.value.add(base);\n      }\n      if (entry.value.count(m -> !m.isAny(Modifier.NATIVE,Modifier.ABSTRACT) && !m.isVoid()) > 1) {\n        err(\"Type \" + type + \" has multiple components implementing non-void method \"+ entry.key+ \".\");\n      }\n      entry.value.sort(Structs.comps(Structs.comparingFloat(m -> m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0),Structs.comparing(Selement::name)));\n      Smethod first=entry.value.first();\n      if (first.has(InternalImpl.class)) {\n        continue;\n      }\n      MethodSpec.Builder mbuilder=MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);\n      if (entry.value.contains(s -> s.has(CallSuper.class)))       mbuilder.addAnnotation(CallSuper.class);\n      if (first.is(Modifier.STATIC))       mbuilder.addModifiers(Modifier.STATIC);\n      mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));\n      mbuilder.returns(first.retn());\n      mbuilder.addExceptions(first.thrownt());\n      for (      Svar var : first.params()) {\n        mbuilder.addParameter(var.tname(),var.name());\n      }\n      boolean writeBlock=first.ret().toString().equals(\"void\") && entry.value.size > 1;\n      if ((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) && entry.value.size == 1 && !entry.value.first().has(InternalImpl.class)) {\n        err(entry.value.first().up().getSimpleName() + \"#\" + entry.value.first()+ \" is an abstract method and must be implemented in some component\",type);\n      }\n      if (first.name().equals(\"add\") || first.name().equals(\"remove\")) {\n        mbuilder.addStatement(\"if(added == $L) return\",first.name().equals(\"add\"));\n        for (        GroupDefinition def : groups) {\n          mbuilder.addStatement(\"Groups.$L.$L(this)\",def.name,first.name());\n        }\n      }\n      if (hasIO) {\n        if ((first.name().equals(\"read\") || first.name().equals(\"write\"))) {\n          io.write(mbuilder,first.name().equals(\"write\"));\n        }\n        if ((first.name().equals(\"readSync\") || first.name().equals(\"writeSync\"))) {\n          io.writeSync(mbuilder,first.name().equals(\"writeSync\"),syncedFields,allFields);\n        }\n        if ((first.name().equals(\"readSyncManual\") || first.name().equals(\"writeSyncManual\"))) {\n          io.writeSyncManual(mbuilder,first.name().equals(\"writeSyncManual\"),syncedFields);\n        }\n        if (first.name().equals(\"interpolate\")) {\n          io.writeInterpolate(mbuilder,syncedFields);\n        }\n        if (first.name().equals(\"snapSync\")) {\n          mbuilder.addStatement(\"updateSpacing = 16\");\n          mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n          for (          Svar field : syncedFields) {\n            mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name() + EntityIO.targetSuf);\n            mbuilder.addStatement(\"$L = $L\",field.name(),field.name() + EntityIO.targetSuf);\n          }\n        }\n        if (first.name().equals(\"snapInterpolation\")) {\n          mbuilder.addStatement(\"updateSpacing = 16\");\n          mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n          for (          Svar field : syncedFields) {\n            mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name());\n            mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.targetSuf,field.name());\n          }\n        }\n      }\n      for (      Smethod elem : entry.value) {\n        String descStr=elem.descString();\n        if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))         continue;\n        String str=methodBlocks.get(descStr);\n        String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n        if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n          continue;\n        }\n        if (writeBlock) {\n          str=str.replace(\"return;\",\"break \" + blockName + \";\");\n          mbuilder.addCode(blockName + \": {\\n\");\n        }\n        str=str.substring(2,str.length() - 1);\n        mbuilder.addCode(str);\n        if (writeBlock)         mbuilder.addCode(\"}\\n\");\n      }\n      if (first.name().equals(\"remove\") && ann.pooled()) {\n        mbuilder.addStatement(\"mindustry.gen.Groups.queueFree(($T)this)\",Poolable.class);\n      }\n      builder.addMethod(mbuilder.build());\n    }\n    if (ann.pooled()) {\n      builder.addSuperinterface(Poolable.class);\n      MethodSpec.Builder resetBuilder=MethodSpec.methodBuilder(\"reset\").addModifiers(Modifier.PUBLIC);\n      for (      FieldSpec spec : allFieldSpecs) {\n        @Nullable Svar variable=specVariables.get(spec);\n        if (variable != null && variable.isAny(Modifier.STATIC,Modifier.FINAL))         continue;\n        String desc=variable.descString();\n        if (spec.type.isPrimitive()) {\n          resetBuilder.addStatement(\"$L = $L\",spec.name,variable != null && varInitializers.containsKey(desc) ? varInitializers.get(desc) : getDefault(spec.type.toString()));\n        }\n else {\n          if (!varInitializers.containsKey(desc)) {\n            resetBuilder.addStatement(\"$L = null\",spec.name);\n          }\n        }\n      }\n      builder.addMethod(resetBuilder.build());\n    }\n    builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PROTECTED).build());\n    builder.addMethod(MethodSpec.methodBuilder(\"create\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(tname(packageName + \".\" + name)).addStatement(ann.pooled() ? \"return Pools.obtain($L.class, \" + name + \"::new)\" : \"return new $L()\",name).build());\n    definitions.add(new EntityDefinition(packageName + \".\" + name,builder,type,typeIsBase ? null : baseClass,components,groups,allFieldSpecs));\n  }\n  TypeSpec.Builder groupsBuilder=TypeSpec.classBuilder(\"Groups\").addModifiers(Modifier.PUBLIC);\n  MethodSpec.Builder groupInit=MethodSpec.methodBuilder(\"init\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  for (  GroupDefinition group : groupDefs) {\n    ClassName itype=group.baseType;\n    ClassName groupc=ClassName.bestGuess(\"mindustry.entities.EntityGroup\");\n    groupsBuilder.addField(ParameterizedTypeName.get(ClassName.bestGuess(\"mindustry.entities.EntityGroup\"),itype),group.name,Modifier.PUBLIC,Modifier.STATIC);\n    groupInit.addStatement(\"$L = new $T<>($L.class, $L, $L)\",group.name,groupc,itype,group.spatial,group.mapping);\n  }\n  groupsBuilder.addMethod(groupInit.build());\n  MethodSpec.Builder groupClear=MethodSpec.methodBuilder(\"clear\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  for (  GroupDefinition group : groupDefs) {\n    groupClear.addStatement(\"$L.clear()\",group.name);\n  }\n  groupsBuilder.addMethod(groupClear.build());\n  groupsBuilder.addField(FieldSpec.builder(ParameterizedTypeName.get(Seq.class,Poolable.class),\"freeQueue\",Modifier.PRIVATE,Modifier.STATIC).initializer(\"new Seq<>()\").build());\n  MethodSpec.Builder groupFreeQueue=MethodSpec.methodBuilder(\"queueFree\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).addParameter(Poolable.class,\"obj\").addStatement(\"freeQueue.add(obj)\");\n  groupsBuilder.addMethod(groupFreeQueue.build());\n  MethodSpec.Builder groupResize=MethodSpec.methodBuilder(\"resize\").addParameter(TypeName.FLOAT,\"x\").addParameter(TypeName.FLOAT,\"y\").addParameter(TypeName.FLOAT,\"w\").addParameter(TypeName.FLOAT,\"h\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  MethodSpec.Builder groupUpdate=MethodSpec.methodBuilder(\"update\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  groupUpdate.addStatement(\"for($T p : freeQueue) $T.free(p)\",Poolable.class,Pools.class).addStatement(\"freeQueue.clear()\");\n  for (  GroupDefinition group : groupDefs) {\n    if (group.spatial) {\n      groupResize.addStatement(\"$L.resize(x, y, w, h)\",group.name);\n      groupUpdate.addStatement(\"$L.updatePhysics()\",group.name);\n    }\n  }\n  groupUpdate.addStatement(\"all.update()\");\n  for (  GroupDefinition group : groupDefs) {\n    if (group.collides) {\n      groupUpdate.addStatement(\"$L.collide()\",group.name);\n    }\n  }\n  groupsBuilder.addMethod(groupResize.build());\n  groupsBuilder.addMethod(groupUpdate.build());\n  write(groupsBuilder);\n  StringMap map=new StringMap();\n  Fi idProps=rootDirectory.child(\"annotations/src/main/resources/classids.properties\");\n  if (!idProps.exists())   idProps.writeString(\"\");\n  PropertiesUtils.load(map,idProps.reader());\n  Integer max=map.values().toSeq().map(Integer::parseInt).max(i -> i);\n  int maxID=max == null ? 0 : max + 1;\n  definitions.sort(Structs.comparing(t -> t.naming.toString()));\n  for (  EntityDefinition def : definitions) {\n    String name=def.naming.fullName();\n    if (map.containsKey(name)) {\n      def.classID=map.getInt(name);\n    }\n else {\n      def.classID=maxID++;\n      map.put(name,def.classID + \"\");\n    }\n  }\n  OrderedMap<String,String> res=new OrderedMap<>();\n  res.putAll(map);\n  res.orderedKeys().sort();\n  PropertiesUtils.store(res,idProps.writer(false),\"Maps entity names to IDs. Autogenerated.\");\n  TypeSpec.Builder idBuilder=TypeSpec.classBuilder(\"EntityMapping\").addModifiers(Modifier.PUBLIC).addField(FieldSpec.builder(TypeName.get(Prov[].class),\"idMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new Prov[256]\").build()).addField(FieldSpec.builder(ParameterizedTypeName.get(ClassName.get(ObjectMap.class),tname(String.class),tname(Prov.class)),\"nameMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new ObjectMap<>()\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(int.class,\"id\").addStatement(\"return idMap[id]\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(String.class,\"name\").addStatement(\"return nameMap.get(name)\").build());\n  CodeBlock.Builder idStore=CodeBlock.builder();\n  for (  EntityDefinition def : definitions) {\n    idStore.addStatement(\"idMap[$L] = $L::new\",def.classID,def.name);\n    extraNames.get(def.naming).each(extra -> {\n      idStore.addStatement(\"nameMap.put($S, $L::new)\",extra,def.name);\n      if (!Strings.camelToKebab(extra).equals(extra)) {\n        idStore.addStatement(\"nameMap.put($S, $L::new)\",Strings.camelToKebab(extra),def.name);\n      }\n    }\n);\n    def.builder.addMethod(MethodSpec.methodBuilder(\"classId\").addAnnotation(Override.class).returns(int.class).addModifiers(Modifier.PUBLIC).addStatement(\"return \" + def.classID).build());\n  }\n  idBuilder.addStaticBlock(idStore.build());\n  write(idBuilder);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2846,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 31649,
        "startLineNumber" : 216,
        "startColumnNumber" : 14,
        "endLineNumber" : 813,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (round == 2) {\n  for (  Selement<?> group : allGroups) {\n    GroupDef an=group.annotation(GroupDef.class);\n    Seq<Stype> types=types(an,GroupDef::value).map(stype -> {\n      Stype result=interfaceToComp(stype);\n      if (result == null)       throw new IllegalArgumentException(\"Interface \" + stype + \" does not have an associated component!\");\n      return result;\n    }\n);\n    Stype repr=types.first();\n    String groupType=repr.annotation(Component.class).base() ? baseName(repr) : interfaceName(repr);\n    boolean collides=an.collide();\n    groupDefs.add(new GroupDefinition(group.name().startsWith(\"g\") ? group.name().substring(1) : group.name(),ClassName.bestGuess(packageName + \".\" + groupType),types,an.spatial(),an.mapping(),collides));\n  }\n  ObjectMap<String,Selement> usedNames=new ObjectMap<>();\n  ObjectMap<Selement,ObjectSet<String>> extraNames=new ObjectMap<>();\n  for (  Selement<?> type : allDefs) {\n    EntityDef ann=type.annotation(EntityDef.class);\n    Seq<Stype> components=allComponents(type);\n    Seq<GroupDefinition> groups=groupDefs.select(g -> (!g.components.isEmpty() && !g.components.contains(s -> !components.contains(s))) || g.manualInclusions.contains(type));\n    ObjectMap<String,Seq<Smethod>> methods=new ObjectMap<>();\n    ObjectMap<FieldSpec,Svar> specVariables=new ObjectMap<>();\n    ObjectSet<String> usedFields=new ObjectSet<>();\n    Seq<Stype> baseClasses=components.select(s -> s.annotation(Component.class).base());\n    if (baseClasses.size > 2) {\n      err(\"No entity may have more than 2 base classes. Base classes: \" + baseClasses,type);\n    }\n    Stype baseClassType=baseClasses.any() ? baseClasses.first() : null;\n    @Nullable TypeName baseClass=baseClasses.any() ? tname(packageName + \".\" + baseName(baseClassType)) : null;\n    boolean typeIsBase=baseClassType != null && type.has(Component.class) && type.annotation(Component.class).base();\n    if (type.isType() && (!type.name().endsWith(\"Def\") && !type.name().endsWith(\"Comp\"))) {\n      err(\"All entity def names must end with 'Def'/'Comp'\",type.e);\n    }\n    String name=type.isType() ? type.name().replace(\"Def\",\"\").replace(\"Comp\",\"\") : createName(type);\n    if (!typeIsBase && baseClass != null && name.equals(baseName(baseClassType))) {\n      name+=\"Entity\";\n    }\n    if (ann.legacy()) {\n      name+=\"Legacy\" + Strings.capitalize(type.name());\n    }\n    if (usedNames.containsKey(name)) {\n      extraNames.get(usedNames.get(name),ObjectSet::new).add(type.name());\n      continue;\n    }\n    usedNames.put(name,type);\n    extraNames.get(type,ObjectSet::new).add(name);\n    if (!type.isType()) {\n      extraNames.get(type,ObjectSet::new).add(type.name());\n    }\n    TypeSpec.Builder builder=TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC);\n    builder.addMethod(MethodSpec.methodBuilder(\"serialize\").addModifiers(Modifier.PUBLIC).returns(boolean.class).addStatement(\"return \" + ann.serialize()).build());\n    Seq<Svar> syncedFields=new Seq<>();\n    Seq<Svar> allFields=new Seq<>();\n    Seq<FieldSpec> allFieldSpecs=new Seq<>();\n    boolean isSync=components.contains(s -> s.name().contains(\"Sync\"));\n    for (    Stype comp : components) {\n      boolean isShadowed=baseClass != null && !typeIsBase && baseClassDeps.get(baseClassType).contains(comp);\n      Seq<Svar> fields=comp.fields().select(f -> !f.has(Import.class));\n      for (      Svar f : fields) {\n        if (!usedFields.add(f.name())) {\n          err(\"Field '\" + f.name() + \"' of component '\"+ comp.name()+ \"' redefines a field in entity '\"+ type.name()+ \"'\");\n          continue;\n        }\n        FieldSpec.Builder fbuilder=FieldSpec.builder(f.tname(),f.name());\n        if (f.is(Modifier.STATIC)) {\n          fbuilder.addModifiers(Modifier.STATIC);\n          if (f.is(Modifier.FINAL))           fbuilder.addModifiers(Modifier.FINAL);\n        }\n        if (f.is(Modifier.TRANSIENT)) {\n          fbuilder.addModifiers(Modifier.TRANSIENT);\n        }\n        if (varInitializers.containsKey(f.descString())) {\n          fbuilder.initializer(varInitializers.get(f.descString()));\n        }\n        fbuilder.addModifiers(f.has(ReadOnly.class) ? Modifier.PROTECTED : Modifier.PUBLIC);\n        fbuilder.addAnnotations(f.annotations().map(AnnotationSpec::get));\n        FieldSpec spec=fbuilder.build();\n        boolean isVisible=!f.is(Modifier.STATIC) && !f.is(Modifier.PRIVATE) && !f.has(ReadOnly.class);\n        if (!isShadowed || !isVisible) {\n          builder.addField(spec);\n        }\n        specVariables.put(spec,f);\n        allFieldSpecs.add(spec);\n        allFields.add(f);\n        if (f.has(SyncField.class) && isSync) {\n          if (!f.tname().toString().equals(\"float\"))           err(\"All SyncFields must be of type float\",f);\n          syncedFields.add(f);\n          builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.targetSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n          builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.lastSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n        }\n      }\n      for (      Smethod elem : comp.methods()) {\n        methods.get(elem.toString(),Seq::new).add(elem);\n      }\n    }\n    syncedFields.sortComparing(Selement::name);\n    builder.addMethod(MethodSpec.methodBuilder(\"toString\").addAnnotation(Override.class).returns(String.class).addModifiers(Modifier.PUBLIC).addStatement(\"return $S + $L\",name + \"#\",\"id\").build());\n    EntityIO io=new EntityIO(type.name(),builder,allFieldSpecs,serializer,rootDirectory.child(\"annotations/src/main/resources/revisions\").child(type.name()));\n    boolean hasIO=ann.genio() && (components.contains(s -> s.name().contains(\"Sync\")) || ann.serialize());\n    for (    ObjectMap.Entry<String,Seq<Smethod>> entry : methods) {\n      if (entry.value.contains(m -> m.has(Replace.class))) {\n        if (entry.value.count(m -> m.has(Replace.class)) > 1) {\n          err(\"Type \" + type + \" has multiple components replacing method \"+ entry.key+ \".\");\n        }\n        Smethod base=entry.value.find(m -> m.has(Replace.class));\n        entry.value.clear();\n        entry.value.add(base);\n      }\n      if (entry.value.count(m -> !m.isAny(Modifier.NATIVE,Modifier.ABSTRACT) && !m.isVoid()) > 1) {\n        err(\"Type \" + type + \" has multiple components implementing non-void method \"+ entry.key+ \".\");\n      }\n      entry.value.sort(Structs.comps(Structs.comparingFloat(m -> m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0),Structs.comparing(Selement::name)));\n      Smethod first=entry.value.first();\n      if (first.has(InternalImpl.class)) {\n        continue;\n      }\n      MethodSpec.Builder mbuilder=MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);\n      if (entry.value.contains(s -> s.has(CallSuper.class)))       mbuilder.addAnnotation(CallSuper.class);\n      if (first.is(Modifier.STATIC))       mbuilder.addModifiers(Modifier.STATIC);\n      mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));\n      mbuilder.returns(first.retn());\n      mbuilder.addExceptions(first.thrownt());\n      for (      Svar var : first.params()) {\n        mbuilder.addParameter(var.tname(),var.name());\n      }\n      boolean writeBlock=first.ret().toString().equals(\"void\") && entry.value.size > 1;\n      if ((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) && entry.value.size == 1 && !entry.value.first().has(InternalImpl.class)) {\n        err(entry.value.first().up().getSimpleName() + \"#\" + entry.value.first()+ \" is an abstract method and must be implemented in some component\",type);\n      }\n      if (first.name().equals(\"add\") || first.name().equals(\"remove\")) {\n        mbuilder.addStatement(\"if(added == $L) return\",first.name().equals(\"add\"));\n        for (        GroupDefinition def : groups) {\n          mbuilder.addStatement(\"Groups.$L.$L(this)\",def.name,first.name());\n        }\n      }\n      if (hasIO) {\n        if ((first.name().equals(\"read\") || first.name().equals(\"write\"))) {\n          io.write(mbuilder,first.name().equals(\"write\"));\n        }\n        if ((first.name().equals(\"readSync\") || first.name().equals(\"writeSync\"))) {\n          io.writeSync(mbuilder,first.name().equals(\"writeSync\"),syncedFields,allFields);\n        }\n        if ((first.name().equals(\"readSyncManual\") || first.name().equals(\"writeSyncManual\"))) {\n          io.writeSyncManual(mbuilder,first.name().equals(\"writeSyncManual\"),syncedFields);\n        }\n        if (first.name().equals(\"interpolate\")) {\n          io.writeInterpolate(mbuilder,syncedFields);\n        }\n        if (first.name().equals(\"snapSync\")) {\n          mbuilder.addStatement(\"updateSpacing = 16\");\n          mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n          for (          Svar field : syncedFields) {\n            mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name() + EntityIO.targetSuf);\n            mbuilder.addStatement(\"$L = $L\",field.name(),field.name() + EntityIO.targetSuf);\n          }\n        }\n        if (first.name().equals(\"snapInterpolation\")) {\n          mbuilder.addStatement(\"updateSpacing = 16\");\n          mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n          for (          Svar field : syncedFields) {\n            mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name());\n            mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.targetSuf,field.name());\n          }\n        }\n      }\n      for (      Smethod elem : entry.value) {\n        String descStr=elem.descString();\n        if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))         continue;\n        String str=methodBlocks.get(descStr);\n        String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n        if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n          continue;\n        }\n        if (writeBlock) {\n          str=str.replace(\"return;\",\"break \" + blockName + \";\");\n          mbuilder.addCode(blockName + \": {\\n\");\n        }\n        str=str.substring(2,str.length() - 1);\n        mbuilder.addCode(str);\n        if (writeBlock)         mbuilder.addCode(\"}\\n\");\n      }\n      if (first.name().equals(\"remove\") && ann.pooled()) {\n        mbuilder.addStatement(\"mindustry.gen.Groups.queueFree(($T)this)\",Poolable.class);\n      }\n      builder.addMethod(mbuilder.build());\n    }\n    if (ann.pooled()) {\n      builder.addSuperinterface(Poolable.class);\n      MethodSpec.Builder resetBuilder=MethodSpec.methodBuilder(\"reset\").addModifiers(Modifier.PUBLIC);\n      for (      FieldSpec spec : allFieldSpecs) {\n        @Nullable Svar variable=specVariables.get(spec);\n        if (variable != null && variable.isAny(Modifier.STATIC,Modifier.FINAL))         continue;\n        String desc=variable.descString();\n        if (spec.type.isPrimitive()) {\n          resetBuilder.addStatement(\"$L = $L\",spec.name,variable != null && varInitializers.containsKey(desc) ? varInitializers.get(desc) : getDefault(spec.type.toString()));\n        }\n else {\n          if (!varInitializers.containsKey(desc)) {\n            resetBuilder.addStatement(\"$L = null\",spec.name);\n          }\n        }\n      }\n      builder.addMethod(resetBuilder.build());\n    }\n    builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PROTECTED).build());\n    builder.addMethod(MethodSpec.methodBuilder(\"create\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(tname(packageName + \".\" + name)).addStatement(ann.pooled() ? \"return Pools.obtain($L.class, \" + name + \"::new)\" : \"return new $L()\",name).build());\n    definitions.add(new EntityDefinition(packageName + \".\" + name,builder,type,typeIsBase ? null : baseClass,components,groups,allFieldSpecs));\n  }\n  TypeSpec.Builder groupsBuilder=TypeSpec.classBuilder(\"Groups\").addModifiers(Modifier.PUBLIC);\n  MethodSpec.Builder groupInit=MethodSpec.methodBuilder(\"init\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  for (  GroupDefinition group : groupDefs) {\n    ClassName itype=group.baseType;\n    ClassName groupc=ClassName.bestGuess(\"mindustry.entities.EntityGroup\");\n    groupsBuilder.addField(ParameterizedTypeName.get(ClassName.bestGuess(\"mindustry.entities.EntityGroup\"),itype),group.name,Modifier.PUBLIC,Modifier.STATIC);\n    groupInit.addStatement(\"$L = new $T<>($L.class, $L, $L)\",group.name,groupc,itype,group.spatial,group.mapping);\n  }\n  groupsBuilder.addMethod(groupInit.build());\n  MethodSpec.Builder groupClear=MethodSpec.methodBuilder(\"clear\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  for (  GroupDefinition group : groupDefs) {\n    groupClear.addStatement(\"$L.clear()\",group.name);\n  }\n  groupsBuilder.addMethod(groupClear.build());\n  groupsBuilder.addField(FieldSpec.builder(ParameterizedTypeName.get(Seq.class,Poolable.class),\"freeQueue\",Modifier.PRIVATE,Modifier.STATIC).initializer(\"new Seq<>()\").build());\n  MethodSpec.Builder groupFreeQueue=MethodSpec.methodBuilder(\"queueFree\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).addParameter(Poolable.class,\"obj\").addStatement(\"freeQueue.add(obj)\");\n  groupsBuilder.addMethod(groupFreeQueue.build());\n  MethodSpec.Builder groupResize=MethodSpec.methodBuilder(\"resize\").addParameter(TypeName.FLOAT,\"x\").addParameter(TypeName.FLOAT,\"y\").addParameter(TypeName.FLOAT,\"w\").addParameter(TypeName.FLOAT,\"h\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  MethodSpec.Builder groupUpdate=MethodSpec.methodBuilder(\"update\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  groupUpdate.addStatement(\"for($T p : freeQueue) $T.free(p)\",Poolable.class,Pools.class).addStatement(\"freeQueue.clear()\");\n  for (  GroupDefinition group : groupDefs) {\n    if (group.spatial) {\n      groupResize.addStatement(\"$L.resize(x, y, w, h)\",group.name);\n      groupUpdate.addStatement(\"$L.updatePhysics()\",group.name);\n    }\n  }\n  groupUpdate.addStatement(\"all.update()\");\n  for (  GroupDefinition group : groupDefs) {\n    if (group.collides) {\n      groupUpdate.addStatement(\"$L.collide()\",group.name);\n    }\n  }\n  groupsBuilder.addMethod(groupResize.build());\n  groupsBuilder.addMethod(groupUpdate.build());\n  write(groupsBuilder);\n  StringMap map=new StringMap();\n  Fi idProps=rootDirectory.child(\"annotations/src/main/resources/classids.properties\");\n  if (!idProps.exists())   idProps.writeString(\"\");\n  PropertiesUtils.load(map,idProps.reader());\n  Integer max=map.values().toSeq().map(Integer::parseInt).max(i -> i);\n  int maxID=max == null ? 0 : max + 1;\n  definitions.sort(Structs.comparing(t -> t.naming.toString()));\n  for (  EntityDefinition def : definitions) {\n    String name=def.naming.fullName();\n    if (map.containsKey(name)) {\n      def.classID=map.getInt(name);\n    }\n else {\n      def.classID=maxID++;\n      map.put(name,def.classID + \"\");\n    }\n  }\n  OrderedMap<String,String> res=new OrderedMap<>();\n  res.putAll(map);\n  res.orderedKeys().sort();\n  PropertiesUtils.store(res,idProps.writer(false),\"Maps entity names to IDs. Autogenerated.\");\n  TypeSpec.Builder idBuilder=TypeSpec.classBuilder(\"EntityMapping\").addModifiers(Modifier.PUBLIC).addField(FieldSpec.builder(TypeName.get(Prov[].class),\"idMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new Prov[256]\").build()).addField(FieldSpec.builder(ParameterizedTypeName.get(ClassName.get(ObjectMap.class),tname(String.class),tname(Prov.class)),\"nameMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new ObjectMap<>()\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(int.class,\"id\").addStatement(\"return idMap[id]\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(String.class,\"name\").addStatement(\"return nameMap.get(name)\").build());\n  CodeBlock.Builder idStore=CodeBlock.builder();\n  for (  EntityDefinition def : definitions) {\n    idStore.addStatement(\"idMap[$L] = $L::new\",def.classID,def.name);\n    extraNames.get(def.naming).each(extra -> {\n      idStore.addStatement(\"nameMap.put($S, $L::new)\",extra,def.name);\n      if (!Strings.camelToKebab(extra).equals(extra)) {\n        idStore.addStatement(\"nameMap.put($S, $L::new)\",Strings.camelToKebab(extra),def.name);\n      }\n    }\n);\n    def.builder.addMethod(MethodSpec.methodBuilder(\"classId\").addAnnotation(Override.class).returns(int.class).addModifiers(Modifier.PUBLIC).addStatement(\"return \" + def.classID).build());\n  }\n  idBuilder.addStaticBlock(idStore.build());\n  write(idBuilder);\n}\n else {\n  for (  TypeSpec.Builder b : baseClasses) {\n    write(b,imports.asArray());\n  }\n  for (  EntityDefinition def : definitions) {\n    ObjectSet<String> methodNames=def.components.flatMap(type -> type.methods().map(Smethod::simpleString)).<String>as().asSet();\n    if (def.extend != null) {\n      def.builder.superclass(def.extend);\n    }\n    for (    Stype comp : def.components) {\n      Stype inter=allInterfaces.find(i -> i.name().equals(interfaceName(comp)));\n      if (inter == null) {\n        err(\"Failed to generate interface for\",comp);\n        return;\n      }\n      def.builder.addSuperinterface(inter.tname());\n      for (      Smethod method : inter.methods()) {\n        String var=method.name();\n        FieldSpec field=Seq.with(def.fieldSpecs).find(f -> f.name.equals(var));\n        if (field == null || methodNames.contains(method.simpleString()))         continue;\n        if (!method.isVoid()) {\n          def.builder.addMethod(MethodSpec.overriding(method.e).addStatement(\"return \" + var).build());\n        }\n        if (method.isVoid() && !Seq.with(field.annotations).contains(f -> f.type.toString().equals(\"@mindustry.annotations.Annotations.ReadOnly\"))) {\n          def.builder.addMethod(MethodSpec.overriding(method.e).addStatement(\"this.\" + var + \" = \"+ var).build());\n        }\n      }\n    }\n    write(def.builder,imports.asArray());\n  }\n  TypeSpec.Builder nullsBuilder=TypeSpec.classBuilder(\"Nulls\").addModifiers(Modifier.PUBLIC).addModifiers(Modifier.FINAL);\n  for (  Stype interf : allInterfaces) {\n    Seq<Stype> dependencies=interf.allInterfaces().and(interf);\n    Seq<Smethod> methods=dependencies.flatMap(Stype::methods);\n    methods.sortComparing(Object::toString);\n    Stype superclass=dependencies.map(this::interfaceToComp).find(s -> s != null && s.annotation(Component.class).base());\n    TypeName type=superclass != null && interfaceToComp(interf).annotation(Component.class).base() ? tname(baseName(superclass)) : interf.tname();\n    ObjectSet<String> signatures=new ObjectSet<>();\n    String baseName=interf.name().substring(0,interf.name().length() - 1);\n    String className=\"Null\" + baseName;\n    TypeSpec.Builder nullBuilder=TypeSpec.classBuilder(className).addModifiers(Modifier.FINAL);\n    nullBuilder.addSuperinterface(interf.tname());\n    if (superclass != null)     nullBuilder.superclass(tname(baseName(superclass)));\n    for (    Smethod method : methods) {\n      String signature=method.toString();\n      if (signatures.contains(signature))       continue;\n      Stype compType=interfaceToComp(method.type());\n      MethodSpec.Builder builder=MethodSpec.overriding(method.e).addModifiers(Modifier.PUBLIC,Modifier.FINAL);\n      builder.addAnnotation(OverrideCallSuper.class);\n      if (!method.isVoid()) {\n        if (method.name().equals(\"isNull\")) {\n          builder.addStatement(\"return true\");\n        }\n else         if (method.name().equals(\"id\")) {\n          builder.addStatement(\"return -1\");\n        }\n else {\n          Svar variable=compType == null || method.params().size > 0 ? null : compType.fields().find(v -> v.name().equals(method.name()));\n          String desc=variable == null ? null : variable.descString();\n          if (variable == null || !varInitializers.containsKey(desc)) {\n            builder.addStatement(\"return \" + getDefault(method.ret().toString()));\n          }\n else {\n            String init=varInitializers.get(desc);\n            builder.addStatement(\"return \" + (init.equals(\"{}\") ? \"new \" + variable.mirror().toString() : \"\") + init);\n          }\n        }\n      }\n      nullBuilder.addMethod(builder.build());\n      signatures.add(signature);\n    }\n    nullsBuilder.addField(FieldSpec.builder(type,Strings.camelize(baseName)).initializer(\"new \" + className + \"()\").addModifiers(Modifier.FINAL,Modifier.STATIC,Modifier.PUBLIC).build());\n    write(nullBuilder);\n  }\n  write(nullsBuilder);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 3538,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 39751,
        "startLineNumber" : 58,
        "startColumnNumber" : 8,
        "endLineNumber" : 813,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (round == 1) {\n  serializer=TypeIOResolver.resolve(this);\n  baseComponents=types(BaseComponent.class);\n  Seq<Stype> allComponents=types(Component.class);\n  for (  Stype component : allComponents) {\n    for (    Svar f : component.fields()) {\n      VariableTree tree=f.tree();\n      if (tree.getInitializer() != null) {\n        String init=tree.getInitializer().toString();\n        varInitializers.put(f.descString(),init);\n      }\n    }\n    for (    Smethod elem : component.methods()) {\n      if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE))       continue;\n      methodBlocks.put(elem.descString(),elem.tree().getBody().toString().replaceAll(\"this\\\\.<(.*)>self\\\\(\\\\)\",\"this\").replaceAll(\"self\\\\(\\\\)\",\"this\").replaceAll(\" yield \",\"\").replaceAll(\"\\\\/\\\\*missing\\\\*\\\\/\",\"var\"));\n    }\n  }\n  for (  Stype type : allComponents) {\n    componentNames.put(type.name(),type);\n  }\n  for (  Stype comp : allComponents) {\n    imports.addAll(getImports(comp.e));\n  }\n  for (  Stype component : allComponents) {\n    TypeSpec.Builder inter=TypeSpec.interfaceBuilder(interfaceName(component)).addModifiers(Modifier.PUBLIC).addAnnotation(EntityInterface.class);\n    inter.addJavadoc(\"Interface for {@link $L}\",component.fullName());\n    for (    Stype extraInterface : component.interfaces().select(i -> !isCompInterface(i))) {\n      inter.superinterfaces.add(tname(extraInterface.fullName()));\n    }\n    Seq<Stype> depends=getDependencies(component);\n    for (    Stype type : depends) {\n      inter.addSuperinterface(ClassName.get(packageName,interfaceName(type)));\n    }\n    ObjectSet<String> signatures=new ObjectSet<>();\n    for (    Smethod method : component.methods()) {\n      if (method.isAny(Modifier.PRIVATE,Modifier.STATIC))       continue;\n      signatures.add(method.e.toString());\n      inter.addMethod(MethodSpec.methodBuilder(method.name()).addJavadoc(method.doc() == null ? \"\" : method.doc()).addExceptions(method.thrownt()).addTypeVariables(method.typeVariables().map(TypeVariableName::get)).returns(method.ret().toString().equals(\"void\") ? TypeName.VOID : method.retn()).addParameters(method.params().map(v -> ParameterSpec.builder(v.tname(),v.name()).build())).addModifiers(Modifier.PUBLIC,Modifier.ABSTRACT).build());\n    }\n    for (    Svar field : component.fields().select(e -> !e.is(Modifier.STATIC) && !e.is(Modifier.PRIVATE) && !e.has(Import.class))) {\n      String cname=field.name();\n      if (!signatures.contains(cname + \"()\")) {\n        inter.addMethod(MethodSpec.methodBuilder(cname).addModifiers(Modifier.ABSTRACT,Modifier.PUBLIC).addAnnotations(Seq.with(field.annotations()).select(a -> a.toString().contains(\"Null\")).map(AnnotationSpec::get)).addJavadoc(field.doc() == null ? \"\" : field.doc()).returns(field.tname()).build());\n      }\n      if (!field.is(Modifier.FINAL) && !signatures.contains(cname + \"(\" + field.mirror().toString()+ \")\") && !field.annotations().contains(f -> f.toString().equals(\"@mindustry.annotations.Annotations.ReadOnly\"))) {\n        inter.addMethod(MethodSpec.methodBuilder(cname).addModifiers(Modifier.ABSTRACT,Modifier.PUBLIC).addJavadoc(field.doc() == null ? \"\" : field.doc()).addParameter(ParameterSpec.builder(field.tname(),field.name()).addAnnotations(Seq.with(field.annotations()).select(a -> a.toString().contains(\"Null\")).map(AnnotationSpec::get)).build()).build());\n      }\n    }\n    write(inter);\n    if (component.annotation(Component.class).base()) {\n      Seq<Stype> deps=depends.copy().and(component);\n      baseClassDeps.get(component,ObjectSet::new).addAll(deps);\n      if (!component.has(EntityDef.class)) {\n        TypeSpec.Builder base=TypeSpec.classBuilder(baseName(component)).addModifiers(Modifier.PUBLIC,Modifier.ABSTRACT);\n        for (        Stype type : deps) {\n          for (          Svar field : type.fields().select(e -> !e.is(Modifier.STATIC) && !e.is(Modifier.PRIVATE) && !e.has(Import.class)&& !e.has(ReadOnly.class))) {\n            FieldSpec.Builder builder=FieldSpec.builder(field.tname(),field.name(),Modifier.PUBLIC);\n            if (field.is(Modifier.TRANSIENT))             builder.addModifiers(Modifier.TRANSIENT);\n            builder.addAnnotations(field.annotations().map(AnnotationSpec::get));\n            if (varInitializers.containsKey(field.descString())) {\n              builder.initializer(varInitializers.get(field.descString()));\n            }\n            base.addField(builder.build());\n          }\n        }\n        for (        Stype type : deps) {\n          base.addSuperinterface(tname(packageName,interfaceName(type)));\n        }\n        baseClasses.add(base);\n      }\n    }\n    Log.debug(\"&gGenerating interface for \" + component.name());\n    for (    TypeName tn : inter.superinterfaces) {\n      Log.debug(\"&g> &lbimplements @\",simpleName(tn.toString()));\n    }\n    for (    MethodSpec spec : inter.methodSpecs) {\n      Log.debug(\"&g> > &c@ @(@)\",simpleName(spec.returnType.toString()),spec.name,Seq.with(spec.parameters).toString(\", \",p -> simpleName(p.type.toString()) + \" \" + p.name));\n    }\n    Log.debug(\"\");\n  }\n}\n else if (round == 2) {\n  for (  Selement<?> group : allGroups) {\n    GroupDef an=group.annotation(GroupDef.class);\n    Seq<Stype> types=types(an,GroupDef::value).map(stype -> {\n      Stype result=interfaceToComp(stype);\n      if (result == null)       throw new IllegalArgumentException(\"Interface \" + stype + \" does not have an associated component!\");\n      return result;\n    }\n);\n    Stype repr=types.first();\n    String groupType=repr.annotation(Component.class).base() ? baseName(repr) : interfaceName(repr);\n    boolean collides=an.collide();\n    groupDefs.add(new GroupDefinition(group.name().startsWith(\"g\") ? group.name().substring(1) : group.name(),ClassName.bestGuess(packageName + \".\" + groupType),types,an.spatial(),an.mapping(),collides));\n  }\n  ObjectMap<String,Selement> usedNames=new ObjectMap<>();\n  ObjectMap<Selement,ObjectSet<String>> extraNames=new ObjectMap<>();\n  for (  Selement<?> type : allDefs) {\n    EntityDef ann=type.annotation(EntityDef.class);\n    Seq<Stype> components=allComponents(type);\n    Seq<GroupDefinition> groups=groupDefs.select(g -> (!g.components.isEmpty() && !g.components.contains(s -> !components.contains(s))) || g.manualInclusions.contains(type));\n    ObjectMap<String,Seq<Smethod>> methods=new ObjectMap<>();\n    ObjectMap<FieldSpec,Svar> specVariables=new ObjectMap<>();\n    ObjectSet<String> usedFields=new ObjectSet<>();\n    Seq<Stype> baseClasses=components.select(s -> s.annotation(Component.class).base());\n    if (baseClasses.size > 2) {\n      err(\"No entity may have more than 2 base classes. Base classes: \" + baseClasses,type);\n    }\n    Stype baseClassType=baseClasses.any() ? baseClasses.first() : null;\n    @Nullable TypeName baseClass=baseClasses.any() ? tname(packageName + \".\" + baseName(baseClassType)) : null;\n    boolean typeIsBase=baseClassType != null && type.has(Component.class) && type.annotation(Component.class).base();\n    if (type.isType() && (!type.name().endsWith(\"Def\") && !type.name().endsWith(\"Comp\"))) {\n      err(\"All entity def names must end with 'Def'/'Comp'\",type.e);\n    }\n    String name=type.isType() ? type.name().replace(\"Def\",\"\").replace(\"Comp\",\"\") : createName(type);\n    if (!typeIsBase && baseClass != null && name.equals(baseName(baseClassType))) {\n      name+=\"Entity\";\n    }\n    if (ann.legacy()) {\n      name+=\"Legacy\" + Strings.capitalize(type.name());\n    }\n    if (usedNames.containsKey(name)) {\n      extraNames.get(usedNames.get(name),ObjectSet::new).add(type.name());\n      continue;\n    }\n    usedNames.put(name,type);\n    extraNames.get(type,ObjectSet::new).add(name);\n    if (!type.isType()) {\n      extraNames.get(type,ObjectSet::new).add(type.name());\n    }\n    TypeSpec.Builder builder=TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC);\n    builder.addMethod(MethodSpec.methodBuilder(\"serialize\").addModifiers(Modifier.PUBLIC).returns(boolean.class).addStatement(\"return \" + ann.serialize()).build());\n    Seq<Svar> syncedFields=new Seq<>();\n    Seq<Svar> allFields=new Seq<>();\n    Seq<FieldSpec> allFieldSpecs=new Seq<>();\n    boolean isSync=components.contains(s -> s.name().contains(\"Sync\"));\n    for (    Stype comp : components) {\n      boolean isShadowed=baseClass != null && !typeIsBase && baseClassDeps.get(baseClassType).contains(comp);\n      Seq<Svar> fields=comp.fields().select(f -> !f.has(Import.class));\n      for (      Svar f : fields) {\n        if (!usedFields.add(f.name())) {\n          err(\"Field '\" + f.name() + \"' of component '\"+ comp.name()+ \"' redefines a field in entity '\"+ type.name()+ \"'\");\n          continue;\n        }\n        FieldSpec.Builder fbuilder=FieldSpec.builder(f.tname(),f.name());\n        if (f.is(Modifier.STATIC)) {\n          fbuilder.addModifiers(Modifier.STATIC);\n          if (f.is(Modifier.FINAL))           fbuilder.addModifiers(Modifier.FINAL);\n        }\n        if (f.is(Modifier.TRANSIENT)) {\n          fbuilder.addModifiers(Modifier.TRANSIENT);\n        }\n        if (varInitializers.containsKey(f.descString())) {\n          fbuilder.initializer(varInitializers.get(f.descString()));\n        }\n        fbuilder.addModifiers(f.has(ReadOnly.class) ? Modifier.PROTECTED : Modifier.PUBLIC);\n        fbuilder.addAnnotations(f.annotations().map(AnnotationSpec::get));\n        FieldSpec spec=fbuilder.build();\n        boolean isVisible=!f.is(Modifier.STATIC) && !f.is(Modifier.PRIVATE) && !f.has(ReadOnly.class);\n        if (!isShadowed || !isVisible) {\n          builder.addField(spec);\n        }\n        specVariables.put(spec,f);\n        allFieldSpecs.add(spec);\n        allFields.add(f);\n        if (f.has(SyncField.class) && isSync) {\n          if (!f.tname().toString().equals(\"float\"))           err(\"All SyncFields must be of type float\",f);\n          syncedFields.add(f);\n          builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.targetSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n          builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.lastSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n        }\n      }\n      for (      Smethod elem : comp.methods()) {\n        methods.get(elem.toString(),Seq::new).add(elem);\n      }\n    }\n    syncedFields.sortComparing(Selement::name);\n    builder.addMethod(MethodSpec.methodBuilder(\"toString\").addAnnotation(Override.class).returns(String.class).addModifiers(Modifier.PUBLIC).addStatement(\"return $S + $L\",name + \"#\",\"id\").build());\n    EntityIO io=new EntityIO(type.name(),builder,allFieldSpecs,serializer,rootDirectory.child(\"annotations/src/main/resources/revisions\").child(type.name()));\n    boolean hasIO=ann.genio() && (components.contains(s -> s.name().contains(\"Sync\")) || ann.serialize());\n    for (    ObjectMap.Entry<String,Seq<Smethod>> entry : methods) {\n      if (entry.value.contains(m -> m.has(Replace.class))) {\n        if (entry.value.count(m -> m.has(Replace.class)) > 1) {\n          err(\"Type \" + type + \" has multiple components replacing method \"+ entry.key+ \".\");\n        }\n        Smethod base=entry.value.find(m -> m.has(Replace.class));\n        entry.value.clear();\n        entry.value.add(base);\n      }\n      if (entry.value.count(m -> !m.isAny(Modifier.NATIVE,Modifier.ABSTRACT) && !m.isVoid()) > 1) {\n        err(\"Type \" + type + \" has multiple components implementing non-void method \"+ entry.key+ \".\");\n      }\n      entry.value.sort(Structs.comps(Structs.comparingFloat(m -> m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0),Structs.comparing(Selement::name)));\n      Smethod first=entry.value.first();\n      if (first.has(InternalImpl.class)) {\n        continue;\n      }\n      MethodSpec.Builder mbuilder=MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);\n      if (entry.value.contains(s -> s.has(CallSuper.class)))       mbuilder.addAnnotation(CallSuper.class);\n      if (first.is(Modifier.STATIC))       mbuilder.addModifiers(Modifier.STATIC);\n      mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));\n      mbuilder.returns(first.retn());\n      mbuilder.addExceptions(first.thrownt());\n      for (      Svar var : first.params()) {\n        mbuilder.addParameter(var.tname(),var.name());\n      }\n      boolean writeBlock=first.ret().toString().equals(\"void\") && entry.value.size > 1;\n      if ((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) && entry.value.size == 1 && !entry.value.first().has(InternalImpl.class)) {\n        err(entry.value.first().up().getSimpleName() + \"#\" + entry.value.first()+ \" is an abstract method and must be implemented in some component\",type);\n      }\n      if (first.name().equals(\"add\") || first.name().equals(\"remove\")) {\n        mbuilder.addStatement(\"if(added == $L) return\",first.name().equals(\"add\"));\n        for (        GroupDefinition def : groups) {\n          mbuilder.addStatement(\"Groups.$L.$L(this)\",def.name,first.name());\n        }\n      }\n      if (hasIO) {\n        if ((first.name().equals(\"read\") || first.name().equals(\"write\"))) {\n          io.write(mbuilder,first.name().equals(\"write\"));\n        }\n        if ((first.name().equals(\"readSync\") || first.name().equals(\"writeSync\"))) {\n          io.writeSync(mbuilder,first.name().equals(\"writeSync\"),syncedFields,allFields);\n        }\n        if ((first.name().equals(\"readSyncManual\") || first.name().equals(\"writeSyncManual\"))) {\n          io.writeSyncManual(mbuilder,first.name().equals(\"writeSyncManual\"),syncedFields);\n        }\n        if (first.name().equals(\"interpolate\")) {\n          io.writeInterpolate(mbuilder,syncedFields);\n        }\n        if (first.name().equals(\"snapSync\")) {\n          mbuilder.addStatement(\"updateSpacing = 16\");\n          mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n          for (          Svar field : syncedFields) {\n            mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name() + EntityIO.targetSuf);\n            mbuilder.addStatement(\"$L = $L\",field.name(),field.name() + EntityIO.targetSuf);\n          }\n        }\n        if (first.name().equals(\"snapInterpolation\")) {\n          mbuilder.addStatement(\"updateSpacing = 16\");\n          mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n          for (          Svar field : syncedFields) {\n            mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name());\n            mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.targetSuf,field.name());\n          }\n        }\n      }\n      for (      Smethod elem : entry.value) {\n        String descStr=elem.descString();\n        if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))         continue;\n        String str=methodBlocks.get(descStr);\n        String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n        if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n          continue;\n        }\n        if (writeBlock) {\n          str=str.replace(\"return;\",\"break \" + blockName + \";\");\n          mbuilder.addCode(blockName + \": {\\n\");\n        }\n        str=str.substring(2,str.length() - 1);\n        mbuilder.addCode(str);\n        if (writeBlock)         mbuilder.addCode(\"}\\n\");\n      }\n      if (first.name().equals(\"remove\") && ann.pooled()) {\n        mbuilder.addStatement(\"mindustry.gen.Groups.queueFree(($T)this)\",Poolable.class);\n      }\n      builder.addMethod(mbuilder.build());\n    }\n    if (ann.pooled()) {\n      builder.addSuperinterface(Poolable.class);\n      MethodSpec.Builder resetBuilder=MethodSpec.methodBuilder(\"reset\").addModifiers(Modifier.PUBLIC);\n      for (      FieldSpec spec : allFieldSpecs) {\n        @Nullable Svar variable=specVariables.get(spec);\n        if (variable != null && variable.isAny(Modifier.STATIC,Modifier.FINAL))         continue;\n        String desc=variable.descString();\n        if (spec.type.isPrimitive()) {\n          resetBuilder.addStatement(\"$L = $L\",spec.name,variable != null && varInitializers.containsKey(desc) ? varInitializers.get(desc) : getDefault(spec.type.toString()));\n        }\n else {\n          if (!varInitializers.containsKey(desc)) {\n            resetBuilder.addStatement(\"$L = null\",spec.name);\n          }\n        }\n      }\n      builder.addMethod(resetBuilder.build());\n    }\n    builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PROTECTED).build());\n    builder.addMethod(MethodSpec.methodBuilder(\"create\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(tname(packageName + \".\" + name)).addStatement(ann.pooled() ? \"return Pools.obtain($L.class, \" + name + \"::new)\" : \"return new $L()\",name).build());\n    definitions.add(new EntityDefinition(packageName + \".\" + name,builder,type,typeIsBase ? null : baseClass,components,groups,allFieldSpecs));\n  }\n  TypeSpec.Builder groupsBuilder=TypeSpec.classBuilder(\"Groups\").addModifiers(Modifier.PUBLIC);\n  MethodSpec.Builder groupInit=MethodSpec.methodBuilder(\"init\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  for (  GroupDefinition group : groupDefs) {\n    ClassName itype=group.baseType;\n    ClassName groupc=ClassName.bestGuess(\"mindustry.entities.EntityGroup\");\n    groupsBuilder.addField(ParameterizedTypeName.get(ClassName.bestGuess(\"mindustry.entities.EntityGroup\"),itype),group.name,Modifier.PUBLIC,Modifier.STATIC);\n    groupInit.addStatement(\"$L = new $T<>($L.class, $L, $L)\",group.name,groupc,itype,group.spatial,group.mapping);\n  }\n  groupsBuilder.addMethod(groupInit.build());\n  MethodSpec.Builder groupClear=MethodSpec.methodBuilder(\"clear\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  for (  GroupDefinition group : groupDefs) {\n    groupClear.addStatement(\"$L.clear()\",group.name);\n  }\n  groupsBuilder.addMethod(groupClear.build());\n  groupsBuilder.addField(FieldSpec.builder(ParameterizedTypeName.get(Seq.class,Poolable.class),\"freeQueue\",Modifier.PRIVATE,Modifier.STATIC).initializer(\"new Seq<>()\").build());\n  MethodSpec.Builder groupFreeQueue=MethodSpec.methodBuilder(\"queueFree\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).addParameter(Poolable.class,\"obj\").addStatement(\"freeQueue.add(obj)\");\n  groupsBuilder.addMethod(groupFreeQueue.build());\n  MethodSpec.Builder groupResize=MethodSpec.methodBuilder(\"resize\").addParameter(TypeName.FLOAT,\"x\").addParameter(TypeName.FLOAT,\"y\").addParameter(TypeName.FLOAT,\"w\").addParameter(TypeName.FLOAT,\"h\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  MethodSpec.Builder groupUpdate=MethodSpec.methodBuilder(\"update\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n  groupUpdate.addStatement(\"for($T p : freeQueue) $T.free(p)\",Poolable.class,Pools.class).addStatement(\"freeQueue.clear()\");\n  for (  GroupDefinition group : groupDefs) {\n    if (group.spatial) {\n      groupResize.addStatement(\"$L.resize(x, y, w, h)\",group.name);\n      groupUpdate.addStatement(\"$L.updatePhysics()\",group.name);\n    }\n  }\n  groupUpdate.addStatement(\"all.update()\");\n  for (  GroupDefinition group : groupDefs) {\n    if (group.collides) {\n      groupUpdate.addStatement(\"$L.collide()\",group.name);\n    }\n  }\n  groupsBuilder.addMethod(groupResize.build());\n  groupsBuilder.addMethod(groupUpdate.build());\n  write(groupsBuilder);\n  StringMap map=new StringMap();\n  Fi idProps=rootDirectory.child(\"annotations/src/main/resources/classids.properties\");\n  if (!idProps.exists())   idProps.writeString(\"\");\n  PropertiesUtils.load(map,idProps.reader());\n  Integer max=map.values().toSeq().map(Integer::parseInt).max(i -> i);\n  int maxID=max == null ? 0 : max + 1;\n  definitions.sort(Structs.comparing(t -> t.naming.toString()));\n  for (  EntityDefinition def : definitions) {\n    String name=def.naming.fullName();\n    if (map.containsKey(name)) {\n      def.classID=map.getInt(name);\n    }\n else {\n      def.classID=maxID++;\n      map.put(name,def.classID + \"\");\n    }\n  }\n  OrderedMap<String,String> res=new OrderedMap<>();\n  res.putAll(map);\n  res.orderedKeys().sort();\n  PropertiesUtils.store(res,idProps.writer(false),\"Maps entity names to IDs. Autogenerated.\");\n  TypeSpec.Builder idBuilder=TypeSpec.classBuilder(\"EntityMapping\").addModifiers(Modifier.PUBLIC).addField(FieldSpec.builder(TypeName.get(Prov[].class),\"idMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new Prov[256]\").build()).addField(FieldSpec.builder(ParameterizedTypeName.get(ClassName.get(ObjectMap.class),tname(String.class),tname(Prov.class)),\"nameMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new ObjectMap<>()\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(int.class,\"id\").addStatement(\"return idMap[id]\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(String.class,\"name\").addStatement(\"return nameMap.get(name)\").build());\n  CodeBlock.Builder idStore=CodeBlock.builder();\n  for (  EntityDefinition def : definitions) {\n    idStore.addStatement(\"idMap[$L] = $L::new\",def.classID,def.name);\n    extraNames.get(def.naming).each(extra -> {\n      idStore.addStatement(\"nameMap.put($S, $L::new)\",extra,def.name);\n      if (!Strings.camelToKebab(extra).equals(extra)) {\n        idStore.addStatement(\"nameMap.put($S, $L::new)\",Strings.camelToKebab(extra),def.name);\n      }\n    }\n);\n    def.builder.addMethod(MethodSpec.methodBuilder(\"classId\").addAnnotation(Override.class).returns(int.class).addModifiers(Modifier.PUBLIC).addStatement(\"return \" + def.classID).build());\n  }\n  idBuilder.addStaticBlock(idStore.build());\n  write(idBuilder);\n}\n else {\n  for (  TypeSpec.Builder b : baseClasses) {\n    write(b,imports.asArray());\n  }\n  for (  EntityDefinition def : definitions) {\n    ObjectSet<String> methodNames=def.components.flatMap(type -> type.methods().map(Smethod::simpleString)).<String>as().asSet();\n    if (def.extend != null) {\n      def.builder.superclass(def.extend);\n    }\n    for (    Stype comp : def.components) {\n      Stype inter=allInterfaces.find(i -> i.name().equals(interfaceName(comp)));\n      if (inter == null) {\n        err(\"Failed to generate interface for\",comp);\n        return;\n      }\n      def.builder.addSuperinterface(inter.tname());\n      for (      Smethod method : inter.methods()) {\n        String var=method.name();\n        FieldSpec field=Seq.with(def.fieldSpecs).find(f -> f.name.equals(var));\n        if (field == null || methodNames.contains(method.simpleString()))         continue;\n        if (!method.isVoid()) {\n          def.builder.addMethod(MethodSpec.overriding(method.e).addStatement(\"return \" + var).build());\n        }\n        if (method.isVoid() && !Seq.with(field.annotations).contains(f -> f.type.toString().equals(\"@mindustry.annotations.Annotations.ReadOnly\"))) {\n          def.builder.addMethod(MethodSpec.overriding(method.e).addStatement(\"this.\" + var + \" = \"+ var).build());\n        }\n      }\n    }\n    write(def.builder,imports.asArray());\n  }\n  TypeSpec.Builder nullsBuilder=TypeSpec.classBuilder(\"Nulls\").addModifiers(Modifier.PUBLIC).addModifiers(Modifier.FINAL);\n  for (  Stype interf : allInterfaces) {\n    Seq<Stype> dependencies=interf.allInterfaces().and(interf);\n    Seq<Smethod> methods=dependencies.flatMap(Stype::methods);\n    methods.sortComparing(Object::toString);\n    Stype superclass=dependencies.map(this::interfaceToComp).find(s -> s != null && s.annotation(Component.class).base());\n    TypeName type=superclass != null && interfaceToComp(interf).annotation(Component.class).base() ? tname(baseName(superclass)) : interf.tname();\n    ObjectSet<String> signatures=new ObjectSet<>();\n    String baseName=interf.name().substring(0,interf.name().length() - 1);\n    String className=\"Null\" + baseName;\n    TypeSpec.Builder nullBuilder=TypeSpec.classBuilder(className).addModifiers(Modifier.FINAL);\n    nullBuilder.addSuperinterface(interf.tname());\n    if (superclass != null)     nullBuilder.superclass(tname(baseName(superclass)));\n    for (    Smethod method : methods) {\n      String signature=method.toString();\n      if (signatures.contains(signature))       continue;\n      Stype compType=interfaceToComp(method.type());\n      MethodSpec.Builder builder=MethodSpec.overriding(method.e).addModifiers(Modifier.PUBLIC,Modifier.FINAL);\n      builder.addAnnotation(OverrideCallSuper.class);\n      if (!method.isVoid()) {\n        if (method.name().equals(\"isNull\")) {\n          builder.addStatement(\"return true\");\n        }\n else         if (method.name().equals(\"id\")) {\n          builder.addStatement(\"return -1\");\n        }\n else {\n          Svar variable=compType == null || method.params().size > 0 ? null : compType.fields().find(v -> v.name().equals(method.name()));\n          String desc=variable == null ? null : variable.descString();\n          if (variable == null || !varInitializers.containsKey(desc)) {\n            builder.addStatement(\"return \" + getDefault(method.ret().toString()));\n          }\n else {\n            String init=varInitializers.get(desc);\n            builder.addStatement(\"return \" + (init.equals(\"{}\") ? \"new \" + variable.mirror().toString() : \"\") + init);\n          }\n        }\n      }\n      nullBuilder.addMethod(builder.build());\n      signatures.add(signature);\n    }\n    nullsBuilder.addField(FieldSpec.builder(type,Strings.camelize(baseName)).initializer(\"new \" + className + \"()\").addModifiers(Modifier.FINAL,Modifier.STATIC,Modifier.PUBLIC).build());\n    write(nullBuilder);\n  }\n  write(nullsBuilder);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 4436,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 39980,
        "startLineNumber" : 52,
        "startColumnNumber" : 62,
        "endLineNumber" : 814,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  allGroups.addAll(elements(GroupDef.class));\n  allDefs.addAll(elements(EntityDef.class));\n  allInterfaces.addAll(types(EntityInterface.class));\n  if (round == 1) {\n    serializer=TypeIOResolver.resolve(this);\n    baseComponents=types(BaseComponent.class);\n    Seq<Stype> allComponents=types(Component.class);\n    for (    Stype component : allComponents) {\n      for (      Svar f : component.fields()) {\n        VariableTree tree=f.tree();\n        if (tree.getInitializer() != null) {\n          String init=tree.getInitializer().toString();\n          varInitializers.put(f.descString(),init);\n        }\n      }\n      for (      Smethod elem : component.methods()) {\n        if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE))         continue;\n        methodBlocks.put(elem.descString(),elem.tree().getBody().toString().replaceAll(\"this\\\\.<(.*)>self\\\\(\\\\)\",\"this\").replaceAll(\"self\\\\(\\\\)\",\"this\").replaceAll(\" yield \",\"\").replaceAll(\"\\\\/\\\\*missing\\\\*\\\\/\",\"var\"));\n      }\n    }\n    for (    Stype type : allComponents) {\n      componentNames.put(type.name(),type);\n    }\n    for (    Stype comp : allComponents) {\n      imports.addAll(getImports(comp.e));\n    }\n    for (    Stype component : allComponents) {\n      TypeSpec.Builder inter=TypeSpec.interfaceBuilder(interfaceName(component)).addModifiers(Modifier.PUBLIC).addAnnotation(EntityInterface.class);\n      inter.addJavadoc(\"Interface for {@link $L}\",component.fullName());\n      for (      Stype extraInterface : component.interfaces().select(i -> !isCompInterface(i))) {\n        inter.superinterfaces.add(tname(extraInterface.fullName()));\n      }\n      Seq<Stype> depends=getDependencies(component);\n      for (      Stype type : depends) {\n        inter.addSuperinterface(ClassName.get(packageName,interfaceName(type)));\n      }\n      ObjectSet<String> signatures=new ObjectSet<>();\n      for (      Smethod method : component.methods()) {\n        if (method.isAny(Modifier.PRIVATE,Modifier.STATIC))         continue;\n        signatures.add(method.e.toString());\n        inter.addMethod(MethodSpec.methodBuilder(method.name()).addJavadoc(method.doc() == null ? \"\" : method.doc()).addExceptions(method.thrownt()).addTypeVariables(method.typeVariables().map(TypeVariableName::get)).returns(method.ret().toString().equals(\"void\") ? TypeName.VOID : method.retn()).addParameters(method.params().map(v -> ParameterSpec.builder(v.tname(),v.name()).build())).addModifiers(Modifier.PUBLIC,Modifier.ABSTRACT).build());\n      }\n      for (      Svar field : component.fields().select(e -> !e.is(Modifier.STATIC) && !e.is(Modifier.PRIVATE) && !e.has(Import.class))) {\n        String cname=field.name();\n        if (!signatures.contains(cname + \"()\")) {\n          inter.addMethod(MethodSpec.methodBuilder(cname).addModifiers(Modifier.ABSTRACT,Modifier.PUBLIC).addAnnotations(Seq.with(field.annotations()).select(a -> a.toString().contains(\"Null\")).map(AnnotationSpec::get)).addJavadoc(field.doc() == null ? \"\" : field.doc()).returns(field.tname()).build());\n        }\n        if (!field.is(Modifier.FINAL) && !signatures.contains(cname + \"(\" + field.mirror().toString()+ \")\") && !field.annotations().contains(f -> f.toString().equals(\"@mindustry.annotations.Annotations.ReadOnly\"))) {\n          inter.addMethod(MethodSpec.methodBuilder(cname).addModifiers(Modifier.ABSTRACT,Modifier.PUBLIC).addJavadoc(field.doc() == null ? \"\" : field.doc()).addParameter(ParameterSpec.builder(field.tname(),field.name()).addAnnotations(Seq.with(field.annotations()).select(a -> a.toString().contains(\"Null\")).map(AnnotationSpec::get)).build()).build());\n        }\n      }\n      write(inter);\n      if (component.annotation(Component.class).base()) {\n        Seq<Stype> deps=depends.copy().and(component);\n        baseClassDeps.get(component,ObjectSet::new).addAll(deps);\n        if (!component.has(EntityDef.class)) {\n          TypeSpec.Builder base=TypeSpec.classBuilder(baseName(component)).addModifiers(Modifier.PUBLIC,Modifier.ABSTRACT);\n          for (          Stype type : deps) {\n            for (            Svar field : type.fields().select(e -> !e.is(Modifier.STATIC) && !e.is(Modifier.PRIVATE) && !e.has(Import.class)&& !e.has(ReadOnly.class))) {\n              FieldSpec.Builder builder=FieldSpec.builder(field.tname(),field.name(),Modifier.PUBLIC);\n              if (field.is(Modifier.TRANSIENT))               builder.addModifiers(Modifier.TRANSIENT);\n              builder.addAnnotations(field.annotations().map(AnnotationSpec::get));\n              if (varInitializers.containsKey(field.descString())) {\n                builder.initializer(varInitializers.get(field.descString()));\n              }\n              base.addField(builder.build());\n            }\n          }\n          for (          Stype type : deps) {\n            base.addSuperinterface(tname(packageName,interfaceName(type)));\n          }\n          baseClasses.add(base);\n        }\n      }\n      Log.debug(\"&gGenerating interface for \" + component.name());\n      for (      TypeName tn : inter.superinterfaces) {\n        Log.debug(\"&g> &lbimplements @\",simpleName(tn.toString()));\n      }\n      for (      MethodSpec spec : inter.methodSpecs) {\n        Log.debug(\"&g> > &c@ @(@)\",simpleName(spec.returnType.toString()),spec.name,Seq.with(spec.parameters).toString(\", \",p -> simpleName(p.type.toString()) + \" \" + p.name));\n      }\n      Log.debug(\"\");\n    }\n  }\n else   if (round == 2) {\n    for (    Selement<?> group : allGroups) {\n      GroupDef an=group.annotation(GroupDef.class);\n      Seq<Stype> types=types(an,GroupDef::value).map(stype -> {\n        Stype result=interfaceToComp(stype);\n        if (result == null)         throw new IllegalArgumentException(\"Interface \" + stype + \" does not have an associated component!\");\n        return result;\n      }\n);\n      Stype repr=types.first();\n      String groupType=repr.annotation(Component.class).base() ? baseName(repr) : interfaceName(repr);\n      boolean collides=an.collide();\n      groupDefs.add(new GroupDefinition(group.name().startsWith(\"g\") ? group.name().substring(1) : group.name(),ClassName.bestGuess(packageName + \".\" + groupType),types,an.spatial(),an.mapping(),collides));\n    }\n    ObjectMap<String,Selement> usedNames=new ObjectMap<>();\n    ObjectMap<Selement,ObjectSet<String>> extraNames=new ObjectMap<>();\n    for (    Selement<?> type : allDefs) {\n      EntityDef ann=type.annotation(EntityDef.class);\n      Seq<Stype> components=allComponents(type);\n      Seq<GroupDefinition> groups=groupDefs.select(g -> (!g.components.isEmpty() && !g.components.contains(s -> !components.contains(s))) || g.manualInclusions.contains(type));\n      ObjectMap<String,Seq<Smethod>> methods=new ObjectMap<>();\n      ObjectMap<FieldSpec,Svar> specVariables=new ObjectMap<>();\n      ObjectSet<String> usedFields=new ObjectSet<>();\n      Seq<Stype> baseClasses=components.select(s -> s.annotation(Component.class).base());\n      if (baseClasses.size > 2) {\n        err(\"No entity may have more than 2 base classes. Base classes: \" + baseClasses,type);\n      }\n      Stype baseClassType=baseClasses.any() ? baseClasses.first() : null;\n      @Nullable TypeName baseClass=baseClasses.any() ? tname(packageName + \".\" + baseName(baseClassType)) : null;\n      boolean typeIsBase=baseClassType != null && type.has(Component.class) && type.annotation(Component.class).base();\n      if (type.isType() && (!type.name().endsWith(\"Def\") && !type.name().endsWith(\"Comp\"))) {\n        err(\"All entity def names must end with 'Def'/'Comp'\",type.e);\n      }\n      String name=type.isType() ? type.name().replace(\"Def\",\"\").replace(\"Comp\",\"\") : createName(type);\n      if (!typeIsBase && baseClass != null && name.equals(baseName(baseClassType))) {\n        name+=\"Entity\";\n      }\n      if (ann.legacy()) {\n        name+=\"Legacy\" + Strings.capitalize(type.name());\n      }\n      if (usedNames.containsKey(name)) {\n        extraNames.get(usedNames.get(name),ObjectSet::new).add(type.name());\n        continue;\n      }\n      usedNames.put(name,type);\n      extraNames.get(type,ObjectSet::new).add(name);\n      if (!type.isType()) {\n        extraNames.get(type,ObjectSet::new).add(type.name());\n      }\n      TypeSpec.Builder builder=TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC);\n      builder.addMethod(MethodSpec.methodBuilder(\"serialize\").addModifiers(Modifier.PUBLIC).returns(boolean.class).addStatement(\"return \" + ann.serialize()).build());\n      Seq<Svar> syncedFields=new Seq<>();\n      Seq<Svar> allFields=new Seq<>();\n      Seq<FieldSpec> allFieldSpecs=new Seq<>();\n      boolean isSync=components.contains(s -> s.name().contains(\"Sync\"));\n      for (      Stype comp : components) {\n        boolean isShadowed=baseClass != null && !typeIsBase && baseClassDeps.get(baseClassType).contains(comp);\n        Seq<Svar> fields=comp.fields().select(f -> !f.has(Import.class));\n        for (        Svar f : fields) {\n          if (!usedFields.add(f.name())) {\n            err(\"Field '\" + f.name() + \"' of component '\"+ comp.name()+ \"' redefines a field in entity '\"+ type.name()+ \"'\");\n            continue;\n          }\n          FieldSpec.Builder fbuilder=FieldSpec.builder(f.tname(),f.name());\n          if (f.is(Modifier.STATIC)) {\n            fbuilder.addModifiers(Modifier.STATIC);\n            if (f.is(Modifier.FINAL))             fbuilder.addModifiers(Modifier.FINAL);\n          }\n          if (f.is(Modifier.TRANSIENT)) {\n            fbuilder.addModifiers(Modifier.TRANSIENT);\n          }\n          if (varInitializers.containsKey(f.descString())) {\n            fbuilder.initializer(varInitializers.get(f.descString()));\n          }\n          fbuilder.addModifiers(f.has(ReadOnly.class) ? Modifier.PROTECTED : Modifier.PUBLIC);\n          fbuilder.addAnnotations(f.annotations().map(AnnotationSpec::get));\n          FieldSpec spec=fbuilder.build();\n          boolean isVisible=!f.is(Modifier.STATIC) && !f.is(Modifier.PRIVATE) && !f.has(ReadOnly.class);\n          if (!isShadowed || !isVisible) {\n            builder.addField(spec);\n          }\n          specVariables.put(spec,f);\n          allFieldSpecs.add(spec);\n          allFields.add(f);\n          if (f.has(SyncField.class) && isSync) {\n            if (!f.tname().toString().equals(\"float\"))             err(\"All SyncFields must be of type float\",f);\n            syncedFields.add(f);\n            builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.targetSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n            builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.lastSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n          }\n        }\n        for (        Smethod elem : comp.methods()) {\n          methods.get(elem.toString(),Seq::new).add(elem);\n        }\n      }\n      syncedFields.sortComparing(Selement::name);\n      builder.addMethod(MethodSpec.methodBuilder(\"toString\").addAnnotation(Override.class).returns(String.class).addModifiers(Modifier.PUBLIC).addStatement(\"return $S + $L\",name + \"#\",\"id\").build());\n      EntityIO io=new EntityIO(type.name(),builder,allFieldSpecs,serializer,rootDirectory.child(\"annotations/src/main/resources/revisions\").child(type.name()));\n      boolean hasIO=ann.genio() && (components.contains(s -> s.name().contains(\"Sync\")) || ann.serialize());\n      for (      ObjectMap.Entry<String,Seq<Smethod>> entry : methods) {\n        if (entry.value.contains(m -> m.has(Replace.class))) {\n          if (entry.value.count(m -> m.has(Replace.class)) > 1) {\n            err(\"Type \" + type + \" has multiple components replacing method \"+ entry.key+ \".\");\n          }\n          Smethod base=entry.value.find(m -> m.has(Replace.class));\n          entry.value.clear();\n          entry.value.add(base);\n        }\n        if (entry.value.count(m -> !m.isAny(Modifier.NATIVE,Modifier.ABSTRACT) && !m.isVoid()) > 1) {\n          err(\"Type \" + type + \" has multiple components implementing non-void method \"+ entry.key+ \".\");\n        }\n        entry.value.sort(Structs.comps(Structs.comparingFloat(m -> m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0),Structs.comparing(Selement::name)));\n        Smethod first=entry.value.first();\n        if (first.has(InternalImpl.class)) {\n          continue;\n        }\n        MethodSpec.Builder mbuilder=MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);\n        if (entry.value.contains(s -> s.has(CallSuper.class)))         mbuilder.addAnnotation(CallSuper.class);\n        if (first.is(Modifier.STATIC))         mbuilder.addModifiers(Modifier.STATIC);\n        mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));\n        mbuilder.returns(first.retn());\n        mbuilder.addExceptions(first.thrownt());\n        for (        Svar var : first.params()) {\n          mbuilder.addParameter(var.tname(),var.name());\n        }\n        boolean writeBlock=first.ret().toString().equals(\"void\") && entry.value.size > 1;\n        if ((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) && entry.value.size == 1 && !entry.value.first().has(InternalImpl.class)) {\n          err(entry.value.first().up().getSimpleName() + \"#\" + entry.value.first()+ \" is an abstract method and must be implemented in some component\",type);\n        }\n        if (first.name().equals(\"add\") || first.name().equals(\"remove\")) {\n          mbuilder.addStatement(\"if(added == $L) return\",first.name().equals(\"add\"));\n          for (          GroupDefinition def : groups) {\n            mbuilder.addStatement(\"Groups.$L.$L(this)\",def.name,first.name());\n          }\n        }\n        if (hasIO) {\n          if ((first.name().equals(\"read\") || first.name().equals(\"write\"))) {\n            io.write(mbuilder,first.name().equals(\"write\"));\n          }\n          if ((first.name().equals(\"readSync\") || first.name().equals(\"writeSync\"))) {\n            io.writeSync(mbuilder,first.name().equals(\"writeSync\"),syncedFields,allFields);\n          }\n          if ((first.name().equals(\"readSyncManual\") || first.name().equals(\"writeSyncManual\"))) {\n            io.writeSyncManual(mbuilder,first.name().equals(\"writeSyncManual\"),syncedFields);\n          }\n          if (first.name().equals(\"interpolate\")) {\n            io.writeInterpolate(mbuilder,syncedFields);\n          }\n          if (first.name().equals(\"snapSync\")) {\n            mbuilder.addStatement(\"updateSpacing = 16\");\n            mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n            for (            Svar field : syncedFields) {\n              mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name() + EntityIO.targetSuf);\n              mbuilder.addStatement(\"$L = $L\",field.name(),field.name() + EntityIO.targetSuf);\n            }\n          }\n          if (first.name().equals(\"snapInterpolation\")) {\n            mbuilder.addStatement(\"updateSpacing = 16\");\n            mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n            for (            Svar field : syncedFields) {\n              mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name());\n              mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.targetSuf,field.name());\n            }\n          }\n        }\n        for (        Smethod elem : entry.value) {\n          String descStr=elem.descString();\n          if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))           continue;\n          String str=methodBlocks.get(descStr);\n          String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n          if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n            continue;\n          }\n          if (writeBlock) {\n            str=str.replace(\"return;\",\"break \" + blockName + \";\");\n            mbuilder.addCode(blockName + \": {\\n\");\n          }\n          str=str.substring(2,str.length() - 1);\n          mbuilder.addCode(str);\n          if (writeBlock)           mbuilder.addCode(\"}\\n\");\n        }\n        if (first.name().equals(\"remove\") && ann.pooled()) {\n          mbuilder.addStatement(\"mindustry.gen.Groups.queueFree(($T)this)\",Poolable.class);\n        }\n        builder.addMethod(mbuilder.build());\n      }\n      if (ann.pooled()) {\n        builder.addSuperinterface(Poolable.class);\n        MethodSpec.Builder resetBuilder=MethodSpec.methodBuilder(\"reset\").addModifiers(Modifier.PUBLIC);\n        for (        FieldSpec spec : allFieldSpecs) {\n          @Nullable Svar variable=specVariables.get(spec);\n          if (variable != null && variable.isAny(Modifier.STATIC,Modifier.FINAL))           continue;\n          String desc=variable.descString();\n          if (spec.type.isPrimitive()) {\n            resetBuilder.addStatement(\"$L = $L\",spec.name,variable != null && varInitializers.containsKey(desc) ? varInitializers.get(desc) : getDefault(spec.type.toString()));\n          }\n else {\n            if (!varInitializers.containsKey(desc)) {\n              resetBuilder.addStatement(\"$L = null\",spec.name);\n            }\n          }\n        }\n        builder.addMethod(resetBuilder.build());\n      }\n      builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PROTECTED).build());\n      builder.addMethod(MethodSpec.methodBuilder(\"create\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(tname(packageName + \".\" + name)).addStatement(ann.pooled() ? \"return Pools.obtain($L.class, \" + name + \"::new)\" : \"return new $L()\",name).build());\n      definitions.add(new EntityDefinition(packageName + \".\" + name,builder,type,typeIsBase ? null : baseClass,components,groups,allFieldSpecs));\n    }\n    TypeSpec.Builder groupsBuilder=TypeSpec.classBuilder(\"Groups\").addModifiers(Modifier.PUBLIC);\n    MethodSpec.Builder groupInit=MethodSpec.methodBuilder(\"init\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n    for (    GroupDefinition group : groupDefs) {\n      ClassName itype=group.baseType;\n      ClassName groupc=ClassName.bestGuess(\"mindustry.entities.EntityGroup\");\n      groupsBuilder.addField(ParameterizedTypeName.get(ClassName.bestGuess(\"mindustry.entities.EntityGroup\"),itype),group.name,Modifier.PUBLIC,Modifier.STATIC);\n      groupInit.addStatement(\"$L = new $T<>($L.class, $L, $L)\",group.name,groupc,itype,group.spatial,group.mapping);\n    }\n    groupsBuilder.addMethod(groupInit.build());\n    MethodSpec.Builder groupClear=MethodSpec.methodBuilder(\"clear\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n    for (    GroupDefinition group : groupDefs) {\n      groupClear.addStatement(\"$L.clear()\",group.name);\n    }\n    groupsBuilder.addMethod(groupClear.build());\n    groupsBuilder.addField(FieldSpec.builder(ParameterizedTypeName.get(Seq.class,Poolable.class),\"freeQueue\",Modifier.PRIVATE,Modifier.STATIC).initializer(\"new Seq<>()\").build());\n    MethodSpec.Builder groupFreeQueue=MethodSpec.methodBuilder(\"queueFree\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).addParameter(Poolable.class,\"obj\").addStatement(\"freeQueue.add(obj)\");\n    groupsBuilder.addMethod(groupFreeQueue.build());\n    MethodSpec.Builder groupResize=MethodSpec.methodBuilder(\"resize\").addParameter(TypeName.FLOAT,\"x\").addParameter(TypeName.FLOAT,\"y\").addParameter(TypeName.FLOAT,\"w\").addParameter(TypeName.FLOAT,\"h\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n    MethodSpec.Builder groupUpdate=MethodSpec.methodBuilder(\"update\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n    groupUpdate.addStatement(\"for($T p : freeQueue) $T.free(p)\",Poolable.class,Pools.class).addStatement(\"freeQueue.clear()\");\n    for (    GroupDefinition group : groupDefs) {\n      if (group.spatial) {\n        groupResize.addStatement(\"$L.resize(x, y, w, h)\",group.name);\n        groupUpdate.addStatement(\"$L.updatePhysics()\",group.name);\n      }\n    }\n    groupUpdate.addStatement(\"all.update()\");\n    for (    GroupDefinition group : groupDefs) {\n      if (group.collides) {\n        groupUpdate.addStatement(\"$L.collide()\",group.name);\n      }\n    }\n    groupsBuilder.addMethod(groupResize.build());\n    groupsBuilder.addMethod(groupUpdate.build());\n    write(groupsBuilder);\n    StringMap map=new StringMap();\n    Fi idProps=rootDirectory.child(\"annotations/src/main/resources/classids.properties\");\n    if (!idProps.exists())     idProps.writeString(\"\");\n    PropertiesUtils.load(map,idProps.reader());\n    Integer max=map.values().toSeq().map(Integer::parseInt).max(i -> i);\n    int maxID=max == null ? 0 : max + 1;\n    definitions.sort(Structs.comparing(t -> t.naming.toString()));\n    for (    EntityDefinition def : definitions) {\n      String name=def.naming.fullName();\n      if (map.containsKey(name)) {\n        def.classID=map.getInt(name);\n      }\n else {\n        def.classID=maxID++;\n        map.put(name,def.classID + \"\");\n      }\n    }\n    OrderedMap<String,String> res=new OrderedMap<>();\n    res.putAll(map);\n    res.orderedKeys().sort();\n    PropertiesUtils.store(res,idProps.writer(false),\"Maps entity names to IDs. Autogenerated.\");\n    TypeSpec.Builder idBuilder=TypeSpec.classBuilder(\"EntityMapping\").addModifiers(Modifier.PUBLIC).addField(FieldSpec.builder(TypeName.get(Prov[].class),\"idMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new Prov[256]\").build()).addField(FieldSpec.builder(ParameterizedTypeName.get(ClassName.get(ObjectMap.class),tname(String.class),tname(Prov.class)),\"nameMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new ObjectMap<>()\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(int.class,\"id\").addStatement(\"return idMap[id]\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(String.class,\"name\").addStatement(\"return nameMap.get(name)\").build());\n    CodeBlock.Builder idStore=CodeBlock.builder();\n    for (    EntityDefinition def : definitions) {\n      idStore.addStatement(\"idMap[$L] = $L::new\",def.classID,def.name);\n      extraNames.get(def.naming).each(extra -> {\n        idStore.addStatement(\"nameMap.put($S, $L::new)\",extra,def.name);\n        if (!Strings.camelToKebab(extra).equals(extra)) {\n          idStore.addStatement(\"nameMap.put($S, $L::new)\",Strings.camelToKebab(extra),def.name);\n        }\n      }\n);\n      def.builder.addMethod(MethodSpec.methodBuilder(\"classId\").addAnnotation(Override.class).returns(int.class).addModifiers(Modifier.PUBLIC).addStatement(\"return \" + def.classID).build());\n    }\n    idBuilder.addStaticBlock(idStore.build());\n    write(idBuilder);\n  }\n else {\n    for (    TypeSpec.Builder b : baseClasses) {\n      write(b,imports.asArray());\n    }\n    for (    EntityDefinition def : definitions) {\n      ObjectSet<String> methodNames=def.components.flatMap(type -> type.methods().map(Smethod::simpleString)).<String>as().asSet();\n      if (def.extend != null) {\n        def.builder.superclass(def.extend);\n      }\n      for (      Stype comp : def.components) {\n        Stype inter=allInterfaces.find(i -> i.name().equals(interfaceName(comp)));\n        if (inter == null) {\n          err(\"Failed to generate interface for\",comp);\n          return;\n        }\n        def.builder.addSuperinterface(inter.tname());\n        for (        Smethod method : inter.methods()) {\n          String var=method.name();\n          FieldSpec field=Seq.with(def.fieldSpecs).find(f -> f.name.equals(var));\n          if (field == null || methodNames.contains(method.simpleString()))           continue;\n          if (!method.isVoid()) {\n            def.builder.addMethod(MethodSpec.overriding(method.e).addStatement(\"return \" + var).build());\n          }\n          if (method.isVoid() && !Seq.with(field.annotations).contains(f -> f.type.toString().equals(\"@mindustry.annotations.Annotations.ReadOnly\"))) {\n            def.builder.addMethod(MethodSpec.overriding(method.e).addStatement(\"this.\" + var + \" = \"+ var).build());\n          }\n        }\n      }\n      write(def.builder,imports.asArray());\n    }\n    TypeSpec.Builder nullsBuilder=TypeSpec.classBuilder(\"Nulls\").addModifiers(Modifier.PUBLIC).addModifiers(Modifier.FINAL);\n    for (    Stype interf : allInterfaces) {\n      Seq<Stype> dependencies=interf.allInterfaces().and(interf);\n      Seq<Smethod> methods=dependencies.flatMap(Stype::methods);\n      methods.sortComparing(Object::toString);\n      Stype superclass=dependencies.map(this::interfaceToComp).find(s -> s != null && s.annotation(Component.class).base());\n      TypeName type=superclass != null && interfaceToComp(interf).annotation(Component.class).base() ? tname(baseName(superclass)) : interf.tname();\n      ObjectSet<String> signatures=new ObjectSet<>();\n      String baseName=interf.name().substring(0,interf.name().length() - 1);\n      String className=\"Null\" + baseName;\n      TypeSpec.Builder nullBuilder=TypeSpec.classBuilder(className).addModifiers(Modifier.FINAL);\n      nullBuilder.addSuperinterface(interf.tname());\n      if (superclass != null)       nullBuilder.superclass(tname(baseName(superclass)));\n      for (      Smethod method : methods) {\n        String signature=method.toString();\n        if (signatures.contains(signature))         continue;\n        Stype compType=interfaceToComp(method.type());\n        MethodSpec.Builder builder=MethodSpec.overriding(method.e).addModifiers(Modifier.PUBLIC,Modifier.FINAL);\n        builder.addAnnotation(OverrideCallSuper.class);\n        if (!method.isVoid()) {\n          if (method.name().equals(\"isNull\")) {\n            builder.addStatement(\"return true\");\n          }\n else           if (method.name().equals(\"id\")) {\n            builder.addStatement(\"return -1\");\n          }\n else {\n            Svar variable=compType == null || method.params().size > 0 ? null : compType.fields().find(v -> v.name().equals(method.name()));\n            String desc=variable == null ? null : variable.descString();\n            if (variable == null || !varInitializers.containsKey(desc)) {\n              builder.addStatement(\"return \" + getDefault(method.ret().toString()));\n            }\n else {\n              String init=varInitializers.get(desc);\n              builder.addStatement(\"return \" + (init.equals(\"{}\") ? \"new \" + variable.mirror().toString() : \"\") + init);\n            }\n          }\n        }\n        nullBuilder.addMethod(builder.build());\n        signatures.add(signature);\n      }\n      nullsBuilder.addField(FieldSpec.builder(type,Strings.camelize(baseName)).initializer(\"new \" + className + \"()\").addModifiers(Modifier.FINAL,Modifier.STATIC,Modifier.PUBLIC).build());\n      write(nullBuilder);\n    }\n    write(nullsBuilder);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 4464,
      "astHeight" : 24
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 40052,
        "startLineNumber" : 51,
        "startColumnNumber" : 4,
        "endLineNumber" : 814,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@Override public void process(RoundEnvironment env) throws Exception {\n  allGroups.addAll(elements(GroupDef.class));\n  allDefs.addAll(elements(EntityDef.class));\n  allInterfaces.addAll(types(EntityInterface.class));\n  if (round == 1) {\n    serializer=TypeIOResolver.resolve(this);\n    baseComponents=types(BaseComponent.class);\n    Seq<Stype> allComponents=types(Component.class);\n    for (    Stype component : allComponents) {\n      for (      Svar f : component.fields()) {\n        VariableTree tree=f.tree();\n        if (tree.getInitializer() != null) {\n          String init=tree.getInitializer().toString();\n          varInitializers.put(f.descString(),init);\n        }\n      }\n      for (      Smethod elem : component.methods()) {\n        if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE))         continue;\n        methodBlocks.put(elem.descString(),elem.tree().getBody().toString().replaceAll(\"this\\\\.<(.*)>self\\\\(\\\\)\",\"this\").replaceAll(\"self\\\\(\\\\)\",\"this\").replaceAll(\" yield \",\"\").replaceAll(\"\\\\/\\\\*missing\\\\*\\\\/\",\"var\"));\n      }\n    }\n    for (    Stype type : allComponents) {\n      componentNames.put(type.name(),type);\n    }\n    for (    Stype comp : allComponents) {\n      imports.addAll(getImports(comp.e));\n    }\n    for (    Stype component : allComponents) {\n      TypeSpec.Builder inter=TypeSpec.interfaceBuilder(interfaceName(component)).addModifiers(Modifier.PUBLIC).addAnnotation(EntityInterface.class);\n      inter.addJavadoc(\"Interface for {@link $L}\",component.fullName());\n      for (      Stype extraInterface : component.interfaces().select(i -> !isCompInterface(i))) {\n        inter.superinterfaces.add(tname(extraInterface.fullName()));\n      }\n      Seq<Stype> depends=getDependencies(component);\n      for (      Stype type : depends) {\n        inter.addSuperinterface(ClassName.get(packageName,interfaceName(type)));\n      }\n      ObjectSet<String> signatures=new ObjectSet<>();\n      for (      Smethod method : component.methods()) {\n        if (method.isAny(Modifier.PRIVATE,Modifier.STATIC))         continue;\n        signatures.add(method.e.toString());\n        inter.addMethod(MethodSpec.methodBuilder(method.name()).addJavadoc(method.doc() == null ? \"\" : method.doc()).addExceptions(method.thrownt()).addTypeVariables(method.typeVariables().map(TypeVariableName::get)).returns(method.ret().toString().equals(\"void\") ? TypeName.VOID : method.retn()).addParameters(method.params().map(v -> ParameterSpec.builder(v.tname(),v.name()).build())).addModifiers(Modifier.PUBLIC,Modifier.ABSTRACT).build());\n      }\n      for (      Svar field : component.fields().select(e -> !e.is(Modifier.STATIC) && !e.is(Modifier.PRIVATE) && !e.has(Import.class))) {\n        String cname=field.name();\n        if (!signatures.contains(cname + \"()\")) {\n          inter.addMethod(MethodSpec.methodBuilder(cname).addModifiers(Modifier.ABSTRACT,Modifier.PUBLIC).addAnnotations(Seq.with(field.annotations()).select(a -> a.toString().contains(\"Null\")).map(AnnotationSpec::get)).addJavadoc(field.doc() == null ? \"\" : field.doc()).returns(field.tname()).build());\n        }\n        if (!field.is(Modifier.FINAL) && !signatures.contains(cname + \"(\" + field.mirror().toString()+ \")\") && !field.annotations().contains(f -> f.toString().equals(\"@mindustry.annotations.Annotations.ReadOnly\"))) {\n          inter.addMethod(MethodSpec.methodBuilder(cname).addModifiers(Modifier.ABSTRACT,Modifier.PUBLIC).addJavadoc(field.doc() == null ? \"\" : field.doc()).addParameter(ParameterSpec.builder(field.tname(),field.name()).addAnnotations(Seq.with(field.annotations()).select(a -> a.toString().contains(\"Null\")).map(AnnotationSpec::get)).build()).build());\n        }\n      }\n      write(inter);\n      if (component.annotation(Component.class).base()) {\n        Seq<Stype> deps=depends.copy().and(component);\n        baseClassDeps.get(component,ObjectSet::new).addAll(deps);\n        if (!component.has(EntityDef.class)) {\n          TypeSpec.Builder base=TypeSpec.classBuilder(baseName(component)).addModifiers(Modifier.PUBLIC,Modifier.ABSTRACT);\n          for (          Stype type : deps) {\n            for (            Svar field : type.fields().select(e -> !e.is(Modifier.STATIC) && !e.is(Modifier.PRIVATE) && !e.has(Import.class)&& !e.has(ReadOnly.class))) {\n              FieldSpec.Builder builder=FieldSpec.builder(field.tname(),field.name(),Modifier.PUBLIC);\n              if (field.is(Modifier.TRANSIENT))               builder.addModifiers(Modifier.TRANSIENT);\n              builder.addAnnotations(field.annotations().map(AnnotationSpec::get));\n              if (varInitializers.containsKey(field.descString())) {\n                builder.initializer(varInitializers.get(field.descString()));\n              }\n              base.addField(builder.build());\n            }\n          }\n          for (          Stype type : deps) {\n            base.addSuperinterface(tname(packageName,interfaceName(type)));\n          }\n          baseClasses.add(base);\n        }\n      }\n      Log.debug(\"&gGenerating interface for \" + component.name());\n      for (      TypeName tn : inter.superinterfaces) {\n        Log.debug(\"&g> &lbimplements @\",simpleName(tn.toString()));\n      }\n      for (      MethodSpec spec : inter.methodSpecs) {\n        Log.debug(\"&g> > &c@ @(@)\",simpleName(spec.returnType.toString()),spec.name,Seq.with(spec.parameters).toString(\", \",p -> simpleName(p.type.toString()) + \" \" + p.name));\n      }\n      Log.debug(\"\");\n    }\n  }\n else   if (round == 2) {\n    for (    Selement<?> group : allGroups) {\n      GroupDef an=group.annotation(GroupDef.class);\n      Seq<Stype> types=types(an,GroupDef::value).map(stype -> {\n        Stype result=interfaceToComp(stype);\n        if (result == null)         throw new IllegalArgumentException(\"Interface \" + stype + \" does not have an associated component!\");\n        return result;\n      }\n);\n      Stype repr=types.first();\n      String groupType=repr.annotation(Component.class).base() ? baseName(repr) : interfaceName(repr);\n      boolean collides=an.collide();\n      groupDefs.add(new GroupDefinition(group.name().startsWith(\"g\") ? group.name().substring(1) : group.name(),ClassName.bestGuess(packageName + \".\" + groupType),types,an.spatial(),an.mapping(),collides));\n    }\n    ObjectMap<String,Selement> usedNames=new ObjectMap<>();\n    ObjectMap<Selement,ObjectSet<String>> extraNames=new ObjectMap<>();\n    for (    Selement<?> type : allDefs) {\n      EntityDef ann=type.annotation(EntityDef.class);\n      Seq<Stype> components=allComponents(type);\n      Seq<GroupDefinition> groups=groupDefs.select(g -> (!g.components.isEmpty() && !g.components.contains(s -> !components.contains(s))) || g.manualInclusions.contains(type));\n      ObjectMap<String,Seq<Smethod>> methods=new ObjectMap<>();\n      ObjectMap<FieldSpec,Svar> specVariables=new ObjectMap<>();\n      ObjectSet<String> usedFields=new ObjectSet<>();\n      Seq<Stype> baseClasses=components.select(s -> s.annotation(Component.class).base());\n      if (baseClasses.size > 2) {\n        err(\"No entity may have more than 2 base classes. Base classes: \" + baseClasses,type);\n      }\n      Stype baseClassType=baseClasses.any() ? baseClasses.first() : null;\n      @Nullable TypeName baseClass=baseClasses.any() ? tname(packageName + \".\" + baseName(baseClassType)) : null;\n      boolean typeIsBase=baseClassType != null && type.has(Component.class) && type.annotation(Component.class).base();\n      if (type.isType() && (!type.name().endsWith(\"Def\") && !type.name().endsWith(\"Comp\"))) {\n        err(\"All entity def names must end with 'Def'/'Comp'\",type.e);\n      }\n      String name=type.isType() ? type.name().replace(\"Def\",\"\").replace(\"Comp\",\"\") : createName(type);\n      if (!typeIsBase && baseClass != null && name.equals(baseName(baseClassType))) {\n        name+=\"Entity\";\n      }\n      if (ann.legacy()) {\n        name+=\"Legacy\" + Strings.capitalize(type.name());\n      }\n      if (usedNames.containsKey(name)) {\n        extraNames.get(usedNames.get(name),ObjectSet::new).add(type.name());\n        continue;\n      }\n      usedNames.put(name,type);\n      extraNames.get(type,ObjectSet::new).add(name);\n      if (!type.isType()) {\n        extraNames.get(type,ObjectSet::new).add(type.name());\n      }\n      TypeSpec.Builder builder=TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC);\n      builder.addMethod(MethodSpec.methodBuilder(\"serialize\").addModifiers(Modifier.PUBLIC).returns(boolean.class).addStatement(\"return \" + ann.serialize()).build());\n      Seq<Svar> syncedFields=new Seq<>();\n      Seq<Svar> allFields=new Seq<>();\n      Seq<FieldSpec> allFieldSpecs=new Seq<>();\n      boolean isSync=components.contains(s -> s.name().contains(\"Sync\"));\n      for (      Stype comp : components) {\n        boolean isShadowed=baseClass != null && !typeIsBase && baseClassDeps.get(baseClassType).contains(comp);\n        Seq<Svar> fields=comp.fields().select(f -> !f.has(Import.class));\n        for (        Svar f : fields) {\n          if (!usedFields.add(f.name())) {\n            err(\"Field '\" + f.name() + \"' of component '\"+ comp.name()+ \"' redefines a field in entity '\"+ type.name()+ \"'\");\n            continue;\n          }\n          FieldSpec.Builder fbuilder=FieldSpec.builder(f.tname(),f.name());\n          if (f.is(Modifier.STATIC)) {\n            fbuilder.addModifiers(Modifier.STATIC);\n            if (f.is(Modifier.FINAL))             fbuilder.addModifiers(Modifier.FINAL);\n          }\n          if (f.is(Modifier.TRANSIENT)) {\n            fbuilder.addModifiers(Modifier.TRANSIENT);\n          }\n          if (varInitializers.containsKey(f.descString())) {\n            fbuilder.initializer(varInitializers.get(f.descString()));\n          }\n          fbuilder.addModifiers(f.has(ReadOnly.class) ? Modifier.PROTECTED : Modifier.PUBLIC);\n          fbuilder.addAnnotations(f.annotations().map(AnnotationSpec::get));\n          FieldSpec spec=fbuilder.build();\n          boolean isVisible=!f.is(Modifier.STATIC) && !f.is(Modifier.PRIVATE) && !f.has(ReadOnly.class);\n          if (!isShadowed || !isVisible) {\n            builder.addField(spec);\n          }\n          specVariables.put(spec,f);\n          allFieldSpecs.add(spec);\n          allFields.add(f);\n          if (f.has(SyncField.class) && isSync) {\n            if (!f.tname().toString().equals(\"float\"))             err(\"All SyncFields must be of type float\",f);\n            syncedFields.add(f);\n            builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.targetSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n            builder.addField(FieldSpec.builder(float.class,f.name() + EntityIO.lastSuf).addModifiers(Modifier.TRANSIENT,Modifier.PRIVATE).build());\n          }\n        }\n        for (        Smethod elem : comp.methods()) {\n          methods.get(elem.toString(),Seq::new).add(elem);\n        }\n      }\n      syncedFields.sortComparing(Selement::name);\n      builder.addMethod(MethodSpec.methodBuilder(\"toString\").addAnnotation(Override.class).returns(String.class).addModifiers(Modifier.PUBLIC).addStatement(\"return $S + $L\",name + \"#\",\"id\").build());\n      EntityIO io=new EntityIO(type.name(),builder,allFieldSpecs,serializer,rootDirectory.child(\"annotations/src/main/resources/revisions\").child(type.name()));\n      boolean hasIO=ann.genio() && (components.contains(s -> s.name().contains(\"Sync\")) || ann.serialize());\n      for (      ObjectMap.Entry<String,Seq<Smethod>> entry : methods) {\n        if (entry.value.contains(m -> m.has(Replace.class))) {\n          if (entry.value.count(m -> m.has(Replace.class)) > 1) {\n            err(\"Type \" + type + \" has multiple components replacing method \"+ entry.key+ \".\");\n          }\n          Smethod base=entry.value.find(m -> m.has(Replace.class));\n          entry.value.clear();\n          entry.value.add(base);\n        }\n        if (entry.value.count(m -> !m.isAny(Modifier.NATIVE,Modifier.ABSTRACT) && !m.isVoid()) > 1) {\n          err(\"Type \" + type + \" has multiple components implementing non-void method \"+ entry.key+ \".\");\n        }\n        entry.value.sort(Structs.comps(Structs.comparingFloat(m -> m.has(MethodPriority.class) ? m.annotation(MethodPriority.class).value() : 0),Structs.comparing(Selement::name)));\n        Smethod first=entry.value.first();\n        if (first.has(InternalImpl.class)) {\n          continue;\n        }\n        MethodSpec.Builder mbuilder=MethodSpec.methodBuilder(first.name()).addModifiers(first.is(Modifier.PRIVATE) ? Modifier.PRIVATE : Modifier.PUBLIC);\n        if (entry.value.contains(s -> s.has(CallSuper.class)))         mbuilder.addAnnotation(CallSuper.class);\n        if (first.is(Modifier.STATIC))         mbuilder.addModifiers(Modifier.STATIC);\n        mbuilder.addTypeVariables(first.typeVariables().map(TypeVariableName::get));\n        mbuilder.returns(first.retn());\n        mbuilder.addExceptions(first.thrownt());\n        for (        Svar var : first.params()) {\n          mbuilder.addParameter(var.tname(),var.name());\n        }\n        boolean writeBlock=first.ret().toString().equals(\"void\") && entry.value.size > 1;\n        if ((entry.value.first().is(Modifier.ABSTRACT) || entry.value.first().is(Modifier.NATIVE)) && entry.value.size == 1 && !entry.value.first().has(InternalImpl.class)) {\n          err(entry.value.first().up().getSimpleName() + \"#\" + entry.value.first()+ \" is an abstract method and must be implemented in some component\",type);\n        }\n        if (first.name().equals(\"add\") || first.name().equals(\"remove\")) {\n          mbuilder.addStatement(\"if(added == $L) return\",first.name().equals(\"add\"));\n          for (          GroupDefinition def : groups) {\n            mbuilder.addStatement(\"Groups.$L.$L(this)\",def.name,first.name());\n          }\n        }\n        if (hasIO) {\n          if ((first.name().equals(\"read\") || first.name().equals(\"write\"))) {\n            io.write(mbuilder,first.name().equals(\"write\"));\n          }\n          if ((first.name().equals(\"readSync\") || first.name().equals(\"writeSync\"))) {\n            io.writeSync(mbuilder,first.name().equals(\"writeSync\"),syncedFields,allFields);\n          }\n          if ((first.name().equals(\"readSyncManual\") || first.name().equals(\"writeSyncManual\"))) {\n            io.writeSyncManual(mbuilder,first.name().equals(\"writeSyncManual\"),syncedFields);\n          }\n          if (first.name().equals(\"interpolate\")) {\n            io.writeInterpolate(mbuilder,syncedFields);\n          }\n          if (first.name().equals(\"snapSync\")) {\n            mbuilder.addStatement(\"updateSpacing = 16\");\n            mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n            for (            Svar field : syncedFields) {\n              mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name() + EntityIO.targetSuf);\n              mbuilder.addStatement(\"$L = $L\",field.name(),field.name() + EntityIO.targetSuf);\n            }\n          }\n          if (first.name().equals(\"snapInterpolation\")) {\n            mbuilder.addStatement(\"updateSpacing = 16\");\n            mbuilder.addStatement(\"lastUpdated = $T.millis()\",Time.class);\n            for (            Svar field : syncedFields) {\n              mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.lastSuf,field.name());\n              mbuilder.addStatement(\"$L = $L\",field.name() + EntityIO.targetSuf,field.name());\n            }\n          }\n        }\n        for (        Smethod elem : entry.value) {\n          String descStr=elem.descString();\n          if (elem.is(Modifier.ABSTRACT) || elem.is(Modifier.NATIVE) || !methodBlocks.containsKey(descStr))           continue;\n          String str=methodBlocks.get(descStr);\n          String blockName=elem.up().getSimpleName().toString().toLowerCase().replace(\"comp\",\"\");\n          if (str.replace(\"{\",\"\").replace(\"\\n\",\"\").replace(\"}\",\"\").replace(\"\\t\",\"\").replace(\" \",\"\").isEmpty()) {\n            continue;\n          }\n          if (writeBlock) {\n            str=str.replace(\"return;\",\"break \" + blockName + \";\");\n            mbuilder.addCode(blockName + \": {\\n\");\n          }\n          str=str.substring(2,str.length() - 1);\n          mbuilder.addCode(str);\n          if (writeBlock)           mbuilder.addCode(\"}\\n\");\n        }\n        if (first.name().equals(\"remove\") && ann.pooled()) {\n          mbuilder.addStatement(\"mindustry.gen.Groups.queueFree(($T)this)\",Poolable.class);\n        }\n        builder.addMethod(mbuilder.build());\n      }\n      if (ann.pooled()) {\n        builder.addSuperinterface(Poolable.class);\n        MethodSpec.Builder resetBuilder=MethodSpec.methodBuilder(\"reset\").addModifiers(Modifier.PUBLIC);\n        for (        FieldSpec spec : allFieldSpecs) {\n          @Nullable Svar variable=specVariables.get(spec);\n          if (variable != null && variable.isAny(Modifier.STATIC,Modifier.FINAL))           continue;\n          String desc=variable.descString();\n          if (spec.type.isPrimitive()) {\n            resetBuilder.addStatement(\"$L = $L\",spec.name,variable != null && varInitializers.containsKey(desc) ? varInitializers.get(desc) : getDefault(spec.type.toString()));\n          }\n else {\n            if (!varInitializers.containsKey(desc)) {\n              resetBuilder.addStatement(\"$L = null\",spec.name);\n            }\n          }\n        }\n        builder.addMethod(resetBuilder.build());\n      }\n      builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PROTECTED).build());\n      builder.addMethod(MethodSpec.methodBuilder(\"create\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(tname(packageName + \".\" + name)).addStatement(ann.pooled() ? \"return Pools.obtain($L.class, \" + name + \"::new)\" : \"return new $L()\",name).build());\n      definitions.add(new EntityDefinition(packageName + \".\" + name,builder,type,typeIsBase ? null : baseClass,components,groups,allFieldSpecs));\n    }\n    TypeSpec.Builder groupsBuilder=TypeSpec.classBuilder(\"Groups\").addModifiers(Modifier.PUBLIC);\n    MethodSpec.Builder groupInit=MethodSpec.methodBuilder(\"init\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n    for (    GroupDefinition group : groupDefs) {\n      ClassName itype=group.baseType;\n      ClassName groupc=ClassName.bestGuess(\"mindustry.entities.EntityGroup\");\n      groupsBuilder.addField(ParameterizedTypeName.get(ClassName.bestGuess(\"mindustry.entities.EntityGroup\"),itype),group.name,Modifier.PUBLIC,Modifier.STATIC);\n      groupInit.addStatement(\"$L = new $T<>($L.class, $L, $L)\",group.name,groupc,itype,group.spatial,group.mapping);\n    }\n    groupsBuilder.addMethod(groupInit.build());\n    MethodSpec.Builder groupClear=MethodSpec.methodBuilder(\"clear\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n    for (    GroupDefinition group : groupDefs) {\n      groupClear.addStatement(\"$L.clear()\",group.name);\n    }\n    groupsBuilder.addMethod(groupClear.build());\n    groupsBuilder.addField(FieldSpec.builder(ParameterizedTypeName.get(Seq.class,Poolable.class),\"freeQueue\",Modifier.PRIVATE,Modifier.STATIC).initializer(\"new Seq<>()\").build());\n    MethodSpec.Builder groupFreeQueue=MethodSpec.methodBuilder(\"queueFree\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).addParameter(Poolable.class,\"obj\").addStatement(\"freeQueue.add(obj)\");\n    groupsBuilder.addMethod(groupFreeQueue.build());\n    MethodSpec.Builder groupResize=MethodSpec.methodBuilder(\"resize\").addParameter(TypeName.FLOAT,\"x\").addParameter(TypeName.FLOAT,\"y\").addParameter(TypeName.FLOAT,\"w\").addParameter(TypeName.FLOAT,\"h\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n    MethodSpec.Builder groupUpdate=MethodSpec.methodBuilder(\"update\").addModifiers(Modifier.PUBLIC,Modifier.STATIC);\n    groupUpdate.addStatement(\"for($T p : freeQueue) $T.free(p)\",Poolable.class,Pools.class).addStatement(\"freeQueue.clear()\");\n    for (    GroupDefinition group : groupDefs) {\n      if (group.spatial) {\n        groupResize.addStatement(\"$L.resize(x, y, w, h)\",group.name);\n        groupUpdate.addStatement(\"$L.updatePhysics()\",group.name);\n      }\n    }\n    groupUpdate.addStatement(\"all.update()\");\n    for (    GroupDefinition group : groupDefs) {\n      if (group.collides) {\n        groupUpdate.addStatement(\"$L.collide()\",group.name);\n      }\n    }\n    groupsBuilder.addMethod(groupResize.build());\n    groupsBuilder.addMethod(groupUpdate.build());\n    write(groupsBuilder);\n    StringMap map=new StringMap();\n    Fi idProps=rootDirectory.child(\"annotations/src/main/resources/classids.properties\");\n    if (!idProps.exists())     idProps.writeString(\"\");\n    PropertiesUtils.load(map,idProps.reader());\n    Integer max=map.values().toSeq().map(Integer::parseInt).max(i -> i);\n    int maxID=max == null ? 0 : max + 1;\n    definitions.sort(Structs.comparing(t -> t.naming.toString()));\n    for (    EntityDefinition def : definitions) {\n      String name=def.naming.fullName();\n      if (map.containsKey(name)) {\n        def.classID=map.getInt(name);\n      }\n else {\n        def.classID=maxID++;\n        map.put(name,def.classID + \"\");\n      }\n    }\n    OrderedMap<String,String> res=new OrderedMap<>();\n    res.putAll(map);\n    res.orderedKeys().sort();\n    PropertiesUtils.store(res,idProps.writer(false),\"Maps entity names to IDs. Autogenerated.\");\n    TypeSpec.Builder idBuilder=TypeSpec.classBuilder(\"EntityMapping\").addModifiers(Modifier.PUBLIC).addField(FieldSpec.builder(TypeName.get(Prov[].class),\"idMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new Prov[256]\").build()).addField(FieldSpec.builder(ParameterizedTypeName.get(ClassName.get(ObjectMap.class),tname(String.class),tname(Prov.class)),\"nameMap\",Modifier.PUBLIC,Modifier.STATIC).initializer(\"new ObjectMap<>()\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(int.class,\"id\").addStatement(\"return idMap[id]\").build()).addMethod(MethodSpec.methodBuilder(\"map\").addModifiers(Modifier.PUBLIC,Modifier.STATIC).returns(TypeName.get(Prov.class)).addParameter(String.class,\"name\").addStatement(\"return nameMap.get(name)\").build());\n    CodeBlock.Builder idStore=CodeBlock.builder();\n    for (    EntityDefinition def : definitions) {\n      idStore.addStatement(\"idMap[$L] = $L::new\",def.classID,def.name);\n      extraNames.get(def.naming).each(extra -> {\n        idStore.addStatement(\"nameMap.put($S, $L::new)\",extra,def.name);\n        if (!Strings.camelToKebab(extra).equals(extra)) {\n          idStore.addStatement(\"nameMap.put($S, $L::new)\",Strings.camelToKebab(extra),def.name);\n        }\n      }\n);\n      def.builder.addMethod(MethodSpec.methodBuilder(\"classId\").addAnnotation(Override.class).returns(int.class).addModifiers(Modifier.PUBLIC).addStatement(\"return \" + def.classID).build());\n    }\n    idBuilder.addStaticBlock(idStore.build());\n    write(idBuilder);\n  }\n else {\n    for (    TypeSpec.Builder b : baseClasses) {\n      write(b,imports.asArray());\n    }\n    for (    EntityDefinition def : definitions) {\n      ObjectSet<String> methodNames=def.components.flatMap(type -> type.methods().map(Smethod::simpleString)).<String>as().asSet();\n      if (def.extend != null) {\n        def.builder.superclass(def.extend);\n      }\n      for (      Stype comp : def.components) {\n        Stype inter=allInterfaces.find(i -> i.name().equals(interfaceName(comp)));\n        if (inter == null) {\n          err(\"Failed to generate interface for\",comp);\n          return;\n        }\n        def.builder.addSuperinterface(inter.tname());\n        for (        Smethod method : inter.methods()) {\n          String var=method.name();\n          FieldSpec field=Seq.with(def.fieldSpecs).find(f -> f.name.equals(var));\n          if (field == null || methodNames.contains(method.simpleString()))           continue;\n          if (!method.isVoid()) {\n            def.builder.addMethod(MethodSpec.overriding(method.e).addStatement(\"return \" + var).build());\n          }\n          if (method.isVoid() && !Seq.with(field.annotations).contains(f -> f.type.toString().equals(\"@mindustry.annotations.Annotations.ReadOnly\"))) {\n            def.builder.addMethod(MethodSpec.overriding(method.e).addStatement(\"this.\" + var + \" = \"+ var).build());\n          }\n        }\n      }\n      write(def.builder,imports.asArray());\n    }\n    TypeSpec.Builder nullsBuilder=TypeSpec.classBuilder(\"Nulls\").addModifiers(Modifier.PUBLIC).addModifiers(Modifier.FINAL);\n    for (    Stype interf : allInterfaces) {\n      Seq<Stype> dependencies=interf.allInterfaces().and(interf);\n      Seq<Smethod> methods=dependencies.flatMap(Stype::methods);\n      methods.sortComparing(Object::toString);\n      Stype superclass=dependencies.map(this::interfaceToComp).find(s -> s != null && s.annotation(Component.class).base());\n      TypeName type=superclass != null && interfaceToComp(interf).annotation(Component.class).base() ? tname(baseName(superclass)) : interf.tname();\n      ObjectSet<String> signatures=new ObjectSet<>();\n      String baseName=interf.name().substring(0,interf.name().length() - 1);\n      String className=\"Null\" + baseName;\n      TypeSpec.Builder nullBuilder=TypeSpec.classBuilder(className).addModifiers(Modifier.FINAL);\n      nullBuilder.addSuperinterface(interf.tname());\n      if (superclass != null)       nullBuilder.superclass(tname(baseName(superclass)));\n      for (      Smethod method : methods) {\n        String signature=method.toString();\n        if (signatures.contains(signature))         continue;\n        Stype compType=interfaceToComp(method.type());\n        MethodSpec.Builder builder=MethodSpec.overriding(method.e).addModifiers(Modifier.PUBLIC,Modifier.FINAL);\n        builder.addAnnotation(OverrideCallSuper.class);\n        if (!method.isVoid()) {\n          if (method.name().equals(\"isNull\")) {\n            builder.addStatement(\"return true\");\n          }\n else           if (method.name().equals(\"id\")) {\n            builder.addStatement(\"return -1\");\n          }\n else {\n            Svar variable=compType == null || method.params().size > 0 ? null : compType.fields().find(v -> v.name().equals(method.name()));\n            String desc=variable == null ? null : variable.descString();\n            if (variable == null || !varInitializers.containsKey(desc)) {\n              builder.addStatement(\"return \" + getDefault(method.ret().toString()));\n            }\n else {\n              String init=varInitializers.get(desc);\n              builder.addStatement(\"return \" + (init.equals(\"{}\") ? \"new \" + variable.mirror().toString() : \"\") + init);\n            }\n          }\n        }\n        nullBuilder.addMethod(builder.build());\n        signatures.add(signature);\n      }\n      nullsBuilder.addField(FieldSpec.builder(type,Strings.camelize(baseName)).initializer(\"new \" + className + \"()\").addModifiers(Modifier.FINAL,Modifier.STATIC,Modifier.PUBLIC).build());\n      write(nullBuilder);\n    }\n    write(nullsBuilder);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 4476,
      "astHeight" : 25
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 519,
        "startColumnNumber" : 24,
        "endLineNumber" : 519,
        "endColumnNumber" : 63
      },
      "nodeContext" : "if (writeBlock) mbuilder.addCode(\"}\\n\");\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  } ],
  "positionList" : [ {
    "charLength" : 5,
    "startLineNumber" : 519,
    "startColumnNumber" : 56,
    "endLineNumber" : 519,
    "endColumnNumber" : 61
  } ],
  "layoutRelationDataList" : [ ]
}