{
  "id" : 452,
  "expression" : "1",
  "projectName" : "libgdx@libgdx",
  "commitID" : "3485b16e8979c0141421bc80cb8831b7a0403f67",
  "filePath" : "/gdx/src/com/badlogic/gdx/math/DelaunayTriangulator.java",
  "occurrences" : 19,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 76,
      "startColumnNumber" : 40,
      "endLineNumber" : 76,
      "endColumnNumber" : 41
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 9,
        "startLineNumber" : 76,
        "startColumnNumber" : 33,
        "endLineNumber" : 76,
        "endColumnNumber" : 42
      },
      "nodeContext" : "points[1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 16,
        "startLineNumber" : 76,
        "startColumnNumber" : 26,
        "endLineNumber" : 76,
        "endColumnNumber" : 42
      },
      "nodeContext" : "ymin=points[1]",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 76,
        "startColumnNumber" : 2,
        "endLineNumber" : 76,
        "endColumnNumber" : 43
      },
      "nodeContext" : "float xmin=points[0], ymin=points[1];\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 76,
        "startColumnNumber" : 2,
        "endLineNumber" : 76,
        "endColumnNumber" : 43
      },
      "nodeContext" : "float xmin=points[0], ymin=points[1];\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 12,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 94,
      "startColumnNumber" : 16,
      "endLineNumber" : 94,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,leftHandSide]",
      "nodePosition" : {
        "charLength" : 16,
        "startLineNumber" : 94,
        "startColumnNumber" : 2,
        "endLineNumber" : 94,
        "endColumnNumber" : 18
      },
      "nodeContext" : "superTriangle[1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 30,
        "startLineNumber" : 94,
        "startColumnNumber" : 2,
        "endLineNumber" : 94,
        "endColumnNumber" : 32
      },
      "nodeContext" : "superTriangle[1]=ymid - dmax",
      "nodeType" : "Assignment",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 94,
        "startColumnNumber" : 2,
        "endLineNumber" : 94,
        "endColumnNumber" : 33
      },
      "nodeContext" : "superTriangle[1]=ymid - dmax;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 94,
        "startColumnNumber" : 2,
        "endLineNumber" : 94,
        "endColumnNumber" : 33
      },
      "nodeContext" : "superTriangle[1]=ymid - dmax;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 115,
      "startColumnNumber" : 57,
      "endLineNumber" : 115,
      "endColumnNumber" : 58
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 115,
        "startColumnNumber" : 44,
        "endLineNumber" : 115,
        "endColumnNumber" : 58
      },
      "nodeContext" : "pointIndex + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 115,
        "startColumnNumber" : 37,
        "endLineNumber" : 115,
        "endColumnNumber" : 59
      },
      "nodeContext" : "points[pointIndex + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 115,
        "startColumnNumber" : 33,
        "endLineNumber" : 115,
        "endColumnNumber" : 59
      },
      "nodeContext" : "y=points[pointIndex + 1]",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 115,
        "startColumnNumber" : 3,
        "endLineNumber" : 115,
        "endColumnNumber" : 60
      },
      "nodeContext" : "float x=points[pointIndex], y=points[pointIndex + 1];\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 115,
        "startColumnNumber" : 3,
        "endLineNumber" : 115,
        "endColumnNumber" : 60
      },
      "nodeContext" : "float x=points[pointIndex], y=points[pointIndex + 1];\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 120,
      "startColumnNumber" : 45,
      "endLineNumber" : 120,
      "endColumnNumber" : 46
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 120,
        "startColumnNumber" : 28,
        "endLineNumber" : 120,
        "endColumnNumber" : 46
      },
      "nodeContext" : "triangles.size - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationExpression,fragments]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 120,
        "startColumnNumber" : 12,
        "endLineNumber" : 120,
        "endColumnNumber" : 46
      },
      "nodeContext" : "triangleIndex=triangles.size - 1",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 120,
        "startColumnNumber" : 8,
        "endLineNumber" : 120,
        "endColumnNumber" : 46
      },
      "nodeContext" : "int triangleIndex=triangles.size - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1239,
        "startLineNumber" : 120,
        "startColumnNumber" : 3,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 241,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 120,
        "startColumnNumber" : 8,
        "endLineNumber" : 120,
        "endColumnNumber" : 46
      },
      "nodeContext" : "int triangleIndex=triangles.size - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 124,
      "startColumnNumber" : 44,
      "endLineNumber" : 124,
      "endColumnNumber" : 45
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 124,
        "startColumnNumber" : 28,
        "endLineNumber" : 124,
        "endColumnNumber" : 45
      },
      "nodeContext" : "triangleIndex - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 124,
        "startColumnNumber" : 13,
        "endLineNumber" : 124,
        "endColumnNumber" : 46
      },
      "nodeContext" : "trianglesArray[triangleIndex - 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 124,
        "startColumnNumber" : 8,
        "endLineNumber" : 124,
        "endColumnNumber" : 46
      },
      "nodeContext" : "p2=trianglesArray[triangleIndex - 1]",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 124,
        "endColumnNumber" : 47
      },
      "nodeContext" : "int p2=trianglesArray[triangleIndex - 1];\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1154,
        "startLineNumber" : 120,
        "startColumnNumber" : 88,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 225,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1239,
        "startLineNumber" : 120,
        "startColumnNumber" : 3,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 241,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 124,
        "endColumnNumber" : 47
      },
      "nodeContext" : "int p2=trianglesArray[triangleIndex - 1];\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 130,
      "startColumnNumber" : 28,
      "endLineNumber" : 130,
      "endColumnNumber" : 29
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 5,
        "startLineNumber" : 130,
        "startColumnNumber" : 24,
        "endLineNumber" : 130,
        "endColumnNumber" : 29
      },
      "nodeContext" : "i + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 130,
        "startColumnNumber" : 10,
        "endLineNumber" : 130,
        "endColumnNumber" : 30
      },
      "nodeContext" : "superTriangle[i + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 130,
        "startColumnNumber" : 5,
        "endLineNumber" : 130,
        "endColumnNumber" : 30
      },
      "nodeContext" : "y1=superTriangle[i + 1]",
      "nodeType" : "Assignment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 130,
        "startColumnNumber" : 5,
        "endLineNumber" : 130,
        "endColumnNumber" : 31
      },
      "nodeContext" : "y1=superTriangle[i + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 94,
        "startLineNumber" : 127,
        "startColumnNumber" : 19,
        "endLineNumber" : 131,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int i=p1 - end;\n  x1=superTriangle[i];\n  y1=superTriangle[i + 1];\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 22,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 127,
        "startColumnNumber" : 4,
        "endLineNumber" : 134,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (p1 >= end) {\n  int i=p1 - end;\n  x1=superTriangle[i];\n  y1=superTriangle[i + 1];\n}\n else {\n  x1=points[p1];\n  y1=points[p1 + 1];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1154,
        "startLineNumber" : 120,
        "startColumnNumber" : 88,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 225,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1239,
        "startLineNumber" : 120,
        "startColumnNumber" : 3,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 241,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 130,
        "startColumnNumber" : 5,
        "endLineNumber" : 130,
        "endColumnNumber" : 31
      },
      "nodeContext" : "y1=superTriangle[i + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 133,
      "startColumnNumber" : 22,
      "endLineNumber" : 133,
      "endColumnNumber" : 23
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 133,
        "startColumnNumber" : 17,
        "endLineNumber" : 133,
        "endColumnNumber" : 23
      },
      "nodeContext" : "p1 + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 133,
        "startColumnNumber" : 10,
        "endLineNumber" : 133,
        "endColumnNumber" : 24
      },
      "nodeContext" : "points[p1 + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 133,
        "startColumnNumber" : 5,
        "endLineNumber" : 133,
        "endColumnNumber" : 24
      },
      "nodeContext" : "y1=points[p1 + 1]",
      "nodeType" : "Assignment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 133,
        "startColumnNumber" : 5,
        "endLineNumber" : 133,
        "endColumnNumber" : 25
      },
      "nodeContext" : "y1=points[p1 + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 131,
        "startColumnNumber" : 11,
        "endLineNumber" : 134,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  x1=points[p1];\n  y1=points[p1 + 1];\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 127,
        "startColumnNumber" : 4,
        "endLineNumber" : 134,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (p1 >= end) {\n  int i=p1 - end;\n  x1=superTriangle[i];\n  y1=superTriangle[i + 1];\n}\n else {\n  x1=points[p1];\n  y1=points[p1 + 1];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1154,
        "startLineNumber" : 120,
        "startColumnNumber" : 88,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 225,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1239,
        "startLineNumber" : 120,
        "startColumnNumber" : 3,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 241,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 133,
        "startColumnNumber" : 5,
        "endLineNumber" : 133,
        "endColumnNumber" : 25
      },
      "nodeContext" : "y1=points[p1 + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 138,
      "startColumnNumber" : 28,
      "endLineNumber" : 138,
      "endColumnNumber" : 29
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 5,
        "startLineNumber" : 138,
        "startColumnNumber" : 24,
        "endLineNumber" : 138,
        "endColumnNumber" : 29
      },
      "nodeContext" : "i + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 138,
        "startColumnNumber" : 10,
        "endLineNumber" : 138,
        "endColumnNumber" : 30
      },
      "nodeContext" : "superTriangle[i + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 138,
        "startColumnNumber" : 5,
        "endLineNumber" : 138,
        "endColumnNumber" : 30
      },
      "nodeContext" : "y2=superTriangle[i + 1]",
      "nodeType" : "Assignment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 138,
        "startColumnNumber" : 5,
        "endLineNumber" : 138,
        "endColumnNumber" : 31
      },
      "nodeContext" : "y2=superTriangle[i + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 94,
        "startLineNumber" : 135,
        "startColumnNumber" : 19,
        "endLineNumber" : 139,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int i=p2 - end;\n  x2=superTriangle[i];\n  y2=superTriangle[i + 1];\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 22,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 135,
        "startColumnNumber" : 4,
        "endLineNumber" : 142,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (p2 >= end) {\n  int i=p2 - end;\n  x2=superTriangle[i];\n  y2=superTriangle[i + 1];\n}\n else {\n  x2=points[p2];\n  y2=points[p2 + 1];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1154,
        "startLineNumber" : 120,
        "startColumnNumber" : 88,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 225,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1239,
        "startLineNumber" : 120,
        "startColumnNumber" : 3,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 241,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 138,
        "startColumnNumber" : 5,
        "endLineNumber" : 138,
        "endColumnNumber" : 31
      },
      "nodeContext" : "y2=superTriangle[i + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 141,
      "startColumnNumber" : 22,
      "endLineNumber" : 141,
      "endColumnNumber" : 23
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 141,
        "startColumnNumber" : 17,
        "endLineNumber" : 141,
        "endColumnNumber" : 23
      },
      "nodeContext" : "p2 + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 141,
        "startColumnNumber" : 10,
        "endLineNumber" : 141,
        "endColumnNumber" : 24
      },
      "nodeContext" : "points[p2 + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 141,
        "startColumnNumber" : 5,
        "endLineNumber" : 141,
        "endColumnNumber" : 24
      },
      "nodeContext" : "y2=points[p2 + 1]",
      "nodeType" : "Assignment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 141,
        "startColumnNumber" : 5,
        "endLineNumber" : 141,
        "endColumnNumber" : 25
      },
      "nodeContext" : "y2=points[p2 + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 139,
        "startColumnNumber" : 11,
        "endLineNumber" : 142,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  x2=points[p2];\n  y2=points[p2 + 1];\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 135,
        "startColumnNumber" : 4,
        "endLineNumber" : 142,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (p2 >= end) {\n  int i=p2 - end;\n  x2=superTriangle[i];\n  y2=superTriangle[i + 1];\n}\n else {\n  x2=points[p2];\n  y2=points[p2 + 1];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1154,
        "startLineNumber" : 120,
        "startColumnNumber" : 88,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 225,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1239,
        "startLineNumber" : 120,
        "startColumnNumber" : 3,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 241,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 141,
        "startColumnNumber" : 5,
        "endLineNumber" : 141,
        "endColumnNumber" : 25
      },
      "nodeContext" : "y2=points[p2 + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 146,
      "startColumnNumber" : 28,
      "endLineNumber" : 146,
      "endColumnNumber" : 29
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 5,
        "startLineNumber" : 146,
        "startColumnNumber" : 24,
        "endLineNumber" : 146,
        "endColumnNumber" : 29
      },
      "nodeContext" : "i + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 146,
        "startColumnNumber" : 10,
        "endLineNumber" : 146,
        "endColumnNumber" : 30
      },
      "nodeContext" : "superTriangle[i + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 146,
        "startColumnNumber" : 5,
        "endLineNumber" : 146,
        "endColumnNumber" : 30
      },
      "nodeContext" : "y3=superTriangle[i + 1]",
      "nodeType" : "Assignment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 146,
        "startColumnNumber" : 5,
        "endLineNumber" : 146,
        "endColumnNumber" : 31
      },
      "nodeContext" : "y3=superTriangle[i + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 94,
        "startLineNumber" : 143,
        "startColumnNumber" : 19,
        "endLineNumber" : 147,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int i=p3 - end;\n  x3=superTriangle[i];\n  y3=superTriangle[i + 1];\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 22,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 143,
        "startColumnNumber" : 4,
        "endLineNumber" : 150,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (p3 >= end) {\n  int i=p3 - end;\n  x3=superTriangle[i];\n  y3=superTriangle[i + 1];\n}\n else {\n  x3=points[p3];\n  y3=points[p3 + 1];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1154,
        "startLineNumber" : 120,
        "startColumnNumber" : 88,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 225,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1239,
        "startLineNumber" : 120,
        "startColumnNumber" : 3,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 241,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 146,
        "startColumnNumber" : 5,
        "endLineNumber" : 146,
        "endColumnNumber" : 31
      },
      "nodeContext" : "y3=superTriangle[i + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 149,
      "startColumnNumber" : 22,
      "endLineNumber" : 149,
      "endColumnNumber" : 23
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 149,
        "startColumnNumber" : 17,
        "endLineNumber" : 149,
        "endColumnNumber" : 23
      },
      "nodeContext" : "p3 + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 14,
        "startLineNumber" : 149,
        "startColumnNumber" : 10,
        "endLineNumber" : 149,
        "endColumnNumber" : 24
      },
      "nodeContext" : "points[p3 + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 149,
        "startColumnNumber" : 5,
        "endLineNumber" : 149,
        "endColumnNumber" : 24
      },
      "nodeContext" : "y3=points[p3 + 1]",
      "nodeType" : "Assignment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 149,
        "startColumnNumber" : 5,
        "endLineNumber" : 149,
        "endColumnNumber" : 25
      },
      "nodeContext" : "y3=points[p3 + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 147,
        "startColumnNumber" : 11,
        "endLineNumber" : 150,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  x3=points[p3];\n  y3=points[p3 + 1];\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 173,
        "startLineNumber" : 143,
        "startColumnNumber" : 4,
        "endLineNumber" : 150,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (p3 >= end) {\n  int i=p3 - end;\n  x3=superTriangle[i];\n  y3=superTriangle[i + 1];\n}\n else {\n  x3=points[p3];\n  y3=points[p3 + 1];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 1154,
        "startLineNumber" : 120,
        "startColumnNumber" : 88,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 225,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1239,
        "startLineNumber" : 120,
        "startColumnNumber" : 3,
        "endLineNumber" : 163,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n  int completeIndex=triangleIndex / 3;\n  if (completeArray[completeIndex])   continue;\n  int p1=trianglesArray[triangleIndex - 2];\n  int p2=trianglesArray[triangleIndex - 1];\n  int p3=trianglesArray[triangleIndex];\n  float x1, y1, x2, y2, x3, y3;\n  if (p1 >= end) {\n    int i=p1 - end;\n    x1=superTriangle[i];\n    y1=superTriangle[i + 1];\n  }\n else {\n    x1=points[p1];\n    y1=points[p1 + 1];\n  }\n  if (p2 >= end) {\n    int i=p2 - end;\n    x2=superTriangle[i];\n    y2=superTriangle[i + 1];\n  }\n else {\n    x2=points[p2];\n    y2=points[p2 + 1];\n  }\n  if (p3 >= end) {\n    int i=p3 - end;\n    x3=superTriangle[i];\n    y3=superTriangle[i + 1];\n  }\n else {\n    x3=points[p3];\n    y3=points[p3 + 1];\n  }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:    completeArray[completeIndex]=true;\n  break;\ncase INSIDE:edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 241,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 149,
        "startColumnNumber" : 5,
        "endLineNumber" : 149,
        "endColumnNumber" : 25
      },
      "nodeContext" : "y3=points[p3 + 1];\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 169,
      "startColumnNumber" : 15,
      "endLineNumber" : 169,
      "endColumnNumber" : 16
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 2,
        "startLineNumber" : 169,
        "startColumnNumber" : 14,
        "endLineNumber" : 169,
        "endColumnNumber" : 16
      },
      "nodeContext" : "-1",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 2,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 8,
        "startLineNumber" : 169,
        "startColumnNumber" : 8,
        "endLineNumber" : 169,
        "endColumnNumber" : 16
      },
      "nodeContext" : "p1 == -1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 23,
        "startLineNumber" : 169,
        "startColumnNumber" : 4,
        "endLineNumber" : 169,
        "endColumnNumber" : 27
      },
      "nodeContext" : "if (p1 == -1) continue;\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 656,
        "startLineNumber" : 166,
        "startColumnNumber" : 50,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 96,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 703,
        "startLineNumber" : 166,
        "startColumnNumber" : 3,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int i=0, n=edges.size; i < n; i+=2) {\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 113,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 23,
        "startLineNumber" : 169,
        "startColumnNumber" : 4,
        "endLineNumber" : 169,
        "endColumnNumber" : 27
      },
      "nodeContext" : "if (p1 == -1) continue;\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 170,
      "startColumnNumber" : 28,
      "endLineNumber" : 170,
      "endColumnNumber" : 29
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 5,
        "startLineNumber" : 170,
        "startColumnNumber" : 24,
        "endLineNumber" : 170,
        "endColumnNumber" : 29
      },
      "nodeContext" : "i + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 170,
        "startColumnNumber" : 13,
        "endLineNumber" : 170,
        "endColumnNumber" : 30
      },
      "nodeContext" : "edgesArray[i + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 170,
        "startColumnNumber" : 8,
        "endLineNumber" : 170,
        "endColumnNumber" : 30
      },
      "nodeContext" : "p2=edgesArray[i + 1]",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 27,
        "startLineNumber" : 170,
        "startColumnNumber" : 4,
        "endLineNumber" : 170,
        "endColumnNumber" : 31
      },
      "nodeContext" : "int p2=edgesArray[i + 1];\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 656,
        "startLineNumber" : 166,
        "startColumnNumber" : 50,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 96,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 703,
        "startLineNumber" : 166,
        "startColumnNumber" : 3,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int i=0, n=edges.size; i < n; i+=2) {\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 113,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 27,
        "startLineNumber" : 170,
        "startColumnNumber" : 4,
        "endLineNumber" : 170,
        "endColumnNumber" : 31
      },
      "nodeContext" : "int p2=edgesArray[i + 1];\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 173,
      "startColumnNumber" : 31,
      "endLineNumber" : 173,
      "endColumnNumber" : 32
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 173,
        "startColumnNumber" : 26,
        "endLineNumber" : 173,
        "endColumnNumber" : 32
      },
      "nodeContext" : "ii + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 173,
        "startColumnNumber" : 15,
        "endLineNumber" : 173,
        "endColumnNumber" : 33
      },
      "nodeContext" : "edgesArray[ii + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 24,
        "startLineNumber" : 173,
        "startColumnNumber" : 9,
        "endLineNumber" : 173,
        "endColumnNumber" : 33
      },
      "nodeContext" : "p1 == edgesArray[ii + 1]",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 173,
        "startColumnNumber" : 9,
        "endLineNumber" : 173,
        "endColumnNumber" : 57
      },
      "nodeContext" : "p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 111,
        "startLineNumber" : 173,
        "startColumnNumber" : 5,
        "endLineNumber" : 176,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n  skip=true;\n  edgesArray[ii]=-1;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 26,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 126,
        "startLineNumber" : 172,
        "startColumnNumber" : 42,
        "endLineNumber" : 177,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n    skip=true;\n    edgesArray[ii]=-1;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 27,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 164,
        "startLineNumber" : 172,
        "startColumnNumber" : 4,
        "endLineNumber" : 177,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (int ii=i + 2; ii < n; ii+=2) {\n  if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n    skip=true;\n    edgesArray[ii]=-1;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 656,
        "startLineNumber" : 166,
        "startColumnNumber" : 50,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 96,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 703,
        "startLineNumber" : 166,
        "startColumnNumber" : 3,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int i=0, n=edges.size; i < n; i+=2) {\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 113,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 173,
        "startColumnNumber" : 9,
        "endLineNumber" : 173,
        "endColumnNumber" : 57
      },
      "nodeContext" : "p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 175,
      "startColumnNumber" : 24,
      "endLineNumber" : 175,
      "endColumnNumber" : 25
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 2,
        "startLineNumber" : 175,
        "startColumnNumber" : 23,
        "endLineNumber" : 175,
        "endColumnNumber" : 25
      },
      "nodeContext" : "-1",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 2,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 175,
        "startColumnNumber" : 6,
        "endLineNumber" : 175,
        "endColumnNumber" : 25
      },
      "nodeContext" : "edgesArray[ii]=-1",
      "nodeType" : "Assignment",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 175,
        "startColumnNumber" : 6,
        "endLineNumber" : 175,
        "endColumnNumber" : 26
      },
      "nodeContext" : "edgesArray[ii]=-1;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 173,
        "startColumnNumber" : 59,
        "endLineNumber" : 176,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  skip=true;\n  edgesArray[ii]=-1;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 111,
        "startLineNumber" : 173,
        "startColumnNumber" : 5,
        "endLineNumber" : 176,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n  skip=true;\n  edgesArray[ii]=-1;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 26,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 126,
        "startLineNumber" : 172,
        "startColumnNumber" : 42,
        "endLineNumber" : 177,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n    skip=true;\n    edgesArray[ii]=-1;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 27,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 164,
        "startLineNumber" : 172,
        "startColumnNumber" : 4,
        "endLineNumber" : 177,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (int ii=i + 2; ii < n; ii+=2) {\n  if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n    skip=true;\n    edgesArray[ii]=-1;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 656,
        "startLineNumber" : 166,
        "startColumnNumber" : 50,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 96,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 703,
        "startLineNumber" : 166,
        "startColumnNumber" : 3,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int i=0, n=edges.size; i < n; i+=2) {\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 113,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 175,
        "startColumnNumber" : 6,
        "endLineNumber" : 175,
        "endColumnNumber" : 26
      },
      "nodeContext" : "edgesArray[ii]=-1;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 182,
      "startColumnNumber" : 33,
      "endLineNumber" : 182,
      "endColumnNumber" : 34
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 5,
        "startLineNumber" : 182,
        "startColumnNumber" : 29,
        "endLineNumber" : 182,
        "endColumnNumber" : 34
      },
      "nodeContext" : "i + 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 182,
        "startColumnNumber" : 18,
        "endLineNumber" : 182,
        "endColumnNumber" : 35
      },
      "nodeContext" : "edgesArray[i + 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 182,
        "startColumnNumber" : 4,
        "endLineNumber" : 182,
        "endColumnNumber" : 36
      },
      "nodeContext" : "triangles.add(edgesArray[i + 1])",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 182,
        "startColumnNumber" : 4,
        "endLineNumber" : 182,
        "endColumnNumber" : 37
      },
      "nodeContext" : "triangles.add(edgesArray[i + 1]);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 656,
        "startLineNumber" : 166,
        "startColumnNumber" : 50,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 96,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 703,
        "startLineNumber" : 166,
        "startColumnNumber" : 3,
        "endLineNumber" : 185,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int i=0, n=edges.size; i < n; i+=2) {\n  int p1=edgesArray[i];\n  if (p1 == -1)   continue;\n  int p2=edgesArray[i + 1];\n  boolean skip=false;\n  for (int ii=i + 2; ii < n; ii+=2) {\n    if (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\n      skip=true;\n      edgesArray[ii]=-1;\n    }\n  }\n  if (skip)   continue;\n  triangles.add(p1);\n  triangles.add(edgesArray[i + 1]);\n  triangles.add(pointIndex);\n  complete.add(false);\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 113,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2276,
        "startLineNumber" : 114,
        "startColumnNumber" : 67,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 400,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2341,
        "startLineNumber" : 114,
        "startColumnNumber" : 2,
        "endLineNumber" : 187,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n  float x=points[pointIndex], y=points[pointIndex + 1];\n  short[] trianglesArray=triangles.items;\n  boolean[] completeArray=complete.items;\n  for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n    int completeIndex=triangleIndex / 3;\n    if (completeArray[completeIndex])     continue;\n    int p1=trianglesArray[triangleIndex - 2];\n    int p2=trianglesArray[triangleIndex - 1];\n    int p3=trianglesArray[triangleIndex];\n    float x1, y1, x2, y2, x3, y3;\n    if (p1 >= end) {\n      int i=p1 - end;\n      x1=superTriangle[i];\n      y1=superTriangle[i + 1];\n    }\n else {\n      x1=points[p1];\n      y1=points[p1 + 1];\n    }\n    if (p2 >= end) {\n      int i=p2 - end;\n      x2=superTriangle[i];\n      y2=superTriangle[i + 1];\n    }\n else {\n      x2=points[p2];\n      y2=points[p2 + 1];\n    }\n    if (p3 >= end) {\n      int i=p3 - end;\n      x3=superTriangle[i];\n      y3=superTriangle[i + 1];\n    }\n else {\n      x3=points[p3];\n      y3=points[p3 + 1];\n    }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:      completeArray[completeIndex]=true;\n    break;\ncase INSIDE:  edges.add(p1,p2,p2,p3);\nedges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 412,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 182,
        "startColumnNumber" : 4,
        "endLineNumber" : 182,
        "endColumnNumber" : 37
      },
      "nodeContext" : "triangles.add(edgesArray[i + 1]);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 191,
      "startColumnNumber" : 32,
      "endLineNumber" : 191,
      "endColumnNumber" : 33
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 18,
        "startLineNumber" : 191,
        "startColumnNumber" : 15,
        "endLineNumber" : 191,
        "endColumnNumber" : 33
      },
      "nodeContext" : "triangles.size - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationExpression,fragments]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 191,
        "startColumnNumber" : 11,
        "endLineNumber" : 191,
        "endColumnNumber" : 33
      },
      "nodeContext" : "i=triangles.size - 1",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 191,
        "startColumnNumber" : 7,
        "endLineNumber" : 191,
        "endColumnNumber" : 33
      },
      "nodeContext" : "int i=triangles.size - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 262,
        "startLineNumber" : 191,
        "startColumnNumber" : 2,
        "endLineNumber" : 197,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int i=triangles.size - 1; i >= 0; i-=3) {\n  if (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\n    triangles.removeIndex(i);\n    triangles.removeIndex(i - 1);\n    triangles.removeIndex(i - 2);\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 59,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 191,
        "startColumnNumber" : 7,
        "endLineNumber" : 191,
        "endColumnNumber" : 33
      },
      "nodeContext" : "int i=triangles.size - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 192,
      "startColumnNumber" : 54,
      "endLineNumber" : 192,
      "endColumnNumber" : 55
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayAccess,index]",
      "nodePosition" : {
        "charLength" : 5,
        "startLineNumber" : 192,
        "startColumnNumber" : 50,
        "endLineNumber" : 192,
        "endColumnNumber" : 55
      },
      "nodeContext" : "i - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 192,
        "startColumnNumber" : 35,
        "endLineNumber" : 192,
        "endColumnNumber" : 56
      },
      "nodeContext" : "trianglesArray[i - 1]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 192,
        "startColumnNumber" : 35,
        "endLineNumber" : 192,
        "endColumnNumber" : 63
      },
      "nodeContext" : "trianglesArray[i - 1] >= end",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 192,
        "startColumnNumber" : 7,
        "endLineNumber" : 192,
        "endColumnNumber" : 63
      },
      "nodeContext" : "trianglesArray[i] >= end || trianglesArray[i - 1] >= end",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 192,
        "startColumnNumber" : 7,
        "endLineNumber" : 192,
        "endColumnNumber" : 95
      },
      "nodeContext" : "trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 21,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 202,
        "startLineNumber" : 192,
        "startColumnNumber" : 3,
        "endLineNumber" : 196,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\n  triangles.removeIndex(i);\n  triangles.removeIndex(i - 1);\n  triangles.removeIndex(i - 2);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 42,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 213,
        "startLineNumber" : 191,
        "startColumnNumber" : 51,
        "endLineNumber" : 197,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\n    triangles.removeIndex(i);\n    triangles.removeIndex(i - 1);\n    triangles.removeIndex(i - 2);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 43,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 262,
        "startLineNumber" : 191,
        "startColumnNumber" : 2,
        "endLineNumber" : 197,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int i=triangles.size - 1; i >= 0; i-=3) {\n  if (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\n    triangles.removeIndex(i);\n    triangles.removeIndex(i - 1);\n    triangles.removeIndex(i - 2);\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 59,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 192,
        "startColumnNumber" : 7,
        "endLineNumber" : 192,
        "endColumnNumber" : 95
      },
      "nodeContext" : "trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 21,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "1",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 194,
      "startColumnNumber" : 30,
      "endLineNumber" : 194,
      "endColumnNumber" : 31
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 5,
        "startLineNumber" : 194,
        "startColumnNumber" : 26,
        "endLineNumber" : 194,
        "endColumnNumber" : 31
      },
      "nodeContext" : "i - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 194,
        "startColumnNumber" : 4,
        "endLineNumber" : 194,
        "endColumnNumber" : 32
      },
      "nodeContext" : "triangles.removeIndex(i - 1)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 194,
        "startColumnNumber" : 4,
        "endLineNumber" : 194,
        "endColumnNumber" : 33
      },
      "nodeContext" : "triangles.removeIndex(i - 1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 108,
        "startLineNumber" : 192,
        "startColumnNumber" : 97,
        "endLineNumber" : 196,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  triangles.removeIndex(i);\n  triangles.removeIndex(i - 1);\n  triangles.removeIndex(i - 2);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 20,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 202,
        "startLineNumber" : 192,
        "startColumnNumber" : 3,
        "endLineNumber" : 196,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\n  triangles.removeIndex(i);\n  triangles.removeIndex(i - 1);\n  triangles.removeIndex(i - 2);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 42,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 213,
        "startLineNumber" : 191,
        "startColumnNumber" : 51,
        "endLineNumber" : 197,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\n    triangles.removeIndex(i);\n    triangles.removeIndex(i - 1);\n    triangles.removeIndex(i - 2);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 43,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 262,
        "startLineNumber" : 191,
        "startColumnNumber" : 2,
        "endLineNumber" : 197,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int i=triangles.size - 1; i >= 0; i-=3) {\n  if (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\n    triangles.removeIndex(i);\n    triangles.removeIndex(i - 1);\n    triangles.removeIndex(i - 2);\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 59,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5071,
        "startLineNumber" : 58,
        "startColumnNumber" : 92,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 917,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5859,
        "startLineNumber" : 51,
        "startColumnNumber" : 1,
        "endLineNumber" : 216,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Triangulates the given point cloud to a list of triangle indices that make up the Delaunay triangulation.\n * @param points x,y pairs describing points. Duplicate points will result in undefined behavior.\n * @param sorted If false, the points will be sorted by the x coordinate, which is required by the triangulation algorithm. Ifsorting is done the input array is not modified, the returned indices are for the input array, and count*2 additional working memory is needed.\n * @return triples of indices into the points that describe the triangles in clockwise order. Note the returned array is reusedfor later calls to the same method. \n */\npublic ShortArray computeTriangles(float[] points,int offset,int count,boolean sorted){\n  if (count > 32767)   throw new IllegalArgumentException(\"count must be <= \" + 32767);\n  ShortArray triangles=this.triangles;\n  triangles.clear();\n  if (count < 6)   return triangles;\n  triangles.ensureCapacity(count);\n  if (!sorted) {\n    if (sortedPoints == null || sortedPoints.length < count)     sortedPoints=new float[count];\n    System.arraycopy(points,offset,sortedPoints,0,count);\n    points=sortedPoints;\n    offset=0;\n    sort(points,count);\n  }\n  int end=offset + count;\n  float xmin=points[0], ymin=points[1];\n  float xmax=xmin, ymax=ymin;\n  for (int i=offset + 2; i < end; i++) {\n    float value=points[i];\n    if (value < xmin)     xmin=value;\n    if (value > xmax)     xmax=value;\n    i++;\n    value=points[i];\n    if (value < ymin)     ymin=value;\n    if (value > ymax)     ymax=value;\n  }\n  float dx=xmax - xmin, dy=ymax - ymin;\n  float dmax=(dx > dy ? dx : dy) * 20f;\n  float xmid=(xmax + xmin) / 2f, ymid=(ymax + ymin) / 2f;\n  float[] superTriangle=this.superTriangle;\n  superTriangle[0]=xmid - dmax;\n  superTriangle[1]=ymid - dmax;\n  superTriangle[2]=xmid;\n  superTriangle[3]=ymid + dmax;\n  superTriangle[4]=xmid + dmax;\n  superTriangle[5]=ymid - dmax;\n  IntArray edges=this.edges;\n  edges.ensureCapacity(count / 2);\n  BooleanArray complete=this.complete;\n  complete.clear();\n  complete.ensureCapacity(count);\n  triangles.add(end);\n  triangles.add(end + 2);\n  triangles.add(end + 4);\n  complete.add(false);\n  for (int pointIndex=offset; pointIndex < end; pointIndex+=2) {\n    float x=points[pointIndex], y=points[pointIndex + 1];\n    short[] trianglesArray=triangles.items;\n    boolean[] completeArray=complete.items;\n    for (int triangleIndex=triangles.size - 1; triangleIndex >= 0; triangleIndex-=3) {\n      int completeIndex=triangleIndex / 3;\n      if (completeArray[completeIndex])       continue;\n      int p1=trianglesArray[triangleIndex - 2];\n      int p2=trianglesArray[triangleIndex - 1];\n      int p3=trianglesArray[triangleIndex];\n      float x1, y1, x2, y2, x3, y3;\n      if (p1 >= end) {\n        int i=p1 - end;\n        x1=superTriangle[i];\n        y1=superTriangle[i + 1];\n      }\n else {\n        x1=points[p1];\n        y1=points[p1 + 1];\n      }\n      if (p2 >= end) {\n        int i=p2 - end;\n        x2=superTriangle[i];\n        y2=superTriangle[i + 1];\n      }\n else {\n        x2=points[p2];\n        y2=points[p2 + 1];\n      }\n      if (p3 >= end) {\n        int i=p3 - end;\n        x3=superTriangle[i];\n        y3=superTriangle[i + 1];\n      }\n else {\n        x3=points[p3];\n        y3=points[p3 + 1];\n      }\nswitch (circumCircle(x,y,x1,y1,x2,y2,x3,y3)) {\ncase COMPLETE:        completeArray[completeIndex]=true;\n      break;\ncase INSIDE:    edges.add(p1,p2,p2,p3);\n  edges.add(p3,p1);\ntriangles.removeRange(triangleIndex - 2,triangleIndex);\ncomplete.removeIndex(completeIndex);\nbreak;\n}\n}\nint[] edgesArray=edges.items;\nfor (int i=0, n=edges.size; i < n; i+=2) {\nint p1=edgesArray[i];\nif (p1 == -1) continue;\nint p2=edgesArray[i + 1];\nboolean skip=false;\nfor (int ii=i + 2; ii < n; ii+=2) {\nif (p1 == edgesArray[ii + 1] && p2 == edgesArray[ii]) {\nskip=true;\nedgesArray[ii]=-1;\n}\n}\nif (skip) continue;\ntriangles.add(p1);\ntriangles.add(edgesArray[i + 1]);\ntriangles.add(pointIndex);\ncomplete.add(false);\n}\nedges.clear();\n}\nshort[] trianglesArray=triangles.items;\nfor (int i=triangles.size - 1; i >= 0; i-=3) {\nif (trianglesArray[i] >= end || trianglesArray[i - 1] >= end || trianglesArray[i - 2] >= end) {\ntriangles.removeIndex(i);\ntriangles.removeIndex(i - 1);\ntriangles.removeIndex(i - 2);\n}\n}\nif (!sorted) {\nshort[] originalIndicesArray=originalIndices.items;\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(originalIndicesArray[trianglesArray[i] / 2] * 2);\n}\nif (offset == 0) {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)(trianglesArray[i] / 2);\n}\n else {\nfor (int i=0, n=triangles.size; i < n; i++) trianglesArray[i]=(short)((trianglesArray[i] - offset) / 2);\n}\nreturn triangles;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 937,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 194,
        "startColumnNumber" : 4,
        "endLineNumber" : 194,
        "endColumnNumber" : 33
      },
      "nodeContext" : "triangles.removeIndex(i - 1);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 1,
    "startLineNumber" : 76,
    "startColumnNumber" : 40,
    "endLineNumber" : 76,
    "endColumnNumber" : 41
  }, {
    "charLength" : 1,
    "startLineNumber" : 94,
    "startColumnNumber" : 16,
    "endLineNumber" : 94,
    "endColumnNumber" : 17
  }, {
    "charLength" : 1,
    "startLineNumber" : 115,
    "startColumnNumber" : 57,
    "endLineNumber" : 115,
    "endColumnNumber" : 58
  }, {
    "charLength" : 1,
    "startLineNumber" : 120,
    "startColumnNumber" : 45,
    "endLineNumber" : 120,
    "endColumnNumber" : 46
  }, {
    "charLength" : 1,
    "startLineNumber" : 124,
    "startColumnNumber" : 44,
    "endLineNumber" : 124,
    "endColumnNumber" : 45
  }, {
    "charLength" : 1,
    "startLineNumber" : 130,
    "startColumnNumber" : 28,
    "endLineNumber" : 130,
    "endColumnNumber" : 29
  }, {
    "charLength" : 1,
    "startLineNumber" : 133,
    "startColumnNumber" : 22,
    "endLineNumber" : 133,
    "endColumnNumber" : 23
  }, {
    "charLength" : 1,
    "startLineNumber" : 138,
    "startColumnNumber" : 28,
    "endLineNumber" : 138,
    "endColumnNumber" : 29
  }, {
    "charLength" : 1,
    "startLineNumber" : 141,
    "startColumnNumber" : 22,
    "endLineNumber" : 141,
    "endColumnNumber" : 23
  }, {
    "charLength" : 1,
    "startLineNumber" : 146,
    "startColumnNumber" : 28,
    "endLineNumber" : 146,
    "endColumnNumber" : 29
  }, {
    "charLength" : 1,
    "startLineNumber" : 149,
    "startColumnNumber" : 22,
    "endLineNumber" : 149,
    "endColumnNumber" : 23
  }, {
    "charLength" : 1,
    "startLineNumber" : 169,
    "startColumnNumber" : 15,
    "endLineNumber" : 169,
    "endColumnNumber" : 16
  }, {
    "charLength" : 1,
    "startLineNumber" : 170,
    "startColumnNumber" : 28,
    "endLineNumber" : 170,
    "endColumnNumber" : 29
  }, {
    "charLength" : 1,
    "startLineNumber" : 173,
    "startColumnNumber" : 31,
    "endLineNumber" : 173,
    "endColumnNumber" : 32
  }, {
    "charLength" : 1,
    "startLineNumber" : 175,
    "startColumnNumber" : 24,
    "endLineNumber" : 175,
    "endColumnNumber" : 25
  }, {
    "charLength" : 1,
    "startLineNumber" : 182,
    "startColumnNumber" : 33,
    "endLineNumber" : 182,
    "endColumnNumber" : 34
  }, {
    "charLength" : 1,
    "startLineNumber" : 191,
    "startColumnNumber" : 32,
    "endLineNumber" : 191,
    "endColumnNumber" : 33
  }, {
    "charLength" : 1,
    "startLineNumber" : 192,
    "startColumnNumber" : 54,
    "endLineNumber" : 192,
    "endColumnNumber" : 55
  }, {
    "charLength" : 1,
    "startLineNumber" : 194,
    "startColumnNumber" : 30,
    "endLineNumber" : 194,
    "endColumnNumber" : 31
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 14,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 15,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 16,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 17,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 18,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 14,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 15,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 16,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 17,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 18,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 17,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 18,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 14,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 15,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 16,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 17,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 18,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 16,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 17,
    "layout" : 10
  }, {
    "firstKey" : 5,
    "secondKey" : 18,
    "layout" : 10
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 16,
    "layout" : 10
  }, {
    "firstKey" : 6,
    "secondKey" : 17,
    "layout" : 10
  }, {
    "firstKey" : 6,
    "secondKey" : 18,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 16,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 17,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 18,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 16,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 17,
    "layout" : 10
  }, {
    "firstKey" : 8,
    "secondKey" : 18,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 16,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 17,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 18,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 10,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 10,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 10,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 10,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 10,
    "secondKey" : 16,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 17,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 18,
    "layout" : 10
  }, {
    "firstKey" : 11,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 14,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 15,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 17,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 18,
    "layout" : 7
  }, {
    "firstKey" : 12,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 12,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 12,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 12,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 12,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 12,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 12,
    "secondKey" : 16,
    "layout" : 8
  }, {
    "firstKey" : 12,
    "secondKey" : 17,
    "layout" : 8
  }, {
    "firstKey" : 12,
    "secondKey" : 18,
    "layout" : 8
  }, {
    "firstKey" : 13,
    "secondKey" : 0,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 1,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 13,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 16,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 17,
    "layout" : 11
  }, {
    "firstKey" : 13,
    "secondKey" : 18,
    "layout" : 11
  }, {
    "firstKey" : 14,
    "secondKey" : 0,
    "layout" : 11
  }, {
    "firstKey" : 14,
    "secondKey" : 1,
    "layout" : 11
  }, {
    "firstKey" : 14,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 14,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 14,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 14,
    "secondKey" : 16,
    "layout" : 11
  }, {
    "firstKey" : 14,
    "secondKey" : 17,
    "layout" : 11
  }, {
    "firstKey" : 14,
    "secondKey" : 18,
    "layout" : 11
  }, {
    "firstKey" : 15,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 15,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 15,
    "secondKey" : 16,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 17,
    "layout" : 8
  }, {
    "firstKey" : 15,
    "secondKey" : 18,
    "layout" : 8
  }, {
    "firstKey" : 16,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 14,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 15,
    "layout" : 4
  }, {
    "firstKey" : 16,
    "secondKey" : 17,
    "layout" : 3
  }, {
    "firstKey" : 16,
    "secondKey" : 18,
    "layout" : 3
  }, {
    "firstKey" : 17,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 14,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 15,
    "layout" : 8
  }, {
    "firstKey" : 17,
    "secondKey" : 16,
    "layout" : 7
  }, {
    "firstKey" : 17,
    "secondKey" : 18,
    "layout" : 5
  }, {
    "firstKey" : 18,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 14,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 15,
    "layout" : 7
  }, {
    "firstKey" : 18,
    "secondKey" : 16,
    "layout" : 6
  }, {
    "firstKey" : 18,
    "secondKey" : 17,
    "layout" : 4
  } ]
}