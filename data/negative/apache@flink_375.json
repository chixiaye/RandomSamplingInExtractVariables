{
  "id" : 375,
  "expression" : "ExceptionUtils.findThrowable(cause,PartitionException.class)",
  "projectName" : "apache@flink",
  "commitID" : "f8cb19e70ca7da6423dfb01b97e05c4d520c9fde",
  "filePath" : "/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/flip1/RestartPipelinedRegionFailoverStrategy.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "ExceptionUtils.findThrowable(cause,PartitionException.class)",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 61,
      "startLineNumber" : 129,
      "startColumnNumber" : 16,
      "endLineNumber" : 129,
      "endColumnNumber" : 77
    },
    "astNodeNumber" : 7,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 104,
        "startLineNumber" : 128,
        "startColumnNumber" : 37,
        "endLineNumber" : 129,
        "endColumnNumber" : 77
      },
      "nodeContext" : "dataConsumptionException=ExceptionUtils.findThrowable(cause,PartitionException.class)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 134,
        "startLineNumber" : 128,
        "startColumnNumber" : 8,
        "endLineNumber" : 129,
        "endColumnNumber" : 78
      },
      "nodeContext" : "Optional<PartitionException> dataConsumptionException=ExceptionUtils.findThrowable(cause,PartitionException.class);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 2130,
        "startLineNumber" : 114,
        "startColumnNumber" : 66,
        "endLineNumber" : 157,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  LOG.info(\"Calculating tasks to restart to recover the failed task {}.\",executionVertexId);\n  final SchedulingPipelinedRegion failedRegion=topology.getPipelinedRegionOfVertex(executionVertexId);\n  if (failedRegion == null) {\n    throw new IllegalStateException(\"Can not find the failover region for task \" + executionVertexId,cause);\n  }\n  Optional<PartitionException> dataConsumptionException=ExceptionUtils.findThrowable(cause,PartitionException.class);\n  if (dataConsumptionException.isPresent()) {\n    resultPartitionAvailabilityChecker.markResultPartitionFailed(dataConsumptionException.get().getPartitionId().getPartitionId());\n  }\n  Set<ExecutionVertexID> tasksToRestart=new HashSet<>();\n  for (  SchedulingPipelinedRegion region : getRegionsToRestart(failedRegion)) {\n    for (    SchedulingExecutionVertex vertex : region.getVertices()) {\n      if (vertex.getState() != ExecutionState.CREATED) {\n        tasksToRestart.add(vertex.getId());\n      }\n    }\n  }\n  if (dataConsumptionException.isPresent()) {\n    resultPartitionAvailabilityChecker.removeResultPartitionFromFailedState(dataConsumptionException.get().getPartitionId().getPartitionId());\n  }\n  LOG.info(\"{} tasks should be restarted to recover the failed task {}. \",tasksToRestart.size(),executionVertexId);\n  return tasksToRestart;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 134,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 2991,
        "startLineNumber" : 100,
        "startColumnNumber" : 4,
        "endLineNumber" : 157,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Returns a set of IDs corresponding to the set of vertices that should be restarted. In this strategy, all task vertices in 'involved' regions are proposed to be restarted. The 'involved' regions are calculated with rules below: 1. The region containing the failed task is always involved 2. If an input result partition of an involved region is not available, i.e. Missing or Corrupted, the region containing the partition producer task is involved 3. If a region is involved, all of its consumer regions are involved\n * @param executionVertexId ID of the failed task\n * @param cause cause of the failure\n * @return set of IDs of vertices to restart\n */\n@Override public Set<ExecutionVertexID> getTasksNeedingRestart(ExecutionVertexID executionVertexId,Throwable cause){\n  LOG.info(\"Calculating tasks to restart to recover the failed task {}.\",executionVertexId);\n  final SchedulingPipelinedRegion failedRegion=topology.getPipelinedRegionOfVertex(executionVertexId);\n  if (failedRegion == null) {\n    throw new IllegalStateException(\"Can not find the failover region for task \" + executionVertexId,cause);\n  }\n  Optional<PartitionException> dataConsumptionException=ExceptionUtils.findThrowable(cause,PartitionException.class);\n  if (dataConsumptionException.isPresent()) {\n    resultPartitionAvailabilityChecker.markResultPartitionFailed(dataConsumptionException.get().getPartitionId().getPartitionId());\n  }\n  Set<ExecutionVertexID> tasksToRestart=new HashSet<>();\n  for (  SchedulingPipelinedRegion region : getRegionsToRestart(failedRegion)) {\n    for (    SchedulingExecutionVertex vertex : region.getVertices()) {\n      if (vertex.getState() != ExecutionState.CREATED) {\n        tasksToRestart.add(vertex.getId());\n      }\n    }\n  }\n  if (dataConsumptionException.isPresent()) {\n    resultPartitionAvailabilityChecker.removeResultPartitionFromFailedState(dataConsumptionException.get().getPartitionId().getPartitionId());\n  }\n  LOG.info(\"{} tasks should be restarted to recover the failed task {}. \",tasksToRestart.size(),executionVertexId);\n  return tasksToRestart;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 153,
      "astHeight" : 12
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 104,
        "startLineNumber" : 128,
        "startColumnNumber" : 37,
        "endLineNumber" : 129,
        "endColumnNumber" : 77
      },
      "nodeContext" : "dataConsumptionException=ExceptionUtils.findThrowable(cause,PartitionException.class)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 4,
    "type" : "java.util.Optional<org.apache.flink.runtime.io.network.partition.PartitionException>"
  } ],
  "positionList" : [ {
    "charLength" : 61,
    "startLineNumber" : 129,
    "startColumnNumber" : 16,
    "endLineNumber" : 129,
    "endColumnNumber" : 77
  } ],
  "layoutRelationDataList" : [ ]
}