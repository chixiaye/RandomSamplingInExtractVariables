{
  "id" : 515,
  "expression" : "client",
  "projectName" : "alibaba@nacos",
  "commitID" : "4e7346db1d6657ffe07c96bebd2d348229c2812f",
  "filePath" : "core/src/main/java/com/alibaba/nacos/core/remote/ConnectionManager.java",
  "occurrences" : 11,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 310,
      "startColumnNumber" : 41,
      "endLineNumber" : 310,
      "endColumnNumber" : 47
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 310,
        "startColumnNumber" : 41,
        "endLineNumber" : 310,
        "endColumnNumber" : 61
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 310,
        "startColumnNumber" : 41,
        "endLineNumber" : 310,
        "endColumnNumber" : 74
      },
      "nodeContext" : "client.getMetaInfo().getAppName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 310,
        "startColumnNumber" : 31,
        "endLineNumber" : 310,
        "endColumnNumber" : 74
      },
      "nodeContext" : "appName=client.getMetaInfo().getAppName()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 310,
        "startColumnNumber" : 24,
        "endLineNumber" : 310,
        "endColumnNumber" : 75
      },
      "nodeContext" : "String appName=client.getMetaInfo().getAppName();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1545,
        "startLineNumber" : 307,
        "startColumnNumber" : 72,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 126,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1597,
        "startLineNumber" : 307,
        "startColumnNumber" : 20,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 139,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 310,
        "startColumnNumber" : 24,
        "endLineNumber" : 310,
        "endColumnNumber" : 75
      },
      "nodeContext" : "String appName=client.getMetaInfo().getAppName();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 311,
      "startColumnNumber" : 42,
      "endLineNumber" : 311,
      "endColumnNumber" : 48
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 311,
        "startColumnNumber" : 42,
        "endLineNumber" : 311,
        "endColumnNumber" : 62
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 311,
        "startColumnNumber" : 42,
        "endLineNumber" : 311,
        "endColumnNumber" : 76
      },
      "nodeContext" : "client.getMetaInfo().getClientIp()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 311,
        "startColumnNumber" : 31,
        "endLineNumber" : 311,
        "endColumnNumber" : 76
      },
      "nodeContext" : "clientIp=client.getMetaInfo().getClientIp()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 311,
        "startColumnNumber" : 24,
        "endLineNumber" : 311,
        "endColumnNumber" : 77
      },
      "nodeContext" : "String clientIp=client.getMetaInfo().getClientIp();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1545,
        "startLineNumber" : 307,
        "startColumnNumber" : 72,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 126,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1597,
        "startLineNumber" : 307,
        "startColumnNumber" : 20,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 139,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 311,
        "startColumnNumber" : 24,
        "endLineNumber" : 311,
        "endColumnNumber" : 77
      },
      "nodeContext" : "String clientIp=client.getMetaInfo().getClientIp();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 312,
      "startColumnNumber" : 28,
      "endLineNumber" : 312,
      "endColumnNumber" : 34
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 312,
        "startColumnNumber" : 28,
        "endLineNumber" : 312,
        "endColumnNumber" : 48
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 312,
        "startColumnNumber" : 28,
        "endLineNumber" : 312,
        "endColumnNumber" : 62
      },
      "nodeContext" : "client.getMetaInfo().isSdkSource()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 312,
        "startColumnNumber" : 28,
        "endLineNumber" : 312,
        "endColumnNumber" : 99
      },
      "nodeContext" : "client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1256,
        "startLineNumber" : 312,
        "startColumnNumber" : 24,
        "endLineNumber" : 329,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n  int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n  if (countLimitOfIp < 0) {\n    int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n    countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n  }\n  if (countLimitOfIp < 0) {\n    countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n  }\n  if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n    AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n    if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n      expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 97,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1545,
        "startLineNumber" : 307,
        "startColumnNumber" : 72,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 126,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1597,
        "startLineNumber" : 307,
        "startColumnNumber" : 20,
        "endLineNumber" : 330,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String appName=client.getMetaInfo().getAppName();\n  String clientIp=client.getMetaInfo().getClientIp();\n  if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n    int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n    if (countLimitOfIp < 0) {\n      int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n      countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n    }\n    if (countLimitOfIp < 0) {\n      countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n    }\n    if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n      AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n      if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n        expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n      }\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 139,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 312,
        "startColumnNumber" : 28,
        "endLineNumber" : 312,
        "endColumnNumber" : 99
      },
      "nodeContext" : "client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 344,
      "startColumnNumber" : 42,
      "endLineNumber" : 344,
      "endColumnNumber" : 48
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 344,
        "startColumnNumber" : 42,
        "endLineNumber" : 344,
        "endColumnNumber" : 62
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 344,
        "startColumnNumber" : 42,
        "endLineNumber" : 344,
        "endColumnNumber" : 76
      },
      "nodeContext" : "client.getMetaInfo().getClientIp()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 344,
        "startColumnNumber" : 31,
        "endLineNumber" : 344,
        "endColumnNumber" : 76
      },
      "nodeContext" : "clientIp=client.getMetaInfo().getClientIp()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 344,
        "startColumnNumber" : 24,
        "endLineNumber" : 344,
        "endColumnNumber" : 77
      },
      "nodeContext" : "String clientIp=client.getMetaInfo().getClientIp();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 740,
        "startLineNumber" : 342,
        "startColumnNumber" : 72,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 75,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 792,
        "startLineNumber" : 342,
        "startColumnNumber" : 20,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 88,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 344,
        "startColumnNumber" : 24,
        "endLineNumber" : 344,
        "endColumnNumber" : 77
      },
      "nodeContext" : "String clientIp=client.getMetaInfo().getClientIp();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 348,
      "startColumnNumber" : 44,
      "endLineNumber" : 348,
      "endColumnNumber" : 50
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 348,
        "startColumnNumber" : 44,
        "endLineNumber" : 348,
        "endColumnNumber" : 64
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 348,
        "startColumnNumber" : 44,
        "endLineNumber" : 348,
        "endColumnNumber" : 82
      },
      "nodeContext" : "client.getMetaInfo().getConnectionId()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 348,
        "startColumnNumber" : 28,
        "endLineNumber" : 348,
        "endColumnNumber" : 83
      },
      "nodeContext" : "expelClient.add(client.getMetaInfo().getConnectionId())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 348,
        "startColumnNumber" : 28,
        "endLineNumber" : 348,
        "endColumnNumber" : 84
      },
      "nodeContext" : "expelClient.add(client.getMetaInfo().getConnectionId());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 209,
        "startLineNumber" : 346,
        "startColumnNumber" : 71,
        "endLineNumber" : 350,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  integer.decrementAndGet();\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 453,
        "startLineNumber" : 346,
        "startColumnNumber" : 24,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (integer != null && integer.intValue() > 0) {\n  integer.decrementAndGet();\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n}\n else if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n  outDatedConnections.add(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 47,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 740,
        "startLineNumber" : 342,
        "startColumnNumber" : 72,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 75,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 792,
        "startLineNumber" : 342,
        "startColumnNumber" : 20,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 88,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 348,
        "startColumnNumber" : 28,
        "endLineNumber" : 348,
        "endColumnNumber" : 84
      },
      "nodeContext" : "expelClient.add(client.getMetaInfo().getConnectionId());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 350,
      "startColumnNumber" : 41,
      "endLineNumber" : 350,
      "endColumnNumber" : 47
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 350,
        "startColumnNumber" : 41,
        "endLineNumber" : 350,
        "endColumnNumber" : 61
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 350,
        "startColumnNumber" : 41,
        "endLineNumber" : 350,
        "endColumnNumber" : 81
      },
      "nodeContext" : "client.getMetaInfo().getLastActiveTime()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 350,
        "startColumnNumber" : 35,
        "endLineNumber" : 350,
        "endColumnNumber" : 81
      },
      "nodeContext" : "now - client.getMetaInfo().getLastActiveTime()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 65,
        "startLineNumber" : 350,
        "startColumnNumber" : 35,
        "endLineNumber" : 350,
        "endColumnNumber" : 100
      },
      "nodeContext" : "now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 191,
        "startLineNumber" : 350,
        "startColumnNumber" : 31,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n  outDatedConnections.add(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 20,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 453,
        "startLineNumber" : 346,
        "startColumnNumber" : 24,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (integer != null && integer.intValue() > 0) {\n  integer.decrementAndGet();\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n}\n else if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n  outDatedConnections.add(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 47,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 740,
        "startLineNumber" : 342,
        "startColumnNumber" : 72,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 75,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 792,
        "startLineNumber" : 342,
        "startColumnNumber" : 20,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 88,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 65,
        "startLineNumber" : 350,
        "startColumnNumber" : 35,
        "endLineNumber" : 350,
        "endColumnNumber" : 100
      },
      "nodeContext" : "now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 351,
      "startColumnNumber" : 52,
      "endLineNumber" : 351,
      "endColumnNumber" : 58
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 351,
        "startColumnNumber" : 52,
        "endLineNumber" : 351,
        "endColumnNumber" : 72
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 351,
        "startColumnNumber" : 52,
        "endLineNumber" : 351,
        "endColumnNumber" : 90
      },
      "nodeContext" : "client.getMetaInfo().getConnectionId()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 351,
        "startColumnNumber" : 28,
        "endLineNumber" : 351,
        "endColumnNumber" : 91
      },
      "nodeContext" : "outDatedConnections.add(client.getMetaInfo().getConnectionId())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 351,
        "startColumnNumber" : 28,
        "endLineNumber" : 351,
        "endColumnNumber" : 92
      },
      "nodeContext" : "outDatedConnections.add(client.getMetaInfo().getConnectionId());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 120,
        "startLineNumber" : 350,
        "startColumnNumber" : 102,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  outDatedConnections.add(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 10,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 191,
        "startLineNumber" : 350,
        "startColumnNumber" : 31,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n  outDatedConnections.add(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 20,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 453,
        "startLineNumber" : 346,
        "startColumnNumber" : 24,
        "endLineNumber" : 352,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (integer != null && integer.intValue() > 0) {\n  integer.decrementAndGet();\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n}\n else if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n  outDatedConnections.add(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 47,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 740,
        "startLineNumber" : 342,
        "startColumnNumber" : 72,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 75,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 792,
        "startLineNumber" : 342,
        "startColumnNumber" : 20,
        "endLineNumber" : 354,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  String clientIp=client.getMetaInfo().getClientIp();\n  AtomicInteger integer=expelForIp.get(clientIp);\n  if (integer != null && integer.intValue() > 0) {\n    integer.decrementAndGet();\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n  }\n else   if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n    outDatedConnections.add(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 88,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 64,
        "startLineNumber" : 351,
        "startColumnNumber" : 28,
        "endLineNumber" : 351,
        "endColumnNumber" : 92
      },
      "nodeContext" : "outDatedConnections.add(client.getMetaInfo().getConnectionId());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 360,
      "startColumnNumber" : 56,
      "endLineNumber" : 360,
      "endColumnNumber" : 62
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.FieldAccess,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 360,
        "startColumnNumber" : 56,
        "endLineNumber" : 360,
        "endColumnNumber" : 76
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 360,
        "startColumnNumber" : 56,
        "endLineNumber" : 360,
        "endColumnNumber" : 85
      },
      "nodeContext" : "client.getMetaInfo().clientIp",
      "nodeType" : "FieldAccess",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.PrefixExpression,operand]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 360,
        "startColumnNumber" : 33,
        "endLineNumber" : 360,
        "endColumnNumber" : 86
      },
      "nodeContext" : "expelForIp.containsKey(client.getMetaInfo().clientIp)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 360,
        "startColumnNumber" : 32,
        "endLineNumber" : 360,
        "endColumnNumber" : 86
      },
      "nodeContext" : "!expelForIp.containsKey(client.getMetaInfo().clientIp)",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 147,
        "startLineNumber" : 360,
        "startColumnNumber" : 32,
        "endLineNumber" : 361,
        "endColumnNumber" : 68
      },
      "nodeContext" : "!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 18,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 419,
        "startLineNumber" : 360,
        "startColumnNumber" : 28,
        "endLineNumber" : 365,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n  outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 541,
        "startLineNumber" : 358,
        "startColumnNumber" : 76,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 50,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 593,
        "startLineNumber" : 358,
        "startColumnNumber" : 24,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 63,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 641,
        "startLineNumber" : 357,
        "startColumnNumber" : 40,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 64,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 661,
        "startLineNumber" : 357,
        "startColumnNumber" : 20,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (expelCount > 0) {\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 360,
        "startColumnNumber" : 32,
        "endLineNumber" : 360,
        "endColumnNumber" : 86
      },
      "nodeContext" : "!expelForIp.containsKey(client.getMetaInfo().clientIp)",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 360,
      "startColumnNumber" : 90,
      "endLineNumber" : 360,
      "endColumnNumber" : 96
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 360,
        "startColumnNumber" : 90,
        "endLineNumber" : 360,
        "endColumnNumber" : 110
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 360,
        "startColumnNumber" : 90,
        "endLineNumber" : 361,
        "endColumnNumber" : 50
      },
      "nodeContext" : "client.getMetaInfo().isSdkSource()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 147,
        "startLineNumber" : 360,
        "startColumnNumber" : 32,
        "endLineNumber" : 361,
        "endColumnNumber" : 68
      },
      "nodeContext" : "!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 18,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 419,
        "startLineNumber" : 360,
        "startColumnNumber" : 28,
        "endLineNumber" : 365,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n  outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 541,
        "startLineNumber" : 358,
        "startColumnNumber" : 76,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 50,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 593,
        "startLineNumber" : 358,
        "startColumnNumber" : 24,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 63,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 641,
        "startLineNumber" : 357,
        "startColumnNumber" : 40,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 64,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 661,
        "startLineNumber" : 357,
        "startColumnNumber" : 20,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (expelCount > 0) {\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 360,
        "startColumnNumber" : 90,
        "endLineNumber" : 360,
        "endColumnNumber" : 110
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 362,
      "startColumnNumber" : 48,
      "endLineNumber" : 362,
      "endColumnNumber" : 54
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 362,
        "startColumnNumber" : 48,
        "endLineNumber" : 362,
        "endColumnNumber" : 68
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 362,
        "startColumnNumber" : 48,
        "endLineNumber" : 362,
        "endColumnNumber" : 86
      },
      "nodeContext" : "client.getMetaInfo().getConnectionId()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 362,
        "startColumnNumber" : 32,
        "endLineNumber" : 362,
        "endColumnNumber" : 87
      },
      "nodeContext" : "expelClient.add(client.getMetaInfo().getConnectionId())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 362,
        "startColumnNumber" : 32,
        "endLineNumber" : 362,
        "endColumnNumber" : 88
      },
      "nodeContext" : "expelClient.add(client.getMetaInfo().getConnectionId());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 266,
        "startLineNumber" : 361,
        "startColumnNumber" : 70,
        "endLineNumber" : 365,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n  outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 22,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 419,
        "startLineNumber" : 360,
        "startColumnNumber" : 28,
        "endLineNumber" : 365,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n  outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 541,
        "startLineNumber" : 358,
        "startColumnNumber" : 76,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 50,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 593,
        "startLineNumber" : 358,
        "startColumnNumber" : 24,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 63,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 641,
        "startLineNumber" : 357,
        "startColumnNumber" : 40,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 64,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 661,
        "startLineNumber" : 357,
        "startColumnNumber" : 20,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (expelCount > 0) {\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 362,
        "startColumnNumber" : 32,
        "endLineNumber" : 362,
        "endColumnNumber" : 88
      },
      "nodeContext" : "expelClient.add(client.getMetaInfo().getConnectionId());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  }, {
    "nodeContext" : "client",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 6,
      "startLineNumber" : 364,
      "startColumnNumber" : 59,
      "endLineNumber" : 364,
      "endColumnNumber" : 65
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 20,
        "startLineNumber" : 364,
        "startColumnNumber" : 59,
        "endLineNumber" : 364,
        "endColumnNumber" : 79
      },
      "nodeContext" : "client.getMetaInfo()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 364,
        "startColumnNumber" : 59,
        "endLineNumber" : 364,
        "endColumnNumber" : 97
      },
      "nodeContext" : "client.getMetaInfo().getConnectionId()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 66,
        "startLineNumber" : 364,
        "startColumnNumber" : 32,
        "endLineNumber" : 364,
        "endColumnNumber" : 98
      },
      "nodeContext" : "outDatedConnections.remove(client.getMetaInfo().getConnectionId())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 67,
        "startLineNumber" : 364,
        "startColumnNumber" : 32,
        "endLineNumber" : 364,
        "endColumnNumber" : 99
      },
      "nodeContext" : "outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 266,
        "startLineNumber" : 361,
        "startColumnNumber" : 70,
        "endLineNumber" : 365,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n  outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 22,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 419,
        "startLineNumber" : 360,
        "startColumnNumber" : 28,
        "endLineNumber" : 365,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n  expelClient.add(client.getMetaInfo().getConnectionId());\n  expelCount--;\n  outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 541,
        "startLineNumber" : 358,
        "startColumnNumber" : 76,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 50,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 593,
        "startLineNumber" : 358,
        "startColumnNumber" : 24,
        "endLineNumber" : 366,
        "endColumnNumber" : 25
      },
      "nodeContext" : "for (Map.Entry<String,Connection> entry : entries) {\n  Connection client=entry.getValue();\n  if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n    expelClient.add(client.getMetaInfo().getConnectionId());\n    expelCount--;\n    outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 63,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 641,
        "startLineNumber" : 357,
        "startColumnNumber" : 40,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 64,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 661,
        "startLineNumber" : 357,
        "startColumnNumber" : 20,
        "endLineNumber" : 367,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (expelCount > 0) {\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n      outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11231,
        "startLineNumber" : 286,
        "startColumnNumber" : 20,
        "endLineNumber" : 472,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 852,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11364,
        "startLineNumber" : 286,
        "startColumnNumber" : 16,
        "endLineNumber" : 474,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  int totalCount=connections.size();\n  Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n  MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n  Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n  int currentSdkClientCount=currentSdkClientCount();\n  boolean isLoaderClient=loadClient >= 0;\n  int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n  int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n  Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n  List<String> expelClient=new LinkedList<>();\n  Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String appName=client.getMetaInfo().getAppName();\n    String clientIp=client.getMetaInfo().getClientIp();\n    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n      int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n      if (countLimitOfIp < 0) {\n        int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n        countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n      }\n      if (countLimitOfIp < 0) {\n        countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n      }\n      if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n        AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n        if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n          expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n        }\n      }\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n  if (expelForIp.size() > 0) {\n    Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n  }\n  Set<String> outDatedConnections=new HashSet<>();\n  long now=System.currentTimeMillis();\n  for (  Map.Entry<String,Connection> entry : entries) {\n    Connection client=entry.getValue();\n    String clientIp=client.getMetaInfo().getClientIp();\n    AtomicInteger integer=expelForIp.get(clientIp);\n    if (integer != null && integer.intValue() > 0) {\n      integer.decrementAndGet();\n      expelClient.add(client.getMetaInfo().getConnectionId());\n      expelCount--;\n    }\n else     if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n      outDatedConnections.add(client.getMetaInfo().getConnectionId());\n    }\n  }\n  if (expelCount > 0) {\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n        outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n      }\n    }\n  }\n  String serverIp=null;\n  String serverPort=null;\n  if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n    String[] split=redirectAddress.split(Constants.COLON);\n    serverIp=split[0];\n    serverPort=split[1];\n  }\n  for (  String expelledClientId : expelClient) {\n    try {\n      Connection connection=getConnection(expelledClientId);\n      if (connection != null) {\n        ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n        connectResetRequest.setServerIp(serverIp);\n        connectResetRequest.setServerPort(serverPort);\n        connection.asyncRequest(connectResetRequest,null);\n        Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n      }\n    }\n catch (    ConnectionAlreadyClosedException e) {\n      unregister(expelledClientId);\n    }\ncatch (    Exception e) {\n      Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n    }\n  }\n  Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n  if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n    Set<String> successConnections=new HashSet<>();\n    final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      try {\n        Connection connection=getConnection(outDateConnectionId);\n        if (connection != null) {\n          ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n          connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n            @Override public Executor getExecutor(){\n              return null;\n            }\n            @Override public long getTimeout(){\n              return 1000L;\n            }\n            @Override public void onResponse(            Response response){\n              latch.countDown();\n              if (response != null && response.isSuccess()) {\n                connection.freshActiveTime();\n                successConnections.add(outDateConnectionId);\n              }\n            }\n            @Override public void onException(            Throwable e){\n              latch.countDown();\n            }\n          }\n);\n          Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n        }\n else {\n          latch.countDown();\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        latch.countDown();\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n        latch.countDown();\n      }\n    }\n    latch.await(3000L,TimeUnit.MILLISECONDS);\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n    for (    String outDateConnectionId : outDatedConnections) {\n      if (!successConnections.contains(outDateConnectionId)) {\n        Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n        unregister(outDateConnectionId);\n      }\n    }\n  }\n  if (isLoaderClient) {\n    loadClient=-1;\n    redirectAddress=null;\n  }\n  Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n}\n catch (Throwable e) {\n  Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 867,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11396,
        "startLineNumber" : 285,
        "startColumnNumber" : 30,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 868,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.AnonymousClassDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11436,
        "startLineNumber" : 284,
        "startColumnNumber" : 12,
        "endLineNumber" : 475,
        "endColumnNumber" : 13
      },
      "nodeContext" : "@Override public void run(){\n  try {\n    int totalCount=connections.size();\n    Loggers.REMOTE_DIGEST.info(\"Connection check task start\");\n    MetricsMonitor.getLongConnectionMonitor().set(totalCount);\n    Set<Map.Entry<String,Connection>> entries=connections.entrySet();\n    int currentSdkClientCount=currentSdkClientCount();\n    boolean isLoaderClient=loadClient >= 0;\n    int currentMaxClient=isLoaderClient ? loadClient : connectionLimitRule.countLimit;\n    int expelCount=currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient,0);\n    Loggers.REMOTE_DIGEST.info(\"Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}\",totalCount,currentSdkClientCount,(totalCount - currentSdkClientCount),currentMaxClient + (isLoaderClient ? \"(loaderCount)\" : \"\"),expelCount);\n    List<String> expelClient=new LinkedList<>();\n    Map<String,AtomicInteger> expelForIp=new HashMap<>(16);\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String appName=client.getMetaInfo().getAppName();\n      String clientIp=client.getMetaInfo().getClientIp();\n      if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {\n        int countLimitOfIp=connectionLimitRule.getCountLimitOfIp(clientIp);\n        if (countLimitOfIp < 0) {\n          int countLimitOfApp=connectionLimitRule.getCountLimitOfApp(appName);\n          countLimitOfIp=countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;\n        }\n        if (countLimitOfIp < 0) {\n          countLimitOfIp=connectionLimitRule.getCountLimitPerClientIpDefault();\n        }\n        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {\n          AtomicInteger currentCountIp=connectionForClientIp.get(clientIp);\n          if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {\n            expelForIp.put(clientIp,new AtomicInteger(currentCountIp.get() - countLimitOfIp));\n          }\n        }\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Check over limit for ip limit rule, over limit ip count={}\",expelForIp.size());\n    if (expelForIp.size() > 0) {\n      Loggers.REMOTE_DIGEST.info(\"Over limit ip expel info,\",expelForIp);\n    }\n    Set<String> outDatedConnections=new HashSet<>();\n    long now=System.currentTimeMillis();\n    for (    Map.Entry<String,Connection> entry : entries) {\n      Connection client=entry.getValue();\n      String clientIp=client.getMetaInfo().getClientIp();\n      AtomicInteger integer=expelForIp.get(clientIp);\n      if (integer != null && integer.intValue() > 0) {\n        integer.decrementAndGet();\n        expelClient.add(client.getMetaInfo().getConnectionId());\n        expelCount--;\n      }\n else       if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {\n        outDatedConnections.add(client.getMetaInfo().getConnectionId());\n      }\n    }\n    if (expelCount > 0) {\n      for (      Map.Entry<String,Connection> entry : entries) {\n        Connection client=entry.getValue();\n        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo().isSdkSource() && expelCount > 0) {\n          expelClient.add(client.getMetaInfo().getConnectionId());\n          expelCount--;\n          outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n        }\n      }\n    }\n    String serverIp=null;\n    String serverPort=null;\n    if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {\n      String[] split=redirectAddress.split(Constants.COLON);\n      serverIp=split[0];\n      serverPort=split[1];\n    }\n    for (    String expelledClientId : expelClient) {\n      try {\n        Connection connection=getConnection(expelledClientId);\n        if (connection != null) {\n          ConnectResetRequest connectResetRequest=new ConnectResetRequest();\n          connectResetRequest.setServerIp(serverIp);\n          connectResetRequest.setServerPort(serverPort);\n          connection.asyncRequest(connectResetRequest,null);\n          Loggers.REMOTE_DIGEST.info(\"Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}\",expelledClientId,connectResetRequest.getServerIp(),connectResetRequest.getServerPort());\n        }\n      }\n catch (      ConnectionAlreadyClosedException e) {\n        unregister(expelledClientId);\n      }\ncatch (      Exception e) {\n        Loggers.REMOTE_DIGEST.error(\"Error occurs when expel connection :\",expelledClientId,e);\n      }\n    }\n    Loggers.REMOTE_DIGEST.info(\"Out dated connection ,size={}\",outDatedConnections.size());\n    if (CollectionUtils.isNotEmpty(outDatedConnections)) {\n      Set<String> successConnections=new HashSet<>();\n      final CountDownLatch latch=new CountDownLatch(outDatedConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        try {\n          Connection connection=getConnection(outDateConnectionId);\n          if (connection != null) {\n            ClientDetectionRequest clientDetectionRequest=new ClientDetectionRequest();\n            connection.asyncRequest(clientDetectionRequest,new RequestCallBack(){\n              @Override public Executor getExecutor(){\n                return null;\n              }\n              @Override public long getTimeout(){\n                return 1000L;\n              }\n              @Override public void onResponse(              Response response){\n                latch.countDown();\n                if (response != null && response.isSuccess()) {\n                  connection.freshActiveTime();\n                  successConnections.add(outDateConnectionId);\n                }\n              }\n              @Override public void onException(              Throwable e){\n                latch.countDown();\n              }\n            }\n);\n            Loggers.REMOTE_DIGEST.info(\"[{}]send connection active request \",outDateConnectionId);\n          }\n else {\n            latch.countDown();\n          }\n        }\n catch (        ConnectionAlreadyClosedException e) {\n          latch.countDown();\n        }\ncatch (        Exception e) {\n          Loggers.REMOTE_DIGEST.error(\"[{}]Error occurs when check client active detection ,error={}\",outDateConnectionId,e);\n          latch.countDown();\n        }\n      }\n      latch.await(3000L,TimeUnit.MILLISECONDS);\n      Loggers.REMOTE_DIGEST.info(\"Out dated connection check successCount={}\",successConnections.size());\n      for (      String outDateConnectionId : outDatedConnections) {\n        if (!successConnections.contains(outDateConnectionId)) {\n          Loggers.REMOTE_DIGEST.info(\"[{}]Unregister Out dated connection....\",outDateConnectionId);\n          unregister(outDateConnectionId);\n        }\n      }\n    }\n    if (isLoaderClient) {\n      loadClient=-1;\n      redirectAddress=null;\n    }\n    Loggers.REMOTE_DIGEST.info(\"Connection check task end\");\n  }\n catch (  Throwable e) {\n    Loggers.REMOTE.error(\"Error occurs during connection check... \",e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 874,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 67,
        "startLineNumber" : 364,
        "startColumnNumber" : 32,
        "endLineNumber" : 364,
        "endColumnNumber" : 99
      },
      "nodeContext" : "outDatedConnections.remove(client.getMetaInfo().getConnectionId());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "com.alibaba.nacos.core.remote.Connection"
  } ],
  "positionList" : [ {
    "charLength" : 6,
    "startLineNumber" : 310,
    "startColumnNumber" : 41,
    "endLineNumber" : 310,
    "endColumnNumber" : 47
  }, {
    "charLength" : 6,
    "startLineNumber" : 311,
    "startColumnNumber" : 42,
    "endLineNumber" : 311,
    "endColumnNumber" : 48
  }, {
    "charLength" : 6,
    "startLineNumber" : 312,
    "startColumnNumber" : 28,
    "endLineNumber" : 312,
    "endColumnNumber" : 34
  }, {
    "charLength" : 6,
    "startLineNumber" : 344,
    "startColumnNumber" : 42,
    "endLineNumber" : 344,
    "endColumnNumber" : 48
  }, {
    "charLength" : 6,
    "startLineNumber" : 348,
    "startColumnNumber" : 44,
    "endLineNumber" : 348,
    "endColumnNumber" : 50
  }, {
    "charLength" : 6,
    "startLineNumber" : 350,
    "startColumnNumber" : 41,
    "endLineNumber" : 350,
    "endColumnNumber" : 47
  }, {
    "charLength" : 6,
    "startLineNumber" : 351,
    "startColumnNumber" : 52,
    "endLineNumber" : 351,
    "endColumnNumber" : 58
  }, {
    "charLength" : 6,
    "startLineNumber" : 360,
    "startColumnNumber" : 56,
    "endLineNumber" : 360,
    "endColumnNumber" : 62
  }, {
    "charLength" : 6,
    "startLineNumber" : 360,
    "startColumnNumber" : 90,
    "endLineNumber" : 360,
    "endColumnNumber" : 96
  }, {
    "charLength" : 6,
    "startLineNumber" : 362,
    "startColumnNumber" : 48,
    "endLineNumber" : 362,
    "endColumnNumber" : 54
  }, {
    "charLength" : 6,
    "startLineNumber" : 364,
    "startColumnNumber" : 59,
    "endLineNumber" : 364,
    "endColumnNumber" : 65
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 10
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 10
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 10
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 4
  } ]
}