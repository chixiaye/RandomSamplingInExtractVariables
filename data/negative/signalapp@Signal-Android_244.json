{
  "id" : 244,
  "expression" : "TAG",
  "projectName" : "signalapp@Signal-Android",
  "commitID" : "2068fa80416a11892d4665e3656be70df4512340",
  "filePath" : "app/src/main/java/org/thoughtcrime/securesms/messages/GroupSendUtil.java",
  "occurrences" : 14,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 164,
      "startColumnNumber" : 14,
      "endLineNumber" : 164,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 164,
        "startColumnNumber" : 8,
        "endLineNumber" : 164,
        "endColumnNumber" : 62
      },
      "nodeContext" : "Log.i(TAG,\"Recipients not in a group. Using legacy.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 164,
        "startColumnNumber" : 8,
        "endLineNumber" : 164,
        "endColumnNumber" : 63
      },
      "nodeContext" : "Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 155,
        "startLineNumber" : 163,
        "startColumnNumber" : 27,
        "endLineNumber" : 167,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 16,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 992,
        "startLineNumber" : 163,
        "startColumnNumber" : 6,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (groupId == null) {\n  Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 109,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1006,
        "startLineNumber" : 162,
        "startColumnNumber" : 34,
        "endLineNumber" : 180,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 110,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1185,
        "startLineNumber" : 162,
        "startColumnNumber" : 4,
        "endLineNumber" : 184,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (FeatureFlags.senderKey()) {\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n else {\n  Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 130,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 164,
        "startColumnNumber" : 8,
        "endLineNumber" : 164,
        "endColumnNumber" : 63
      },
      "nodeContext" : "Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 168,
      "startColumnNumber" : 14,
      "endLineNumber" : 168,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 73,
        "startLineNumber" : 168,
        "startColumnNumber" : 8,
        "endLineNumber" : 168,
        "endColumnNumber" : 81
      },
      "nodeContext" : "Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 168,
        "startColumnNumber" : 8,
        "endLineNumber" : 168,
        "endColumnNumber" : 82
      },
      "nodeContext" : "Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 174,
        "startLineNumber" : 167,
        "startColumnNumber" : 94,
        "endLineNumber" : 171,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 16,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 810,
        "startLineNumber" : 167,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 89,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 992,
        "startLineNumber" : 163,
        "startColumnNumber" : 6,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (groupId == null) {\n  Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 109,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1006,
        "startLineNumber" : 162,
        "startColumnNumber" : 34,
        "endLineNumber" : 180,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 110,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1185,
        "startLineNumber" : 162,
        "startColumnNumber" : 4,
        "endLineNumber" : 184,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (FeatureFlags.senderKey()) {\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n else {\n  Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 130,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 168,
        "startColumnNumber" : 8,
        "endLineNumber" : 168,
        "endColumnNumber" : 82
      },
      "nodeContext" : "Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 172,
      "startColumnNumber" : 14,
      "endLineNumber" : 172,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 95,
        "startLineNumber" : 172,
        "startColumnNumber" : 8,
        "endLineNumber" : 172,
        "endColumnNumber" : 103
      },
      "nodeContext" : "Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 172,
        "startColumnNumber" : 8,
        "endLineNumber" : 172,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 114,
        "startLineNumber" : 171,
        "startColumnNumber" : 72,
        "endLineNumber" : 173,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 12,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 549,
        "startLineNumber" : 171,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 810,
        "startLineNumber" : 167,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 89,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 992,
        "startLineNumber" : 163,
        "startColumnNumber" : 6,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (groupId == null) {\n  Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 109,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1006,
        "startLineNumber" : 162,
        "startColumnNumber" : 34,
        "endLineNumber" : 180,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 110,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1185,
        "startLineNumber" : 162,
        "startColumnNumber" : 4,
        "endLineNumber" : 184,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (FeatureFlags.senderKey()) {\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n else {\n  Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 130,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 96,
        "startLineNumber" : 172,
        "startColumnNumber" : 8,
        "endLineNumber" : 172,
        "endColumnNumber" : 104
      },
      "nodeContext" : "Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 174,
      "startColumnNumber" : 14,
      "endLineNumber" : 174,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 105,
        "startLineNumber" : 174,
        "startColumnNumber" : 8,
        "endLineNumber" : 174,
        "endColumnNumber" : 113
      },
      "nodeContext" : "Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 106,
        "startLineNumber" : 174,
        "startColumnNumber" : 8,
        "endLineNumber" : 174,
        "endColumnNumber" : 114
      },
      "nodeContext" : "Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 206,
        "startLineNumber" : 173,
        "startColumnNumber" : 46,
        "endLineNumber" : 177,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 21,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 370,
        "startLineNumber" : 173,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 43,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 549,
        "startLineNumber" : 171,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 810,
        "startLineNumber" : 167,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 89,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 992,
        "startLineNumber" : 163,
        "startColumnNumber" : 6,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (groupId == null) {\n  Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 109,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1006,
        "startLineNumber" : 162,
        "startColumnNumber" : 34,
        "endLineNumber" : 180,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 110,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1185,
        "startLineNumber" : 162,
        "startColumnNumber" : 4,
        "endLineNumber" : 184,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (FeatureFlags.senderKey()) {\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n else {\n  Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 130,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 106,
        "startLineNumber" : 174,
        "startColumnNumber" : 8,
        "endLineNumber" : 174,
        "endColumnNumber" : 114
      },
      "nodeContext" : "Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 178,
      "startColumnNumber" : 14,
      "endLineNumber" : 178,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 106,
        "startLineNumber" : 178,
        "startColumnNumber" : 8,
        "endLineNumber" : 178,
        "endColumnNumber" : 114
      },
      "nodeContext" : "Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 107,
        "startLineNumber" : 178,
        "startColumnNumber" : 8,
        "endLineNumber" : 178,
        "endColumnNumber" : 115
      },
      "nodeContext" : "Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 125,
        "startLineNumber" : 177,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 370,
        "startLineNumber" : 173,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 43,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 549,
        "startLineNumber" : 171,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 810,
        "startLineNumber" : 167,
        "startColumnNumber" : 13,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 89,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 992,
        "startLineNumber" : 163,
        "startColumnNumber" : 6,
        "endLineNumber" : 179,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (groupId == null) {\n  Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n  Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n  Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n}\n else if (senderKeyTargets.size() < 2) {\n  Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n else {\n  Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 109,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1006,
        "startLineNumber" : 162,
        "startColumnNumber" : 34,
        "endLineNumber" : 180,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 110,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1185,
        "startLineNumber" : 162,
        "startColumnNumber" : 4,
        "endLineNumber" : 184,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (FeatureFlags.senderKey()) {\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n else {\n  Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 130,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 107,
        "startLineNumber" : 178,
        "startColumnNumber" : 8,
        "endLineNumber" : 178,
        "endColumnNumber" : 115
      },
      "nodeContext" : "Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 15,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 181,
      "startColumnNumber" : 12,
      "endLineNumber" : 181,
      "endColumnNumber" : 15
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 181,
        "startColumnNumber" : 6,
        "endLineNumber" : 181,
        "endColumnNumber" : 56
      },
      "nodeContext" : "Log.i(TAG,\"Feature flag disabled. Using legacy.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 181,
        "startColumnNumber" : 6,
        "endLineNumber" : 181,
        "endColumnNumber" : 57
      },
      "nodeContext" : "Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 143,
        "startLineNumber" : 180,
        "startColumnNumber" : 11,
        "endLineNumber" : 184,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 16,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1185,
        "startLineNumber" : 162,
        "startColumnNumber" : 4,
        "endLineNumber" : 184,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (FeatureFlags.senderKey()) {\n  if (groupId == null) {\n    Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n    Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else   if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n    Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n  }\n else   if (senderKeyTargets.size() < 2) {\n    Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n else {\n    Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n  }\n}\n else {\n  Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n  legacyTargets.addAll(senderKeyTargets);\n  senderKeyTargets.clear();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 130,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 181,
        "startColumnNumber" : 6,
        "endLineNumber" : 181,
        "endColumnNumber" : 57
      },
      "nodeContext" : "Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 195,
      "startColumnNumber" : 14,
      "endLineNumber" : 195,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 108,
        "startLineNumber" : 195,
        "startColumnNumber" : 8,
        "endLineNumber" : 195,
        "endColumnNumber" : 116
      },
      "nodeContext" : "Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 16,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 109,
        "startLineNumber" : 195,
        "startColumnNumber" : 8,
        "endLineNumber" : 195,
        "endColumnNumber" : 117
      },
      "nodeContext" : "Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 188,
        "startLineNumber" : 194,
        "startColumnNumber" : 55,
        "endLineNumber" : 197,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n  SenderKeyUtil.rotateOurKey(context,distributionId);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 24,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 237,
        "startLineNumber" : 194,
        "startColumnNumber" : 6,
        "endLineNumber" : 197,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n  Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n  SenderKeyUtil.rotateOurKey(context,distributionId);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 33,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2046,
        "startLineNumber" : 189,
        "startColumnNumber" : 56,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 247,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2098,
        "startLineNumber" : 189,
        "startColumnNumber" : 4,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (senderKeyTargets.size() > 0 && groupId != null) {\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 257,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 109,
        "startLineNumber" : 195,
        "startColumnNumber" : 8,
        "endLineNumber" : 195,
        "endColumnNumber" : 117
      },
      "nodeContext" : "Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 207,
      "startColumnNumber" : 14,
      "endLineNumber" : 207,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 115,
        "startLineNumber" : 207,
        "startColumnNumber" : 8,
        "endLineNumber" : 207,
        "endColumnNumber" : 123
      },
      "nodeContext" : "Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 116,
        "startLineNumber" : 207,
        "startColumnNumber" : 8,
        "endLineNumber" : 207,
        "endColumnNumber" : 124
      },
      "nodeContext" : "Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 977,
        "startLineNumber" : 199,
        "startColumnNumber" : 10,
        "endLineNumber" : 212,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n  List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n  if (sendOperation.shouldIncludeInMessageLog()) {\n    DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 128,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1487,
        "startLineNumber" : 199,
        "startColumnNumber" : 6,
        "endLineNumber" : 221,
        "endColumnNumber" : 7
      },
      "nodeContext" : "try {\n  List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n  List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n  if (sendOperation.shouldIncludeInMessageLog()) {\n    DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n  }\n}\n catch (InvalidUnidentifiedAccessHeaderException e) {\n  Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\ncatch (NoSessionException e) {\n  Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\ncatch (InvalidKeyException e) {\n  Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 183,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2046,
        "startLineNumber" : 189,
        "startColumnNumber" : 56,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 247,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2098,
        "startLineNumber" : 189,
        "startColumnNumber" : 4,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (senderKeyTargets.size() > 0 && groupId != null) {\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 257,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 116,
        "startLineNumber" : 207,
        "startColumnNumber" : 8,
        "endLineNumber" : 207,
        "endColumnNumber" : 124
      },
      "nodeContext" : "Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 213,
      "startColumnNumber" : 14,
      "endLineNumber" : 213,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 75,
        "startLineNumber" : 213,
        "startColumnNumber" : 8,
        "endLineNumber" : 213,
        "endColumnNumber" : 83
      },
      "nodeContext" : "Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 213,
        "startColumnNumber" : 8,
        "endLineNumber" : 213,
        "endColumnNumber" : 84
      },
      "nodeContext" : "Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CatchClause,body]",
      "nodePosition" : {
        "charLength" : 142,
        "startLineNumber" : 212,
        "startColumnNumber" : 59,
        "endLineNumber" : 215,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,catchClauses]",
      "nodePosition" : {
        "charLength" : 193,
        "startLineNumber" : 212,
        "startColumnNumber" : 8,
        "endLineNumber" : 215,
        "endColumnNumber" : 7
      },
      "nodeContext" : "catch (InvalidUnidentifiedAccessHeaderException e) {\n  Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "CatchClause",
      "astNodeNumber" : 18,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1487,
        "startLineNumber" : 199,
        "startColumnNumber" : 6,
        "endLineNumber" : 221,
        "endColumnNumber" : 7
      },
      "nodeContext" : "try {\n  List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n  List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n  if (sendOperation.shouldIncludeInMessageLog()) {\n    DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n  }\n}\n catch (InvalidUnidentifiedAccessHeaderException e) {\n  Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\ncatch (NoSessionException e) {\n  Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\ncatch (InvalidKeyException e) {\n  Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 183,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2046,
        "startLineNumber" : 189,
        "startColumnNumber" : 56,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 247,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2098,
        "startLineNumber" : 189,
        "startColumnNumber" : 4,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (senderKeyTargets.size() > 0 && groupId != null) {\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 257,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 213,
        "startColumnNumber" : 8,
        "endLineNumber" : 213,
        "endColumnNumber" : 84
      },
      "nodeContext" : "Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 216,
      "startColumnNumber" : 14,
      "endLineNumber" : 216,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 216,
        "startColumnNumber" : 8,
        "endLineNumber" : 216,
        "endColumnNumber" : 66
      },
      "nodeContext" : "Log.w(TAG,\"No session. Falling back to legacy sends.\",e)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 59,
        "startLineNumber" : 216,
        "startColumnNumber" : 8,
        "endLineNumber" : 216,
        "endColumnNumber" : 67
      },
      "nodeContext" : "Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CatchClause,body]",
      "nodePosition" : {
        "charLength" : 125,
        "startLineNumber" : 215,
        "startColumnNumber" : 37,
        "endLineNumber" : 218,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,catchClauses]",
      "nodePosition" : {
        "charLength" : 154,
        "startLineNumber" : 215,
        "startColumnNumber" : 8,
        "endLineNumber" : 218,
        "endColumnNumber" : 7
      },
      "nodeContext" : "catch (NoSessionException e) {\n  Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "CatchClause",
      "astNodeNumber" : 18,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1487,
        "startLineNumber" : 199,
        "startColumnNumber" : 6,
        "endLineNumber" : 221,
        "endColumnNumber" : 7
      },
      "nodeContext" : "try {\n  List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n  List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n  if (sendOperation.shouldIncludeInMessageLog()) {\n    DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n  }\n}\n catch (InvalidUnidentifiedAccessHeaderException e) {\n  Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\ncatch (NoSessionException e) {\n  Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\ncatch (InvalidKeyException e) {\n  Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 183,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2046,
        "startLineNumber" : 189,
        "startColumnNumber" : 56,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 247,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2098,
        "startLineNumber" : 189,
        "startColumnNumber" : 4,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (senderKeyTargets.size() > 0 && groupId != null) {\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 257,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 59,
        "startLineNumber" : 216,
        "startColumnNumber" : 8,
        "endLineNumber" : 216,
        "endColumnNumber" : 67
      },
      "nodeContext" : "Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 219,
      "startColumnNumber" : 14,
      "endLineNumber" : 219,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 59,
        "startLineNumber" : 219,
        "startColumnNumber" : 8,
        "endLineNumber" : 219,
        "endColumnNumber" : 67
      },
      "nodeContext" : "Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 219,
        "startColumnNumber" : 8,
        "endLineNumber" : 219,
        "endColumnNumber" : 68
      },
      "nodeContext" : "Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CatchClause,body]",
      "nodePosition" : {
        "charLength" : 126,
        "startLineNumber" : 218,
        "startColumnNumber" : 38,
        "endLineNumber" : 221,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 13,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,catchClauses]",
      "nodePosition" : {
        "charLength" : 156,
        "startLineNumber" : 218,
        "startColumnNumber" : 8,
        "endLineNumber" : 221,
        "endColumnNumber" : 7
      },
      "nodeContext" : "catch (InvalidKeyException e) {\n  Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "CatchClause",
      "astNodeNumber" : 18,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1487,
        "startLineNumber" : 199,
        "startColumnNumber" : 6,
        "endLineNumber" : 221,
        "endColumnNumber" : 7
      },
      "nodeContext" : "try {\n  List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n  List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n  if (sendOperation.shouldIncludeInMessageLog()) {\n    DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n  }\n}\n catch (InvalidUnidentifiedAccessHeaderException e) {\n  Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\ncatch (NoSessionException e) {\n  Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\ncatch (InvalidKeyException e) {\n  Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n  legacyTargets.addAll(senderKeyTargets);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 183,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2046,
        "startLineNumber" : 189,
        "startColumnNumber" : 56,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 247,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2098,
        "startLineNumber" : 189,
        "startColumnNumber" : 4,
        "endLineNumber" : 222,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (senderKeyTargets.size() > 0 && groupId != null) {\n  DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n  long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n  long keyAge=System.currentTimeMillis() - keyCreateTime;\n  if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n    Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n    SenderKeyUtil.rotateOurKey(context,distributionId);\n  }\n  try {\n    List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n    List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n    if (sendOperation.shouldIncludeInMessageLog()) {\n      DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n    }\n  }\n catch (  InvalidUnidentifiedAccessHeaderException e) {\n    Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  NoSessionException e) {\n    Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\ncatch (  InvalidKeyException e) {\n    Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n    legacyTargets.addAll(senderKeyTargets);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 257,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 219,
        "startColumnNumber" : 8,
        "endLineNumber" : 219,
        "endColumnNumber" : 68
      },
      "nodeContext" : "Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 232,
      "startColumnNumber" : 14,
      "endLineNumber" : 232,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 67,
        "startLineNumber" : 232,
        "startColumnNumber" : 8,
        "endLineNumber" : 232,
        "endColumnNumber" : 75
      },
      "nodeContext" : "Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 232,
        "startColumnNumber" : 8,
        "endLineNumber" : 232,
        "endColumnNumber" : 76
      },
      "nodeContext" : "Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 86,
        "startLineNumber" : 231,
        "startColumnNumber" : 36,
        "endLineNumber" : 233,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 12,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 233,
        "startLineNumber" : 231,
        "startColumnNumber" : 6,
        "endLineNumber" : 235,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (legacyTargets.size() > 0) {\n  Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n}\n else {\n  Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 25,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1903,
        "startLineNumber" : 230,
        "startColumnNumber" : 70,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (legacyTargets.size() > 0) {\n    Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n  }\n else {\n    Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n  }\n  List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n  boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n  final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n  final AtomicLong entryId=new AtomicLong(-1);\n  final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n  List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n    if (!includeInMessageLog) {\n      return;\n    }\nsynchronized (entryId) {\n      if (entryId.get() == -1) {\n        entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n      }\n else {\n        messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n      }\n    }\n  }\n,cancelationSignal);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 231,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1969,
        "startLineNumber" : 230,
        "startColumnNumber" : 4,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n  if (legacyTargets.size() > 0) {\n    Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n  }\n else {\n    Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n  }\n  List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n  boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n  final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n  final AtomicLong entryId=new AtomicLong(-1);\n  final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n  List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n    if (!includeInMessageLog) {\n      return;\n    }\nsynchronized (entryId) {\n      if (entryId.get() == -1) {\n        entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n      }\n else {\n        messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n      }\n    }\n  }\n,cancelationSignal);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 239,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 232,
        "startColumnNumber" : 8,
        "endLineNumber" : 232,
        "endColumnNumber" : 76
      },
      "nodeContext" : "Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 234,
      "startColumnNumber" : 14,
      "endLineNumber" : 234,
      "endColumnNumber" : 17
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 92,
        "startLineNumber" : 234,
        "startColumnNumber" : 8,
        "endLineNumber" : 234,
        "endColumnNumber" : 100
      },
      "nodeContext" : "Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 234,
        "startColumnNumber" : 8,
        "endLineNumber" : 234,
        "endColumnNumber" : 101
      },
      "nodeContext" : "Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 111,
        "startLineNumber" : 233,
        "startColumnNumber" : 13,
        "endLineNumber" : 235,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 233,
        "startLineNumber" : 231,
        "startColumnNumber" : 6,
        "endLineNumber" : 235,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (legacyTargets.size() > 0) {\n  Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n}\n else {\n  Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 25,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1903,
        "startLineNumber" : 230,
        "startColumnNumber" : 70,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (legacyTargets.size() > 0) {\n    Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n  }\n else {\n    Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n  }\n  List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n  boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n  final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n  final AtomicLong entryId=new AtomicLong(-1);\n  final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n  List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n    if (!includeInMessageLog) {\n      return;\n    }\nsynchronized (entryId) {\n      if (entryId.get() == -1) {\n        entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n      }\n else {\n        messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n      }\n    }\n  }\n,cancelationSignal);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 231,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1969,
        "startLineNumber" : 230,
        "startColumnNumber" : 4,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n  if (legacyTargets.size() > 0) {\n    Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n  }\n else {\n    Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n  }\n  List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n  boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n  final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n  final AtomicLong entryId=new AtomicLong(-1);\n  final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n  List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n    if (!includeInMessageLog) {\n      return;\n    }\nsynchronized (entryId) {\n      if (entryId.get() == -1) {\n        entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n      }\n else {\n        messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n      }\n    }\n  }\n,cancelationSignal);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 239,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 234,
        "startColumnNumber" : 8,
        "endLineNumber" : 234,
        "endColumnNumber" : 101
      },
      "nodeContext" : "Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "TAG",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 3,
      "startLineNumber" : 262,
      "startColumnNumber" : 12,
      "endLineNumber" : 262,
      "endColumnNumber" : 15
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 104,
        "startLineNumber" : 262,
        "startColumnNumber" : 6,
        "endLineNumber" : 262,
        "endColumnNumber" : 110
      },
      "nodeContext" : "Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 105,
        "startLineNumber" : 262,
        "startColumnNumber" : 6,
        "endLineNumber" : 262,
        "endColumnNumber" : 111
      },
      "nodeContext" : "Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1903,
        "startLineNumber" : 230,
        "startColumnNumber" : 70,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (legacyTargets.size() > 0) {\n    Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n  }\n else {\n    Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n  }\n  List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n  boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n  final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n  final AtomicLong entryId=new AtomicLong(-1);\n  final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n  List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n    if (!includeInMessageLog) {\n      return;\n    }\nsynchronized (entryId) {\n      if (entryId.get() == -1) {\n        entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n      }\n else {\n        messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n      }\n    }\n  }\n,cancelationSignal);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 231,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1969,
        "startLineNumber" : 230,
        "startColumnNumber" : 4,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n  if (legacyTargets.size() > 0) {\n    Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n  }\n else {\n    Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n  }\n  List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n  List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n  boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n  final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n  final AtomicLong entryId=new AtomicLong(-1);\n  final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n  List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n    if (!includeInMessageLog) {\n      return;\n    }\nsynchronized (entryId) {\n      if (entryId.get() == -1) {\n        entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n      }\n else {\n        messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n      }\n    }\n  }\n,cancelationSignal);\n  allResults.addAll(results);\n  int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n  Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 239,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 105,
        "startLineNumber" : 262,
        "startColumnNumber" : 6,
        "endLineNumber" : 262,
        "endColumnNumber" : 111
      },
      "nodeContext" : "Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  } ],
  "positionList" : [ {
    "charLength" : 3,
    "startLineNumber" : 164,
    "startColumnNumber" : 14,
    "endLineNumber" : 164,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 168,
    "startColumnNumber" : 14,
    "endLineNumber" : 168,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 172,
    "startColumnNumber" : 14,
    "endLineNumber" : 172,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 174,
    "startColumnNumber" : 14,
    "endLineNumber" : 174,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 178,
    "startColumnNumber" : 14,
    "endLineNumber" : 178,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 181,
    "startColumnNumber" : 12,
    "endLineNumber" : 181,
    "endColumnNumber" : 15
  }, {
    "charLength" : 3,
    "startLineNumber" : 195,
    "startColumnNumber" : 14,
    "endLineNumber" : 195,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 207,
    "startColumnNumber" : 14,
    "endLineNumber" : 207,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 213,
    "startColumnNumber" : 14,
    "endLineNumber" : 213,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 216,
    "startColumnNumber" : 14,
    "endLineNumber" : 216,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 219,
    "startColumnNumber" : 14,
    "endLineNumber" : 219,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 232,
    "startColumnNumber" : 14,
    "endLineNumber" : 232,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 234,
    "startColumnNumber" : 14,
    "endLineNumber" : 234,
    "endColumnNumber" : 17
  }, {
    "charLength" : 3,
    "startLineNumber" : 262,
    "startColumnNumber" : 12,
    "endLineNumber" : 262,
    "endColumnNumber" : 15
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 1,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 3,
    "secondKey" : 11,
    "layout" : 9
  }, {
    "firstKey" : 3,
    "secondKey" : 12,
    "layout" : 9
  }, {
    "firstKey" : 3,
    "secondKey" : 13,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 11,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 12,
    "layout" : 9
  }, {
    "firstKey" : 4,
    "secondKey" : 13,
    "layout" : 9
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 6,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 6,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 11,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 12,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 13,
    "layout" : 6
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 8,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 9,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 9,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 10,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 10,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 11,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 11,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 11,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 12,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 3,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 7,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 8,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 9,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 10,
    "layout" : 6
  }, {
    "firstKey" : 12,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 12,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 13,
    "secondKey" : 11,
    "layout" : 2
  }, {
    "firstKey" : 13,
    "secondKey" : 12,
    "layout" : 2
  } ]
}