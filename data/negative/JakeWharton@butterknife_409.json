{
  "id" : 409,
  "expression" : "annotationClass",
  "projectName" : "JakeWharton@butterknife",
  "commitID" : "45b1eb9534d51405b993ae17dabc774a9d4a3892",
  "filePath" : "butterknife/src/main/java/butterknife/internal/InjectViewProcessor.java",
  "occurrences" : 14,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 211,
      "startColumnNumber" : 60,
      "endLineNumber" : 211,
      "endColumnNumber" : 75
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 211,
        "startColumnNumber" : 60,
        "endLineNumber" : 211,
        "endColumnNumber" : 91
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 86,
        "startLineNumber" : 211,
        "startColumnNumber" : 6,
        "endLineNumber" : 211,
        "endColumnNumber" : 92
      },
      "nodeContext" : "error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 211,
        "startColumnNumber" : 6,
        "endLineNumber" : 211,
        "endColumnNumber" : 93
      },
      "nodeContext" : "error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 115,
        "startLineNumber" : 210,
        "startColumnNumber" : 80,
        "endLineNumber" : 213,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n  return;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 191,
        "startLineNumber" : 210,
        "startColumnNumber" : 4,
        "endLineNumber" : 213,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n  error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 23,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 87,
        "startLineNumber" : 211,
        "startColumnNumber" : 6,
        "endLineNumber" : 211,
        "endColumnNumber" : 93
      },
      "nodeContext" : "error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 219,
      "startColumnNumber" : 50,
      "endLineNumber" : 219,
      "endColumnNumber" : 65
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 219,
        "startColumnNumber" : 28,
        "endLineNumber" : 219,
        "endColumnNumber" : 66
      },
      "nodeContext" : "element.getAnnotation(annotationClass)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 219,
        "startColumnNumber" : 15,
        "endLineNumber" : 219,
        "endColumnNumber" : 66
      },
      "nodeContext" : "annotation=element.getAnnotation(annotationClass)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 219,
        "startColumnNumber" : 4,
        "endLineNumber" : 219,
        "endColumnNumber" : 67
      },
      "nodeContext" : "Annotation annotation=element.getAnnotation(annotationClass);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 219,
        "startColumnNumber" : 4,
        "endLineNumber" : 219,
        "endColumnNumber" : 67
      },
      "nodeContext" : "Annotation annotation=element.getAnnotation(annotationClass);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 220,
      "startColumnNumber" : 29,
      "endLineNumber" : 220,
      "endColumnNumber" : 44
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 220,
        "startColumnNumber" : 29,
        "endLineNumber" : 220,
        "endColumnNumber" : 71
      },
      "nodeContext" : "annotationClass.getDeclaredMethod(\"value\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 220,
        "startColumnNumber" : 11,
        "endLineNumber" : 220,
        "endColumnNumber" : 71
      },
      "nodeContext" : "annotationValue=annotationClass.getDeclaredMethod(\"value\")",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 220,
        "startColumnNumber" : 4,
        "endLineNumber" : 220,
        "endColumnNumber" : 72
      },
      "nodeContext" : "Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 220,
        "startColumnNumber" : 4,
        "endLineNumber" : 220,
        "endColumnNumber" : 72
      },
      "nodeContext" : "Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 222,
      "startColumnNumber" : 75,
      "endLineNumber" : 222,
      "endColumnNumber" : 90
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 157,
        "startLineNumber" : 222,
        "startColumnNumber" : 6,
        "endLineNumber" : 223,
        "endColumnNumber" : 71
      },
      "nodeContext" : "error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 158,
        "startLineNumber" : 222,
        "startColumnNumber" : 6,
        "endLineNumber" : 223,
        "endColumnNumber" : 72
      },
      "nodeContext" : "error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 186,
        "startLineNumber" : 221,
        "startColumnNumber" : 83,
        "endLineNumber" : 225,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n  return;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 265,
        "startLineNumber" : 221,
        "startColumnNumber" : 4,
        "endLineNumber" : 225,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n  error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 27,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 157,
        "startLineNumber" : 222,
        "startColumnNumber" : 6,
        "endLineNumber" : 223,
        "endColumnNumber" : 71
      },
      "nodeContext" : "error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 232,
      "startColumnNumber" : 47,
      "endLineNumber" : 232,
      "endColumnNumber" : 62
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 232,
        "startColumnNumber" : 23,
        "endLineNumber" : 232,
        "endColumnNumber" : 83
      },
      "nodeContext" : "isValidForGeneratedCode(annotationClass,\"methods\",element)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 232,
        "startColumnNumber" : 12,
        "endLineNumber" : 232,
        "endColumnNumber" : 83
      },
      "nodeContext" : "hasError=isValidForGeneratedCode(annotationClass,\"methods\",element)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 80,
        "startLineNumber" : 232,
        "startColumnNumber" : 4,
        "endLineNumber" : 232,
        "endColumnNumber" : 84
      },
      "nodeContext" : "boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 80,
        "startLineNumber" : 232,
        "startColumnNumber" : 4,
        "endLineNumber" : 232,
        "endColumnNumber" : 84
      },
      "nodeContext" : "boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 238,
      "startColumnNumber" : 12,
      "endLineNumber" : 238,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 238,
        "startColumnNumber" : 12,
        "endLineNumber" : 238,
        "endColumnNumber" : 43
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 200,
        "startLineNumber" : 237,
        "startColumnNumber" : 8,
        "endLineNumber" : 239,
        "endColumnNumber" : 36
      },
      "nodeContext" : "error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 201,
        "startLineNumber" : 237,
        "startColumnNumber" : 8,
        "endLineNumber" : 239,
        "endColumnNumber" : 37
      },
      "nodeContext" : "error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 15,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 244,
        "startLineNumber" : 236,
        "startColumnNumber" : 28,
        "endLineNumber" : 241,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n  hasError=true;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 20,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 266,
        "startLineNumber" : 236,
        "startColumnNumber" : 6,
        "endLineNumber" : 241,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (!seenIds.add(id)) {\n  error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n  hasError=true;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 26,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 280,
        "startLineNumber" : 235,
        "startColumnNumber" : 23,
        "endLineNumber" : 242,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!seenIds.add(id)) {\n    error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 27,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 299,
        "startLineNumber" : 235,
        "startColumnNumber" : 4,
        "endLineNumber" : 242,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (int id : ids) {\n  if (!seenIds.add(id)) {\n    error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 32,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 238,
        "startColumnNumber" : 12,
        "endLineNumber" : 238,
        "endColumnNumber" : 43
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 244,
      "startColumnNumber" : 34,
      "endLineNumber" : 244,
      "endColumnNumber" : 49
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 244,
        "startColumnNumber" : 34,
        "endLineNumber" : 244,
        "endColumnNumber" : 84
      },
      "nodeContext" : "annotationClass.getAnnotation(ListenerClass.class)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 66,
        "startLineNumber" : 244,
        "startColumnNumber" : 18,
        "endLineNumber" : 244,
        "endColumnNumber" : 84
      },
      "nodeContext" : "listenerClass=annotationClass.getAnnotation(ListenerClass.class)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 244,
        "startColumnNumber" : 4,
        "endLineNumber" : 244,
        "endColumnNumber" : 85
      },
      "nodeContext" : "ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 244,
        "startColumnNumber" : 4,
        "endLineNumber" : 244,
        "endColumnNumber" : 85
      },
      "nodeContext" : "ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 247,
      "startColumnNumber" : 10,
      "endLineNumber" : 247,
      "endColumnNumber" : 25
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 247,
        "startColumnNumber" : 10,
        "endLineNumber" : 247,
        "endColumnNumber" : 41
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 120,
        "startLineNumber" : 246,
        "startColumnNumber" : 6,
        "endLineNumber" : 247,
        "endColumnNumber" : 42
      },
      "nodeContext" : "error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 121,
        "startLineNumber" : 246,
        "startColumnNumber" : 6,
        "endLineNumber" : 247,
        "endColumnNumber" : 43
      },
      "nodeContext" : "error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 204,
        "startLineNumber" : 245,
        "startColumnNumber" : 31,
        "endLineNumber" : 249,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n  return;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 15,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 231,
        "startLineNumber" : 245,
        "startColumnNumber" : 4,
        "endLineNumber" : 249,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (listenerClass == null) {\n  error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 19,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 247,
        "startColumnNumber" : 10,
        "endLineNumber" : 247,
        "endColumnNumber" : 41
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 259,
      "startColumnNumber" : 42,
      "endLineNumber" : 259,
      "endColumnNumber" : 57
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 259,
        "startColumnNumber" : 42,
        "endLineNumber" : 259,
        "endColumnNumber" : 67
      },
      "nodeContext" : "annotationClass.getName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 259,
        "startColumnNumber" : 14,
        "endLineNumber" : 259,
        "endColumnNumber" : 68
      },
      "nodeContext" : "elementUtils.getTypeElement(annotationClass.getName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 164,
        "startLineNumber" : 259,
        "startColumnNumber" : 8,
        "endLineNumber" : 260,
        "endColumnNumber" : 84
      },
      "nodeContext" : "error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 18,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 165,
        "startLineNumber" : 259,
        "startColumnNumber" : 8,
        "endLineNumber" : 260,
        "endColumnNumber" : 85
      },
      "nodeContext" : "error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 19,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CatchClause,body]",
      "nodePosition" : {
        "charLength" : 263,
        "startLineNumber" : 258,
        "startColumnNumber" : 43,
        "endLineNumber" : 262,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n  return;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 21,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,catchClauses]",
      "nodePosition" : {
        "charLength" : 298,
        "startLineNumber" : 258,
        "startColumnNumber" : 8,
        "endLineNumber" : 262,
        "endColumnNumber" : 7
      },
      "nodeContext" : "catch (IllegalArgumentException e) {\n  error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n  return;\n}\n",
      "nodeType" : "CatchClause",
      "astNodeNumber" : 26,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 422,
        "startLineNumber" : 255,
        "startColumnNumber" : 6,
        "endLineNumber" : 262,
        "endColumnNumber" : 7
      },
      "nodeContext" : "try {\n  listener=Listener.from(listenerClassClass);\n  LISTENER_MAP.put(listenerClassClass,listener);\n}\n catch (IllegalArgumentException e) {\n  error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n  return;\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 436,
        "startLineNumber" : 254,
        "startColumnNumber" : 26,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  try {\n    listener=Listener.from(listenerClassClass);\n    LISTENER_MAP.put(listenerClassClass,listener);\n  }\n catch (  IllegalArgumentException e) {\n    error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n    return;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 42,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 458,
        "startLineNumber" : 254,
        "startColumnNumber" : 4,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (listener == null) {\n  try {\n    listener=Listener.from(listenerClassClass);\n    LISTENER_MAP.put(listenerClassClass,listener);\n  }\n catch (  IllegalArgumentException e) {\n    error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n    return;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 46,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 259,
        "startColumnNumber" : 14,
        "endLineNumber" : 259,
        "endColumnNumber" : 68
      },
      "nodeContext" : "elementUtils.getTypeElement(annotationClass.getName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 260,
      "startColumnNumber" : 58,
      "endLineNumber" : 260,
      "endColumnNumber" : 73
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 260,
        "startColumnNumber" : 58,
        "endLineNumber" : 260,
        "endColumnNumber" : 83
      },
      "nodeContext" : "annotationClass.getName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 164,
        "startLineNumber" : 259,
        "startColumnNumber" : 8,
        "endLineNumber" : 260,
        "endColumnNumber" : 84
      },
      "nodeContext" : "error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 18,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 165,
        "startLineNumber" : 259,
        "startColumnNumber" : 8,
        "endLineNumber" : 260,
        "endColumnNumber" : 85
      },
      "nodeContext" : "error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 19,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.CatchClause,body]",
      "nodePosition" : {
        "charLength" : 263,
        "startLineNumber" : 258,
        "startColumnNumber" : 43,
        "endLineNumber" : 262,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n  return;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 21,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,catchClauses]",
      "nodePosition" : {
        "charLength" : 298,
        "startLineNumber" : 258,
        "startColumnNumber" : 8,
        "endLineNumber" : 262,
        "endColumnNumber" : 7
      },
      "nodeContext" : "catch (IllegalArgumentException e) {\n  error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n  return;\n}\n",
      "nodeType" : "CatchClause",
      "astNodeNumber" : 26,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 422,
        "startLineNumber" : 255,
        "startColumnNumber" : 6,
        "endLineNumber" : 262,
        "endColumnNumber" : 7
      },
      "nodeContext" : "try {\n  listener=Listener.from(listenerClassClass);\n  LISTENER_MAP.put(listenerClassClass,listener);\n}\n catch (IllegalArgumentException e) {\n  error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n  return;\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 436,
        "startLineNumber" : 254,
        "startColumnNumber" : 26,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  try {\n    listener=Listener.from(listenerClassClass);\n    LISTENER_MAP.put(listenerClassClass,listener);\n  }\n catch (  IllegalArgumentException e) {\n    error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n    return;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 42,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 458,
        "startLineNumber" : 254,
        "startColumnNumber" : 4,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (listener == null) {\n  try {\n    listener=Listener.from(listenerClassClass);\n    LISTENER_MAP.put(listenerClassClass,listener);\n  }\n catch (  IllegalArgumentException e) {\n    error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n    return;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 46,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 260,
        "startColumnNumber" : 58,
        "endLineNumber" : 260,
        "endColumnNumber" : 83
      },
      "nodeContext" : "annotationClass.getName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 269,
      "startColumnNumber" : 10,
      "endLineNumber" : 269,
      "endColumnNumber" : 25
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 269,
        "startColumnNumber" : 10,
        "endLineNumber" : 269,
        "endColumnNumber" : 41
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 223,
        "startLineNumber" : 268,
        "startColumnNumber" : 6,
        "endLineNumber" : 270,
        "endColumnNumber" : 71
      },
      "nodeContext" : "error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 18,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 224,
        "startLineNumber" : 268,
        "startColumnNumber" : 6,
        "endLineNumber" : 270,
        "endColumnNumber" : 72
      },
      "nodeContext" : "error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 19,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 261,
        "startLineNumber" : 267,
        "startColumnNumber" : 71,
        "endLineNumber" : 272,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n  hasError=true;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 24,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 328,
        "startLineNumber" : 267,
        "startColumnNumber" : 4,
        "endLineNumber" : 272,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (methodParameters.size() > listener.getParameterTypes().size()) {\n  error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n  hasError=true;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 34,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 269,
        "startColumnNumber" : 10,
        "endLineNumber" : 269,
        "endColumnNumber" : 41
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 277,
      "startColumnNumber" : 10,
      "endLineNumber" : 277,
      "endColumnNumber" : 25
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 277,
        "startColumnNumber" : 10,
        "endLineNumber" : 277,
        "endColumnNumber" : 41
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 208,
        "startLineNumber" : 276,
        "startColumnNumber" : 6,
        "endLineNumber" : 278,
        "endColumnNumber" : 71
      },
      "nodeContext" : "error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 16,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 209,
        "startLineNumber" : 276,
        "startColumnNumber" : 6,
        "endLineNumber" : 278,
        "endColumnNumber" : 72
      },
      "nodeContext" : "error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 17,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 246,
        "startLineNumber" : 275,
        "startColumnNumber" : 88,
        "endLineNumber" : 280,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n  hasError=true;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 22,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 330,
        "startLineNumber" : 275,
        "startColumnNumber" : 4,
        "endLineNumber" : 280,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n  error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n  hasError=true;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 34,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 277,
        "startColumnNumber" : 10,
        "endLineNumber" : 277,
        "endColumnNumber" : 41
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 308,
      "startColumnNumber" : 22,
      "endLineNumber" : 308,
      "endColumnNumber" : 37
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 308,
        "startColumnNumber" : 22,
        "endLineNumber" : 308,
        "endColumnNumber" : 53
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 90,
        "startLineNumber" : 307,
        "startColumnNumber" : 10,
        "endLineNumber" : 308,
        "endColumnNumber" : 54
      },
      "nodeContext" : "builder.append(\"Unable to match @\").append(annotationClass.getSimpleName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 9,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 136,
        "startLineNumber" : 307,
        "startColumnNumber" : 10,
        "endLineNumber" : 309,
        "endColumnNumber" : 45
      },
      "nodeContext" : "builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 195,
        "startLineNumber" : 307,
        "startColumnNumber" : 10,
        "endLineNumber" : 310,
        "endColumnNumber" : 58
      },
      "nodeContext" : "builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 17,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 222,
        "startLineNumber" : 307,
        "startColumnNumber" : 10,
        "endLineNumber" : 311,
        "endColumnNumber" : 26
      },
      "nodeContext" : "builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.')",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 20,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 269,
        "startLineNumber" : 307,
        "startColumnNumber" : 10,
        "endLineNumber" : 312,
        "endColumnNumber" : 46
      },
      "nodeContext" : "builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 25,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 296,
        "startLineNumber" : 307,
        "startColumnNumber" : 10,
        "endLineNumber" : 313,
        "endColumnNumber" : 26
      },
      "nodeContext" : "builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')')",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 28,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 297,
        "startLineNumber" : 307,
        "startColumnNumber" : 10,
        "endLineNumber" : 313,
        "endColumnNumber" : 27
      },
      "nodeContext" : "builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 29,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1549,
        "startLineNumber" : 305,
        "startColumnNumber" : 35,
        "endLineNumber" : 340,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  StringBuilder builder=new StringBuilder();\n  builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n  for (int j=0; j < parameters.length; j++) {\n    Parameter parameter=parameters[j];\n    builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n    if (parameter == null) {\n      builder.append(\"did not match any listener parameters\");\n    }\n else {\n      builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n    }\n  }\n  builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n  for (  String parameterType : listener.getParameterTypes()) {\n    builder.append(\"\\n  \").append(parameterType);\n  }\n  builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n  error(executableElement,builder.toString());\n  return;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 162,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1576,
        "startLineNumber" : 305,
        "startColumnNumber" : 8,
        "endLineNumber" : 340,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (parameters[i] == null) {\n  StringBuilder builder=new StringBuilder();\n  builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n  for (int j=0; j < parameters.length; j++) {\n    Parameter parameter=parameters[j];\n    builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n    if (parameter == null) {\n      builder.append(\"did not match any listener parameters\");\n    }\n else {\n      builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n    }\n  }\n  builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n  for (  String parameterType : listener.getParameterTypes()) {\n    builder.append(\"\\n  \").append(parameterType);\n  }\n  builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n  error(executableElement,builder.toString());\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 168,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2101,
        "startLineNumber" : 291,
        "startColumnNumber" : 56,
        "endLineNumber" : 341,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  VariableElement methodParameter=methodParameters.get(i);\n  TypeMirror methodParameterType=methodParameter.asType();\n  for (int j=0; j < parameterTypes.size(); j++) {\n    if (methodParameterUsed.get(j)) {\n      continue;\n    }\n    if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n      parameters[i]=new Parameter(j,methodParameterType.toString());\n      methodParameterUsed.set(j);\n      break;\n    }\n  }\n  if (parameters[i] == null) {\n    StringBuilder builder=new StringBuilder();\n    builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n    for (int j=0; j < parameters.length; j++) {\n      Parameter parameter=parameters[j];\n      builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n      if (parameter == null) {\n        builder.append(\"did not match any listener parameters\");\n      }\n else {\n        builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n      }\n    }\n    builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n    for (    String parameterType : listener.getParameterTypes()) {\n      builder.append(\"\\n  \").append(parameterType);\n    }\n    builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n    error(executableElement,builder.toString());\n    return;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 234,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2151,
        "startLineNumber" : 291,
        "startColumnNumber" : 6,
        "endLineNumber" : 341,
        "endColumnNumber" : 7
      },
      "nodeContext" : "for (int i=0; i < methodParameters.size(); i++) {\n  VariableElement methodParameter=methodParameters.get(i);\n  TypeMirror methodParameterType=methodParameter.asType();\n  for (int j=0; j < parameterTypes.size(); j++) {\n    if (methodParameterUsed.get(j)) {\n      continue;\n    }\n    if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n      parameters[i]=new Parameter(j,methodParameterType.toString());\n      methodParameterUsed.set(j);\n      break;\n    }\n  }\n  if (parameters[i] == null) {\n    StringBuilder builder=new StringBuilder();\n    builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n    for (int j=0; j < parameters.length; j++) {\n      Parameter parameter=parameters[j];\n      builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n      if (parameter == null) {\n        builder.append(\"did not match any listener parameters\");\n      }\n else {\n        builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n      }\n    }\n    builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n    for (    String parameterType : listener.getParameterTypes()) {\n      builder.append(\"\\n  \").append(parameterType);\n    }\n    builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n    error(executableElement,builder.toString());\n    return;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 247,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2362,
        "startLineNumber" : 287,
        "startColumnNumber" : 37,
        "endLineNumber" : 342,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  parameters=new Parameter[methodParameters.size()];\n  BitSet methodParameterUsed=new BitSet(methodParameters.size());\n  List<String> parameterTypes=listener.getParameterTypes();\n  for (int i=0; i < methodParameters.size(); i++) {\n    VariableElement methodParameter=methodParameters.get(i);\n    TypeMirror methodParameterType=methodParameter.asType();\n    for (int j=0; j < parameterTypes.size(); j++) {\n      if (methodParameterUsed.get(j)) {\n        continue;\n      }\n      if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n        parameters[i]=new Parameter(j,methodParameterType.toString());\n        methodParameterUsed.set(j);\n        break;\n      }\n    }\n    if (parameters[i] == null) {\n      StringBuilder builder=new StringBuilder();\n      builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n      for (int j=0; j < parameters.length; j++) {\n        Parameter parameter=parameters[j];\n        builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n        if (parameter == null) {\n          builder.append(\"did not match any listener parameters\");\n        }\n else {\n          builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n        }\n      }\n      builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n      for (      String parameterType : listener.getParameterTypes()) {\n        builder.append(\"\\n  \").append(parameterType);\n      }\n      builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n      error(executableElement,builder.toString());\n      return;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 281,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2395,
        "startLineNumber" : 287,
        "startColumnNumber" : 4,
        "endLineNumber" : 342,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (!methodParameters.isEmpty()) {\n  parameters=new Parameter[methodParameters.size()];\n  BitSet methodParameterUsed=new BitSet(methodParameters.size());\n  List<String> parameterTypes=listener.getParameterTypes();\n  for (int i=0; i < methodParameters.size(); i++) {\n    VariableElement methodParameter=methodParameters.get(i);\n    TypeMirror methodParameterType=methodParameter.asType();\n    for (int j=0; j < parameterTypes.size(); j++) {\n      if (methodParameterUsed.get(j)) {\n        continue;\n      }\n      if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n        parameters[i]=new Parameter(j,methodParameterType.toString());\n        methodParameterUsed.set(j);\n        break;\n      }\n    }\n    if (parameters[i] == null) {\n      StringBuilder builder=new StringBuilder();\n      builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n      for (int j=0; j < parameters.length; j++) {\n        Parameter parameter=parameters[j];\n        builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n        if (parameter == null) {\n          builder.append(\"did not match any listener parameters\");\n        }\n else {\n          builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n        }\n      }\n      builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n      for (      String parameterType : listener.getParameterTypes()) {\n        builder.append(\"\\n  \").append(parameterType);\n      }\n      builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n      error(executableElement,builder.toString());\n      return;\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 286,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 308,
        "startColumnNumber" : 22,
        "endLineNumber" : 308,
        "endColumnNumber" : 53
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  }, {
    "nodeContext" : "annotationClass",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 15,
      "startLineNumber" : 348,
      "startColumnNumber" : 12,
      "endLineNumber" : 348,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 348,
        "startColumnNumber" : 12,
        "endLineNumber" : 348,
        "endColumnNumber" : 43
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 150,
        "startLineNumber" : 347,
        "startColumnNumber" : 8,
        "endLineNumber" : 348,
        "endColumnNumber" : 85
      },
      "nodeContext" : "error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 151,
        "startLineNumber" : 347,
        "startColumnNumber" : 8,
        "endLineNumber" : 348,
        "endColumnNumber" : 86
      },
      "nodeContext" : "error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 185,
        "startLineNumber" : 346,
        "startColumnNumber" : 92,
        "endLineNumber" : 350,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n  return;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 271,
        "startLineNumber" : 346,
        "startColumnNumber" : 6,
        "endLineNumber" : 350,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n  error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 27,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 285,
        "startLineNumber" : 345,
        "startColumnNumber" : 23,
        "endLineNumber" : 351,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n    error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n    return;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 28,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 304,
        "startLineNumber" : 345,
        "startColumnNumber" : 4,
        "endLineNumber" : 351,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (int id : ids) {\n  if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n    error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n    return;\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 33,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6627,
        "startLineNumber" : 208,
        "startColumnNumber" : 23,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 716,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6837,
        "startLineNumber" : 206,
        "startColumnNumber" : 2,
        "endLineNumber" : 356,
        "endColumnNumber" : 3
      },
      "nodeContext" : "private void parseListenerAnnotation(Class<? extends Annotation> annotationClass,Element element,Map<TypeElement,ViewInjector> targetClassMap,Set<TypeMirror> erasedTargetTypes) throws Exception {\n  if (!(element instanceof ExecutableElement) || element.getKind() != METHOD) {\n    error(element,\"@%s annotation must be on a method.\",annotationClass.getSimpleName());\n    return;\n  }\n  ExecutableElement executableElement=(ExecutableElement)element;\n  TypeElement enclosingElement=(TypeElement)element.getEnclosingElement();\n  Annotation annotation=element.getAnnotation(annotationClass);\n  Method annotationValue=annotationClass.getDeclaredMethod(\"value\");\n  if (annotationValue == null || annotationValue.getReturnType() != int[].class) {\n    error(element,\"@%s annotation lacks int[] value property. (%s.%s)\",annotationClass,enclosingElement.getQualifiedName(),element.getSimpleName());\n    return;\n  }\n  int[] ids=(int[])annotationValue.invoke(annotation);\n  String name=executableElement.getSimpleName().toString();\n  boolean required=element.getAnnotation(Optional.class) == null;\n  boolean hasError=isValidForGeneratedCode(annotationClass,\"methods\",element);\n  Set<Integer> seenIds=new LinkedHashSet<Integer>(ids.length);\n  for (  int id : ids) {\n    if (!seenIds.add(id)) {\n      error(element,\"@%s annotation for method contains duplicate ID %d. (%s.%s)\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName(),element.getSimpleName());\n      hasError=true;\n    }\n  }\n  ListenerClass listenerClass=annotationClass.getAnnotation(ListenerClass.class);\n  if (listenerClass == null) {\n    error(element,\"No @%s defined on @%s.\",ListenerClass.class.getSimpleName(),annotationClass.getSimpleName());\n    return;\n  }\n  Class<?> listenerClassClass=listenerClass.value();\n  Listener listener=LISTENER_MAP.get(listenerClassClass);\n  if (listener == null) {\n    try {\n      listener=Listener.from(listenerClassClass);\n      LISTENER_MAP.put(listenerClassClass,listener);\n    }\n catch (    IllegalArgumentException e) {\n      error(elementUtils.getTypeElement(annotationClass.getName()),\"%s (%s on @%s)\",e.getMessage(),listenerClassClass.getName(),annotationClass.getName());\n      return;\n    }\n  }\n  List<? extends VariableElement> methodParameters=executableElement.getParameters();\n  if (methodParameters.size() > listener.getParameterTypes().size()) {\n    error(element,\"@%s methods can have at most %s parameter(s). (%s.%s)\",annotationClass.getSimpleName(),listener.getParameterTypes().size(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (!executableElement.getReturnType().toString().equals(listener.getReturnType())) {\n    error(element,\"@%s methods must have a '%s' return type. (%s.%s)\",annotationClass.getSimpleName(),listener.getReturnType(),enclosingElement.getQualifiedName(),element.getSimpleName());\n    hasError=true;\n  }\n  if (hasError) {\n    return;\n  }\n  Parameter[] parameters=Parameter.NONE;\n  if (!methodParameters.isEmpty()) {\n    parameters=new Parameter[methodParameters.size()];\n    BitSet methodParameterUsed=new BitSet(methodParameters.size());\n    List<String> parameterTypes=listener.getParameterTypes();\n    for (int i=0; i < methodParameters.size(); i++) {\n      VariableElement methodParameter=methodParameters.get(i);\n      TypeMirror methodParameterType=methodParameter.asType();\n      for (int j=0; j < parameterTypes.size(); j++) {\n        if (methodParameterUsed.get(j)) {\n          continue;\n        }\n        if (isSubtypeOfType(methodParameterType,parameterTypes.get(j))) {\n          parameters[i]=new Parameter(j,methodParameterType.toString());\n          methodParameterUsed.set(j);\n          break;\n        }\n      }\n      if (parameters[i] == null) {\n        StringBuilder builder=new StringBuilder();\n        builder.append(\"Unable to match @\").append(annotationClass.getSimpleName()).append(\" method arguments. (\").append(enclosingElement.getQualifiedName()).append('.').append(element.getSimpleName()).append(')');\n        for (int j=0; j < parameters.length; j++) {\n          Parameter parameter=parameters[j];\n          builder.append(\"\\n\\n  Parameter #\").append(j + 1).append(\": \").append(methodParameters.get(j).asType().toString()).append(\"\\n    \");\n          if (parameter == null) {\n            builder.append(\"did not match any listener parameters\");\n          }\n else {\n            builder.append(\"matched listener parameter #\").append(parameter.getListenerPosition() + 1).append(\": \").append(parameter.getType());\n          }\n        }\n        builder.append(\"\\n\\nMethods may have up to \").append(listener.getParameterTypes().size()).append(\" parameter(s):\\n\");\n        for (        String parameterType : listener.getParameterTypes()) {\n          builder.append(\"\\n  \").append(parameterType);\n        }\n        builder.append(\"\\n\\nThese may be listed in any order but will be searched for from top to bottom.\");\n        error(executableElement,builder.toString());\n        return;\n      }\n    }\n  }\n  ViewInjector viewInjector=getOrCreateTargetClass(targetClassMap,enclosingElement);\n  for (  int id : ids) {\n    if (!viewInjector.addMethod(id,listener,name,Arrays.asList(parameters),required)) {\n      error(element,\"Multiple @%s methods declared for ID %s in %s.\",annotationClass.getSimpleName(),id,enclosingElement.getQualifiedName());\n      return;\n    }\n  }\n  TypeMirror erasedTargetType=typeUtils.erasure(enclosingElement.asType());\n  erasedTargetTypes.add(erasedTargetType);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 750,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 348,
        "startColumnNumber" : 12,
        "endLineNumber" : 348,
        "endColumnNumber" : 43
      },
      "nodeContext" : "annotationClass.getSimpleName()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "java.lang.Class<>"
  } ],
  "positionList" : [ {
    "charLength" : 15,
    "startLineNumber" : 211,
    "startColumnNumber" : 60,
    "endLineNumber" : 211,
    "endColumnNumber" : 75
  }, {
    "charLength" : 15,
    "startLineNumber" : 219,
    "startColumnNumber" : 50,
    "endLineNumber" : 219,
    "endColumnNumber" : 65
  }, {
    "charLength" : 15,
    "startLineNumber" : 220,
    "startColumnNumber" : 29,
    "endLineNumber" : 220,
    "endColumnNumber" : 44
  }, {
    "charLength" : 15,
    "startLineNumber" : 222,
    "startColumnNumber" : 75,
    "endLineNumber" : 222,
    "endColumnNumber" : 90
  }, {
    "charLength" : 15,
    "startLineNumber" : 232,
    "startColumnNumber" : 47,
    "endLineNumber" : 232,
    "endColumnNumber" : 62
  }, {
    "charLength" : 15,
    "startLineNumber" : 238,
    "startColumnNumber" : 12,
    "endLineNumber" : 238,
    "endColumnNumber" : 27
  }, {
    "charLength" : 15,
    "startLineNumber" : 244,
    "startColumnNumber" : 34,
    "endLineNumber" : 244,
    "endColumnNumber" : 49
  }, {
    "charLength" : 15,
    "startLineNumber" : 247,
    "startColumnNumber" : 10,
    "endLineNumber" : 247,
    "endColumnNumber" : 25
  }, {
    "charLength" : 15,
    "startLineNumber" : 259,
    "startColumnNumber" : 42,
    "endLineNumber" : 259,
    "endColumnNumber" : 57
  }, {
    "charLength" : 15,
    "startLineNumber" : 260,
    "startColumnNumber" : 58,
    "endLineNumber" : 260,
    "endColumnNumber" : 73
  }, {
    "charLength" : 15,
    "startLineNumber" : 269,
    "startColumnNumber" : 10,
    "endLineNumber" : 269,
    "endColumnNumber" : 25
  }, {
    "charLength" : 15,
    "startLineNumber" : 277,
    "startColumnNumber" : 10,
    "endLineNumber" : 277,
    "endColumnNumber" : 25
  }, {
    "charLength" : 15,
    "startLineNumber" : 308,
    "startColumnNumber" : 22,
    "endLineNumber" : 308,
    "endColumnNumber" : 37
  }, {
    "charLength" : 15,
    "startLineNumber" : 348,
    "startColumnNumber" : 12,
    "endLineNumber" : 348,
    "endColumnNumber" : 27
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 0,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 9,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 10,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 11,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 12,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 13,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 12,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 13,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 9,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 10,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 11,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 12,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 13,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 7,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 9,
    "layout" : 2
  }, {
    "firstKey" : 8,
    "secondKey" : 10,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 11,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 12,
    "layout" : 9
  }, {
    "firstKey" : 8,
    "secondKey" : 13,
    "layout" : 9
  }, {
    "firstKey" : 9,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 6,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 8,
    "layout" : 1
  }, {
    "firstKey" : 9,
    "secondKey" : 10,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 11,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 12,
    "layout" : 8
  }, {
    "firstKey" : 9,
    "secondKey" : 13,
    "layout" : 8
  }, {
    "firstKey" : 10,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 11,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 10,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 1,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 9,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 10,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 12,
    "layout" : 5
  }, {
    "firstKey" : 11,
    "secondKey" : 13,
    "layout" : 5
  }, {
    "firstKey" : 12,
    "secondKey" : 0,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 1,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 2,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 3,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 4,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 5,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 6,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 7,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 8,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 9,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 10,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 11,
    "layout" : 14
  }, {
    "firstKey" : 12,
    "secondKey" : 13,
    "layout" : 14
  }, {
    "firstKey" : 13,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 6,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 7,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 8,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 9,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 10,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 11,
    "layout" : 7
  }, {
    "firstKey" : 13,
    "secondKey" : 12,
    "layout" : 7
  } ]
}