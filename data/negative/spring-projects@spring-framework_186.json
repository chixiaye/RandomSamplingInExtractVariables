{
  "id" : 186,
  "expression" : "listener",
  "projectName" : "spring-projects@spring-framework",
  "commitID" : "d5dab129097f98ed3148473422eb706c20fd10c9",
  "filePath" : "/spring-jms/src/main/java/org/springframework/jms/connection/SingleConnectionFactory.java",
  "occurrences" : 4,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "listener",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 8,
      "startLineNumber" : 577,
      "startColumnNumber" : 10,
      "endLineNumber" : 577,
      "endColumnNumber" : 18
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 577,
        "startColumnNumber" : 10,
        "endLineNumber" : 577,
        "endColumnNumber" : 49
      },
      "nodeContext" : "listener != this.localExceptionListener",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 344,
        "startLineNumber" : 577,
        "startColumnNumber" : 6,
        "endLineNumber" : 585,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (listener != this.localExceptionListener) {\n  if (this.localExceptionListener != null) {\n    aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n  }\n  if (listener != null) {\n    aggregatedExceptionListener.delegates.add(listener);\n  }\n  this.localExceptionListener=listener;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 442,
        "startLineNumber" : 575,
        "startColumnNumber" : 46,
        "endLineNumber" : 587,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  ExceptionListener listener=(ExceptionListener)args[0];\n  if (listener != this.localExceptionListener) {\n    if (this.localExceptionListener != null) {\n      aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n    }\n    if (listener != null) {\n      aggregatedExceptionListener.delegates.add(listener);\n    }\n    this.localExceptionListener=listener;\n  }\n  return null;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 55,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 916,
        "startLineNumber" : 575,
        "startColumnNumber" : 5,
        "endLineNumber" : 594,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (aggregatedExceptionListener != null) {\n  ExceptionListener listener=(ExceptionListener)args[0];\n  if (listener != this.localExceptionListener) {\n    if (this.localExceptionListener != null) {\n      aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n    }\n    if (listener != null) {\n      aggregatedExceptionListener.delegates.add(listener);\n    }\n    this.localExceptionListener=listener;\n  }\n  return null;\n}\n else {\n  throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.SynchronizedStatement,body]",
      "nodePosition" : {
        "charLength" : 929,
        "startLineNumber" : 574,
        "startColumnNumber" : 37,
        "endLineNumber" : 595,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (aggregatedExceptionListener != null) {\n    ExceptionListener listener=(ExceptionListener)args[0];\n    if (listener != this.localExceptionListener) {\n      if (this.localExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      if (listener != null) {\n        aggregatedExceptionListener.delegates.add(listener);\n      }\n      this.localExceptionListener=listener;\n    }\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 74,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 962,
        "startLineNumber" : 574,
        "startColumnNumber" : 4,
        "endLineNumber" : 595,
        "endColumnNumber" : 5
      },
      "nodeContext" : "synchronized (connectionMonitor) {\n  if (aggregatedExceptionListener != null) {\n    ExceptionListener listener=(ExceptionListener)args[0];\n    if (listener != this.localExceptionListener) {\n      if (this.localExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      if (listener != null) {\n        aggregatedExceptionListener.delegates.add(listener);\n      }\n      this.localExceptionListener=listener;\n    }\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n  }\n}\n",
      "nodeType" : "SynchronizedStatement",
      "astNodeNumber" : 76,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1034,
        "startLineNumber" : 572,
        "startColumnNumber" : 77,
        "endLineNumber" : 596,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 77,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3017,
        "startLineNumber" : 572,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 332,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3534,
        "startLineNumber" : 560,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 379,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3646,
        "startLineNumber" : 557,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 392,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3808,
        "startLineNumber" : 553,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"hashCode\")) {\n  return System.identityHashCode(factory());\n}\n else if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 406,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4274,
        "startLineNumber" : 541,
        "startColumnNumber" : 3,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"equals\") && args != null) {\n  Object other=args[0];\n  if (proxy == other) {\n    return true;\n  }\n  if (other == null || !Proxy.isProxyClass(other.getClass())) {\n    return false;\n  }\n  InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n  return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n}\n else if (method.getName().equals(\"hashCode\")) {\n  return System.identityHashCode(factory());\n}\n else if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 474,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4428,
        "startLineNumber" : 540,
        "startColumnNumber" : 94,
        "endLineNumber" : 664,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (method.getName().equals(\"equals\") && args != null) {\n    Object other=args[0];\n    if (proxy == other) {\n      return true;\n    }\n    if (other == null || !Proxy.isProxyClass(other.getClass())) {\n      return false;\n    }\n    InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n    return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n  }\n else   if (method.getName().equals(\"hashCode\")) {\n    return System.identityHashCode(factory());\n  }\n else   if (method.getName().equals(\"toString\")) {\n    return \"Shared JMS Connection: \" + getConnection();\n  }\n else   if (method.getName().equals(\"setClientID\") && args != null) {\n    String currentClientId=getConnection().getClientID();\n    if (currentClientId != null && currentClientId.equals(args[0])) {\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n    }\n  }\n else   if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n      if (aggregatedExceptionListener != null) {\n        ExceptionListener listener=(ExceptionListener)args[0];\n        if (listener != this.localExceptionListener) {\n          if (this.localExceptionListener != null) {\n            aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n          }\n          if (listener != null) {\n            aggregatedExceptionListener.delegates.add(listener);\n          }\n          this.localExceptionListener=listener;\n        }\n        return null;\n      }\n else {\n        throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n      }\n    }\n  }\n else   if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        return this.localExceptionListener;\n      }\n else {\n        return getExceptionListener();\n      }\n    }\n  }\n else   if (method.getName().equals(\"start\")) {\n    localStart();\n    return null;\n  }\n else   if (method.getName().equals(\"stop\")) {\n    localStop();\n    return null;\n  }\n else   if (method.getName().equals(\"close\")) {\n    localStop();\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        if (aggregatedExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        this.localExceptionListener=null;\n      }\n    }\n    return null;\n  }\n else   if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n    Integer mode=Session.AUTO_ACKNOWLEDGE;\n    if (args != null) {\n      if (args.length == 1) {\n        mode=(Integer)args[0];\n      }\n else       if (args.length == 2) {\n        boolean transacted=(Boolean)args[0];\n        Integer ackMode=(Integer)args[1];\n        mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n      }\n    }\n    Session session=getSession(getConnection(),mode);\n    if (session != null) {\n      if (!method.getReturnType().isInstance(session)) {\n        String msg=\"JMS Session does not implement specific domain: \" + session;\n        try {\n          session.close();\n        }\n catch (        Throwable ex) {\n          logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n        }\n        throw new javax.jms.IllegalStateException(msg);\n      }\n      return session;\n    }\n  }\n  try {\n    return method.invoke(getConnection(),args);\n  }\n catch (  InvocationTargetException ex) {\n    throw ex.getTargetException();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 494,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4544,
        "startLineNumber" : 538,
        "startColumnNumber" : 2,
        "endLineNumber" : 664,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@Override @Nullable public Object invoke(Object proxy,Method method,@Nullable Object[] args) throws Throwable {\n  if (method.getName().equals(\"equals\") && args != null) {\n    Object other=args[0];\n    if (proxy == other) {\n      return true;\n    }\n    if (other == null || !Proxy.isProxyClass(other.getClass())) {\n      return false;\n    }\n    InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n    return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n  }\n else   if (method.getName().equals(\"hashCode\")) {\n    return System.identityHashCode(factory());\n  }\n else   if (method.getName().equals(\"toString\")) {\n    return \"Shared JMS Connection: \" + getConnection();\n  }\n else   if (method.getName().equals(\"setClientID\") && args != null) {\n    String currentClientId=getConnection().getClientID();\n    if (currentClientId != null && currentClientId.equals(args[0])) {\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n    }\n  }\n else   if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n      if (aggregatedExceptionListener != null) {\n        ExceptionListener listener=(ExceptionListener)args[0];\n        if (listener != this.localExceptionListener) {\n          if (this.localExceptionListener != null) {\n            aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n          }\n          if (listener != null) {\n            aggregatedExceptionListener.delegates.add(listener);\n          }\n          this.localExceptionListener=listener;\n        }\n        return null;\n      }\n else {\n        throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n      }\n    }\n  }\n else   if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        return this.localExceptionListener;\n      }\n else {\n        return getExceptionListener();\n      }\n    }\n  }\n else   if (method.getName().equals(\"start\")) {\n    localStart();\n    return null;\n  }\n else   if (method.getName().equals(\"stop\")) {\n    localStop();\n    return null;\n  }\n else   if (method.getName().equals(\"close\")) {\n    localStop();\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        if (aggregatedExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        this.localExceptionListener=null;\n      }\n    }\n    return null;\n  }\n else   if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n    Integer mode=Session.AUTO_ACKNOWLEDGE;\n    if (args != null) {\n      if (args.length == 1) {\n        mode=(Integer)args[0];\n      }\n else       if (args.length == 2) {\n        boolean transacted=(Boolean)args[0];\n        Integer ackMode=(Integer)args[1];\n        mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n      }\n    }\n    Session session=getSession(getConnection(),mode);\n    if (session != null) {\n      if (!method.getReturnType().isInstance(session)) {\n        String msg=\"JMS Session does not implement specific domain: \" + session;\n        try {\n          session.close();\n        }\n catch (        Throwable ex) {\n          logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n        }\n        throw new javax.jms.IllegalStateException(msg);\n      }\n      return session;\n    }\n  }\n  try {\n    return method.invoke(getConnection(),args);\n  }\n catch (  InvocationTargetException ex) {\n    throw ex.getTargetException();\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 521,
      "astHeight" : 24
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 577,
        "startColumnNumber" : 10,
        "endLineNumber" : 577,
        "endColumnNumber" : 49
      },
      "nodeContext" : "listener != this.localExceptionListener",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "org.springframework.jms.connection.ExceptionListener"
  }, {
    "nodeContext" : "listener",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 8,
      "startLineNumber" : 581,
      "startColumnNumber" : 11,
      "endLineNumber" : 581,
      "endColumnNumber" : 19
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 16,
        "startLineNumber" : 581,
        "startColumnNumber" : 11,
        "endLineNumber" : 581,
        "endColumnNumber" : 27
      },
      "nodeContext" : "listener != null",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 581,
        "startColumnNumber" : 7,
        "endLineNumber" : 583,
        "endColumnNumber" : 8
      },
      "nodeContext" : "if (listener != null) {\n  aggregatedExceptionListener.delegates.add(listener);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 12,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 299,
        "startLineNumber" : 577,
        "startColumnNumber" : 51,
        "endLineNumber" : 585,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  if (this.localExceptionListener != null) {\n    aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n  }\n  if (listener != null) {\n    aggregatedExceptionListener.delegates.add(listener);\n  }\n  this.localExceptionListener=listener;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 35,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 344,
        "startLineNumber" : 577,
        "startColumnNumber" : 6,
        "endLineNumber" : 585,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (listener != this.localExceptionListener) {\n  if (this.localExceptionListener != null) {\n    aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n  }\n  if (listener != null) {\n    aggregatedExceptionListener.delegates.add(listener);\n  }\n  this.localExceptionListener=listener;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 442,
        "startLineNumber" : 575,
        "startColumnNumber" : 46,
        "endLineNumber" : 587,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  ExceptionListener listener=(ExceptionListener)args[0];\n  if (listener != this.localExceptionListener) {\n    if (this.localExceptionListener != null) {\n      aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n    }\n    if (listener != null) {\n      aggregatedExceptionListener.delegates.add(listener);\n    }\n    this.localExceptionListener=listener;\n  }\n  return null;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 55,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 916,
        "startLineNumber" : 575,
        "startColumnNumber" : 5,
        "endLineNumber" : 594,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (aggregatedExceptionListener != null) {\n  ExceptionListener listener=(ExceptionListener)args[0];\n  if (listener != this.localExceptionListener) {\n    if (this.localExceptionListener != null) {\n      aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n    }\n    if (listener != null) {\n      aggregatedExceptionListener.delegates.add(listener);\n    }\n    this.localExceptionListener=listener;\n  }\n  return null;\n}\n else {\n  throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.SynchronizedStatement,body]",
      "nodePosition" : {
        "charLength" : 929,
        "startLineNumber" : 574,
        "startColumnNumber" : 37,
        "endLineNumber" : 595,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (aggregatedExceptionListener != null) {\n    ExceptionListener listener=(ExceptionListener)args[0];\n    if (listener != this.localExceptionListener) {\n      if (this.localExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      if (listener != null) {\n        aggregatedExceptionListener.delegates.add(listener);\n      }\n      this.localExceptionListener=listener;\n    }\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 74,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 962,
        "startLineNumber" : 574,
        "startColumnNumber" : 4,
        "endLineNumber" : 595,
        "endColumnNumber" : 5
      },
      "nodeContext" : "synchronized (connectionMonitor) {\n  if (aggregatedExceptionListener != null) {\n    ExceptionListener listener=(ExceptionListener)args[0];\n    if (listener != this.localExceptionListener) {\n      if (this.localExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      if (listener != null) {\n        aggregatedExceptionListener.delegates.add(listener);\n      }\n      this.localExceptionListener=listener;\n    }\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n  }\n}\n",
      "nodeType" : "SynchronizedStatement",
      "astNodeNumber" : 76,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1034,
        "startLineNumber" : 572,
        "startColumnNumber" : 77,
        "endLineNumber" : 596,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 77,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3017,
        "startLineNumber" : 572,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 332,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3534,
        "startLineNumber" : 560,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 379,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3646,
        "startLineNumber" : 557,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 392,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3808,
        "startLineNumber" : 553,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"hashCode\")) {\n  return System.identityHashCode(factory());\n}\n else if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 406,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4274,
        "startLineNumber" : 541,
        "startColumnNumber" : 3,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"equals\") && args != null) {\n  Object other=args[0];\n  if (proxy == other) {\n    return true;\n  }\n  if (other == null || !Proxy.isProxyClass(other.getClass())) {\n    return false;\n  }\n  InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n  return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n}\n else if (method.getName().equals(\"hashCode\")) {\n  return System.identityHashCode(factory());\n}\n else if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 474,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4428,
        "startLineNumber" : 540,
        "startColumnNumber" : 94,
        "endLineNumber" : 664,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (method.getName().equals(\"equals\") && args != null) {\n    Object other=args[0];\n    if (proxy == other) {\n      return true;\n    }\n    if (other == null || !Proxy.isProxyClass(other.getClass())) {\n      return false;\n    }\n    InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n    return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n  }\n else   if (method.getName().equals(\"hashCode\")) {\n    return System.identityHashCode(factory());\n  }\n else   if (method.getName().equals(\"toString\")) {\n    return \"Shared JMS Connection: \" + getConnection();\n  }\n else   if (method.getName().equals(\"setClientID\") && args != null) {\n    String currentClientId=getConnection().getClientID();\n    if (currentClientId != null && currentClientId.equals(args[0])) {\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n    }\n  }\n else   if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n      if (aggregatedExceptionListener != null) {\n        ExceptionListener listener=(ExceptionListener)args[0];\n        if (listener != this.localExceptionListener) {\n          if (this.localExceptionListener != null) {\n            aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n          }\n          if (listener != null) {\n            aggregatedExceptionListener.delegates.add(listener);\n          }\n          this.localExceptionListener=listener;\n        }\n        return null;\n      }\n else {\n        throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n      }\n    }\n  }\n else   if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        return this.localExceptionListener;\n      }\n else {\n        return getExceptionListener();\n      }\n    }\n  }\n else   if (method.getName().equals(\"start\")) {\n    localStart();\n    return null;\n  }\n else   if (method.getName().equals(\"stop\")) {\n    localStop();\n    return null;\n  }\n else   if (method.getName().equals(\"close\")) {\n    localStop();\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        if (aggregatedExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        this.localExceptionListener=null;\n      }\n    }\n    return null;\n  }\n else   if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n    Integer mode=Session.AUTO_ACKNOWLEDGE;\n    if (args != null) {\n      if (args.length == 1) {\n        mode=(Integer)args[0];\n      }\n else       if (args.length == 2) {\n        boolean transacted=(Boolean)args[0];\n        Integer ackMode=(Integer)args[1];\n        mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n      }\n    }\n    Session session=getSession(getConnection(),mode);\n    if (session != null) {\n      if (!method.getReturnType().isInstance(session)) {\n        String msg=\"JMS Session does not implement specific domain: \" + session;\n        try {\n          session.close();\n        }\n catch (        Throwable ex) {\n          logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n        }\n        throw new javax.jms.IllegalStateException(msg);\n      }\n      return session;\n    }\n  }\n  try {\n    return method.invoke(getConnection(),args);\n  }\n catch (  InvocationTargetException ex) {\n    throw ex.getTargetException();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 494,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4544,
        "startLineNumber" : 538,
        "startColumnNumber" : 2,
        "endLineNumber" : 664,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@Override @Nullable public Object invoke(Object proxy,Method method,@Nullable Object[] args) throws Throwable {\n  if (method.getName().equals(\"equals\") && args != null) {\n    Object other=args[0];\n    if (proxy == other) {\n      return true;\n    }\n    if (other == null || !Proxy.isProxyClass(other.getClass())) {\n      return false;\n    }\n    InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n    return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n  }\n else   if (method.getName().equals(\"hashCode\")) {\n    return System.identityHashCode(factory());\n  }\n else   if (method.getName().equals(\"toString\")) {\n    return \"Shared JMS Connection: \" + getConnection();\n  }\n else   if (method.getName().equals(\"setClientID\") && args != null) {\n    String currentClientId=getConnection().getClientID();\n    if (currentClientId != null && currentClientId.equals(args[0])) {\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n    }\n  }\n else   if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n      if (aggregatedExceptionListener != null) {\n        ExceptionListener listener=(ExceptionListener)args[0];\n        if (listener != this.localExceptionListener) {\n          if (this.localExceptionListener != null) {\n            aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n          }\n          if (listener != null) {\n            aggregatedExceptionListener.delegates.add(listener);\n          }\n          this.localExceptionListener=listener;\n        }\n        return null;\n      }\n else {\n        throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n      }\n    }\n  }\n else   if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        return this.localExceptionListener;\n      }\n else {\n        return getExceptionListener();\n      }\n    }\n  }\n else   if (method.getName().equals(\"start\")) {\n    localStart();\n    return null;\n  }\n else   if (method.getName().equals(\"stop\")) {\n    localStop();\n    return null;\n  }\n else   if (method.getName().equals(\"close\")) {\n    localStop();\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        if (aggregatedExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        this.localExceptionListener=null;\n      }\n    }\n    return null;\n  }\n else   if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n    Integer mode=Session.AUTO_ACKNOWLEDGE;\n    if (args != null) {\n      if (args.length == 1) {\n        mode=(Integer)args[0];\n      }\n else       if (args.length == 2) {\n        boolean transacted=(Boolean)args[0];\n        Integer ackMode=(Integer)args[1];\n        mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n      }\n    }\n    Session session=getSession(getConnection(),mode);\n    if (session != null) {\n      if (!method.getReturnType().isInstance(session)) {\n        String msg=\"JMS Session does not implement specific domain: \" + session;\n        try {\n          session.close();\n        }\n catch (        Throwable ex) {\n          logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n        }\n        throw new javax.jms.IllegalStateException(msg);\n      }\n      return session;\n    }\n  }\n  try {\n    return method.invoke(getConnection(),args);\n  }\n catch (  InvocationTargetException ex) {\n    throw ex.getTargetException();\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 521,
      "astHeight" : 24
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 16,
        "startLineNumber" : 581,
        "startColumnNumber" : 11,
        "endLineNumber" : 581,
        "endColumnNumber" : 27
      },
      "nodeContext" : "listener != null",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "org.springframework.jms.connection.ExceptionListener"
  }, {
    "nodeContext" : "listener",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 8,
      "startLineNumber" : 582,
      "startColumnNumber" : 50,
      "endLineNumber" : 582,
      "endColumnNumber" : 58
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 582,
        "startColumnNumber" : 8,
        "endLineNumber" : 582,
        "endColumnNumber" : 59
      },
      "nodeContext" : "aggregatedExceptionListener.delegates.add(listener)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 582,
        "startColumnNumber" : 8,
        "endLineNumber" : 582,
        "endColumnNumber" : 60
      },
      "nodeContext" : "aggregatedExceptionListener.delegates.add(listener);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 581,
        "startColumnNumber" : 29,
        "endLineNumber" : 583,
        "endColumnNumber" : 8
      },
      "nodeContext" : "{\n  aggregatedExceptionListener.delegates.add(listener);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 93,
        "startLineNumber" : 581,
        "startColumnNumber" : 7,
        "endLineNumber" : 583,
        "endColumnNumber" : 8
      },
      "nodeContext" : "if (listener != null) {\n  aggregatedExceptionListener.delegates.add(listener);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 12,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 299,
        "startLineNumber" : 577,
        "startColumnNumber" : 51,
        "endLineNumber" : 585,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  if (this.localExceptionListener != null) {\n    aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n  }\n  if (listener != null) {\n    aggregatedExceptionListener.delegates.add(listener);\n  }\n  this.localExceptionListener=listener;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 35,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 344,
        "startLineNumber" : 577,
        "startColumnNumber" : 6,
        "endLineNumber" : 585,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (listener != this.localExceptionListener) {\n  if (this.localExceptionListener != null) {\n    aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n  }\n  if (listener != null) {\n    aggregatedExceptionListener.delegates.add(listener);\n  }\n  this.localExceptionListener=listener;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 442,
        "startLineNumber" : 575,
        "startColumnNumber" : 46,
        "endLineNumber" : 587,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  ExceptionListener listener=(ExceptionListener)args[0];\n  if (listener != this.localExceptionListener) {\n    if (this.localExceptionListener != null) {\n      aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n    }\n    if (listener != null) {\n      aggregatedExceptionListener.delegates.add(listener);\n    }\n    this.localExceptionListener=listener;\n  }\n  return null;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 55,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 916,
        "startLineNumber" : 575,
        "startColumnNumber" : 5,
        "endLineNumber" : 594,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (aggregatedExceptionListener != null) {\n  ExceptionListener listener=(ExceptionListener)args[0];\n  if (listener != this.localExceptionListener) {\n    if (this.localExceptionListener != null) {\n      aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n    }\n    if (listener != null) {\n      aggregatedExceptionListener.delegates.add(listener);\n    }\n    this.localExceptionListener=listener;\n  }\n  return null;\n}\n else {\n  throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.SynchronizedStatement,body]",
      "nodePosition" : {
        "charLength" : 929,
        "startLineNumber" : 574,
        "startColumnNumber" : 37,
        "endLineNumber" : 595,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (aggregatedExceptionListener != null) {\n    ExceptionListener listener=(ExceptionListener)args[0];\n    if (listener != this.localExceptionListener) {\n      if (this.localExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      if (listener != null) {\n        aggregatedExceptionListener.delegates.add(listener);\n      }\n      this.localExceptionListener=listener;\n    }\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 74,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 962,
        "startLineNumber" : 574,
        "startColumnNumber" : 4,
        "endLineNumber" : 595,
        "endColumnNumber" : 5
      },
      "nodeContext" : "synchronized (connectionMonitor) {\n  if (aggregatedExceptionListener != null) {\n    ExceptionListener listener=(ExceptionListener)args[0];\n    if (listener != this.localExceptionListener) {\n      if (this.localExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      if (listener != null) {\n        aggregatedExceptionListener.delegates.add(listener);\n      }\n      this.localExceptionListener=listener;\n    }\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n  }\n}\n",
      "nodeType" : "SynchronizedStatement",
      "astNodeNumber" : 76,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1034,
        "startLineNumber" : 572,
        "startColumnNumber" : 77,
        "endLineNumber" : 596,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 77,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3017,
        "startLineNumber" : 572,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 332,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3534,
        "startLineNumber" : 560,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 379,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3646,
        "startLineNumber" : 557,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 392,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3808,
        "startLineNumber" : 553,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"hashCode\")) {\n  return System.identityHashCode(factory());\n}\n else if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 406,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4274,
        "startLineNumber" : 541,
        "startColumnNumber" : 3,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"equals\") && args != null) {\n  Object other=args[0];\n  if (proxy == other) {\n    return true;\n  }\n  if (other == null || !Proxy.isProxyClass(other.getClass())) {\n    return false;\n  }\n  InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n  return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n}\n else if (method.getName().equals(\"hashCode\")) {\n  return System.identityHashCode(factory());\n}\n else if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 474,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4428,
        "startLineNumber" : 540,
        "startColumnNumber" : 94,
        "endLineNumber" : 664,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (method.getName().equals(\"equals\") && args != null) {\n    Object other=args[0];\n    if (proxy == other) {\n      return true;\n    }\n    if (other == null || !Proxy.isProxyClass(other.getClass())) {\n      return false;\n    }\n    InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n    return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n  }\n else   if (method.getName().equals(\"hashCode\")) {\n    return System.identityHashCode(factory());\n  }\n else   if (method.getName().equals(\"toString\")) {\n    return \"Shared JMS Connection: \" + getConnection();\n  }\n else   if (method.getName().equals(\"setClientID\") && args != null) {\n    String currentClientId=getConnection().getClientID();\n    if (currentClientId != null && currentClientId.equals(args[0])) {\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n    }\n  }\n else   if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n      if (aggregatedExceptionListener != null) {\n        ExceptionListener listener=(ExceptionListener)args[0];\n        if (listener != this.localExceptionListener) {\n          if (this.localExceptionListener != null) {\n            aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n          }\n          if (listener != null) {\n            aggregatedExceptionListener.delegates.add(listener);\n          }\n          this.localExceptionListener=listener;\n        }\n        return null;\n      }\n else {\n        throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n      }\n    }\n  }\n else   if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        return this.localExceptionListener;\n      }\n else {\n        return getExceptionListener();\n      }\n    }\n  }\n else   if (method.getName().equals(\"start\")) {\n    localStart();\n    return null;\n  }\n else   if (method.getName().equals(\"stop\")) {\n    localStop();\n    return null;\n  }\n else   if (method.getName().equals(\"close\")) {\n    localStop();\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        if (aggregatedExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        this.localExceptionListener=null;\n      }\n    }\n    return null;\n  }\n else   if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n    Integer mode=Session.AUTO_ACKNOWLEDGE;\n    if (args != null) {\n      if (args.length == 1) {\n        mode=(Integer)args[0];\n      }\n else       if (args.length == 2) {\n        boolean transacted=(Boolean)args[0];\n        Integer ackMode=(Integer)args[1];\n        mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n      }\n    }\n    Session session=getSession(getConnection(),mode);\n    if (session != null) {\n      if (!method.getReturnType().isInstance(session)) {\n        String msg=\"JMS Session does not implement specific domain: \" + session;\n        try {\n          session.close();\n        }\n catch (        Throwable ex) {\n          logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n        }\n        throw new javax.jms.IllegalStateException(msg);\n      }\n      return session;\n    }\n  }\n  try {\n    return method.invoke(getConnection(),args);\n  }\n catch (  InvocationTargetException ex) {\n    throw ex.getTargetException();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 494,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4544,
        "startLineNumber" : 538,
        "startColumnNumber" : 2,
        "endLineNumber" : 664,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@Override @Nullable public Object invoke(Object proxy,Method method,@Nullable Object[] args) throws Throwable {\n  if (method.getName().equals(\"equals\") && args != null) {\n    Object other=args[0];\n    if (proxy == other) {\n      return true;\n    }\n    if (other == null || !Proxy.isProxyClass(other.getClass())) {\n      return false;\n    }\n    InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n    return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n  }\n else   if (method.getName().equals(\"hashCode\")) {\n    return System.identityHashCode(factory());\n  }\n else   if (method.getName().equals(\"toString\")) {\n    return \"Shared JMS Connection: \" + getConnection();\n  }\n else   if (method.getName().equals(\"setClientID\") && args != null) {\n    String currentClientId=getConnection().getClientID();\n    if (currentClientId != null && currentClientId.equals(args[0])) {\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n    }\n  }\n else   if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n      if (aggregatedExceptionListener != null) {\n        ExceptionListener listener=(ExceptionListener)args[0];\n        if (listener != this.localExceptionListener) {\n          if (this.localExceptionListener != null) {\n            aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n          }\n          if (listener != null) {\n            aggregatedExceptionListener.delegates.add(listener);\n          }\n          this.localExceptionListener=listener;\n        }\n        return null;\n      }\n else {\n        throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n      }\n    }\n  }\n else   if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        return this.localExceptionListener;\n      }\n else {\n        return getExceptionListener();\n      }\n    }\n  }\n else   if (method.getName().equals(\"start\")) {\n    localStart();\n    return null;\n  }\n else   if (method.getName().equals(\"stop\")) {\n    localStop();\n    return null;\n  }\n else   if (method.getName().equals(\"close\")) {\n    localStop();\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        if (aggregatedExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        this.localExceptionListener=null;\n      }\n    }\n    return null;\n  }\n else   if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n    Integer mode=Session.AUTO_ACKNOWLEDGE;\n    if (args != null) {\n      if (args.length == 1) {\n        mode=(Integer)args[0];\n      }\n else       if (args.length == 2) {\n        boolean transacted=(Boolean)args[0];\n        Integer ackMode=(Integer)args[1];\n        mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n      }\n    }\n    Session session=getSession(getConnection(),mode);\n    if (session != null) {\n      if (!method.getReturnType().isInstance(session)) {\n        String msg=\"JMS Session does not implement specific domain: \" + session;\n        try {\n          session.close();\n        }\n catch (        Throwable ex) {\n          logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n        }\n        throw new javax.jms.IllegalStateException(msg);\n      }\n      return session;\n    }\n  }\n  try {\n    return method.invoke(getConnection(),args);\n  }\n catch (  InvocationTargetException ex) {\n    throw ex.getTargetException();\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 521,
      "astHeight" : 24
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 582,
        "startColumnNumber" : 8,
        "endLineNumber" : 582,
        "endColumnNumber" : 60
      },
      "nodeContext" : "aggregatedExceptionListener.delegates.add(listener);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "org.springframework.jms.connection.ExceptionListener"
  }, {
    "nodeContext" : "listener",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 8,
      "startLineNumber" : 584,
      "startColumnNumber" : 37,
      "endLineNumber" : 584,
      "endColumnNumber" : 45
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 584,
        "startColumnNumber" : 7,
        "endLineNumber" : 584,
        "endColumnNumber" : 45
      },
      "nodeContext" : "this.localExceptionListener=listener",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 584,
        "startColumnNumber" : 7,
        "endLineNumber" : 584,
        "endColumnNumber" : 46
      },
      "nodeContext" : "this.localExceptionListener=listener;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 299,
        "startLineNumber" : 577,
        "startColumnNumber" : 51,
        "endLineNumber" : 585,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  if (this.localExceptionListener != null) {\n    aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n  }\n  if (listener != null) {\n    aggregatedExceptionListener.delegates.add(listener);\n  }\n  this.localExceptionListener=listener;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 35,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 344,
        "startLineNumber" : 577,
        "startColumnNumber" : 6,
        "endLineNumber" : 585,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (listener != this.localExceptionListener) {\n  if (this.localExceptionListener != null) {\n    aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n  }\n  if (listener != null) {\n    aggregatedExceptionListener.delegates.add(listener);\n  }\n  this.localExceptionListener=listener;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 41,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 442,
        "startLineNumber" : 575,
        "startColumnNumber" : 46,
        "endLineNumber" : 587,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  ExceptionListener listener=(ExceptionListener)args[0];\n  if (listener != this.localExceptionListener) {\n    if (this.localExceptionListener != null) {\n      aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n    }\n    if (listener != null) {\n      aggregatedExceptionListener.delegates.add(listener);\n    }\n    this.localExceptionListener=listener;\n  }\n  return null;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 55,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 916,
        "startLineNumber" : 575,
        "startColumnNumber" : 5,
        "endLineNumber" : 594,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (aggregatedExceptionListener != null) {\n  ExceptionListener listener=(ExceptionListener)args[0];\n  if (listener != this.localExceptionListener) {\n    if (this.localExceptionListener != null) {\n      aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n    }\n    if (listener != null) {\n      aggregatedExceptionListener.delegates.add(listener);\n    }\n    this.localExceptionListener=listener;\n  }\n  return null;\n}\n else {\n  throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.SynchronizedStatement,body]",
      "nodePosition" : {
        "charLength" : 929,
        "startLineNumber" : 574,
        "startColumnNumber" : 37,
        "endLineNumber" : 595,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (aggregatedExceptionListener != null) {\n    ExceptionListener listener=(ExceptionListener)args[0];\n    if (listener != this.localExceptionListener) {\n      if (this.localExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      if (listener != null) {\n        aggregatedExceptionListener.delegates.add(listener);\n      }\n      this.localExceptionListener=listener;\n    }\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 74,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 962,
        "startLineNumber" : 574,
        "startColumnNumber" : 4,
        "endLineNumber" : 595,
        "endColumnNumber" : 5
      },
      "nodeContext" : "synchronized (connectionMonitor) {\n  if (aggregatedExceptionListener != null) {\n    ExceptionListener listener=(ExceptionListener)args[0];\n    if (listener != this.localExceptionListener) {\n      if (this.localExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      if (listener != null) {\n        aggregatedExceptionListener.delegates.add(listener);\n      }\n      this.localExceptionListener=listener;\n    }\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n  }\n}\n",
      "nodeType" : "SynchronizedStatement",
      "astNodeNumber" : 76,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1034,
        "startLineNumber" : 572,
        "startColumnNumber" : 77,
        "endLineNumber" : 596,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 77,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3017,
        "startLineNumber" : 572,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 332,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3534,
        "startLineNumber" : 560,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 379,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3646,
        "startLineNumber" : 557,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 392,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 3808,
        "startLineNumber" : 553,
        "startColumnNumber" : 8,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"hashCode\")) {\n  return System.identityHashCode(factory());\n}\n else if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 406,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4274,
        "startLineNumber" : 541,
        "startColumnNumber" : 3,
        "endLineNumber" : 657,
        "endColumnNumber" : 4
      },
      "nodeContext" : "if (method.getName().equals(\"equals\") && args != null) {\n  Object other=args[0];\n  if (proxy == other) {\n    return true;\n  }\n  if (other == null || !Proxy.isProxyClass(other.getClass())) {\n    return false;\n  }\n  InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n  return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n}\n else if (method.getName().equals(\"hashCode\")) {\n  return System.identityHashCode(factory());\n}\n else if (method.getName().equals(\"toString\")) {\n  return \"Shared JMS Connection: \" + getConnection();\n}\n else if (method.getName().equals(\"setClientID\") && args != null) {\n  String currentClientId=getConnection().getClientID();\n  if (currentClientId != null && currentClientId.equals(args[0])) {\n    return null;\n  }\n else {\n    throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n  }\n}\n else if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n    if (aggregatedExceptionListener != null) {\n      ExceptionListener listener=(ExceptionListener)args[0];\n      if (listener != this.localExceptionListener) {\n        if (this.localExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        if (listener != null) {\n          aggregatedExceptionListener.delegates.add(listener);\n        }\n        this.localExceptionListener=listener;\n      }\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n    }\n  }\n}\n else if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      return this.localExceptionListener;\n    }\n else {\n      return getExceptionListener();\n    }\n  }\n}\n else if (method.getName().equals(\"start\")) {\n  localStart();\n  return null;\n}\n else if (method.getName().equals(\"stop\")) {\n  localStop();\n  return null;\n}\n else if (method.getName().equals(\"close\")) {\n  localStop();\nsynchronized (connectionMonitor) {\n    if (this.localExceptionListener != null) {\n      if (aggregatedExceptionListener != null) {\n        aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n      }\n      this.localExceptionListener=null;\n    }\n  }\n  return null;\n}\n else if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n  Integer mode=Session.AUTO_ACKNOWLEDGE;\n  if (args != null) {\n    if (args.length == 1) {\n      mode=(Integer)args[0];\n    }\n else     if (args.length == 2) {\n      boolean transacted=(Boolean)args[0];\n      Integer ackMode=(Integer)args[1];\n      mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n    }\n  }\n  Session session=getSession(getConnection(),mode);\n  if (session != null) {\n    if (!method.getReturnType().isInstance(session)) {\n      String msg=\"JMS Session does not implement specific domain: \" + session;\n      try {\n        session.close();\n      }\n catch (      Throwable ex) {\n        logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n      }\n      throw new javax.jms.IllegalStateException(msg);\n    }\n    return session;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 474,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4428,
        "startLineNumber" : 540,
        "startColumnNumber" : 94,
        "endLineNumber" : 664,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (method.getName().equals(\"equals\") && args != null) {\n    Object other=args[0];\n    if (proxy == other) {\n      return true;\n    }\n    if (other == null || !Proxy.isProxyClass(other.getClass())) {\n      return false;\n    }\n    InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n    return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n  }\n else   if (method.getName().equals(\"hashCode\")) {\n    return System.identityHashCode(factory());\n  }\n else   if (method.getName().equals(\"toString\")) {\n    return \"Shared JMS Connection: \" + getConnection();\n  }\n else   if (method.getName().equals(\"setClientID\") && args != null) {\n    String currentClientId=getConnection().getClientID();\n    if (currentClientId != null && currentClientId.equals(args[0])) {\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n    }\n  }\n else   if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n      if (aggregatedExceptionListener != null) {\n        ExceptionListener listener=(ExceptionListener)args[0];\n        if (listener != this.localExceptionListener) {\n          if (this.localExceptionListener != null) {\n            aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n          }\n          if (listener != null) {\n            aggregatedExceptionListener.delegates.add(listener);\n          }\n          this.localExceptionListener=listener;\n        }\n        return null;\n      }\n else {\n        throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n      }\n    }\n  }\n else   if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        return this.localExceptionListener;\n      }\n else {\n        return getExceptionListener();\n      }\n    }\n  }\n else   if (method.getName().equals(\"start\")) {\n    localStart();\n    return null;\n  }\n else   if (method.getName().equals(\"stop\")) {\n    localStop();\n    return null;\n  }\n else   if (method.getName().equals(\"close\")) {\n    localStop();\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        if (aggregatedExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        this.localExceptionListener=null;\n      }\n    }\n    return null;\n  }\n else   if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n    Integer mode=Session.AUTO_ACKNOWLEDGE;\n    if (args != null) {\n      if (args.length == 1) {\n        mode=(Integer)args[0];\n      }\n else       if (args.length == 2) {\n        boolean transacted=(Boolean)args[0];\n        Integer ackMode=(Integer)args[1];\n        mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n      }\n    }\n    Session session=getSession(getConnection(),mode);\n    if (session != null) {\n      if (!method.getReturnType().isInstance(session)) {\n        String msg=\"JMS Session does not implement specific domain: \" + session;\n        try {\n          session.close();\n        }\n catch (        Throwable ex) {\n          logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n        }\n        throw new javax.jms.IllegalStateException(msg);\n      }\n      return session;\n    }\n  }\n  try {\n    return method.invoke(getConnection(),args);\n  }\n catch (  InvocationTargetException ex) {\n    throw ex.getTargetException();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 494,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4544,
        "startLineNumber" : 538,
        "startColumnNumber" : 2,
        "endLineNumber" : 664,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@Override @Nullable public Object invoke(Object proxy,Method method,@Nullable Object[] args) throws Throwable {\n  if (method.getName().equals(\"equals\") && args != null) {\n    Object other=args[0];\n    if (proxy == other) {\n      return true;\n    }\n    if (other == null || !Proxy.isProxyClass(other.getClass())) {\n      return false;\n    }\n    InvocationHandler otherHandler=Proxy.getInvocationHandler(other);\n    return (otherHandler instanceof SharedConnectionInvocationHandler && factory() == ((SharedConnectionInvocationHandler)otherHandler).factory());\n  }\n else   if (method.getName().equals(\"hashCode\")) {\n    return System.identityHashCode(factory());\n  }\n else   if (method.getName().equals(\"toString\")) {\n    return \"Shared JMS Connection: \" + getConnection();\n  }\n else   if (method.getName().equals(\"setClientID\") && args != null) {\n    String currentClientId=getConnection().getClientID();\n    if (currentClientId != null && currentClientId.equals(args[0])) {\n      return null;\n    }\n else {\n      throw new javax.jms.IllegalStateException(\"setClientID call not supported on proxy for shared Connection. \" + \"Set the 'clientId' property on the SingleConnectionFactory instead.\");\n    }\n  }\n else   if (method.getName().equals(\"setExceptionListener\") && args != null) {\nsynchronized (connectionMonitor) {\n      if (aggregatedExceptionListener != null) {\n        ExceptionListener listener=(ExceptionListener)args[0];\n        if (listener != this.localExceptionListener) {\n          if (this.localExceptionListener != null) {\n            aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n          }\n          if (listener != null) {\n            aggregatedExceptionListener.delegates.add(listener);\n          }\n          this.localExceptionListener=listener;\n        }\n        return null;\n      }\n else {\n        throw new javax.jms.IllegalStateException(\"setExceptionListener call not supported on proxy for shared Connection. \" + \"Set the 'exceptionListener' property on the SingleConnectionFactory instead. \" + \"Alternatively, activate SingleConnectionFactory's 'reconnectOnException' feature, \"+ \"which will allow for registering further ExceptionListeners to the recovery chain.\");\n      }\n    }\n  }\n else   if (method.getName().equals(\"getExceptionListener\")) {\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        return this.localExceptionListener;\n      }\n else {\n        return getExceptionListener();\n      }\n    }\n  }\n else   if (method.getName().equals(\"start\")) {\n    localStart();\n    return null;\n  }\n else   if (method.getName().equals(\"stop\")) {\n    localStop();\n    return null;\n  }\n else   if (method.getName().equals(\"close\")) {\n    localStop();\nsynchronized (connectionMonitor) {\n      if (this.localExceptionListener != null) {\n        if (aggregatedExceptionListener != null) {\n          aggregatedExceptionListener.delegates.remove(this.localExceptionListener);\n        }\n        this.localExceptionListener=null;\n      }\n    }\n    return null;\n  }\n else   if (method.getName().equals(\"createSession\") || method.getName().equals(\"createQueueSession\") || method.getName().equals(\"createTopicSession\")) {\n    Integer mode=Session.AUTO_ACKNOWLEDGE;\n    if (args != null) {\n      if (args.length == 1) {\n        mode=(Integer)args[0];\n      }\n else       if (args.length == 2) {\n        boolean transacted=(Boolean)args[0];\n        Integer ackMode=(Integer)args[1];\n        mode=(transacted ? Session.SESSION_TRANSACTED : ackMode);\n      }\n    }\n    Session session=getSession(getConnection(),mode);\n    if (session != null) {\n      if (!method.getReturnType().isInstance(session)) {\n        String msg=\"JMS Session does not implement specific domain: \" + session;\n        try {\n          session.close();\n        }\n catch (        Throwable ex) {\n          logger.trace(\"Failed to close newly obtained JMS Session\",ex);\n        }\n        throw new javax.jms.IllegalStateException(msg);\n      }\n      return session;\n    }\n  }\n  try {\n    return method.invoke(getConnection(),args);\n  }\n catch (  InvocationTargetException ex) {\n    throw ex.getTargetException();\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 521,
      "astHeight" : 24
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 584,
        "startColumnNumber" : 7,
        "endLineNumber" : 584,
        "endColumnNumber" : 46
      },
      "nodeContext" : "this.localExceptionListener=listener;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "org.springframework.jms.connection.ExceptionListener"
  } ],
  "positionList" : [ {
    "charLength" : 8,
    "startLineNumber" : 577,
    "startColumnNumber" : 10,
    "endLineNumber" : 577,
    "endColumnNumber" : 18
  }, {
    "charLength" : 8,
    "startLineNumber" : 581,
    "startColumnNumber" : 11,
    "endLineNumber" : 581,
    "endColumnNumber" : 19
  }, {
    "charLength" : 8,
    "startLineNumber" : 582,
    "startColumnNumber" : 50,
    "endLineNumber" : 582,
    "endColumnNumber" : 58
  }, {
    "charLength" : 8,
    "startLineNumber" : 584,
    "startColumnNumber" : 37,
    "endLineNumber" : 584,
    "endColumnNumber" : 45
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 1
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 1
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 2
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 2
  } ]
}