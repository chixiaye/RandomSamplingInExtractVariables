{
  "id" : 408,
  "expression" : "\"  void enterEveryRule(ParserRuleContext *ctx) override {\\n\"",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/runtime-testsuite/test/org/antlr/v4/test/runtime/cpp/BaseCppTest.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "\"  void enterEveryRule(ParserRuleContext *ctx) override {\\n\"",
    "nodeType" : "StringLiteral",
    "nodePosition" : {
      "charLength" : 60,
      "startLineNumber" : 379,
      "startColumnNumber" : 6,
      "endLineNumber" : 379,
      "endColumnNumber" : 66
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
      "nodePosition" : {
        "charLength" : 1430,
        "startLineNumber" : 366,
        "startColumnNumber" : 3,
        "endLineNumber" : 404,
        "endColumnNumber" : 11
      },
      "nodeContext" : "\"#include \\\\<iostream>\\n\" + \"\\n\" + \"#include \\\"antlr4-runtime.h\\\"\\n\"+ \"#include \\\"<lexerName>.h\\\"\\n\"+ \"#include \\\"<parserName>.h\\\"\\n\"+ \"\\n\"+ \"using namespace antlr4;\\n\"+ \"\\n\"+ \"class TreeShapeListener : public tree::ParseTreeListener {\\n\"+ \"public:\\n\"+ \"  void visitTerminal(tree::TerminalNode *) override {}\\n\"+ \"  void visitErrorNode(tree::ErrorNode *) override {}\\n\"+ \"  void exitEveryRule(ParserRuleContext *) override {}\\n\"+ \"  void enterEveryRule(ParserRuleContext *ctx) override {\\n\"+ \"    for (auto child : ctx->children) {\\n\"+ \"      tree::ParseTree *parent = child->parent;\\n\"+ \"      ParserRuleContext *rule = dynamic_cast\\\\<ParserRuleContext *>(parent);\\n\"+ \"      if (rule != ctx) {\\n\"+ \"        throw \\\"Invalid parse tree shape detected.\\\";\\n\"+ \"      }\\n\"+ \"    }\\n\"+ \"  }\\n\"+ \"};\\n\"+ \"\\n\"+ \"\\n\"+ \"int main(int argc, const char* argv[]) {\\n\"+ \"  ANTLRFileStream input;\\n\"+ \"  input.loadFromFile(argv[1]);\\n\"+ \"  <lexerName> lexer(&input);\\n\"+ \"  CommonTokenStream tokens(&lexer);\\n\"+ \"<createParser>\"+ \"\\n\"+ \"  tree::ParseTree *tree = parser.<parserStartRuleName>;\\n\"+ \"  TreeShapeListener listener;\\n\"+ \"  tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\\n\"+ \"\\n\"+ \"  return 0;\\n\"+ \"}\\n\"",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 39,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 1447,
        "startLineNumber" : 365,
        "startColumnNumber" : 20,
        "endLineNumber" : 405,
        "endColumnNumber" : 3
      },
      "nodeContext" : "new ST(\"#include \\\\<iostream>\\n\" + \"\\n\" + \"#include \\\"antlr4-runtime.h\\\"\\n\"+ \"#include \\\"<lexerName>.h\\\"\\n\"+ \"#include \\\"<parserName>.h\\\"\\n\"+ \"\\n\"+ \"using namespace antlr4;\\n\"+ \"\\n\"+ \"class TreeShapeListener : public tree::ParseTreeListener {\\n\"+ \"public:\\n\"+ \"  void visitTerminal(tree::TerminalNode *) override {}\\n\"+ \"  void visitErrorNode(tree::ErrorNode *) override {}\\n\"+ \"  void exitEveryRule(ParserRuleContext *) override {}\\n\"+ \"  void enterEveryRule(ParserRuleContext *ctx) override {\\n\"+ \"    for (auto child : ctx->children) {\\n\"+ \"      tree::ParseTree *parent = child->parent;\\n\"+ \"      ParserRuleContext *rule = dynamic_cast\\\\<ParserRuleContext *>(parent);\\n\"+ \"      if (rule != ctx) {\\n\"+ \"        throw \\\"Invalid parse tree shape detected.\\\";\\n\"+ \"      }\\n\"+ \"    }\\n\"+ \"  }\\n\"+ \"};\\n\"+ \"\\n\"+ \"\\n\"+ \"int main(int argc, const char* argv[]) {\\n\"+ \"  ANTLRFileStream input;\\n\"+ \"  input.loadFromFile(argv[1]);\\n\"+ \"  <lexerName> lexer(&input);\\n\"+ \"  CommonTokenStream tokens(&lexer);\\n\"+ \"<createParser>\"+ \"\\n\"+ \"  tree::ParseTree *tree = parser.<parserStartRuleName>;\\n\"+ \"  TreeShapeListener listener;\\n\"+ \"  tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\\n\"+ \"\\n\"+ \"  return 0;\\n\"+ \"}\\n\")",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 42,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 1462,
        "startLineNumber" : 365,
        "startColumnNumber" : 5,
        "endLineNumber" : 405,
        "endColumnNumber" : 3
      },
      "nodeContext" : "outputFileST=new ST(\"#include \\\\<iostream>\\n\" + \"\\n\" + \"#include \\\"antlr4-runtime.h\\\"\\n\"+ \"#include \\\"<lexerName>.h\\\"\\n\"+ \"#include \\\"<parserName>.h\\\"\\n\"+ \"\\n\"+ \"using namespace antlr4;\\n\"+ \"\\n\"+ \"class TreeShapeListener : public tree::ParseTreeListener {\\n\"+ \"public:\\n\"+ \"  void visitTerminal(tree::TerminalNode *) override {}\\n\"+ \"  void visitErrorNode(tree::ErrorNode *) override {}\\n\"+ \"  void exitEveryRule(ParserRuleContext *) override {}\\n\"+ \"  void enterEveryRule(ParserRuleContext *ctx) override {\\n\"+ \"    for (auto child : ctx->children) {\\n\"+ \"      tree::ParseTree *parent = child->parent;\\n\"+ \"      ParserRuleContext *rule = dynamic_cast\\\\<ParserRuleContext *>(parent);\\n\"+ \"      if (rule != ctx) {\\n\"+ \"        throw \\\"Invalid parse tree shape detected.\\\";\\n\"+ \"      }\\n\"+ \"    }\\n\"+ \"  }\\n\"+ \"};\\n\"+ \"\\n\"+ \"\\n\"+ \"int main(int argc, const char* argv[]) {\\n\"+ \"  ANTLRFileStream input;\\n\"+ \"  input.loadFromFile(argv[1]);\\n\"+ \"  <lexerName> lexer(&input);\\n\"+ \"  CommonTokenStream tokens(&lexer);\\n\"+ \"<createParser>\"+ \"\\n\"+ \"  tree::ParseTree *tree = parser.<parserStartRuleName>;\\n\"+ \"  TreeShapeListener listener;\\n\"+ \"  tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\\n\"+ \"\\n\"+ \"  return 0;\\n\"+ \"}\\n\")",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 44,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1466,
        "startLineNumber" : 365,
        "startColumnNumber" : 2,
        "endLineNumber" : 405,
        "endColumnNumber" : 4
      },
      "nodeContext" : "ST outputFileST=new ST(\"#include \\\\<iostream>\\n\" + \"\\n\" + \"#include \\\"antlr4-runtime.h\\\"\\n\"+ \"#include \\\"<lexerName>.h\\\"\\n\"+ \"#include \\\"<parserName>.h\\\"\\n\"+ \"\\n\"+ \"using namespace antlr4;\\n\"+ \"\\n\"+ \"class TreeShapeListener : public tree::ParseTreeListener {\\n\"+ \"public:\\n\"+ \"  void visitTerminal(tree::TerminalNode *) override {}\\n\"+ \"  void visitErrorNode(tree::ErrorNode *) override {}\\n\"+ \"  void exitEveryRule(ParserRuleContext *) override {}\\n\"+ \"  void enterEveryRule(ParserRuleContext *ctx) override {\\n\"+ \"    for (auto child : ctx->children) {\\n\"+ \"      tree::ParseTree *parent = child->parent;\\n\"+ \"      ParserRuleContext *rule = dynamic_cast\\\\<ParserRuleContext *>(parent);\\n\"+ \"      if (rule != ctx) {\\n\"+ \"        throw \\\"Invalid parse tree shape detected.\\\";\\n\"+ \"      }\\n\"+ \"    }\\n\"+ \"  }\\n\"+ \"};\\n\"+ \"\\n\"+ \"\\n\"+ \"int main(int argc, const char* argv[]) {\\n\"+ \"  ANTLRFileStream input;\\n\"+ \"  input.loadFromFile(argv[1]);\\n\"+ \"  <lexerName> lexer(&input);\\n\"+ \"  CommonTokenStream tokens(&lexer);\\n\"+ \"<createParser>\"+ \"\\n\"+ \"  tree::ParseTree *tree = parser.<parserStartRuleName>;\\n\"+ \"  TreeShapeListener listener;\\n\"+ \"  tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\\n\"+ \"\\n\"+ \"  return 0;\\n\"+ \"}\\n\");\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 47,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 2233,
        "startLineNumber" : 362,
        "startColumnNumber" : 94,
        "endLineNumber" : 422,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (!parserStartRuleName.endsWith(\")\"))   parserStartRuleName+=\"()\";\n  ST outputFileST=new ST(\"#include \\\\<iostream>\\n\" + \"\\n\" + \"#include \\\"antlr4-runtime.h\\\"\\n\"+ \"#include \\\"<lexerName>.h\\\"\\n\"+ \"#include \\\"<parserName>.h\\\"\\n\"+ \"\\n\"+ \"using namespace antlr4;\\n\"+ \"\\n\"+ \"class TreeShapeListener : public tree::ParseTreeListener {\\n\"+ \"public:\\n\"+ \"  void visitTerminal(tree::TerminalNode *) override {}\\n\"+ \"  void visitErrorNode(tree::ErrorNode *) override {}\\n\"+ \"  void exitEveryRule(ParserRuleContext *) override {}\\n\"+ \"  void enterEveryRule(ParserRuleContext *ctx) override {\\n\"+ \"    for (auto child : ctx->children) {\\n\"+ \"      tree::ParseTree *parent = child->parent;\\n\"+ \"      ParserRuleContext *rule = dynamic_cast\\\\<ParserRuleContext *>(parent);\\n\"+ \"      if (rule != ctx) {\\n\"+ \"        throw \\\"Invalid parse tree shape detected.\\\";\\n\"+ \"      }\\n\"+ \"    }\\n\"+ \"  }\\n\"+ \"};\\n\"+ \"\\n\"+ \"\\n\"+ \"int main(int argc, const char* argv[]) {\\n\"+ \"  ANTLRFileStream input;\\n\"+ \"  input.loadFromFile(argv[1]);\\n\"+ \"  <lexerName> lexer(&input);\\n\"+ \"  CommonTokenStream tokens(&lexer);\\n\"+ \"<createParser>\"+ \"\\n\"+ \"  tree::ParseTree *tree = parser.<parserStartRuleName>;\\n\"+ \"  TreeShapeListener listener;\\n\"+ \"  tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\\n\"+ \"\\n\"+ \"  return 0;\\n\"+ \"}\\n\");\n  String stSource=\"  <parserName> parser(&tokens);\\n\";\n  if (debug) {\n    stSource+=\"  DiagnosticErrorListener errorListener;\\n\";\n    stSource+=\"  parser.addErrorListener(&errorListener);\\n\";\n  }\n  if (trace)   stSource+=\"  parser.setTrace(true);\\n\";\n  ST createParserST=new ST(stSource);\n  outputFileST.add(\"createParser\",createParserST);\n  outputFileST.add(\"parserName\",parserName);\n  outputFileST.add(\"lexerName\",lexerName);\n  outputFileST.add(\"listenerName\",listenerName);\n  outputFileST.add(\"visitorName\",visitorName);\n  outputFileST.add(\"parserStartRuleName\",parserStartRuleName);\n  writeFile(getTempDirPath(),\"Test.cpp\",outputFileST.render());\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 135,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 2478,
        "startLineNumber" : 360,
        "startColumnNumber" : 1,
        "endLineNumber" : 422,
        "endColumnNumber" : 2
      },
      "nodeContext" : "protected void writeParserTestFile(String parserName,String lexerName,String listenerName,String visitorName,String parserStartRuleName,boolean debug,boolean trace){\n  if (!parserStartRuleName.endsWith(\")\"))   parserStartRuleName+=\"()\";\n  ST outputFileST=new ST(\"#include \\\\<iostream>\\n\" + \"\\n\" + \"#include \\\"antlr4-runtime.h\\\"\\n\"+ \"#include \\\"<lexerName>.h\\\"\\n\"+ \"#include \\\"<parserName>.h\\\"\\n\"+ \"\\n\"+ \"using namespace antlr4;\\n\"+ \"\\n\"+ \"class TreeShapeListener : public tree::ParseTreeListener {\\n\"+ \"public:\\n\"+ \"  void visitTerminal(tree::TerminalNode *) override {}\\n\"+ \"  void visitErrorNode(tree::ErrorNode *) override {}\\n\"+ \"  void exitEveryRule(ParserRuleContext *) override {}\\n\"+ \"  void enterEveryRule(ParserRuleContext *ctx) override {\\n\"+ \"    for (auto child : ctx->children) {\\n\"+ \"      tree::ParseTree *parent = child->parent;\\n\"+ \"      ParserRuleContext *rule = dynamic_cast\\\\<ParserRuleContext *>(parent);\\n\"+ \"      if (rule != ctx) {\\n\"+ \"        throw \\\"Invalid parse tree shape detected.\\\";\\n\"+ \"      }\\n\"+ \"    }\\n\"+ \"  }\\n\"+ \"};\\n\"+ \"\\n\"+ \"\\n\"+ \"int main(int argc, const char* argv[]) {\\n\"+ \"  ANTLRFileStream input;\\n\"+ \"  input.loadFromFile(argv[1]);\\n\"+ \"  <lexerName> lexer(&input);\\n\"+ \"  CommonTokenStream tokens(&lexer);\\n\"+ \"<createParser>\"+ \"\\n\"+ \"  tree::ParseTree *tree = parser.<parserStartRuleName>;\\n\"+ \"  TreeShapeListener listener;\\n\"+ \"  tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\\n\"+ \"\\n\"+ \"  return 0;\\n\"+ \"}\\n\");\n  String stSource=\"  <parserName> parser(&tokens);\\n\";\n  if (debug) {\n    stSource+=\"  DiagnosticErrorListener errorListener;\\n\";\n    stSource+=\"  parser.addErrorListener(&errorListener);\\n\";\n  }\n  if (trace)   stSource+=\"  parser.setTrace(true);\\n\";\n  ST createParserST=new ST(stSource);\n  outputFileST.add(\"createParser\",createParserST);\n  outputFileST.add(\"parserName\",parserName);\n  outputFileST.add(\"lexerName\",lexerName);\n  outputFileST.add(\"listenerName\",listenerName);\n  outputFileST.add(\"visitorName\",visitorName);\n  outputFileST.add(\"parserStartRuleName\",parserStartRuleName);\n  writeFile(getTempDirPath(),\"Test.cpp\",outputFileST.render());\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 165,
      "astHeight" : 7
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
      "nodePosition" : {
        "charLength" : 1430,
        "startLineNumber" : 366,
        "startColumnNumber" : 3,
        "endLineNumber" : 404,
        "endColumnNumber" : 11
      },
      "nodeContext" : "\"#include \\\\<iostream>\\n\" + \"\\n\" + \"#include \\\"antlr4-runtime.h\\\"\\n\"+ \"#include \\\"<lexerName>.h\\\"\\n\"+ \"#include \\\"<parserName>.h\\\"\\n\"+ \"\\n\"+ \"using namespace antlr4;\\n\"+ \"\\n\"+ \"class TreeShapeListener : public tree::ParseTreeListener {\\n\"+ \"public:\\n\"+ \"  void visitTerminal(tree::TerminalNode *) override {}\\n\"+ \"  void visitErrorNode(tree::ErrorNode *) override {}\\n\"+ \"  void exitEveryRule(ParserRuleContext *) override {}\\n\"+ \"  void enterEveryRule(ParserRuleContext *ctx) override {\\n\"+ \"    for (auto child : ctx->children) {\\n\"+ \"      tree::ParseTree *parent = child->parent;\\n\"+ \"      ParserRuleContext *rule = dynamic_cast\\\\<ParserRuleContext *>(parent);\\n\"+ \"      if (rule != ctx) {\\n\"+ \"        throw \\\"Invalid parse tree shape detected.\\\";\\n\"+ \"      }\\n\"+ \"    }\\n\"+ \"  }\\n\"+ \"};\\n\"+ \"\\n\"+ \"\\n\"+ \"int main(int argc, const char* argv[]) {\\n\"+ \"  ANTLRFileStream input;\\n\"+ \"  input.loadFromFile(argv[1]);\\n\"+ \"  <lexerName> lexer(&input);\\n\"+ \"  CommonTokenStream tokens(&lexer);\\n\"+ \"<createParser>\"+ \"\\n\"+ \"  tree::ParseTree *tree = parser.<parserStartRuleName>;\\n\"+ \"  TreeShapeListener listener;\\n\"+ \"  tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\\n\"+ \"\\n\"+ \"  return 0;\\n\"+ \"}\\n\"",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 39,
      "astHeight" : 2
    },
    "tokenLength" : 5,
    "type" : "java.lang.String"
  } ],
  "positionList" : [ {
    "charLength" : 60,
    "startLineNumber" : 379,
    "startColumnNumber" : 6,
    "endLineNumber" : 379,
    "endColumnNumber" : 66
  } ],
  "layoutRelationDataList" : [ ]
}