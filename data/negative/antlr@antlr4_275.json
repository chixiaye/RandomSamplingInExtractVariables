{
  "id" : 275,
  "expression" : "i < chunks.size()",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/runtime/Java/src/org/antlr/v4/runtime/tree/pattern/ParseTreePatternMatcher.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "i < chunks.size()",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 17,
      "startLineNumber" : 494,
      "startColumnNumber" : 18,
      "endLineNumber" : 494,
      "endColumnNumber" : 35
    },
    "astNodeNumber" : 5,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 318,
        "startLineNumber" : 494,
        "startColumnNumber" : 2,
        "endLineNumber" : 503,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int i=0; i < chunks.size(); i++) {\n  Chunk c=chunks.get(i);\n  if (c instanceof TextChunk) {\n    TextChunk tc=(TextChunk)c;\n    String unescaped=tc.getText().replace(escape,\"\");\n    if (unescaped.length() < tc.getText().length()) {\n      chunks.set(i,new TextChunk(unescaped));\n    }\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 70,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 2914,
        "startLineNumber" : 412,
        "startColumnNumber" : 42,
        "endLineNumber" : 506,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  int p=0;\n  int n=pattern.length();\n  List<Chunk> chunks=new ArrayList<Chunk>();\n  StringBuilder buf=new StringBuilder();\n  List<Integer> starts=new ArrayList<Integer>();\n  List<Integer> stops=new ArrayList<Integer>();\n  while (p < n) {\n    if (p == pattern.indexOf(escape + start,p)) {\n      p+=escape.length() + start.length();\n    }\n else     if (p == pattern.indexOf(escape + stop,p)) {\n      p+=escape.length() + stop.length();\n    }\n else     if (p == pattern.indexOf(start,p)) {\n      starts.add(p);\n      p+=start.length();\n    }\n else     if (p == pattern.indexOf(stop,p)) {\n      stops.add(p);\n      p+=stop.length();\n    }\n else {\n      p++;\n    }\n  }\n  if (starts.size() > stops.size()) {\n    throw new IllegalArgumentException(\"unterminated tag in pattern: \" + pattern);\n  }\n  if (starts.size() < stops.size()) {\n    throw new IllegalArgumentException(\"missing start tag in pattern: \" + pattern);\n  }\n  int ntags=starts.size();\n  for (int i=0; i < ntags; i++) {\n    if (starts.get(i) >= stops.get(i)) {\n      throw new IllegalArgumentException(\"tag delimiters out of order in pattern: \" + pattern);\n    }\n  }\n  if (ntags == 0) {\n    String text=pattern.substring(0,n);\n    chunks.add(new TextChunk(text));\n  }\n  if (ntags > 0 && starts.get(0) > 0) {\n    String text=pattern.substring(0,starts.get(0));\n    chunks.add(new TextChunk(text));\n  }\n  for (int i=0; i < ntags; i++) {\n    String tag=pattern.substring(starts.get(i) + start.length(),stops.get(i));\n    String ruleOrToken=tag;\n    String label=null;\n    int colon=tag.indexOf(':');\n    if (colon >= 0) {\n      label=tag.substring(0,colon);\n      ruleOrToken=tag.substring(colon + 1,tag.length());\n    }\n    chunks.add(new TagChunk(label,ruleOrToken));\n    if (i + 1 < ntags) {\n      String text=pattern.substring(stops.get(i) + stop.length(),starts.get(i + 1));\n      chunks.add(new TextChunk(text));\n    }\n  }\n  if (ntags > 0) {\n    int afterLastTag=stops.get(ntags - 1) + stop.length();\n    if (afterLastTag < n) {\n      String text=pattern.substring(afterLastTag,n);\n      chunks.add(new TextChunk(text));\n    }\n  }\n  for (int i=0; i < chunks.size(); i++) {\n    Chunk c=chunks.get(i);\n    if (c instanceof TextChunk) {\n      TextChunk tc=(TextChunk)c;\n      String unescaped=tc.getText().replace(escape,\"\");\n      if (unescaped.length() < tc.getText().length()) {\n        chunks.set(i,new TextChunk(unescaped));\n      }\n    }\n  }\n  return chunks;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 516,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3047,
        "startLineNumber" : 411,
        "startColumnNumber" : 1,
        "endLineNumber" : 506,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Split  {@code <ID> = <e:expr> ;} into 4 chunks for tokenizing by {@link #tokenize}. \n */\npublic List<Chunk> split(String pattern){\n  int p=0;\n  int n=pattern.length();\n  List<Chunk> chunks=new ArrayList<Chunk>();\n  StringBuilder buf=new StringBuilder();\n  List<Integer> starts=new ArrayList<Integer>();\n  List<Integer> stops=new ArrayList<Integer>();\n  while (p < n) {\n    if (p == pattern.indexOf(escape + start,p)) {\n      p+=escape.length() + start.length();\n    }\n else     if (p == pattern.indexOf(escape + stop,p)) {\n      p+=escape.length() + stop.length();\n    }\n else     if (p == pattern.indexOf(start,p)) {\n      starts.add(p);\n      p+=start.length();\n    }\n else     if (p == pattern.indexOf(stop,p)) {\n      stops.add(p);\n      p+=stop.length();\n    }\n else {\n      p++;\n    }\n  }\n  if (starts.size() > stops.size()) {\n    throw new IllegalArgumentException(\"unterminated tag in pattern: \" + pattern);\n  }\n  if (starts.size() < stops.size()) {\n    throw new IllegalArgumentException(\"missing start tag in pattern: \" + pattern);\n  }\n  int ntags=starts.size();\n  for (int i=0; i < ntags; i++) {\n    if (starts.get(i) >= stops.get(i)) {\n      throw new IllegalArgumentException(\"tag delimiters out of order in pattern: \" + pattern);\n    }\n  }\n  if (ntags == 0) {\n    String text=pattern.substring(0,n);\n    chunks.add(new TextChunk(text));\n  }\n  if (ntags > 0 && starts.get(0) > 0) {\n    String text=pattern.substring(0,starts.get(0));\n    chunks.add(new TextChunk(text));\n  }\n  for (int i=0; i < ntags; i++) {\n    String tag=pattern.substring(starts.get(i) + start.length(),stops.get(i));\n    String ruleOrToken=tag;\n    String label=null;\n    int colon=tag.indexOf(':');\n    if (colon >= 0) {\n      label=tag.substring(0,colon);\n      ruleOrToken=tag.substring(colon + 1,tag.length());\n    }\n    chunks.add(new TagChunk(label,ruleOrToken));\n    if (i + 1 < ntags) {\n      String text=pattern.substring(stops.get(i) + stop.length(),starts.get(i + 1));\n      chunks.add(new TextChunk(text));\n    }\n  }\n  if (ntags > 0) {\n    int afterLastTag=stops.get(ntags - 1) + stop.length();\n    if (afterLastTag < n) {\n      String text=pattern.substring(afterLastTag,n);\n      chunks.add(new TextChunk(text));\n    }\n  }\n  for (int i=0; i < chunks.size(); i++) {\n    Chunk c=chunks.get(i);\n    if (c instanceof TextChunk) {\n      TextChunk tc=(TextChunk)c;\n      String unescaped=tc.getText().replace(escape,\"\");\n      if (unescaped.length() < tc.getText().length()) {\n        chunks.set(i,new TextChunk(unescaped));\n      }\n    }\n  }\n  return chunks;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 529,
      "astHeight" : 13
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 318,
        "startLineNumber" : 494,
        "startColumnNumber" : 2,
        "endLineNumber" : 503,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (int i=0; i < chunks.size(); i++) {\n  Chunk c=chunks.get(i);\n  if (c instanceof TextChunk) {\n    TextChunk tc=(TextChunk)c;\n    String unescaped=tc.getText().replace(escape,\"\");\n    if (unescaped.length() < tc.getText().length()) {\n      chunks.set(i,new TextChunk(unescaped));\n    }\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 70,
      "astHeight" : 11
    },
    "tokenLength" : 4,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 17,
    "startLineNumber" : 494,
    "startColumnNumber" : 18,
    "endLineNumber" : 494,
    "endColumnNumber" : 35
  } ],
  "layoutRelationDataList" : [ ]
}