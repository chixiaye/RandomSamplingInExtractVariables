{
  "id" : 75,
  "expression" : "result.getBlockedReason()",
  "projectName" : "prestodb@presto",
  "commitID" : "eff77883d0d24dc6022ecde252612d1430c9fbac",
  "filePath" : "/presto-main/src/main/java/com/facebook/presto/execution/scheduler/LegacySqlQueryScheduler.java",
  "occurrences" : 3,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "result.getBlockedReason()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 453,
      "startColumnNumber" : 28,
      "endLineNumber" : 453,
      "endColumnNumber" : 53
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 453,
        "startColumnNumber" : 28,
        "endLineNumber" : 453,
        "endColumnNumber" : 65
      },
      "nodeContext" : "result.getBlockedReason().isPresent()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1284,
        "startLineNumber" : 453,
        "startColumnNumber" : 24,
        "endLineNumber" : 473,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:    break;\ncase WAITING_FOR_SOURCE:  schedulerStats.getWaitingForSource().update(1);\nbreak;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 2999,
        "startLineNumber" : 426,
        "startColumnNumber" : 103,
        "endLineNumber" : 474,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n  StageId stageId=stageExecution.getStageExecutionId().getStageId();\n  stageExecution.beginScheduling();\n  ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n  if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n    for (    RemoteTask task : result.getNewTasks()) {\n      partialResultQueryTaskTracker.trackTask(task);\n      task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n    }\n  }\n  if (result.isFinished()) {\n    stageExecution.schedulingComplete();\n  }\n else   if (!result.getBlocked().isDone()) {\n    blockedStages.add(result.getBlocked());\n  }\n  stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n  schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n  if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:      break;\ncase WAITING_FOR_SOURCE:    schedulerStats.getWaitingForSource().update(1);\n  break;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 180,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3082,
        "startLineNumber" : 426,
        "startColumnNumber" : 20,
        "endLineNumber" : 474,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n  SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n  StageId stageId=stageExecution.getStageExecutionId().getStageId();\n  stageExecution.beginScheduling();\n  ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n  if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n    for (    RemoteTask task : result.getNewTasks()) {\n      partialResultQueryTaskTracker.trackTask(task);\n      task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n    }\n  }\n  if (result.isFinished()) {\n    stageExecution.schedulingComplete();\n  }\n else   if (!result.getBlocked().isDone()) {\n    blockedStages.add(result.getBlocked());\n  }\n  stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n  schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n  if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:      break;\ncase WAITING_FOR_SOURCE:    schedulerStats.getWaitingForSource().update(1);\n  break;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 186,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 5121,
        "startLineNumber" : 419,
        "startColumnNumber" : 100,
        "endLineNumber" : 503,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n  List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n  for (  StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n    SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n    StageId stageId=stageExecution.getStageExecutionId().getStageId();\n    stageExecution.beginScheduling();\n    ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n    if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n      for (      RemoteTask task : result.getNewTasks()) {\n        partialResultQueryTaskTracker.trackTask(task);\n        task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n      }\n    }\n    if (result.isFinished()) {\n      stageExecution.schedulingComplete();\n    }\n else     if (!result.getBlocked().isDone()) {\n      blockedStages.add(result.getBlocked());\n    }\n    stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n    schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n    if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:        break;\ncase WAITING_FOR_SOURCE:      schedulerStats.getWaitingForSource().update(1);\n    break;\ncase SPLIT_QUEUES_FULL:  schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 336,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5205,
        "startLineNumber" : 419,
        "startColumnNumber" : 16,
        "endLineNumber" : 503,
        "endColumnNumber" : 17
      },
      "nodeContext" : "while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n  List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n  List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n  for (  StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n    SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n    StageId stageId=stageExecution.getStageExecutionId().getStageId();\n    stageExecution.beginScheduling();\n    ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n    if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n      for (      RemoteTask task : result.getNewTasks()) {\n        partialResultQueryTaskTracker.trackTask(task);\n        task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n      }\n    }\n    if (result.isFinished()) {\n      stageExecution.schedulingComplete();\n    }\n else     if (!result.getBlocked().isDone()) {\n      blockedStages.add(result.getBlocked());\n    }\n    stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n    schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n    if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:        break;\ncase WAITING_FOR_SOURCE:      schedulerStats.getWaitingForSource().update(1);\n    break;\ncase SPLIT_QUEUES_FULL:  schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 345,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 6266,
        "startLineNumber" : 399,
        "startColumnNumber" : 60,
        "endLineNumber" : 504,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n  List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n  if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n    break;\n  }\n  List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n  sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n  sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n  while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n    List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n    List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n    for (    StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n      SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n      StageId stageId=stageExecution.getStageExecutionId().getStageId();\n      stageExecution.beginScheduling();\n      ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n      if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n        for (        RemoteTask task : result.getNewTasks()) {\n          partialResultQueryTaskTracker.trackTask(task);\n          task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n        }\n      }\n      if (result.isFinished()) {\n        stageExecution.schedulingComplete();\n      }\n else       if (!result.getBlocked().isDone()) {\n        blockedStages.add(result.getBlocked());\n      }\n      stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n      schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n      if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:          break;\ncase WAITING_FOR_SOURCE:        schedulerStats.getWaitingForSource().update(1);\n      break;\ncase SPLIT_QUEUES_FULL:    schedulerStats.getSplitQueuesFull().update(1);\n  break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 425,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6314,
        "startLineNumber" : 399,
        "startColumnNumber" : 12,
        "endLineNumber" : 504,
        "endColumnNumber" : 13
      },
      "nodeContext" : "while (!Thread.currentThread().isInterrupted()) {\n  sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n  List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n  if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n    break;\n  }\n  List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n  sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n  sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n  while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n    List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n    List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n    for (    StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n      SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n      StageId stageId=stageExecution.getStageExecutionId().getStageId();\n      stageExecution.beginScheduling();\n      ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n      if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n        for (        RemoteTask task : result.getNewTasks()) {\n          partialResultQueryTaskTracker.trackTask(task);\n          task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n        }\n      }\n      if (result.isFinished()) {\n        stageExecution.schedulingComplete();\n      }\n else       if (!result.getBlocked().isDone()) {\n        blockedStages.add(result.getBlocked());\n      }\n      stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n      schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n      if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:          break;\ncase WAITING_FOR_SOURCE:        schedulerStats.getWaitingForSource().update(1);\n      break;\ncase SPLIT_QUEUES_FULL:    schedulerStats.getSplitQueuesFull().update(1);\n  break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 432,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 7284,
        "startLineNumber" : 394,
        "startColumnNumber" : 100,
        "endLineNumber" : 521,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Set<StageId> completedStages=new HashSet<>();\n  List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n  while (!Thread.currentThread().isInterrupted()) {\n    sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n    List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n    if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n      break;\n    }\n    List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n    sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n    sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n    while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n      List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n      List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n      for (      StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n        SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n        StageId stageId=stageExecution.getStageExecutionId().getStageId();\n        stageExecution.beginScheduling();\n        ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n        if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n          for (          RemoteTask task : result.getNewTasks()) {\n            partialResultQueryTaskTracker.trackTask(task);\n            task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n          }\n        }\n        if (result.isFinished()) {\n          stageExecution.schedulingComplete();\n        }\n else         if (!result.getBlocked().isDone()) {\n          blockedStages.add(result.getBlocked());\n        }\n        stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n        schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n        if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:            break;\ncase WAITING_FOR_SOURCE:          schedulerStats.getWaitingForSource().update(1);\n        break;\ncase SPLIT_QUEUES_FULL:      schedulerStats.getSplitQueuesFull().update(1);\n    break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:  schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 521,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8228,
        "startLineNumber" : 394,
        "startColumnNumber" : 8,
        "endLineNumber" : 544,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try (SetThreadName ignored=new SetThreadName(\"Query-%s\",queryStateMachine.getQueryId())){\n  Set<StageId> completedStages=new HashSet<>();\n  List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n  while (!Thread.currentThread().isInterrupted()) {\n    sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n    List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n    if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n      break;\n    }\n    List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n    sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n    sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n    while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n      List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n      List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n      for (      StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n        SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n        StageId stageId=stageExecution.getStageExecutionId().getStageId();\n        stageExecution.beginScheduling();\n        ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n        if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n          for (          RemoteTask task : result.getNewTasks()) {\n            partialResultQueryTaskTracker.trackTask(task);\n            task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n          }\n        }\n        if (result.isFinished()) {\n          stageExecution.schedulingComplete();\n        }\n else         if (!result.getBlocked().isDone()) {\n          blockedStages.add(result.getBlocked());\n        }\n        stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n        schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n        if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:            break;\ncase WAITING_FOR_SOURCE:          schedulerStats.getWaitingForSource().update(1);\n        break;\ncase SPLIT_QUEUES_FULL:      schedulerStats.getSplitQueuesFull().update(1);\n    break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:  schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n catch (Throwable t) {\nscheduling.set(false);\nqueryStateMachine.transitionToFailed(t);\nthrow t;\n}\n finally {\nRuntimeException closeError=new RuntimeException();\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\ntry {\nstageExecutionInfo.getStageScheduler().close();\n}\n catch (Throwable t) {\nqueryStateMachine.transitionToFailed(t);\nif (closeError != t) {\ncloseError.addSuppressed(t);\n}\n}\n}\nif (closeError.getSuppressed().length > 0) {\nthrow closeError;\n}\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 608,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8478,
        "startLineNumber" : 386,
        "startColumnNumber" : 4,
        "endLineNumber" : 545,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!scheduling.compareAndSet(false,true)) {\n    return;\n  }\n  List<StageExecutionAndScheduler> scheduledStageExecutions=new ArrayList<>();\n  try (SetThreadName ignored=new SetThreadName(\"Query-%s\",queryStateMachine.getQueryId())){\n    Set<StageId> completedStages=new HashSet<>();\n    List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n    while (!Thread.currentThread().isInterrupted()) {\n      sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n      List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n      if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n        break;\n      }\n      List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n      sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n      sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n      while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n        List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n        List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n        for (        StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n          SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n          StageId stageId=stageExecution.getStageExecutionId().getStageId();\n          stageExecution.beginScheduling();\n          ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n          if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n            for (            RemoteTask task : result.getNewTasks()) {\n              partialResultQueryTaskTracker.trackTask(task);\n              task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n            }\n          }\n          if (result.isFinished()) {\n            stageExecution.schedulingComplete();\n          }\n else           if (!result.getBlocked().isDone()) {\n            blockedStages.add(result.getBlocked());\n          }\n          stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n          schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n          if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:              break;\ncase WAITING_FOR_SOURCE:            schedulerStats.getWaitingForSource().update(1);\n          break;\ncase SPLIT_QUEUES_FULL:        schedulerStats.getSplitQueuesFull().update(1);\n      break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:    schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\n  break;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n catch (Throwable t) {\nscheduling.set(false);\nqueryStateMachine.transitionToFailed(t);\nthrow t;\n}\n finally {\nRuntimeException closeError=new RuntimeException();\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\ntry {\nstageExecutionInfo.getStageScheduler().close();\n}\n catch (Throwable t) {\nqueryStateMachine.transitionToFailed(t);\nif (closeError != t) {\ncloseError.addSuppressed(t);\n}\n}\n}\nif (closeError.getSuppressed().length > 0) {\nthrow closeError;\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 630,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8506,
        "startLineNumber" : 385,
        "startColumnNumber" : 4,
        "endLineNumber" : 545,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private void schedule(){\n  if (!scheduling.compareAndSet(false,true)) {\n    return;\n  }\n  List<StageExecutionAndScheduler> scheduledStageExecutions=new ArrayList<>();\n  try (SetThreadName ignored=new SetThreadName(\"Query-%s\",queryStateMachine.getQueryId())){\n    Set<StageId> completedStages=new HashSet<>();\n    List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n    while (!Thread.currentThread().isInterrupted()) {\n      sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n      List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n      if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n        break;\n      }\n      List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n      sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n      sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n      while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n        List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n        List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n        for (        StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n          SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n          StageId stageId=stageExecution.getStageExecutionId().getStageId();\n          stageExecution.beginScheduling();\n          ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n          if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n            for (            RemoteTask task : result.getNewTasks()) {\n              partialResultQueryTaskTracker.trackTask(task);\n              task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n            }\n          }\n          if (result.isFinished()) {\n            stageExecution.schedulingComplete();\n          }\n else           if (!result.getBlocked().isDone()) {\n            blockedStages.add(result.getBlocked());\n          }\n          stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n          schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n          if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:              break;\ncase WAITING_FOR_SOURCE:            schedulerStats.getWaitingForSource().update(1);\n          break;\ncase SPLIT_QUEUES_FULL:        schedulerStats.getSplitQueuesFull().update(1);\n      break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:    schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\n  break;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n catch (Throwable t) {\nscheduling.set(false);\nqueryStateMachine.transitionToFailed(t);\nthrow t;\n}\n finally {\nRuntimeException closeError=new RuntimeException();\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\ntry {\nstageExecutionInfo.getStageScheduler().close();\n}\n catch (Throwable t) {\nqueryStateMachine.transitionToFailed(t);\nif (closeError != t) {\ncloseError.addSuppressed(t);\n}\n}\n}\nif (closeError.getSuppressed().length > 0) {\nthrow closeError;\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 634,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 453,
        "startColumnNumber" : 28,
        "endLineNumber" : 453,
        "endColumnNumber" : 65
      },
      "nodeContext" : "result.getBlockedReason().isPresent()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 2,
    "type" : "java.util.Optional<com.facebook.presto.execution.scheduler.ScheduleResult.BlockedReason>"
  }, {
    "nodeContext" : "result.getBlockedReason()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 454,
      "startColumnNumber" : 36,
      "endLineNumber" : 454,
      "endColumnNumber" : 61
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.SwitchStatement,expression]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 454,
        "startColumnNumber" : 36,
        "endLineNumber" : 454,
        "endColumnNumber" : 67
      },
      "nodeContext" : "result.getBlockedReason().get()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1185,
        "startLineNumber" : 454,
        "startColumnNumber" : 28,
        "endLineNumber" : 472,
        "endColumnNumber" : 29
      },
      "nodeContext" : "switch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:  break;\ncase WAITING_FOR_SOURCE:schedulerStats.getWaitingForSource().update(1);\nbreak;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 61,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1241,
        "startLineNumber" : 453,
        "startColumnNumber" : 67,
        "endLineNumber" : 473,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:    break;\ncase WAITING_FOR_SOURCE:  schedulerStats.getWaitingForSource().update(1);\nbreak;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 62,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1284,
        "startLineNumber" : 453,
        "startColumnNumber" : 24,
        "endLineNumber" : 473,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:    break;\ncase WAITING_FOR_SOURCE:  schedulerStats.getWaitingForSource().update(1);\nbreak;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 2999,
        "startLineNumber" : 426,
        "startColumnNumber" : 103,
        "endLineNumber" : 474,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n  StageId stageId=stageExecution.getStageExecutionId().getStageId();\n  stageExecution.beginScheduling();\n  ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n  if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n    for (    RemoteTask task : result.getNewTasks()) {\n      partialResultQueryTaskTracker.trackTask(task);\n      task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n    }\n  }\n  if (result.isFinished()) {\n    stageExecution.schedulingComplete();\n  }\n else   if (!result.getBlocked().isDone()) {\n    blockedStages.add(result.getBlocked());\n  }\n  stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n  schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n  if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:      break;\ncase WAITING_FOR_SOURCE:    schedulerStats.getWaitingForSource().update(1);\n  break;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 180,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3082,
        "startLineNumber" : 426,
        "startColumnNumber" : 20,
        "endLineNumber" : 474,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n  SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n  StageId stageId=stageExecution.getStageExecutionId().getStageId();\n  stageExecution.beginScheduling();\n  ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n  if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n    for (    RemoteTask task : result.getNewTasks()) {\n      partialResultQueryTaskTracker.trackTask(task);\n      task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n    }\n  }\n  if (result.isFinished()) {\n    stageExecution.schedulingComplete();\n  }\n else   if (!result.getBlocked().isDone()) {\n    blockedStages.add(result.getBlocked());\n  }\n  stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n  schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n  if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:      break;\ncase WAITING_FOR_SOURCE:    schedulerStats.getWaitingForSource().update(1);\n  break;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 186,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 5121,
        "startLineNumber" : 419,
        "startColumnNumber" : 100,
        "endLineNumber" : 503,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n  List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n  for (  StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n    SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n    StageId stageId=stageExecution.getStageExecutionId().getStageId();\n    stageExecution.beginScheduling();\n    ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n    if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n      for (      RemoteTask task : result.getNewTasks()) {\n        partialResultQueryTaskTracker.trackTask(task);\n        task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n      }\n    }\n    if (result.isFinished()) {\n      stageExecution.schedulingComplete();\n    }\n else     if (!result.getBlocked().isDone()) {\n      blockedStages.add(result.getBlocked());\n    }\n    stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n    schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n    if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:        break;\ncase WAITING_FOR_SOURCE:      schedulerStats.getWaitingForSource().update(1);\n    break;\ncase SPLIT_QUEUES_FULL:  schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 336,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5205,
        "startLineNumber" : 419,
        "startColumnNumber" : 16,
        "endLineNumber" : 503,
        "endColumnNumber" : 17
      },
      "nodeContext" : "while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n  List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n  List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n  for (  StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n    SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n    StageId stageId=stageExecution.getStageExecutionId().getStageId();\n    stageExecution.beginScheduling();\n    ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n    if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n      for (      RemoteTask task : result.getNewTasks()) {\n        partialResultQueryTaskTracker.trackTask(task);\n        task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n      }\n    }\n    if (result.isFinished()) {\n      stageExecution.schedulingComplete();\n    }\n else     if (!result.getBlocked().isDone()) {\n      blockedStages.add(result.getBlocked());\n    }\n    stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n    schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n    if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:        break;\ncase WAITING_FOR_SOURCE:      schedulerStats.getWaitingForSource().update(1);\n    break;\ncase SPLIT_QUEUES_FULL:  schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 345,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 6266,
        "startLineNumber" : 399,
        "startColumnNumber" : 60,
        "endLineNumber" : 504,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n  List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n  if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n    break;\n  }\n  List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n  sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n  sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n  while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n    List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n    List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n    for (    StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n      SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n      StageId stageId=stageExecution.getStageExecutionId().getStageId();\n      stageExecution.beginScheduling();\n      ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n      if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n        for (        RemoteTask task : result.getNewTasks()) {\n          partialResultQueryTaskTracker.trackTask(task);\n          task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n        }\n      }\n      if (result.isFinished()) {\n        stageExecution.schedulingComplete();\n      }\n else       if (!result.getBlocked().isDone()) {\n        blockedStages.add(result.getBlocked());\n      }\n      stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n      schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n      if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:          break;\ncase WAITING_FOR_SOURCE:        schedulerStats.getWaitingForSource().update(1);\n      break;\ncase SPLIT_QUEUES_FULL:    schedulerStats.getSplitQueuesFull().update(1);\n  break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 425,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6314,
        "startLineNumber" : 399,
        "startColumnNumber" : 12,
        "endLineNumber" : 504,
        "endColumnNumber" : 13
      },
      "nodeContext" : "while (!Thread.currentThread().isInterrupted()) {\n  sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n  List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n  if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n    break;\n  }\n  List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n  sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n  sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n  while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n    List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n    List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n    for (    StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n      SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n      StageId stageId=stageExecution.getStageExecutionId().getStageId();\n      stageExecution.beginScheduling();\n      ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n      if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n        for (        RemoteTask task : result.getNewTasks()) {\n          partialResultQueryTaskTracker.trackTask(task);\n          task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n        }\n      }\n      if (result.isFinished()) {\n        stageExecution.schedulingComplete();\n      }\n else       if (!result.getBlocked().isDone()) {\n        blockedStages.add(result.getBlocked());\n      }\n      stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n      schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n      if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:          break;\ncase WAITING_FOR_SOURCE:        schedulerStats.getWaitingForSource().update(1);\n      break;\ncase SPLIT_QUEUES_FULL:    schedulerStats.getSplitQueuesFull().update(1);\n  break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 432,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 7284,
        "startLineNumber" : 394,
        "startColumnNumber" : 100,
        "endLineNumber" : 521,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Set<StageId> completedStages=new HashSet<>();\n  List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n  while (!Thread.currentThread().isInterrupted()) {\n    sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n    List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n    if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n      break;\n    }\n    List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n    sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n    sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n    while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n      List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n      List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n      for (      StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n        SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n        StageId stageId=stageExecution.getStageExecutionId().getStageId();\n        stageExecution.beginScheduling();\n        ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n        if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n          for (          RemoteTask task : result.getNewTasks()) {\n            partialResultQueryTaskTracker.trackTask(task);\n            task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n          }\n        }\n        if (result.isFinished()) {\n          stageExecution.schedulingComplete();\n        }\n else         if (!result.getBlocked().isDone()) {\n          blockedStages.add(result.getBlocked());\n        }\n        stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n        schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n        if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:            break;\ncase WAITING_FOR_SOURCE:          schedulerStats.getWaitingForSource().update(1);\n        break;\ncase SPLIT_QUEUES_FULL:      schedulerStats.getSplitQueuesFull().update(1);\n    break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:  schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 521,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8228,
        "startLineNumber" : 394,
        "startColumnNumber" : 8,
        "endLineNumber" : 544,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try (SetThreadName ignored=new SetThreadName(\"Query-%s\",queryStateMachine.getQueryId())){\n  Set<StageId> completedStages=new HashSet<>();\n  List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n  while (!Thread.currentThread().isInterrupted()) {\n    sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n    List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n    if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n      break;\n    }\n    List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n    sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n    sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n    while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n      List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n      List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n      for (      StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n        SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n        StageId stageId=stageExecution.getStageExecutionId().getStageId();\n        stageExecution.beginScheduling();\n        ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n        if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n          for (          RemoteTask task : result.getNewTasks()) {\n            partialResultQueryTaskTracker.trackTask(task);\n            task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n          }\n        }\n        if (result.isFinished()) {\n          stageExecution.schedulingComplete();\n        }\n else         if (!result.getBlocked().isDone()) {\n          blockedStages.add(result.getBlocked());\n        }\n        stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n        schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n        if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:            break;\ncase WAITING_FOR_SOURCE:          schedulerStats.getWaitingForSource().update(1);\n        break;\ncase SPLIT_QUEUES_FULL:      schedulerStats.getSplitQueuesFull().update(1);\n    break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:  schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n catch (Throwable t) {\nscheduling.set(false);\nqueryStateMachine.transitionToFailed(t);\nthrow t;\n}\n finally {\nRuntimeException closeError=new RuntimeException();\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\ntry {\nstageExecutionInfo.getStageScheduler().close();\n}\n catch (Throwable t) {\nqueryStateMachine.transitionToFailed(t);\nif (closeError != t) {\ncloseError.addSuppressed(t);\n}\n}\n}\nif (closeError.getSuppressed().length > 0) {\nthrow closeError;\n}\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 608,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8478,
        "startLineNumber" : 386,
        "startColumnNumber" : 4,
        "endLineNumber" : 545,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!scheduling.compareAndSet(false,true)) {\n    return;\n  }\n  List<StageExecutionAndScheduler> scheduledStageExecutions=new ArrayList<>();\n  try (SetThreadName ignored=new SetThreadName(\"Query-%s\",queryStateMachine.getQueryId())){\n    Set<StageId> completedStages=new HashSet<>();\n    List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n    while (!Thread.currentThread().isInterrupted()) {\n      sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n      List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n      if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n        break;\n      }\n      List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n      sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n      sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n      while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n        List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n        List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n        for (        StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n          SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n          StageId stageId=stageExecution.getStageExecutionId().getStageId();\n          stageExecution.beginScheduling();\n          ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n          if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n            for (            RemoteTask task : result.getNewTasks()) {\n              partialResultQueryTaskTracker.trackTask(task);\n              task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n            }\n          }\n          if (result.isFinished()) {\n            stageExecution.schedulingComplete();\n          }\n else           if (!result.getBlocked().isDone()) {\n            blockedStages.add(result.getBlocked());\n          }\n          stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n          schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n          if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:              break;\ncase WAITING_FOR_SOURCE:            schedulerStats.getWaitingForSource().update(1);\n          break;\ncase SPLIT_QUEUES_FULL:        schedulerStats.getSplitQueuesFull().update(1);\n      break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:    schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\n  break;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n catch (Throwable t) {\nscheduling.set(false);\nqueryStateMachine.transitionToFailed(t);\nthrow t;\n}\n finally {\nRuntimeException closeError=new RuntimeException();\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\ntry {\nstageExecutionInfo.getStageScheduler().close();\n}\n catch (Throwable t) {\nqueryStateMachine.transitionToFailed(t);\nif (closeError != t) {\ncloseError.addSuppressed(t);\n}\n}\n}\nif (closeError.getSuppressed().length > 0) {\nthrow closeError;\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 630,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8506,
        "startLineNumber" : 385,
        "startColumnNumber" : 4,
        "endLineNumber" : 545,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private void schedule(){\n  if (!scheduling.compareAndSet(false,true)) {\n    return;\n  }\n  List<StageExecutionAndScheduler> scheduledStageExecutions=new ArrayList<>();\n  try (SetThreadName ignored=new SetThreadName(\"Query-%s\",queryStateMachine.getQueryId())){\n    Set<StageId> completedStages=new HashSet<>();\n    List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n    while (!Thread.currentThread().isInterrupted()) {\n      sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n      List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n      if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n        break;\n      }\n      List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n      sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n      sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n      while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n        List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n        List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n        for (        StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n          SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n          StageId stageId=stageExecution.getStageExecutionId().getStageId();\n          stageExecution.beginScheduling();\n          ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n          if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n            for (            RemoteTask task : result.getNewTasks()) {\n              partialResultQueryTaskTracker.trackTask(task);\n              task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n            }\n          }\n          if (result.isFinished()) {\n            stageExecution.schedulingComplete();\n          }\n else           if (!result.getBlocked().isDone()) {\n            blockedStages.add(result.getBlocked());\n          }\n          stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n          schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n          if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:              break;\ncase WAITING_FOR_SOURCE:            schedulerStats.getWaitingForSource().update(1);\n          break;\ncase SPLIT_QUEUES_FULL:        schedulerStats.getSplitQueuesFull().update(1);\n      break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:    schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\n  break;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n catch (Throwable t) {\nscheduling.set(false);\nqueryStateMachine.transitionToFailed(t);\nthrow t;\n}\n finally {\nRuntimeException closeError=new RuntimeException();\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\ntry {\nstageExecutionInfo.getStageScheduler().close();\n}\n catch (Throwable t) {\nqueryStateMachine.transitionToFailed(t);\nif (closeError != t) {\ncloseError.addSuppressed(t);\n}\n}\n}\nif (closeError.getSuppressed().length > 0) {\nthrow closeError;\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 634,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.SwitchStatement,expression]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 454,
        "startColumnNumber" : 36,
        "endLineNumber" : 454,
        "endColumnNumber" : 67
      },
      "nodeContext" : "result.getBlockedReason().get()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 2,
    "type" : "java.util.Optional<com.facebook.presto.execution.scheduler.ScheduleResult.BlockedReason>"
  }, {
    "nodeContext" : "result.getBlockedReason()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 471,
      "startColumnNumber" : 105,
      "endLineNumber" : 471,
      "endColumnNumber" : 130
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 471,
        "startColumnNumber" : 105,
        "endLineNumber" : 471,
        "endColumnNumber" : 136
      },
      "nodeContext" : "result.getBlockedReason().get()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 471,
        "startColumnNumber" : 76,
        "endLineNumber" : 471,
        "endColumnNumber" : 136
      },
      "nodeContext" : "\"Unknown blocked reason: \" + result.getBlockedReason().get()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ThrowStatement,expression]",
      "nodePosition" : {
        "charLength" : 95,
        "startLineNumber" : 471,
        "startColumnNumber" : 42,
        "endLineNumber" : 471,
        "endColumnNumber" : 137
      },
      "nodeContext" : "new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get())",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 102,
        "startLineNumber" : 471,
        "startColumnNumber" : 36,
        "endLineNumber" : 471,
        "endColumnNumber" : 138
      },
      "nodeContext" : "throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n",
      "nodeType" : "ThrowStatement",
      "astNodeNumber" : 11,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1185,
        "startLineNumber" : 454,
        "startColumnNumber" : 28,
        "endLineNumber" : 472,
        "endColumnNumber" : 29
      },
      "nodeContext" : "switch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:  break;\ncase WAITING_FOR_SOURCE:schedulerStats.getWaitingForSource().update(1);\nbreak;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 61,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1241,
        "startLineNumber" : 453,
        "startColumnNumber" : 67,
        "endLineNumber" : 473,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:    break;\ncase WAITING_FOR_SOURCE:  schedulerStats.getWaitingForSource().update(1);\nbreak;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 62,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1284,
        "startLineNumber" : 453,
        "startColumnNumber" : 24,
        "endLineNumber" : 473,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:    break;\ncase WAITING_FOR_SOURCE:  schedulerStats.getWaitingForSource().update(1);\nbreak;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 2999,
        "startLineNumber" : 426,
        "startColumnNumber" : 103,
        "endLineNumber" : 474,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n  StageId stageId=stageExecution.getStageExecutionId().getStageId();\n  stageExecution.beginScheduling();\n  ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n  if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n    for (    RemoteTask task : result.getNewTasks()) {\n      partialResultQueryTaskTracker.trackTask(task);\n      task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n    }\n  }\n  if (result.isFinished()) {\n    stageExecution.schedulingComplete();\n  }\n else   if (!result.getBlocked().isDone()) {\n    blockedStages.add(result.getBlocked());\n  }\n  stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n  schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n  if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:      break;\ncase WAITING_FOR_SOURCE:    schedulerStats.getWaitingForSource().update(1);\n  break;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 180,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3082,
        "startLineNumber" : 426,
        "startColumnNumber" : 20,
        "endLineNumber" : 474,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n  SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n  StageId stageId=stageExecution.getStageExecutionId().getStageId();\n  stageExecution.beginScheduling();\n  ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n  if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n    for (    RemoteTask task : result.getNewTasks()) {\n      partialResultQueryTaskTracker.trackTask(task);\n      task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n    }\n  }\n  if (result.isFinished()) {\n    stageExecution.schedulingComplete();\n  }\n else   if (!result.getBlocked().isDone()) {\n    blockedStages.add(result.getBlocked());\n  }\n  stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n  schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n  if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:      break;\ncase WAITING_FOR_SOURCE:    schedulerStats.getWaitingForSource().update(1);\n  break;\ncase SPLIT_QUEUES_FULL:schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 186,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 5121,
        "startLineNumber" : 419,
        "startColumnNumber" : 100,
        "endLineNumber" : 503,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n  List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n  for (  StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n    SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n    StageId stageId=stageExecution.getStageExecutionId().getStageId();\n    stageExecution.beginScheduling();\n    ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n    if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n      for (      RemoteTask task : result.getNewTasks()) {\n        partialResultQueryTaskTracker.trackTask(task);\n        task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n      }\n    }\n    if (result.isFinished()) {\n      stageExecution.schedulingComplete();\n    }\n else     if (!result.getBlocked().isDone()) {\n      blockedStages.add(result.getBlocked());\n    }\n    stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n    schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n    if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:        break;\ncase WAITING_FOR_SOURCE:      schedulerStats.getWaitingForSource().update(1);\n    break;\ncase SPLIT_QUEUES_FULL:  schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 336,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5205,
        "startLineNumber" : 419,
        "startColumnNumber" : 16,
        "endLineNumber" : 503,
        "endColumnNumber" : 17
      },
      "nodeContext" : "while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n  List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n  List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n  for (  StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n    SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n    StageId stageId=stageExecution.getStageExecutionId().getStageId();\n    stageExecution.beginScheduling();\n    ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n    if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n      for (      RemoteTask task : result.getNewTasks()) {\n        partialResultQueryTaskTracker.trackTask(task);\n        task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n      }\n    }\n    if (result.isFinished()) {\n      stageExecution.schedulingComplete();\n    }\n else     if (!result.getBlocked().isDone()) {\n      blockedStages.add(result.getBlocked());\n    }\n    stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n    schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n    if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:        break;\ncase WAITING_FOR_SOURCE:      schedulerStats.getWaitingForSource().update(1);\n    break;\ncase SPLIT_QUEUES_FULL:  schedulerStats.getSplitQueuesFull().update(1);\nbreak;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 345,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 6266,
        "startLineNumber" : 399,
        "startColumnNumber" : 60,
        "endLineNumber" : 504,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n  List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n  if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n    break;\n  }\n  List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n  sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n  sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n  while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n    List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n    List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n    for (    StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n      SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n      StageId stageId=stageExecution.getStageExecutionId().getStageId();\n      stageExecution.beginScheduling();\n      ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n      if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n        for (        RemoteTask task : result.getNewTasks()) {\n          partialResultQueryTaskTracker.trackTask(task);\n          task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n        }\n      }\n      if (result.isFinished()) {\n        stageExecution.schedulingComplete();\n      }\n else       if (!result.getBlocked().isDone()) {\n        blockedStages.add(result.getBlocked());\n      }\n      stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n      schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n      if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:          break;\ncase WAITING_FOR_SOURCE:        schedulerStats.getWaitingForSource().update(1);\n      break;\ncase SPLIT_QUEUES_FULL:    schedulerStats.getSplitQueuesFull().update(1);\n  break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 425,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6314,
        "startLineNumber" : 399,
        "startColumnNumber" : 12,
        "endLineNumber" : 504,
        "endColumnNumber" : 13
      },
      "nodeContext" : "while (!Thread.currentThread().isInterrupted()) {\n  sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n  List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n  if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n    break;\n  }\n  List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n  sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n  sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n  while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n    List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n    List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n    for (    StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n      SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n      StageId stageId=stageExecution.getStageExecutionId().getStageId();\n      stageExecution.beginScheduling();\n      ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n      if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n        for (        RemoteTask task : result.getNewTasks()) {\n          partialResultQueryTaskTracker.trackTask(task);\n          task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n        }\n      }\n      if (result.isFinished()) {\n        stageExecution.schedulingComplete();\n      }\n else       if (!result.getBlocked().isDone()) {\n        blockedStages.add(result.getBlocked());\n      }\n      stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n      schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n      if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:          break;\ncase WAITING_FOR_SOURCE:        schedulerStats.getWaitingForSource().update(1);\n      break;\ncase SPLIT_QUEUES_FULL:    schedulerStats.getSplitQueuesFull().update(1);\n  break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 432,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 7284,
        "startLineNumber" : 394,
        "startColumnNumber" : 100,
        "endLineNumber" : 521,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Set<StageId> completedStages=new HashSet<>();\n  List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n  while (!Thread.currentThread().isInterrupted()) {\n    sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n    List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n    if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n      break;\n    }\n    List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n    sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n    sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n    while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n      List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n      List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n      for (      StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n        SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n        StageId stageId=stageExecution.getStageExecutionId().getStageId();\n        stageExecution.beginScheduling();\n        ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n        if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n          for (          RemoteTask task : result.getNewTasks()) {\n            partialResultQueryTaskTracker.trackTask(task);\n            task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n          }\n        }\n        if (result.isFinished()) {\n          stageExecution.schedulingComplete();\n        }\n else         if (!result.getBlocked().isDone()) {\n          blockedStages.add(result.getBlocked());\n        }\n        stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n        schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n        if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:            break;\ncase WAITING_FOR_SOURCE:          schedulerStats.getWaitingForSource().update(1);\n        break;\ncase SPLIT_QUEUES_FULL:      schedulerStats.getSplitQueuesFull().update(1);\n    break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:  schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 521,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8228,
        "startLineNumber" : 394,
        "startColumnNumber" : 8,
        "endLineNumber" : 544,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try (SetThreadName ignored=new SetThreadName(\"Query-%s\",queryStateMachine.getQueryId())){\n  Set<StageId> completedStages=new HashSet<>();\n  List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n  while (!Thread.currentThread().isInterrupted()) {\n    sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n    List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n    if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n      break;\n    }\n    List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n    sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n    sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n    while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n      List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n      List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n      for (      StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n        SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n        StageId stageId=stageExecution.getStageExecutionId().getStageId();\n        stageExecution.beginScheduling();\n        ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n        if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n          for (          RemoteTask task : result.getNewTasks()) {\n            partialResultQueryTaskTracker.trackTask(task);\n            task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n          }\n        }\n        if (result.isFinished()) {\n          stageExecution.schedulingComplete();\n        }\n else         if (!result.getBlocked().isDone()) {\n          blockedStages.add(result.getBlocked());\n        }\n        stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n        schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n        if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:            break;\ncase WAITING_FOR_SOURCE:          schedulerStats.getWaitingForSource().update(1);\n        break;\ncase SPLIT_QUEUES_FULL:      schedulerStats.getSplitQueuesFull().update(1);\n    break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:  schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\nbreak;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n catch (Throwable t) {\nscheduling.set(false);\nqueryStateMachine.transitionToFailed(t);\nthrow t;\n}\n finally {\nRuntimeException closeError=new RuntimeException();\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\ntry {\nstageExecutionInfo.getStageScheduler().close();\n}\n catch (Throwable t) {\nqueryStateMachine.transitionToFailed(t);\nif (closeError != t) {\ncloseError.addSuppressed(t);\n}\n}\n}\nif (closeError.getSuppressed().length > 0) {\nthrow closeError;\n}\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 608,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8478,
        "startLineNumber" : 386,
        "startColumnNumber" : 4,
        "endLineNumber" : 545,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!scheduling.compareAndSet(false,true)) {\n    return;\n  }\n  List<StageExecutionAndScheduler> scheduledStageExecutions=new ArrayList<>();\n  try (SetThreadName ignored=new SetThreadName(\"Query-%s\",queryStateMachine.getQueryId())){\n    Set<StageId> completedStages=new HashSet<>();\n    List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n    while (!Thread.currentThread().isInterrupted()) {\n      sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n      List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n      if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n        break;\n      }\n      List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n      sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n      sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n      while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n        List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n        List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n        for (        StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n          SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n          StageId stageId=stageExecution.getStageExecutionId().getStageId();\n          stageExecution.beginScheduling();\n          ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n          if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n            for (            RemoteTask task : result.getNewTasks()) {\n              partialResultQueryTaskTracker.trackTask(task);\n              task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n            }\n          }\n          if (result.isFinished()) {\n            stageExecution.schedulingComplete();\n          }\n else           if (!result.getBlocked().isDone()) {\n            blockedStages.add(result.getBlocked());\n          }\n          stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n          schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n          if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:              break;\ncase WAITING_FOR_SOURCE:            schedulerStats.getWaitingForSource().update(1);\n          break;\ncase SPLIT_QUEUES_FULL:        schedulerStats.getSplitQueuesFull().update(1);\n      break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:    schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\n  break;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n catch (Throwable t) {\nscheduling.set(false);\nqueryStateMachine.transitionToFailed(t);\nthrow t;\n}\n finally {\nRuntimeException closeError=new RuntimeException();\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\ntry {\nstageExecutionInfo.getStageScheduler().close();\n}\n catch (Throwable t) {\nqueryStateMachine.transitionToFailed(t);\nif (closeError != t) {\ncloseError.addSuppressed(t);\n}\n}\n}\nif (closeError.getSuppressed().length > 0) {\nthrow closeError;\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 630,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8506,
        "startLineNumber" : 385,
        "startColumnNumber" : 4,
        "endLineNumber" : 545,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private void schedule(){\n  if (!scheduling.compareAndSet(false,true)) {\n    return;\n  }\n  List<StageExecutionAndScheduler> scheduledStageExecutions=new ArrayList<>();\n  try (SetThreadName ignored=new SetThreadName(\"Query-%s\",queryStateMachine.getQueryId())){\n    Set<StageId> completedStages=new HashSet<>();\n    List<ExecutionSchedule> sectionExecutionSchedules=new LinkedList<>();\n    while (!Thread.currentThread().isInterrupted()) {\n      sectionExecutionSchedules.removeIf(ExecutionSchedule::isFinished);\n      List<StreamingPlanSection> sectionsReadyForExecution=getSectionsReadyForExecution();\n      if (sectionsReadyForExecution.isEmpty() && sectionExecutionSchedules.isEmpty()) {\n        break;\n      }\n      List<List<StageExecutionAndScheduler>> sectionStageExecutions=getStageExecutions(sectionsReadyForExecution);\n      sectionStageExecutions.forEach(scheduledStageExecutions::addAll);\n      sectionStageExecutions.stream().map(executionInfos -> executionInfos.stream().collect(toImmutableList())).map(stages -> executionPolicy.createExecutionSchedule(session,stages)).forEach(sectionExecutionSchedules::add);\n      while (sectionExecutionSchedules.stream().noneMatch(ExecutionSchedule::isFinished)) {\n        List<ListenableFuture<?>> blockedStages=new ArrayList<>();\n        List<StageExecutionAndScheduler> executionsToSchedule=sectionExecutionSchedules.stream().flatMap(schedule -> schedule.getStagesToSchedule().stream()).collect(toImmutableList());\n        for (        StageExecutionAndScheduler stageExecutionAndScheduler : executionsToSchedule) {\n          SqlStageExecution stageExecution=stageExecutionAndScheduler.getStageExecution();\n          StageId stageId=stageExecution.getStageExecutionId().getStageId();\n          stageExecution.beginScheduling();\n          ScheduleResult result=stageExecutionAndScheduler.getStageScheduler().schedule();\n          if (isPartialResultsEnabled(session) && stageExecutionAndScheduler.getStageExecution().getFragment().isLeaf()) {\n            for (            RemoteTask task : result.getNewTasks()) {\n              partialResultQueryTaskTracker.trackTask(task);\n              task.addFinalTaskInfoListener(partialResultQueryTaskTracker::recordTaskFinish);\n            }\n          }\n          if (result.isFinished()) {\n            stageExecution.schedulingComplete();\n          }\n else           if (!result.getBlocked().isDone()) {\n            blockedStages.add(result.getBlocked());\n          }\n          stageExecutionAndScheduler.getStageLinkage().processScheduleResults(stageExecution.getState(),result.getNewTasks());\n          schedulerStats.getSplitsScheduledPerIteration().add(result.getSplitsScheduled());\n          if (result.getBlockedReason().isPresent()) {\nswitch (result.getBlockedReason().get()) {\ncase WRITER_SCALING:              break;\ncase WAITING_FOR_SOURCE:            schedulerStats.getWaitingForSource().update(1);\n          break;\ncase SPLIT_QUEUES_FULL:        schedulerStats.getSplitQueuesFull().update(1);\n      break;\ncase MIXED_SPLIT_QUEUES_FULL_AND_WAITING_FOR_SOURCE:    schedulerStats.getMixedSplitQueuesFullAndWaitingForSource().update(1);\n  break;\ncase NO_ACTIVE_DRIVER_GROUP:schedulerStats.getNoActiveDriverGroup().update(1);\nbreak;\ndefault:throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n}\n}\n}\nboolean stageFinishedExecution=false;\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nSqlStageExecution stageExecution=stageExecutionInfo.getStageExecution();\nStageId stageId=stageExecution.getStageExecutionId().getStageId();\nif (!completedStages.contains(stageId) && stageExecution.getState().isDone()) {\nstageExecutionInfo.getStageLinkage().processScheduleResults(stageExecution.getState(),ImmutableSet.of());\ncompletedStages.add(stageId);\nstageFinishedExecution=true;\n}\n}\nif (stageFinishedExecution) {\nbreak;\n}\nif (!blockedStages.isEmpty()) {\ntry (TimeStat.BlockTimer timer=schedulerStats.getSleepTime().time()){\ntryGetFutureValue(whenAnyComplete(blockedStages),1,SECONDS);\n}\n for (ListenableFuture<?> blockedStage : blockedStages) {\nblockedStage.cancel(true);\n}\n}\n}\n}\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\nStageExecutionState state=stageExecutionInfo.getStageExecution().getState();\nif (state != SCHEDULED && state != RUNNING && !state.isDone()) {\nthrow new PrestoException(GENERIC_INTERNAL_ERROR,format(\"Scheduling is complete, but stage execution %s is in state %s\",stageExecutionInfo.getStageExecution().getStageExecutionId(),state));\n}\n}\nscheduling.set(false);\npartialResultQueryTaskTracker.completeTaskScheduling();\nif (!getSectionsReadyForExecution().isEmpty()) {\nstartScheduling();\n}\n}\n catch (Throwable t) {\nscheduling.set(false);\nqueryStateMachine.transitionToFailed(t);\nthrow t;\n}\n finally {\nRuntimeException closeError=new RuntimeException();\nfor (StageExecutionAndScheduler stageExecutionInfo : scheduledStageExecutions) {\ntry {\nstageExecutionInfo.getStageScheduler().close();\n}\n catch (Throwable t) {\nqueryStateMachine.transitionToFailed(t);\nif (closeError != t) {\ncloseError.addSuppressed(t);\n}\n}\n}\nif (closeError.getSuppressed().length > 0) {\nthrow closeError;\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 634,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 102,
        "startLineNumber" : 471,
        "startColumnNumber" : 36,
        "endLineNumber" : 471,
        "endColumnNumber" : 138
      },
      "nodeContext" : "throw new UnsupportedOperationException(\"Unknown blocked reason: \" + result.getBlockedReason().get());\n",
      "nodeType" : "ThrowStatement",
      "astNodeNumber" : 11,
      "astHeight" : 6
    },
    "tokenLength" : 2,
    "type" : "java.util.Optional<com.facebook.presto.execution.scheduler.ScheduleResult.BlockedReason>"
  } ],
  "positionList" : [ {
    "charLength" : 25,
    "startLineNumber" : 453,
    "startColumnNumber" : 28,
    "endLineNumber" : 453,
    "endColumnNumber" : 53
  }, {
    "charLength" : 25,
    "startLineNumber" : 454,
    "startColumnNumber" : 36,
    "endLineNumber" : 454,
    "endColumnNumber" : 61
  }, {
    "charLength" : 25,
    "startLineNumber" : 471,
    "startColumnNumber" : 105,
    "endLineNumber" : 471,
    "endColumnNumber" : 130
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 1
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 4
  } ]
}