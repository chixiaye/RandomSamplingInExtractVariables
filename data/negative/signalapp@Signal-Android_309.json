{
  "id" : 309,
  "expression" : "recipient",
  "projectName" : "signalapp@Signal-Android",
  "commitID" : "2068fa80416a11892d4665e3656be70df4512340",
  "filePath" : "app/src/main/java/org/thoughtcrime/securesms/messages/GroupSendUtil.java",
  "occurrences" : 6,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "recipient",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 147,
      "startColumnNumber" : 82,
      "endLineNumber" : 147,
      "endColumnNumber" : 91
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 147,
        "startColumnNumber" : 82,
        "endLineNumber" : 147,
        "endColumnNumber" : 99
      },
      "nodeContext" : "recipient.getId()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 147,
        "startColumnNumber" : 57,
        "endLineNumber" : 147,
        "endColumnNumber" : 100
      },
      "nodeContext" : "recipients.getAccessPair(recipient.getId())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 61,
        "startLineNumber" : 147,
        "startColumnNumber" : 39,
        "endLineNumber" : 147,
        "endColumnNumber" : 100
      },
      "nodeContext" : "access=recipients.getAccessPair(recipient.getId())",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 95,
        "startLineNumber" : 147,
        "startColumnNumber" : 6,
        "endLineNumber" : 147,
        "endColumnNumber" : 101
      },
      "nodeContext" : "Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 719,
        "startLineNumber" : 146,
        "startColumnNumber" : 43,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (Recipient recipient : allTargets) {\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 79,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 95,
        "startLineNumber" : 147,
        "startColumnNumber" : 6,
        "endLineNumber" : 147,
        "endColumnNumber" : 101
      },
      "nodeContext" : "Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "org.thoughtcrime.securesms.recipients.Recipient"
  }, {
    "nodeContext" : "recipient",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 148,
      "startColumnNumber" : 124,
      "endLineNumber" : 148,
      "endColumnNumber" : 133
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 148,
        "startColumnNumber" : 124,
        "endLineNumber" : 148,
        "endColumnNumber" : 141
      },
      "nodeContext" : "recipient.getId()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 58,
        "startLineNumber" : 148,
        "startColumnNumber" : 84,
        "endLineNumber" : 148,
        "endColumnNumber" : 142
      },
      "nodeContext" : "groupRecord.get().getMembers().contains(recipient.getId())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 148,
        "startColumnNumber" : 57,
        "endLineNumber" : 148,
        "endColumnNumber" : 142
      },
      "nodeContext" : "groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId())",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 103,
        "startLineNumber" : 148,
        "startColumnNumber" : 39,
        "endLineNumber" : 148,
        "endColumnNumber" : 142
      },
      "nodeContext" : "validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId())",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 137,
        "startLineNumber" : 148,
        "startColumnNumber" : 6,
        "endLineNumber" : 148,
        "endColumnNumber" : 143
      },
      "nodeContext" : "boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 719,
        "startLineNumber" : 146,
        "startColumnNumber" : 43,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (Recipient recipient : allTargets) {\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 79,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 137,
        "startLineNumber" : 148,
        "startColumnNumber" : 6,
        "endLineNumber" : 148,
        "endColumnNumber" : 143
      },
      "nodeContext" : "boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "org.thoughtcrime.securesms.recipients.Recipient"
  }, {
    "nodeContext" : "recipient",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 150,
      "startColumnNumber" : 10,
      "endLineNumber" : 150,
      "endColumnNumber" : 19
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 150,
        "endColumnNumber" : 44
      },
      "nodeContext" : "recipient.getSenderKeyCapability()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 150,
        "endColumnNumber" : 78
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 101,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 151,
        "endColumnNumber" : 29
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 182,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 152,
        "endColumnNumber" : 28
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 300,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 153,
        "endColumnNumber" : 64
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 25,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 343,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 154,
        "endColumnNumber" : 25
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 27,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 458,
        "startLineNumber" : 150,
        "startColumnNumber" : 6,
        "endLineNumber" : 159,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n  senderKeyTargets.add(recipient);\n}\n else {\n  legacyTargets.add(recipient);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 40,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 719,
        "startLineNumber" : 146,
        "startColumnNumber" : 43,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (Recipient recipient : allTargets) {\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 79,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 150,
        "endColumnNumber" : 78
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "org.thoughtcrime.securesms.recipients.Recipient"
  }, {
    "nodeContext" : "recipient",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 151,
      "startColumnNumber" : 10,
      "endLineNumber" : 151,
      "endColumnNumber" : 19
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 151,
        "startColumnNumber" : 10,
        "endLineNumber" : 151,
        "endColumnNumber" : 29
      },
      "nodeContext" : "recipient.hasUuid()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 101,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 151,
        "endColumnNumber" : 29
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 182,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 152,
        "endColumnNumber" : 28
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 300,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 153,
        "endColumnNumber" : 64
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 25,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 343,
        "startLineNumber" : 150,
        "startColumnNumber" : 10,
        "endLineNumber" : 154,
        "endColumnNumber" : 25
      },
      "nodeContext" : "recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 27,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 458,
        "startLineNumber" : 150,
        "startColumnNumber" : 6,
        "endLineNumber" : 159,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n  senderKeyTargets.add(recipient);\n}\n else {\n  legacyTargets.add(recipient);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 40,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 719,
        "startLineNumber" : 146,
        "startColumnNumber" : 43,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (Recipient recipient : allTargets) {\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 79,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 151,
        "startColumnNumber" : 10,
        "endLineNumber" : 151,
        "endColumnNumber" : 29
      },
      "nodeContext" : "recipient.hasUuid()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "org.thoughtcrime.securesms.recipients.Recipient"
  }, {
    "nodeContext" : "recipient",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 156,
      "startColumnNumber" : 29,
      "endLineNumber" : 156,
      "endColumnNumber" : 38
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 156,
        "startColumnNumber" : 8,
        "endLineNumber" : 156,
        "endColumnNumber" : 39
      },
      "nodeContext" : "senderKeyTargets.add(recipient)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 156,
        "startColumnNumber" : 8,
        "endLineNumber" : 156,
        "endColumnNumber" : 40
      },
      "nodeContext" : "senderKeyTargets.add(recipient);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 155,
        "startColumnNumber" : 6,
        "endLineNumber" : 157,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  senderKeyTargets.add(recipient);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 458,
        "startLineNumber" : 150,
        "startColumnNumber" : 6,
        "endLineNumber" : 159,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n  senderKeyTargets.add(recipient);\n}\n else {\n  legacyTargets.add(recipient);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 40,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 719,
        "startLineNumber" : 146,
        "startColumnNumber" : 43,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (Recipient recipient : allTargets) {\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 79,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 156,
        "startColumnNumber" : 8,
        "endLineNumber" : 156,
        "endColumnNumber" : 40
      },
      "nodeContext" : "senderKeyTargets.add(recipient);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "org.thoughtcrime.securesms.recipients.Recipient"
  }, {
    "nodeContext" : "recipient",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 158,
      "startColumnNumber" : 26,
      "endLineNumber" : 158,
      "endColumnNumber" : 35
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 158,
        "startColumnNumber" : 8,
        "endLineNumber" : 158,
        "endColumnNumber" : 36
      },
      "nodeContext" : "legacyTargets.add(recipient)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 158,
        "startColumnNumber" : 8,
        "endLineNumber" : 158,
        "endColumnNumber" : 37
      },
      "nodeContext" : "legacyTargets.add(recipient);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 157,
        "startColumnNumber" : 13,
        "endLineNumber" : 159,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  legacyTargets.add(recipient);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 458,
        "startLineNumber" : 150,
        "startColumnNumber" : 6,
        "endLineNumber" : 159,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n  senderKeyTargets.add(recipient);\n}\n else {\n  legacyTargets.add(recipient);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 40,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 719,
        "startLineNumber" : 146,
        "startColumnNumber" : 43,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 73,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 160,
        "endColumnNumber" : 5
      },
      "nodeContext" : "for (Recipient recipient : allTargets) {\n  Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n  boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n  if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n    senderKeyTargets.add(recipient);\n  }\n else {\n    legacyTargets.add(recipient);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 79,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6859,
        "startLineNumber" : 139,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 815,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7926,
        "startLineNumber" : 124,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Handles all of the logic of sending to a group. Will do sender key sends and legacy 1:1 sends as-needed, and give you back a list of {@link SendMessageResult}s just like we're used to.\n * @param groupId The groupId of the group you're sending to, or null if you're sending to a collection of recipients not joined by a group.\n * @param isRecipientUpdate True if you've already sent this message to some recipients in the past, otherwise false.\n */\n@WorkerThread private static List<SendMessageResult> sendMessage(@NonNull Context context,@Nullable GroupId.V2 groupId,@NonNull List<Recipient> allTargets,boolean isRecipientUpdate,@NonNull SendOperation sendOperation,@Nullable CancelationSignal cancelationSignal) throws IOException, UntrustedIdentityException {\n  RecipientData recipients=new RecipientData(context,allTargets);\n  Optional<GroupRecord> groupRecord=groupId != null ? DatabaseFactory.getGroupDatabase(context).getGroup(groupId) : Optional.absent();\n  List<Recipient> senderKeyTargets=new LinkedList<>();\n  List<Recipient> legacyTargets=new LinkedList<>();\n  for (  Recipient recipient : allTargets) {\n    Optional<UnidentifiedAccessPair> access=recipients.getAccessPair(recipient.getId());\n    boolean validMembership=groupRecord.isPresent() && groupRecord.get().getMembers().contains(recipient.getId());\n    if (recipient.getSenderKeyCapability() == Recipient.Capability.SUPPORTED && recipient.hasUuid() && access.isPresent() && access.get().getTargetUnidentifiedAccess().isPresent() && validMembership) {\n      senderKeyTargets.add(recipient);\n    }\n else {\n      legacyTargets.add(recipient);\n    }\n  }\n  if (FeatureFlags.senderKey()) {\n    if (groupId == null) {\n      Log.i(TAG,\"Recipients not in a group. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (Recipient.self().getSenderKeyCapability() != Recipient.Capability.SUPPORTED) {\n      Log.i(TAG,\"All of our devices do not support sender key. Using legacy.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else     if (SignalStore.internalValues().removeSenderKeyMinimum()) {\n      Log.i(TAG,\"Sender key minimum removed. Using for \" + senderKeyTargets.size() + \" recipients.\");\n    }\n else     if (senderKeyTargets.size() < 2) {\n      Log.i(TAG,\"Too few sender-key-capable users (\" + senderKeyTargets.size() + \"). Doing all legacy sends.\");\n      legacyTargets.addAll(senderKeyTargets);\n      senderKeyTargets.clear();\n    }\n else {\n      Log.i(TAG,\"Can use sender key for \" + senderKeyTargets.size() + \"/\"+ allTargets.size()+ \" recipients.\");\n    }\n  }\n else {\n    Log.i(TAG,\"Feature flag disabled. Using legacy.\");\n    legacyTargets.addAll(senderKeyTargets);\n    senderKeyTargets.clear();\n  }\n  List<SendMessageResult> allResults=new ArrayList<>(allTargets.size());\n  SignalServiceMessageSender messageSender=ApplicationDependencies.getSignalServiceMessageSender();\n  if (senderKeyTargets.size() > 0 && groupId != null) {\n    DistributionId distributionId=DatabaseFactory.getGroupDatabase(context).getOrCreateDistributionId(groupId);\n    long keyCreateTime=SenderKeyUtil.getCreateTimeForOurKey(context,distributionId);\n    long keyAge=System.currentTimeMillis() - keyCreateTime;\n    if (keyCreateTime != -1 && keyAge > MAX_KEY_AGE) {\n      Log.w(TAG,\"Key is \" + (keyAge) + \" ms old (~\"+ TimeUnit.MILLISECONDS.toDays(keyAge)+ \" days). Rotating.\");\n      SenderKeyUtil.rotateOurKey(context,distributionId);\n    }\n    try {\n      List<SignalServiceAddress> targets=senderKeyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n      List<UnidentifiedAccess> access=senderKeyTargets.stream().map(r -> recipients.requireAccess(r.getId())).collect(Collectors.toList());\n      List<SendMessageResult> results=sendOperation.sendWithSenderKey(messageSender,distributionId,targets,access,isRecipientUpdate);\n      allResults.addAll(results);\n      int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n      Log.d(TAG,\"Successfully sent using sender key to \" + successCount + \"/\"+ targets.size()+ \" sender key targets.\");\n      if (sendOperation.shouldIncludeInMessageLog()) {\n        DatabaseFactory.getMessageLogDatabase(context).insertIfPossible(sendOperation.getSentTimestamp(),senderKeyTargets,results,sendOperation.getContentHint(),sendOperation.getRelatedMessageId());\n      }\n    }\n catch (    InvalidUnidentifiedAccessHeaderException e) {\n      Log.w(TAG,\"Someone had a bad UD header. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    NoSessionException e) {\n      Log.w(TAG,\"No session. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\ncatch (    InvalidKeyException e) {\n      Log.w(TAG,\"Invalid Key. Falling back to legacy sends.\",e);\n      legacyTargets.addAll(senderKeyTargets);\n    }\n  }\n  if (cancelationSignal != null && cancelationSignal.isCanceled()) {\n    throw new CancelationException();\n  }\n  boolean onlyTargetIsSelfWithLinkedDevice=legacyTargets.isEmpty() && senderKeyTargets.isEmpty() && TextSecurePreferences.isMultiDevice(context);\n  if (legacyTargets.size() > 0 || onlyTargetIsSelfWithLinkedDevice) {\n    if (legacyTargets.size() > 0) {\n      Log.i(TAG,\"Need to do \" + legacyTargets.size() + \" legacy sends.\");\n    }\n else {\n      Log.i(TAG,\"Need to do a legacy send to send a sync message for a group of only ourselves.\");\n    }\n    List<SignalServiceAddress> targets=legacyTargets.stream().map(r -> recipients.getAddress(r.getId())).collect(Collectors.toList());\n    List<Optional<UnidentifiedAccessPair>> access=legacyTargets.stream().map(r -> recipients.getAccessPair(r.getId())).collect(Collectors.toList());\n    boolean recipientUpdate=isRecipientUpdate || allResults.size() > 0;\n    final MessageSendLogDatabase messageLogDatabase=DatabaseFactory.getMessageLogDatabase(context);\n    final AtomicLong entryId=new AtomicLong(-1);\n    final boolean includeInMessageLog=sendOperation.shouldIncludeInMessageLog();\n    List<SendMessageResult> results=sendOperation.sendLegacy(messageSender,targets,access,recipientUpdate,result -> {\n      if (!includeInMessageLog) {\n        return;\n      }\nsynchronized (entryId) {\n        if (entryId.get() == -1) {\n          entryId.set(messageLogDatabase.insertIfPossible(recipients.requireRecipientId(result.getAddress()),sendOperation.getSentTimestamp(),result,sendOperation.getContentHint(),sendOperation.getRelatedMessageId()));\n        }\n else {\n          messageLogDatabase.addRecipientToExistingEntryIfPossible(entryId.get(),recipients.requireRecipientId(result.getAddress()),result);\n        }\n      }\n    }\n,cancelationSignal);\n    allResults.addAll(results);\n    int successCount=(int)results.stream().filter(SendMessageResult::isSuccess).count();\n    Log.d(TAG,\"Successfully sent using 1:1 to \" + successCount + \"/\"+ targets.size()+ \" legacy targets.\");\n  }\n  return allResults;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 158,
        "startColumnNumber" : 8,
        "endLineNumber" : 158,
        "endColumnNumber" : 37
      },
      "nodeContext" : "legacyTargets.add(recipient);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "org.thoughtcrime.securesms.recipients.Recipient"
  } ],
  "positionList" : [ {
    "charLength" : 9,
    "startLineNumber" : 147,
    "startColumnNumber" : 82,
    "endLineNumber" : 147,
    "endColumnNumber" : 91
  }, {
    "charLength" : 9,
    "startLineNumber" : 148,
    "startColumnNumber" : 124,
    "endLineNumber" : 148,
    "endColumnNumber" : 133
  }, {
    "charLength" : 9,
    "startLineNumber" : 150,
    "startColumnNumber" : 10,
    "endLineNumber" : 150,
    "endColumnNumber" : 19
  }, {
    "charLength" : 9,
    "startLineNumber" : 151,
    "startColumnNumber" : 10,
    "endLineNumber" : 151,
    "endColumnNumber" : 19
  }, {
    "charLength" : 9,
    "startLineNumber" : 156,
    "startColumnNumber" : 29,
    "endLineNumber" : 156,
    "endColumnNumber" : 38
  }, {
    "charLength" : 9,
    "startLineNumber" : 158,
    "startColumnNumber" : 26,
    "endLineNumber" : 158,
    "endColumnNumber" : 35
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 2
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 3
  } ]
}