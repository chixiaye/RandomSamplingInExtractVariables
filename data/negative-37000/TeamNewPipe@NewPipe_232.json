{
  "id" : 232,
  "expression" : "0x81",
  "projectName" : "TeamNewPipe@NewPipe",
  "commitID" : "d7574973e97fa7a3a21aa59967311f6091941830",
  "filePath" : "/app/src/main/java/org/schabi/newpipe/streams/WebMWriter.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "0x81",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 151,
      "startColumnNumber" : 36,
      "endLineNumber" : 151,
      "endColumnNumber" : 40
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ArrayInitializer,expressions]",
      "nodePosition" : {
        "charLength" : 11,
        "startLineNumber" : 151,
        "startColumnNumber" : 29,
        "endLineNumber" : 151,
        "endColumnNumber" : 40
      },
      "nodeContext" : "(byte)0x81",
      "nodeType" : "CastExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayCreation,initializer]",
      "nodePosition" : {
        "charLength" : 923,
        "startLineNumber" : 147,
        "startColumnNumber" : 33,
        "endLineNumber" : 162,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00}",
      "nodeType" : "ArrayInitializer",
      "astNodeNumber" : 128,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 933,
        "startLineNumber" : 147,
        "startColumnNumber" : 23,
        "endLineNumber" : 162,
        "endColumnNumber" : 9
      },
      "nodeContext" : "new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00}",
      "nodeType" : "ArrayCreation",
      "astNodeNumber" : 132,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 949,
        "startLineNumber" : 147,
        "startColumnNumber" : 8,
        "endLineNumber" : 162,
        "endColumnNumber" : 10
      },
      "nodeContext" : "listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00})",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 135,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 950,
        "startLineNumber" : 147,
        "startColumnNumber" : 8,
        "endLineNumber" : 162,
        "endColumnNumber" : 11
      },
      "nodeContext" : "listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 136,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ArrayInitializer,expressions]",
      "nodePosition" : {
        "charLength" : 11,
        "startLineNumber" : 151,
        "startColumnNumber" : 29,
        "endLineNumber" : 151,
        "endColumnNumber" : 40
      },
      "nodeContext" : "(byte)0x81",
      "nodeType" : "CastExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "0x81",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 154,
      "startColumnNumber" : 86,
      "endLineNumber" : 154,
      "endColumnNumber" : 90
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ArrayInitializer,expressions]",
      "nodePosition" : {
        "charLength" : 11,
        "startLineNumber" : 154,
        "startColumnNumber" : 79,
        "endLineNumber" : 154,
        "endColumnNumber" : 90
      },
      "nodeContext" : "(byte)0x81",
      "nodeType" : "CastExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ArrayCreation,initializer]",
      "nodePosition" : {
        "charLength" : 923,
        "startLineNumber" : 147,
        "startColumnNumber" : 33,
        "endLineNumber" : 162,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00}",
      "nodeType" : "ArrayInitializer",
      "astNodeNumber" : 128,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 933,
        "startLineNumber" : 147,
        "startColumnNumber" : 23,
        "endLineNumber" : 162,
        "endColumnNumber" : 9
      },
      "nodeContext" : "new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00}",
      "nodeType" : "ArrayCreation",
      "astNodeNumber" : 132,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 949,
        "startLineNumber" : 147,
        "startColumnNumber" : 8,
        "endLineNumber" : 162,
        "endColumnNumber" : 10
      },
      "nodeContext" : "listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00})",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 135,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 950,
        "startLineNumber" : 147,
        "startColumnNumber" : 8,
        "endLineNumber" : 162,
        "endColumnNumber" : 11
      },
      "nodeContext" : "listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 136,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ArrayInitializer,expressions]",
      "nodePosition" : {
        "charLength" : 11,
        "startLineNumber" : 154,
        "startColumnNumber" : 79,
        "endLineNumber" : 154,
        "endColumnNumber" : 90
      },
      "nodeContext" : "(byte)0x81",
      "nodeType" : "CastExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 4,
    "startLineNumber" : 151,
    "startColumnNumber" : 36,
    "endLineNumber" : 151,
    "endColumnNumber" : 40
  }, {
    "charLength" : 4,
    "startLineNumber" : 154,
    "startColumnNumber" : 86,
    "endLineNumber" : 154,
    "endColumnNumber" : 90
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 1
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 1
  } ]
}