{
  "id" : 123,
  "expression" : "dropped > 0",
  "projectName" : "Anuken@Mindustry",
  "commitID" : "a7188c48845dd423fc9b58bc6bcf6797f6d25b46",
  "filePath" : "/core/src/mindustry/logic/LExecutor.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "dropped > 0",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 11,
      "startLineNumber" : 490,
      "startColumnNumber" : 63,
      "endLineNumber" : 490,
      "endColumnNumber" : 74
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 490,
        "startColumnNumber" : 27,
        "endLineNumber" : 490,
        "endColumnNumber" : 74
      },
      "nodeContext" : "build != null && build.isValid() && dropped > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 126,
        "startLineNumber" : 490,
        "startColumnNumber" : 27,
        "endLineNumber" : 490,
        "endColumnNumber" : 153
      },
      "nodeContext" : "build != null && build.isValid() && dropped > 0 && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 27,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 498,
        "startLineNumber" : 490,
        "startColumnNumber" : 24,
        "endLineNumber" : 496,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (build != null && build.isValid() && dropped > 0 && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\n  int accepted=build.acceptStack(unit.item(),dropped,unit);\n  if (accepted > 0) {\n    Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n    ai.itemTimer=LogicAI.transferDelay;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 70,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 742,
        "startLineNumber" : 485,
        "startColumnNumber" : 37,
        "endLineNumber" : 497,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (ai.itemTimer > 0)   return;\n  Building build=exec.building(p1);\n  int dropped=Math.min(unit.stack.amount,exec.numi(p2));\n  if (build != null && build.isValid() && dropped > 0 && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\n    int accepted=build.acceptStack(unit.item(),dropped,unit);\n    if (accepted > 0) {\n      Call.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\n      ai.itemTimer=LogicAI.transferDelay;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 103,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7382,
        "startLineNumber" : 368,
        "startColumnNumber" : 16,
        "endLineNumber" : 514,
        "endColumnNumber" : 17
      },
      "nodeContext" : "switch (type) {\ncase move, stop, approach ->{\n    ai.control=type;\n    ai.moveX=x1;\n    ai.moveY=y1;\n    if (type == LUnitControl.approach) {\n      ai.moveRad=d1;\n    }\n    if (type == LUnitControl.stop) {\n      unit.mineTile=null;\n      unit.clearBuilding();\n    }\n  }\ncase within ->{\n  exec.setnum(p4,unit.within(x1,y1,d1) ? 1 : 0);\n}\ncase pathfind ->{\nai.control=type;\n}\ncase target ->{\nai.posTarget.set(x1,y1);\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(x1,y1);\nif (unit.canMine()) {\nunit.mineTile=unit.validMine(tile) ? tile : null;\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type.hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit.canBuild() && exec.obj(p3) instanceof Block block) {\nint x=World.toTile(x1 - block.offset / tilesize), y=World.toTile(y1 - block.offset / tilesize);\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || unit.plans.isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=exec.obj(p5) instanceof Content c ? c : null;\nunit.clearBuilding();\nif (ai.plan.tile() != null) {\nunit.updateBuilding=true;\nunit.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x1,y1,range)) {\nexec.setobj(p3,null);\nexec.setobj(p4,null);\n}\n else {\nTile tile=world.tileWorld(x1,y1);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setobj(p4,tile != null && tile.build != null ? tile.build : null);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint dropped=Math.min(unit.stack.amount,exec.numi(p2));\nif (build != null && build.isValid() && dropped > 0 && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && build.isValid() && build.items != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 897,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 7602,
        "startLineNumber" : 364,
        "startColumnNumber" : 58,
        "endLineNumber" : 515,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  ai.controlTimer=LogicAI.logicControlTimeout;\n  float x1=World.unconv(exec.numf(p1)), y1=World.unconv(exec.numf(p2)), d1=World.unconv(exec.numf(p3));\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=x1;\n      ai.moveY=y1;\n      if (type == LUnitControl.approach) {\n        ai.moveRad=d1;\n      }\n      if (type == LUnitControl.stop) {\n        unit.mineTile=null;\n        unit.clearBuilding();\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(x1,y1,d1) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(x1,y1);\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(x1,y1);\nif (unit.canMine()) {\nunit.mineTile=unit.validMine(tile) ? tile : null;\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type.hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit.canBuild() && exec.obj(p3) instanceof Block block) {\nint x=World.toTile(x1 - block.offset / tilesize), y=World.toTile(y1 - block.offset / tilesize);\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || unit.plans.isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=exec.obj(p5) instanceof Content c ? c : null;\nunit.clearBuilding();\nif (ai.plan.tile() != null) {\nunit.updateBuilding=true;\nunit.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x1,y1,range)) {\nexec.setobj(p3,null);\nexec.setobj(p4,null);\n}\n else {\nTile tile=world.tileWorld(x1,y1);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setobj(p4,tile != null && tile.build != null ? tile.build : null);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint dropped=Math.min(unit.stack.amount,exec.numi(p2));\nif (build != null && build.isValid() && dropped > 0 && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && build.isValid() && build.items != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 935,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7648,
        "startLineNumber" : 364,
        "startColumnNumber" : 12,
        "endLineNumber" : 515,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (unitObj instanceof Unit unit && ai != null) {\n  ai.controlTimer=LogicAI.logicControlTimeout;\n  float x1=World.unconv(exec.numf(p1)), y1=World.unconv(exec.numf(p2)), d1=World.unconv(exec.numf(p3));\nswitch (type) {\ncase move, stop, approach ->{\n      ai.control=type;\n      ai.moveX=x1;\n      ai.moveY=y1;\n      if (type == LUnitControl.approach) {\n        ai.moveRad=d1;\n      }\n      if (type == LUnitControl.stop) {\n        unit.mineTile=null;\n        unit.clearBuilding();\n      }\n    }\ncase within ->{\n    exec.setnum(p4,unit.within(x1,y1,d1) ? 1 : 0);\n  }\ncase pathfind ->{\n  ai.control=type;\n}\ncase target ->{\nai.posTarget.set(x1,y1);\nai.aimControl=type;\nai.mainTarget=null;\nai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(x1,y1);\nif (unit.canMine()) {\nunit.mineTile=unit.validMine(tile) ? tile : null;\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type.hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit.canBuild() && exec.obj(p3) instanceof Block block) {\nint x=World.toTile(x1 - block.offset / tilesize), y=World.toTile(y1 - block.offset / tilesize);\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || unit.plans.isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=exec.obj(p5) instanceof Content c ? c : null;\nunit.clearBuilding();\nif (ai.plan.tile() != null) {\nunit.updateBuilding=true;\nunit.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x1,y1,range)) {\nexec.setobj(p3,null);\nexec.setobj(p4,null);\n}\n else {\nTile tile=world.tileWorld(x1,y1);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setobj(p4,tile != null && tile.build != null ? tile.build : null);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint dropped=Math.min(unit.stack.amount,exec.numi(p2));\nif (build != null && build.isValid() && dropped > 0 && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && build.isValid() && build.items != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 946,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7820,
        "startLineNumber" : 359,
        "startColumnNumber" : 39,
        "endLineNumber" : 516,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\n    float x1=World.unconv(exec.numf(p1)), y1=World.unconv(exec.numf(p2)), d1=World.unconv(exec.numf(p3));\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=x1;\n        ai.moveY=y1;\n        if (type == LUnitControl.approach) {\n          ai.moveRad=d1;\n        }\n        if (type == LUnitControl.stop) {\n          unit.mineTile=null;\n          unit.clearBuilding();\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(x1,y1,d1) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(x1,y1);\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(x1,y1);\nif (unit.canMine()) {\nunit.mineTile=unit.validMine(tile) ? tile : null;\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type.hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit.canBuild() && exec.obj(p3) instanceof Block block) {\nint x=World.toTile(x1 - block.offset / tilesize), y=World.toTile(y1 - block.offset / tilesize);\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || unit.plans.isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=exec.obj(p5) instanceof Content c ? c : null;\nunit.clearBuilding();\nif (ai.plan.tile() != null) {\nunit.updateBuilding=true;\nunit.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x1,y1,range)) {\nexec.setobj(p3,null);\nexec.setobj(p4,null);\n}\n else {\nTile tile=world.tileWorld(x1,y1);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setobj(p4,tile != null && tile.build != null ? tile.build : null);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint dropped=Math.min(unit.stack.amount,exec.numi(p2));\nif (build != null && build.isValid() && dropped > 0 && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && build.isValid() && build.items != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 965,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7869,
        "startLineNumber" : 358,
        "startColumnNumber" : 8,
        "endLineNumber" : 516,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override public void run(LExecutor exec){\n  Object unitObj=exec.obj(varUnit);\n  LogicAI ai=checkLogicAI(exec,unitObj);\n  if (unitObj instanceof   Unit unit && ai != null) {\n    ai.controlTimer=LogicAI.logicControlTimeout;\n    float x1=World.unconv(exec.numf(p1)), y1=World.unconv(exec.numf(p2)), d1=World.unconv(exec.numf(p3));\nswitch (type) {\ncase move, stop, approach ->{\n        ai.control=type;\n        ai.moveX=x1;\n        ai.moveY=y1;\n        if (type == LUnitControl.approach) {\n          ai.moveRad=d1;\n        }\n        if (type == LUnitControl.stop) {\n          unit.mineTile=null;\n          unit.clearBuilding();\n        }\n      }\ncase within ->{\n      exec.setnum(p4,unit.within(x1,y1,d1) ? 1 : 0);\n    }\ncase pathfind ->{\n    ai.control=type;\n  }\ncase target ->{\n  ai.posTarget.set(x1,y1);\n  ai.aimControl=type;\n  ai.mainTarget=null;\n  ai.shoot=exec.bool(p3);\n}\ncase targetp ->{\nai.aimControl=type;\nai.mainTarget=exec.obj(p1) instanceof Teamc t ? t : null;\nai.shoot=exec.bool(p2);\n}\ncase boost ->{\nai.boost=exec.bool(p1);\n}\ncase flag ->{\nunit.flag=exec.num(p1);\n}\ncase mine ->{\nTile tile=world.tileWorld(x1,y1);\nif (unit.canMine()) {\nunit.mineTile=unit.validMine(tile) ? tile : null;\n}\n}\ncase payDrop ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay && pay.hasPayload()) {\nCall.payloadDropped(unit,unit.x,unit.y);\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase payTake ->{\nif (ai.payTimer > 0) return;\nif (unit instanceof Payloadc pay) {\nif (exec.bool(p1)) {\nUnit result=Units.closest(unit.team,unit.x,unit.y,unit.type.hitSize * 2f,u -> u.isAI() && u.isGrounded() && pay.canPickup(u)&& u.within(unit,u.hitSize + unit.hitSize * 1.2f));\nif (result != null) {\nCall.pickedUnitPayload(unit,result);\n}\n}\n else {\nBuilding tile=world.buildWorld(unit.x,unit.y);\nif (tile != null && tile.team == unit.team) {\nif (tile.block.buildVisibility != BuildVisibility.hidden && tile.canPickup() && pay.canPickup(tile)) {\nCall.pickedBuildPayload(unit,tile,true);\n}\n else {\nPayload current=tile.getPayload();\nif (current != null && pay.canPickupPayload(current)) {\nCall.pickedBuildPayload(unit,tile,false);\n}\n}\n}\n}\nai.payTimer=LogicAI.transferDelay;\n}\n}\ncase build ->{\nif (unit.canBuild() && exec.obj(p3) instanceof Block block) {\nint x=World.toTile(x1 - block.offset / tilesize), y=World.toTile(y1 - block.offset / tilesize);\nint rot=exec.numi(p4);\nif (ai.plan.x != x || ai.plan.y != y || ai.plan.block != block || unit.plans.isEmpty()) {\nai.plan.progress=0;\nai.plan.initialized=false;\nai.plan.stuck=false;\n}\nai.plan.set(x,y,rot,block);\nai.plan.config=exec.obj(p5) instanceof Content c ? c : null;\nunit.clearBuilding();\nif (ai.plan.tile() != null) {\nunit.updateBuilding=true;\nunit.addBuild(ai.plan);\n}\n}\n}\ncase getBlock ->{\nfloat range=Math.max(unit.range(),buildingRange);\nif (!unit.within(x1,y1,range)) {\nexec.setobj(p3,null);\nexec.setobj(p4,null);\n}\n else {\nTile tile=world.tileWorld(x1,y1);\nBlock block=tile == null ? null : !tile.synthetic() ? (tile.solid() ? Blocks.stoneWall : Blocks.air) : tile.block();\nexec.setobj(p3,block);\nexec.setobj(p4,tile != null && tile.build != null ? tile.build : null);\n}\n}\ncase itemDrop ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint dropped=Math.min(unit.stack.amount,exec.numi(p2));\nif (build != null && build.isValid() && dropped > 0 && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint accepted=build.acceptStack(unit.item(),dropped,unit);\nif (accepted > 0) {\nCall.transferItemTo(unit,unit.item(),accepted,unit.x,unit.y,build);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ncase itemTake ->{\nif (ai.itemTimer > 0) return;\nBuilding build=exec.building(p1);\nint amount=exec.numi(p3);\nif (build != null && build.isValid() && build.items != null && exec.obj(p2) instanceof Item item && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)) {\nint taken=Math.min(build.items.get(item),Math.min(amount,unit.maxAccepted(item)));\nif (taken > 0) {\nCall.takeItems(build,item,taken,unit);\nai.itemTimer=LogicAI.transferDelay;\n}\n}\n}\ndefault ->{\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 975,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 126,
        "startLineNumber" : 490,
        "startColumnNumber" : 27,
        "endLineNumber" : 490,
        "endColumnNumber" : 153
      },
      "nodeContext" : "build != null && build.isValid() && dropped > 0 && unit.within(build,logicItemTransferRange + build.block.size * tilesize / 2f)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 27,
      "astHeight" : 8
    },
    "tokenLength" : 3,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 11,
    "startLineNumber" : 490,
    "startColumnNumber" : 63,
    "endLineNumber" : 490,
    "endColumnNumber" : 74
  } ],
  "layoutRelationDataList" : [ ]
}