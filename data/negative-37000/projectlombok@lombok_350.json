{
  "id" : 350,
  "expression" : "new ArrayList<Statement>()",
  "projectName" : "projectlombok@lombok",
  "commitID" : "25def866b50860715ee7c315c678b8c3d1ba9b56",
  "filePath" : "/src/core/lombok/eclipse/handlers/HandleEqualsAndHashCode.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "new ArrayList<Statement>()",
    "nodeType" : "ClassInstanceCreation",
    "nodePosition" : {
      "charLength" : 26,
      "startLineNumber" : 265,
      "startColumnNumber" : 31,
      "endLineNumber" : 265,
      "endColumnNumber" : 57
    },
    "astNodeNumber" : 6,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 265,
        "startColumnNumber" : 18,
        "endLineNumber" : 265,
        "endColumnNumber" : 57
      },
      "nodeContext" : "statements=new ArrayList<Statement>()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 265,
        "startColumnNumber" : 2,
        "endLineNumber" : 265,
        "endColumnNumber" : 58
      },
      "nodeContext" : "List<Statement> statements=new ArrayList<Statement>();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8076,
        "startLineNumber" : 245,
        "startColumnNumber" : 152,
        "endLineNumber" : 398,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  int pS=source.sourceStart, pE=source.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  MethodDeclaration method=new MethodDeclaration(((CompilationUnitDeclaration)type.top().get()).compilationResult);\n  setGeneratedBy(method,source);\n  method.modifiers=toEclipseModifier(AccessLevel.PUBLIC);\n  method.returnType=TypeReference.baseTypeReference(TypeIds.T_int,0);\n  setGeneratedBy(method.returnType,source);\n  method.annotations=new Annotation[]{makeMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE,source)};\n  method.selector=\"hashCode\".toCharArray();\n  method.thrownExceptions=null;\n  method.typeParameters=null;\n  method.bits|=Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n  method.bodyStart=method.declarationSourceStart=method.sourceStart=source.sourceStart;\n  method.bodyEnd=method.declarationSourceEnd=method.sourceEnd=source.sourceEnd;\n  method.arguments=null;\n  List<Statement> statements=new ArrayList<Statement>();\n  final boolean isEmpty=fields.isEmpty();\n{\n    if (!isEmpty || callSuper) {\n      LocalDeclaration primeDecl=new LocalDeclaration(PRIME,pS,pE);\n      setGeneratedBy(primeDecl,source);\n      primeDecl.modifiers|=Modifier.FINAL;\n      primeDecl.type=TypeReference.baseTypeReference(TypeIds.T_int,0);\n      primeDecl.type.sourceStart=pS;\n      primeDecl.type.sourceEnd=pE;\n      setGeneratedBy(primeDecl.type,source);\n      primeDecl.initialization=makeIntLiteral(\"31\".toCharArray(),source);\n      statements.add(primeDecl);\n    }\n  }\n{\n    LocalDeclaration resultDecl=new LocalDeclaration(RESULT,pS,pE);\n    setGeneratedBy(resultDecl,source);\n    resultDecl.initialization=makeIntLiteral(\"1\".toCharArray(),source);\n    resultDecl.type=TypeReference.baseTypeReference(TypeIds.T_int,0);\n    resultDecl.type.sourceStart=pS;\n    resultDecl.type.sourceEnd=pE;\n    setGeneratedBy(resultDecl.type,source);\n    statements.add(resultDecl);\n  }\n  if (callSuper) {\n    MessageSend callToSuper=new MessageSend();\n    setGeneratedBy(callToSuper,source);\n    callToSuper.sourceStart=pS;\n    callToSuper.sourceEnd=pE;\n    callToSuper.receiver=new SuperReference(pS,pE);\n    setGeneratedBy(callToSuper.receiver,source);\n    callToSuper.selector=\"hashCode\".toCharArray();\n    statements.add(createResultCalculation(source,callToSuper));\n  }\n  for (  EclipseNode field : fields) {\n    TypeReference fType=getFieldType(field,fieldAccess);\n    char[] dollarFieldName=(\"$\" + field.getName()).toCharArray();\n    char[] token=fType.getLastToken();\n    Expression fieldAccessor=createFieldAccessor(field,fieldAccess,source);\n    if (fType.dimensions() == 0 && token != null) {\n      if (Arrays.equals(TypeConstants.BOOLEAN,token)) {\n        IntLiteral int1231=makeIntLiteral(\"1231\".toCharArray(),source);\n        IntLiteral int1237=makeIntLiteral(\"1237\".toCharArray(),source);\n        ConditionalExpression int1231or1237=new ConditionalExpression(fieldAccessor,int1231,int1237);\n        setGeneratedBy(int1231or1237,source);\n        statements.add(createResultCalculation(source,int1231or1237));\n      }\n else       if (Arrays.equals(TypeConstants.LONG,token)) {\n        statements.add(createLocalDeclaration(source,dollarFieldName,TypeReference.baseTypeReference(TypeIds.T_long,0),fieldAccessor));\n        SingleNameReference copy1=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy1,source);\n        SingleNameReference copy2=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy2,source);\n        statements.add(createResultCalculation(source,longToIntForHashCode(copy1,copy2,source)));\n      }\n else       if (Arrays.equals(TypeConstants.FLOAT,token)) {\n        MessageSend floatToIntBits=new MessageSend();\n        floatToIntBits.sourceStart=pS;\n        floatToIntBits.sourceEnd=pE;\n        setGeneratedBy(floatToIntBits,source);\n        floatToIntBits.receiver=generateQualifiedNameRef(source,TypeConstants.JAVA_LANG_FLOAT);\n        floatToIntBits.selector=\"floatToIntBits\".toCharArray();\n        floatToIntBits.arguments=new Expression[]{fieldAccessor};\n        statements.add(createResultCalculation(source,floatToIntBits));\n      }\n else       if (Arrays.equals(TypeConstants.DOUBLE,token)) {\n        MessageSend doubleToLongBits=new MessageSend();\n        doubleToLongBits.sourceStart=pS;\n        doubleToLongBits.sourceEnd=pE;\n        setGeneratedBy(doubleToLongBits,source);\n        doubleToLongBits.receiver=generateQualifiedNameRef(source,TypeConstants.JAVA_LANG_DOUBLE);\n        doubleToLongBits.selector=\"doubleToLongBits\".toCharArray();\n        doubleToLongBits.arguments=new Expression[]{fieldAccessor};\n        statements.add(createLocalDeclaration(source,dollarFieldName,TypeReference.baseTypeReference(TypeIds.T_long,0),doubleToLongBits));\n        SingleNameReference copy1=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy1,source);\n        SingleNameReference copy2=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy2,source);\n        statements.add(createResultCalculation(source,longToIntForHashCode(copy1,copy2,source)));\n      }\n else       if (BUILT_IN_TYPES.contains(new String(token))) {\n        statements.add(createResultCalculation(source,fieldAccessor));\n      }\n else {\n        statements.add(createLocalDeclaration(source,dollarFieldName,generateQualifiedTypeRef(source,TypeConstants.JAVA_LANG_OBJECT),fieldAccessor));\n        SingleNameReference copy1=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy1,source);\n        SingleNameReference copy2=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy2,source);\n        MessageSend hashCodeCall=new MessageSend();\n        hashCodeCall.sourceStart=pS;\n        hashCodeCall.sourceEnd=pE;\n        setGeneratedBy(hashCodeCall,source);\n        hashCodeCall.receiver=copy1;\n        hashCodeCall.selector=\"hashCode\".toCharArray();\n        NullLiteral nullLiteral=new NullLiteral(pS,pE);\n        setGeneratedBy(nullLiteral,source);\n        EqualExpression objIsNull=new EqualExpression(copy2,nullLiteral,OperatorIds.EQUAL_EQUAL);\n        setGeneratedBy(objIsNull,source);\n        IntLiteral int0=makeIntLiteral(\"0\".toCharArray(),source);\n        ConditionalExpression nullOrHashCode=new ConditionalExpression(objIsNull,int0,hashCodeCall);\n        nullOrHashCode.sourceStart=pS;\n        nullOrHashCode.sourceEnd=pE;\n        setGeneratedBy(nullOrHashCode,source);\n        statements.add(createResultCalculation(source,nullOrHashCode));\n      }\n    }\n else     if (fType.dimensions() > 0 && token != null) {\n      MessageSend arraysHashCodeCall=new MessageSend();\n      arraysHashCodeCall.sourceStart=pS;\n      arraysHashCodeCall.sourceEnd=pE;\n      setGeneratedBy(arraysHashCodeCall,source);\n      arraysHashCodeCall.receiver=generateQualifiedNameRef(source,TypeConstants.JAVA,TypeConstants.UTIL,\"Arrays\".toCharArray());\n      if (fType.dimensions() > 1 || !BUILT_IN_TYPES.contains(new String(token))) {\n        arraysHashCodeCall.selector=\"deepHashCode\".toCharArray();\n      }\n else {\n        arraysHashCodeCall.selector=\"hashCode\".toCharArray();\n      }\n      arraysHashCodeCall.arguments=new Expression[]{fieldAccessor};\n      statements.add(createResultCalculation(source,arraysHashCodeCall));\n    }\n  }\n{\n    SingleNameReference resultRef=new SingleNameReference(RESULT,p);\n    setGeneratedBy(resultRef,source);\n    ReturnStatement returnStatement=new ReturnStatement(resultRef,pS,pE);\n    setGeneratedBy(returnStatement,source);\n    statements.add(returnStatement);\n  }\n  method.statements=statements.toArray(new Statement[statements.size()]);\n  return method;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1114,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8227,
        "startLineNumber" : 245,
        "startColumnNumber" : 1,
        "endLineNumber" : 398,
        "endColumnNumber" : 2
      },
      "nodeContext" : "private MethodDeclaration createHashCode(EclipseNode type,Collection<EclipseNode> fields,boolean callSuper,ASTNode source,FieldAccess fieldAccess){\n  int pS=source.sourceStart, pE=source.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  MethodDeclaration method=new MethodDeclaration(((CompilationUnitDeclaration)type.top().get()).compilationResult);\n  setGeneratedBy(method,source);\n  method.modifiers=toEclipseModifier(AccessLevel.PUBLIC);\n  method.returnType=TypeReference.baseTypeReference(TypeIds.T_int,0);\n  setGeneratedBy(method.returnType,source);\n  method.annotations=new Annotation[]{makeMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE,source)};\n  method.selector=\"hashCode\".toCharArray();\n  method.thrownExceptions=null;\n  method.typeParameters=null;\n  method.bits|=Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n  method.bodyStart=method.declarationSourceStart=method.sourceStart=source.sourceStart;\n  method.bodyEnd=method.declarationSourceEnd=method.sourceEnd=source.sourceEnd;\n  method.arguments=null;\n  List<Statement> statements=new ArrayList<Statement>();\n  final boolean isEmpty=fields.isEmpty();\n{\n    if (!isEmpty || callSuper) {\n      LocalDeclaration primeDecl=new LocalDeclaration(PRIME,pS,pE);\n      setGeneratedBy(primeDecl,source);\n      primeDecl.modifiers|=Modifier.FINAL;\n      primeDecl.type=TypeReference.baseTypeReference(TypeIds.T_int,0);\n      primeDecl.type.sourceStart=pS;\n      primeDecl.type.sourceEnd=pE;\n      setGeneratedBy(primeDecl.type,source);\n      primeDecl.initialization=makeIntLiteral(\"31\".toCharArray(),source);\n      statements.add(primeDecl);\n    }\n  }\n{\n    LocalDeclaration resultDecl=new LocalDeclaration(RESULT,pS,pE);\n    setGeneratedBy(resultDecl,source);\n    resultDecl.initialization=makeIntLiteral(\"1\".toCharArray(),source);\n    resultDecl.type=TypeReference.baseTypeReference(TypeIds.T_int,0);\n    resultDecl.type.sourceStart=pS;\n    resultDecl.type.sourceEnd=pE;\n    setGeneratedBy(resultDecl.type,source);\n    statements.add(resultDecl);\n  }\n  if (callSuper) {\n    MessageSend callToSuper=new MessageSend();\n    setGeneratedBy(callToSuper,source);\n    callToSuper.sourceStart=pS;\n    callToSuper.sourceEnd=pE;\n    callToSuper.receiver=new SuperReference(pS,pE);\n    setGeneratedBy(callToSuper.receiver,source);\n    callToSuper.selector=\"hashCode\".toCharArray();\n    statements.add(createResultCalculation(source,callToSuper));\n  }\n  for (  EclipseNode field : fields) {\n    TypeReference fType=getFieldType(field,fieldAccess);\n    char[] dollarFieldName=(\"$\" + field.getName()).toCharArray();\n    char[] token=fType.getLastToken();\n    Expression fieldAccessor=createFieldAccessor(field,fieldAccess,source);\n    if (fType.dimensions() == 0 && token != null) {\n      if (Arrays.equals(TypeConstants.BOOLEAN,token)) {\n        IntLiteral int1231=makeIntLiteral(\"1231\".toCharArray(),source);\n        IntLiteral int1237=makeIntLiteral(\"1237\".toCharArray(),source);\n        ConditionalExpression int1231or1237=new ConditionalExpression(fieldAccessor,int1231,int1237);\n        setGeneratedBy(int1231or1237,source);\n        statements.add(createResultCalculation(source,int1231or1237));\n      }\n else       if (Arrays.equals(TypeConstants.LONG,token)) {\n        statements.add(createLocalDeclaration(source,dollarFieldName,TypeReference.baseTypeReference(TypeIds.T_long,0),fieldAccessor));\n        SingleNameReference copy1=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy1,source);\n        SingleNameReference copy2=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy2,source);\n        statements.add(createResultCalculation(source,longToIntForHashCode(copy1,copy2,source)));\n      }\n else       if (Arrays.equals(TypeConstants.FLOAT,token)) {\n        MessageSend floatToIntBits=new MessageSend();\n        floatToIntBits.sourceStart=pS;\n        floatToIntBits.sourceEnd=pE;\n        setGeneratedBy(floatToIntBits,source);\n        floatToIntBits.receiver=generateQualifiedNameRef(source,TypeConstants.JAVA_LANG_FLOAT);\n        floatToIntBits.selector=\"floatToIntBits\".toCharArray();\n        floatToIntBits.arguments=new Expression[]{fieldAccessor};\n        statements.add(createResultCalculation(source,floatToIntBits));\n      }\n else       if (Arrays.equals(TypeConstants.DOUBLE,token)) {\n        MessageSend doubleToLongBits=new MessageSend();\n        doubleToLongBits.sourceStart=pS;\n        doubleToLongBits.sourceEnd=pE;\n        setGeneratedBy(doubleToLongBits,source);\n        doubleToLongBits.receiver=generateQualifiedNameRef(source,TypeConstants.JAVA_LANG_DOUBLE);\n        doubleToLongBits.selector=\"doubleToLongBits\".toCharArray();\n        doubleToLongBits.arguments=new Expression[]{fieldAccessor};\n        statements.add(createLocalDeclaration(source,dollarFieldName,TypeReference.baseTypeReference(TypeIds.T_long,0),doubleToLongBits));\n        SingleNameReference copy1=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy1,source);\n        SingleNameReference copy2=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy2,source);\n        statements.add(createResultCalculation(source,longToIntForHashCode(copy1,copy2,source)));\n      }\n else       if (BUILT_IN_TYPES.contains(new String(token))) {\n        statements.add(createResultCalculation(source,fieldAccessor));\n      }\n else {\n        statements.add(createLocalDeclaration(source,dollarFieldName,generateQualifiedTypeRef(source,TypeConstants.JAVA_LANG_OBJECT),fieldAccessor));\n        SingleNameReference copy1=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy1,source);\n        SingleNameReference copy2=new SingleNameReference(dollarFieldName,p);\n        setGeneratedBy(copy2,source);\n        MessageSend hashCodeCall=new MessageSend();\n        hashCodeCall.sourceStart=pS;\n        hashCodeCall.sourceEnd=pE;\n        setGeneratedBy(hashCodeCall,source);\n        hashCodeCall.receiver=copy1;\n        hashCodeCall.selector=\"hashCode\".toCharArray();\n        NullLiteral nullLiteral=new NullLiteral(pS,pE);\n        setGeneratedBy(nullLiteral,source);\n        EqualExpression objIsNull=new EqualExpression(copy2,nullLiteral,OperatorIds.EQUAL_EQUAL);\n        setGeneratedBy(objIsNull,source);\n        IntLiteral int0=makeIntLiteral(\"0\".toCharArray(),source);\n        ConditionalExpression nullOrHashCode=new ConditionalExpression(objIsNull,int0,hashCodeCall);\n        nullOrHashCode.sourceStart=pS;\n        nullOrHashCode.sourceEnd=pE;\n        setGeneratedBy(nullOrHashCode,source);\n        statements.add(createResultCalculation(source,nullOrHashCode));\n      }\n    }\n else     if (fType.dimensions() > 0 && token != null) {\n      MessageSend arraysHashCodeCall=new MessageSend();\n      arraysHashCodeCall.sourceStart=pS;\n      arraysHashCodeCall.sourceEnd=pE;\n      setGeneratedBy(arraysHashCodeCall,source);\n      arraysHashCodeCall.receiver=generateQualifiedNameRef(source,TypeConstants.JAVA,TypeConstants.UTIL,\"Arrays\".toCharArray());\n      if (fType.dimensions() > 1 || !BUILT_IN_TYPES.contains(new String(token))) {\n        arraysHashCodeCall.selector=\"deepHashCode\".toCharArray();\n      }\n else {\n        arraysHashCodeCall.selector=\"hashCode\".toCharArray();\n      }\n      arraysHashCodeCall.arguments=new Expression[]{fieldAccessor};\n      statements.add(createResultCalculation(source,arraysHashCodeCall));\n    }\n  }\n{\n    SingleNameReference resultRef=new SingleNameReference(RESULT,p);\n    setGeneratedBy(resultRef,source);\n    ReturnStatement returnStatement=new ReturnStatement(resultRef,pS,pE);\n    setGeneratedBy(returnStatement,source);\n    statements.add(returnStatement);\n  }\n  method.statements=statements.toArray(new Statement[statements.size()]);\n  return method;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1141,
      "astHeight" : 18
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 265,
        "startColumnNumber" : 2,
        "endLineNumber" : 265,
        "endColumnNumber" : 58
      },
      "nodeContext" : "List<Statement> statements=new ArrayList<Statement>();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "java.util.ArrayList<lombok.eclipse.handlers.Statement>"
  } ],
  "positionList" : [ {
    "charLength" : 26,
    "startLineNumber" : 265,
    "startColumnNumber" : 31,
    "endLineNumber" : 265,
    "endColumnNumber" : 57
  } ],
  "layoutRelationDataList" : [ ]
}