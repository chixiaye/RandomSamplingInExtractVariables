{
  "id" : 181,
  "expression" : "val < -32768",
  "projectName" : "libgdx@libgdx",
  "commitID" : "3485b16e8979c0141421bc80cb8831b7a0403f67",
  "filePath" : "/backends/gdx-backend-lwjgl3/src/com/badlogic/gdx/backends/lwjgl3/audio/OggInputStream.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "val < -32768",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 12,
      "startLineNumber" : 355,
      "startColumnNumber" : 15,
      "endLineNumber" : 355,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 4,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 355,
        "startColumnNumber" : 11,
        "endLineNumber" : 357,
        "endColumnNumber" : 12
      },
      "nodeContext" : "if (val < -32768) {\n  val=-32768;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 11,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 616,
        "startLineNumber" : 349,
        "startColumnNumber" : 41,
        "endLineNumber" : 368,
        "endColumnNumber" : 11
      },
      "nodeContext" : "{\n  int val=(int)(pcm[i][mono + j] * 32767.);\n  if (val > 32767) {\n    val=32767;\n  }\n  if (val < -32768) {\n    val=-32768;\n  }\n  if (val < 0)   val=val | 0x8000;\n  if (bigEndian) {\n    convbuffer[ptr]=(byte)(val >>> 8);\n    convbuffer[ptr + 1]=(byte)(val);\n  }\n else {\n    convbuffer[ptr]=(byte)(val);\n    convbuffer[ptr + 1]=(byte)(val >>> 8);\n  }\n  ptr+=2 * (oggInfo.channels);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 104,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 647,
        "startLineNumber" : 349,
        "startColumnNumber" : 10,
        "endLineNumber" : 368,
        "endColumnNumber" : 11
      },
      "nodeContext" : "for (int j=0; j < bout; j++) {\n  int val=(int)(pcm[i][mono + j] * 32767.);\n  if (val > 32767) {\n    val=32767;\n  }\n  if (val < -32768) {\n    val=-32768;\n  }\n  if (val < 0)   val=val | 0x8000;\n  if (bigEndian) {\n    convbuffer[ptr]=(byte)(val >>> 8);\n    convbuffer[ptr + 1]=(byte)(val);\n  }\n else {\n    convbuffer[ptr]=(byte)(val);\n    convbuffer[ptr + 1]=(byte)(val >>> 8);\n  }\n  ptr+=2 * (oggInfo.channels);\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 115,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 758,
        "startLineNumber" : 345,
        "startColumnNumber" : 52,
        "endLineNumber" : 369,
        "endColumnNumber" : 10
      },
      "nodeContext" : "{\n  int ptr=i * 2;\n  int mono=_index[i];\n  for (int j=0; j < bout; j++) {\n    int val=(int)(pcm[i][mono + j] * 32767.);\n    if (val > 32767) {\n      val=32767;\n    }\n    if (val < -32768) {\n      val=-32768;\n    }\n    if (val < 0)     val=val | 0x8000;\n    if (bigEndian) {\n      convbuffer[ptr]=(byte)(val >>> 8);\n      convbuffer[ptr + 1]=(byte)(val);\n    }\n else {\n      convbuffer[ptr]=(byte)(val);\n      convbuffer[ptr + 1]=(byte)(val >>> 8);\n    }\n    ptr+=2 * (oggInfo.channels);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 130,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 801,
        "startLineNumber" : 345,
        "startColumnNumber" : 9,
        "endLineNumber" : 369,
        "endColumnNumber" : 10
      },
      "nodeContext" : "for (int i=0; i < oggInfo.channels; i++) {\n  int ptr=i * 2;\n  int mono=_index[i];\n  for (int j=0; j < bout; j++) {\n    int val=(int)(pcm[i][mono + j] * 32767.);\n    if (val > 32767) {\n      val=32767;\n    }\n    if (val < -32768) {\n      val=-32768;\n    }\n    if (val < 0)     val=val | 0x8000;\n    if (bigEndian) {\n      convbuffer[ptr]=(byte)(val >>> 8);\n      convbuffer[ptr + 1]=(byte)(val);\n    }\n else {\n      convbuffer[ptr]=(byte)(val);\n      convbuffer[ptr + 1]=(byte)(val >>> 8);\n    }\n    ptr+=2 * (oggInfo.channels);\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 143,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 1532,
        "startLineNumber" : 338,
        "startColumnNumber" : 72,
        "endLineNumber" : 382,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  float[][] pcm=_pcm[0];\n  int bout=(samples < convsize ? samples : convsize);\n  for (int i=0; i < oggInfo.channels; i++) {\n    int ptr=i * 2;\n    int mono=_index[i];\n    for (int j=0; j < bout; j++) {\n      int val=(int)(pcm[i][mono + j] * 32767.);\n      if (val > 32767) {\n        val=32767;\n      }\n      if (val < -32768) {\n        val=-32768;\n      }\n      if (val < 0)       val=val | 0x8000;\n      if (bigEndian) {\n        convbuffer[ptr]=(byte)(val >>> 8);\n        convbuffer[ptr + 1]=(byte)(val);\n      }\n else {\n        convbuffer[ptr]=(byte)(val);\n        convbuffer[ptr + 1]=(byte)(val >>> 8);\n      }\n      ptr+=2 * (oggInfo.channels);\n    }\n  }\n  int bytesToWrite=2 * oggInfo.channels * bout;\n  if (bytesToWrite > pcmBuffer.remaining()) {\n    throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n  }\n else {\n    pcmBuffer.put(convbuffer,0,bytesToWrite);\n  }\n  wrote=true;\n  dspState.synthesis_read(bout);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 210,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1596,
        "startLineNumber" : 338,
        "startColumnNumber" : 8,
        "endLineNumber" : 382,
        "endColumnNumber" : 9
      },
      "nodeContext" : "while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n  float[][] pcm=_pcm[0];\n  int bout=(samples < convsize ? samples : convsize);\n  for (int i=0; i < oggInfo.channels; i++) {\n    int ptr=i * 2;\n    int mono=_index[i];\n    for (int j=0; j < bout; j++) {\n      int val=(int)(pcm[i][mono + j] * 32767.);\n      if (val > 32767) {\n        val=32767;\n      }\n      if (val < -32768) {\n        val=-32768;\n      }\n      if (val < 0)       val=val | 0x8000;\n      if (bigEndian) {\n        convbuffer[ptr]=(byte)(val >>> 8);\n        convbuffer[ptr + 1]=(byte)(val);\n      }\n else {\n        convbuffer[ptr]=(byte)(val);\n        convbuffer[ptr + 1]=(byte)(val >>> 8);\n      }\n      ptr+=2 * (oggInfo.channels);\n    }\n  }\n  int bytesToWrite=2 * oggInfo.channels * bout;\n  if (bytesToWrite > pcmBuffer.remaining()) {\n    throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n  }\n else {\n    pcmBuffer.put(convbuffer,0,bytesToWrite);\n  }\n  wrote=true;\n  dspState.synthesis_read(bout);\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 221,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 2083,
        "startLineNumber" : 326,
        "startColumnNumber" : 14,
        "endLineNumber" : 383,
        "endColumnNumber" : 8
      },
      "nodeContext" : "{\n  int samples;\n  if (vorbisBlock.synthesis(packet) == 0) {\n    dspState.synthesis_blockin(vorbisBlock);\n  }\n  while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n    float[][] pcm=_pcm[0];\n    int bout=(samples < convsize ? samples : convsize);\n    for (int i=0; i < oggInfo.channels; i++) {\n      int ptr=i * 2;\n      int mono=_index[i];\n      for (int j=0; j < bout; j++) {\n        int val=(int)(pcm[i][mono + j] * 32767.);\n        if (val > 32767) {\n          val=32767;\n        }\n        if (val < -32768) {\n          val=-32768;\n        }\n        if (val < 0)         val=val | 0x8000;\n        if (bigEndian) {\n          convbuffer[ptr]=(byte)(val >>> 8);\n          convbuffer[ptr + 1]=(byte)(val);\n        }\n else {\n          convbuffer[ptr]=(byte)(val);\n          convbuffer[ptr + 1]=(byte)(val >>> 8);\n        }\n        ptr+=2 * (oggInfo.channels);\n      }\n    }\n    int bytesToWrite=2 * oggInfo.channels * bout;\n    if (bytesToWrite > pcmBuffer.remaining()) {\n      throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n    }\n else {\n      pcmBuffer.put(convbuffer,0,bytesToWrite);\n    }\n    wrote=true;\n    dspState.synthesis_read(bout);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 239,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2227,
        "startLineNumber" : 324,
        "startColumnNumber" : 7,
        "endLineNumber" : 383,
        "endColumnNumber" : 8
      },
      "nodeContext" : "if (result == -1) {\n}\n else {\n  int samples;\n  if (vorbisBlock.synthesis(packet) == 0) {\n    dspState.synthesis_blockin(vorbisBlock);\n  }\n  while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n    float[][] pcm=_pcm[0];\n    int bout=(samples < convsize ? samples : convsize);\n    for (int i=0; i < oggInfo.channels; i++) {\n      int ptr=i * 2;\n      int mono=_index[i];\n      for (int j=0; j < bout; j++) {\n        int val=(int)(pcm[i][mono + j] * 32767.);\n        if (val > 32767) {\n          val=32767;\n        }\n        if (val < -32768) {\n          val=-32768;\n        }\n        if (val < 0)         val=val | 0x8000;\n        if (bigEndian) {\n          convbuffer[ptr]=(byte)(val >>> 8);\n          convbuffer[ptr + 1]=(byte)(val);\n        }\n else {\n          convbuffer[ptr]=(byte)(val);\n          convbuffer[ptr + 1]=(byte)(val >>> 8);\n        }\n        ptr+=2 * (oggInfo.channels);\n      }\n    }\n    int bytesToWrite=2 * oggInfo.channels * bout;\n    if (bytesToWrite > pcmBuffer.remaining()) {\n      throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n    }\n else {\n      pcmBuffer.put(convbuffer,0,bytesToWrite);\n    }\n    wrote=true;\n    dspState.synthesis_read(bout);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 245,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 2346,
        "startLineNumber" : 320,
        "startColumnNumber" : 19,
        "endLineNumber" : 384,
        "endColumnNumber" : 7
      },
      "nodeContext" : "{\n  result=streamState.packetout(packet);\n  if (result == 0)   break;\n  if (result == -1) {\n  }\n else {\n    int samples;\n    if (vorbisBlock.synthesis(packet) == 0) {\n      dspState.synthesis_blockin(vorbisBlock);\n    }\n    while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n      float[][] pcm=_pcm[0];\n      int bout=(samples < convsize ? samples : convsize);\n      for (int i=0; i < oggInfo.channels; i++) {\n        int ptr=i * 2;\n        int mono=_index[i];\n        for (int j=0; j < bout; j++) {\n          int val=(int)(pcm[i][mono + j] * 32767.);\n          if (val > 32767) {\n            val=32767;\n          }\n          if (val < -32768) {\n            val=-32768;\n          }\n          if (val < 0)           val=val | 0x8000;\n          if (bigEndian) {\n            convbuffer[ptr]=(byte)(val >>> 8);\n            convbuffer[ptr + 1]=(byte)(val);\n          }\n else {\n            convbuffer[ptr]=(byte)(val);\n            convbuffer[ptr + 1]=(byte)(val >>> 8);\n          }\n          ptr+=2 * (oggInfo.channels);\n        }\n      }\n      int bytesToWrite=2 * oggInfo.channels * bout;\n      if (bytesToWrite > pcmBuffer.remaining()) {\n        throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n      }\n else {\n        pcmBuffer.put(convbuffer,0,bytesToWrite);\n      }\n      wrote=true;\n      dspState.synthesis_read(bout);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 258,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2359,
        "startLineNumber" : 320,
        "startColumnNumber" : 6,
        "endLineNumber" : 384,
        "endColumnNumber" : 7
      },
      "nodeContext" : "while (true) {\n  result=streamState.packetout(packet);\n  if (result == 0)   break;\n  if (result == -1) {\n  }\n else {\n    int samples;\n    if (vorbisBlock.synthesis(packet) == 0) {\n      dspState.synthesis_blockin(vorbisBlock);\n    }\n    while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n      float[][] pcm=_pcm[0];\n      int bout=(samples < convsize ? samples : convsize);\n      for (int i=0; i < oggInfo.channels; i++) {\n        int ptr=i * 2;\n        int mono=_index[i];\n        for (int j=0; j < bout; j++) {\n          int val=(int)(pcm[i][mono + j] * 32767.);\n          if (val > 32767) {\n            val=32767;\n          }\n          if (val < -32768) {\n            val=-32768;\n          }\n          if (val < 0)           val=val | 0x8000;\n          if (bigEndian) {\n            convbuffer[ptr]=(byte)(val >>> 8);\n            convbuffer[ptr + 1]=(byte)(val);\n          }\n else {\n            convbuffer[ptr]=(byte)(val);\n            convbuffer[ptr + 1]=(byte)(val >>> 8);\n          }\n          ptr+=2 * (oggInfo.channels);\n        }\n      }\n      int bytesToWrite=2 * oggInfo.channels * bout;\n      if (bytesToWrite > pcmBuffer.remaining()) {\n        throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n      }\n else {\n        pcmBuffer.put(convbuffer,0,bytesToWrite);\n      }\n      wrote=true;\n      dspState.synthesis_read(bout);\n    }\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 260,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 2601,
        "startLineNumber" : 317,
        "startColumnNumber" : 12,
        "endLineNumber" : 392,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  streamState.pagein(page);\n  while (true) {\n    result=streamState.packetout(packet);\n    if (result == 0)     break;\n    if (result == -1) {\n    }\n else {\n      int samples;\n      if (vorbisBlock.synthesis(packet) == 0) {\n        dspState.synthesis_blockin(vorbisBlock);\n      }\n      while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n        float[][] pcm=_pcm[0];\n        int bout=(samples < convsize ? samples : convsize);\n        for (int i=0; i < oggInfo.channels; i++) {\n          int ptr=i * 2;\n          int mono=_index[i];\n          for (int j=0; j < bout; j++) {\n            int val=(int)(pcm[i][mono + j] * 32767.);\n            if (val > 32767) {\n              val=32767;\n            }\n            if (val < -32768) {\n              val=-32768;\n            }\n            if (val < 0)             val=val | 0x8000;\n            if (bigEndian) {\n              convbuffer[ptr]=(byte)(val >>> 8);\n              convbuffer[ptr + 1]=(byte)(val);\n            }\n else {\n              convbuffer[ptr]=(byte)(val);\n              convbuffer[ptr + 1]=(byte)(val >>> 8);\n            }\n            ptr+=2 * (oggInfo.channels);\n          }\n        }\n        int bytesToWrite=2 * oggInfo.channels * bout;\n        if (bytesToWrite > pcmBuffer.remaining()) {\n          throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n        }\n else {\n          pcmBuffer.put(convbuffer,0,bytesToWrite);\n        }\n        wrote=true;\n        dspState.synthesis_read(bout);\n      }\n    }\n  }\n  if (page.eos() != 0) {\n    endOfBitStream=true;\n  }\n  if ((!endOfBitStream) && (wrote)) {\n    return;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 286,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2858,
        "startLineNumber" : 314,
        "startColumnNumber" : 5,
        "endLineNumber" : 392,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (result == -1) {\n  Gdx.app.log(\"gdx-audio\",\"Error reading OGG: Corrupt or missing data in bitstream.\");\n}\n else {\n  streamState.pagein(page);\n  while (true) {\n    result=streamState.packetout(packet);\n    if (result == 0)     break;\n    if (result == -1) {\n    }\n else {\n      int samples;\n      if (vorbisBlock.synthesis(packet) == 0) {\n        dspState.synthesis_blockin(vorbisBlock);\n      }\n      while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n        float[][] pcm=_pcm[0];\n        int bout=(samples < convsize ? samples : convsize);\n        for (int i=0; i < oggInfo.channels; i++) {\n          int ptr=i * 2;\n          int mono=_index[i];\n          for (int j=0; j < bout; j++) {\n            int val=(int)(pcm[i][mono + j] * 32767.);\n            if (val > 32767) {\n              val=32767;\n            }\n            if (val < -32768) {\n              val=-32768;\n            }\n            if (val < 0)             val=val | 0x8000;\n            if (bigEndian) {\n              convbuffer[ptr]=(byte)(val >>> 8);\n              convbuffer[ptr + 1]=(byte)(val);\n            }\n else {\n              convbuffer[ptr]=(byte)(val);\n              convbuffer[ptr + 1]=(byte)(val >>> 8);\n            }\n            ptr+=2 * (oggInfo.channels);\n          }\n        }\n        int bytesToWrite=2 * oggInfo.channels * bout;\n        if (bytesToWrite > pcmBuffer.remaining()) {\n          throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n        }\n else {\n          pcmBuffer.put(convbuffer,0,bytesToWrite);\n        }\n        wrote=true;\n        dspState.synthesis_read(bout);\n      }\n    }\n  }\n  if (page.eos() != 0) {\n    endOfBitStream=true;\n  }\n  if ((!endOfBitStream) && (wrote)) {\n    return;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 300,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 2986,
        "startLineNumber" : 307,
        "startColumnNumber" : 28,
        "endLineNumber" : 393,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int result=syncState.pageout(page);\n  if (result == 0) {\n    break;\n  }\n  if (result == -1) {\n    Gdx.app.log(\"gdx-audio\",\"Error reading OGG: Corrupt or missing data in bitstream.\");\n  }\n else {\n    streamState.pagein(page);\n    while (true) {\n      result=streamState.packetout(packet);\n      if (result == 0)       break;\n      if (result == -1) {\n      }\n else {\n        int samples;\n        if (vorbisBlock.synthesis(packet) == 0) {\n          dspState.synthesis_blockin(vorbisBlock);\n        }\n        while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n          float[][] pcm=_pcm[0];\n          int bout=(samples < convsize ? samples : convsize);\n          for (int i=0; i < oggInfo.channels; i++) {\n            int ptr=i * 2;\n            int mono=_index[i];\n            for (int j=0; j < bout; j++) {\n              int val=(int)(pcm[i][mono + j] * 32767.);\n              if (val > 32767) {\n                val=32767;\n              }\n              if (val < -32768) {\n                val=-32768;\n              }\n              if (val < 0)               val=val | 0x8000;\n              if (bigEndian) {\n                convbuffer[ptr]=(byte)(val >>> 8);\n                convbuffer[ptr + 1]=(byte)(val);\n              }\n else {\n                convbuffer[ptr]=(byte)(val);\n                convbuffer[ptr + 1]=(byte)(val >>> 8);\n              }\n              ptr+=2 * (oggInfo.channels);\n            }\n          }\n          int bytesToWrite=2 * oggInfo.channels * bout;\n          if (bytesToWrite > pcmBuffer.remaining()) {\n            throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n          }\n else {\n            pcmBuffer.put(convbuffer,0,bytesToWrite);\n          }\n          wrote=true;\n          dspState.synthesis_read(bout);\n        }\n      }\n    }\n    if (page.eos() != 0) {\n      endOfBitStream=true;\n    }\n    if ((!endOfBitStream) && (wrote)) {\n      return;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 315,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3010,
        "startLineNumber" : 307,
        "startColumnNumber" : 4,
        "endLineNumber" : 393,
        "endColumnNumber" : 5
      },
      "nodeContext" : "while (!endOfBitStream) {\n  int result=syncState.pageout(page);\n  if (result == 0) {\n    break;\n  }\n  if (result == -1) {\n    Gdx.app.log(\"gdx-audio\",\"Error reading OGG: Corrupt or missing data in bitstream.\");\n  }\n else {\n    streamState.pagein(page);\n    while (true) {\n      result=streamState.packetout(packet);\n      if (result == 0)       break;\n      if (result == -1) {\n      }\n else {\n        int samples;\n        if (vorbisBlock.synthesis(packet) == 0) {\n          dspState.synthesis_blockin(vorbisBlock);\n        }\n        while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n          float[][] pcm=_pcm[0];\n          int bout=(samples < convsize ? samples : convsize);\n          for (int i=0; i < oggInfo.channels; i++) {\n            int ptr=i * 2;\n            int mono=_index[i];\n            for (int j=0; j < bout; j++) {\n              int val=(int)(pcm[i][mono + j] * 32767.);\n              if (val > 32767) {\n                val=32767;\n              }\n              if (val < -32768) {\n                val=-32768;\n              }\n              if (val < 0)               val=val | 0x8000;\n              if (bigEndian) {\n                convbuffer[ptr]=(byte)(val >>> 8);\n                convbuffer[ptr + 1]=(byte)(val);\n              }\n else {\n                convbuffer[ptr]=(byte)(val);\n                convbuffer[ptr + 1]=(byte)(val >>> 8);\n              }\n              ptr+=2 * (oggInfo.channels);\n            }\n          }\n          int bytesToWrite=2 * oggInfo.channels * bout;\n          if (bytesToWrite > pcmBuffer.remaining()) {\n            throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n          }\n else {\n            pcmBuffer.put(convbuffer,0,bytesToWrite);\n          }\n          wrote=true;\n          dspState.synthesis_read(bout);\n        }\n      }\n    }\n    if (page.eos() != 0) {\n      endOfBitStream=true;\n    }\n    if ((!endOfBitStream) && (wrote)) {\n      return;\n    }\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 318,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 3499,
        "startLineNumber" : 306,
        "startColumnNumber" : 27,
        "endLineNumber" : 413,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  while (!endOfBitStream) {\n    int result=syncState.pageout(page);\n    if (result == 0) {\n      break;\n    }\n    if (result == -1) {\n      Gdx.app.log(\"gdx-audio\",\"Error reading OGG: Corrupt or missing data in bitstream.\");\n    }\n else {\n      streamState.pagein(page);\n      while (true) {\n        result=streamState.packetout(packet);\n        if (result == 0)         break;\n        if (result == -1) {\n        }\n else {\n          int samples;\n          if (vorbisBlock.synthesis(packet) == 0) {\n            dspState.synthesis_blockin(vorbisBlock);\n          }\n          while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n            float[][] pcm=_pcm[0];\n            int bout=(samples < convsize ? samples : convsize);\n            for (int i=0; i < oggInfo.channels; i++) {\n              int ptr=i * 2;\n              int mono=_index[i];\n              for (int j=0; j < bout; j++) {\n                int val=(int)(pcm[i][mono + j] * 32767.);\n                if (val > 32767) {\n                  val=32767;\n                }\n                if (val < -32768) {\n                  val=-32768;\n                }\n                if (val < 0)                 val=val | 0x8000;\n                if (bigEndian) {\n                  convbuffer[ptr]=(byte)(val >>> 8);\n                  convbuffer[ptr + 1]=(byte)(val);\n                }\n else {\n                  convbuffer[ptr]=(byte)(val);\n                  convbuffer[ptr + 1]=(byte)(val >>> 8);\n                }\n                ptr+=2 * (oggInfo.channels);\n              }\n            }\n            int bytesToWrite=2 * oggInfo.channels * bout;\n            if (bytesToWrite > pcmBuffer.remaining()) {\n              throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n            }\n else {\n              pcmBuffer.put(convbuffer,0,bytesToWrite);\n            }\n            wrote=true;\n            dspState.synthesis_read(bout);\n          }\n        }\n      }\n      if (page.eos() != 0) {\n        endOfBitStream=true;\n      }\n      if ((!endOfBitStream) && (wrote)) {\n        return;\n      }\n    }\n  }\n  if (!endOfBitStream) {\n    bytes=0;\n    int index=syncState.buffer(BUFFER_SIZE);\n    if (index >= 0) {\n      buffer=syncState.data;\n      try {\n        bytes=input.read(buffer,index,BUFFER_SIZE);\n      }\n catch (      Exception e) {\n        throw new GdxRuntimeException(\"Error during Vorbis decoding.\",e);\n      }\n    }\n else {\n      bytes=0;\n    }\n    syncState.wrote(bytes);\n    if (bytes == 0) {\n      endOfBitStream=true;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 388,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3523,
        "startLineNumber" : 306,
        "startColumnNumber" : 3,
        "endLineNumber" : 413,
        "endColumnNumber" : 4
      },
      "nodeContext" : "while (!endOfBitStream) {\n  while (!endOfBitStream) {\n    int result=syncState.pageout(page);\n    if (result == 0) {\n      break;\n    }\n    if (result == -1) {\n      Gdx.app.log(\"gdx-audio\",\"Error reading OGG: Corrupt or missing data in bitstream.\");\n    }\n else {\n      streamState.pagein(page);\n      while (true) {\n        result=streamState.packetout(packet);\n        if (result == 0)         break;\n        if (result == -1) {\n        }\n else {\n          int samples;\n          if (vorbisBlock.synthesis(packet) == 0) {\n            dspState.synthesis_blockin(vorbisBlock);\n          }\n          while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n            float[][] pcm=_pcm[0];\n            int bout=(samples < convsize ? samples : convsize);\n            for (int i=0; i < oggInfo.channels; i++) {\n              int ptr=i * 2;\n              int mono=_index[i];\n              for (int j=0; j < bout; j++) {\n                int val=(int)(pcm[i][mono + j] * 32767.);\n                if (val > 32767) {\n                  val=32767;\n                }\n                if (val < -32768) {\n                  val=-32768;\n                }\n                if (val < 0)                 val=val | 0x8000;\n                if (bigEndian) {\n                  convbuffer[ptr]=(byte)(val >>> 8);\n                  convbuffer[ptr + 1]=(byte)(val);\n                }\n else {\n                  convbuffer[ptr]=(byte)(val);\n                  convbuffer[ptr + 1]=(byte)(val >>> 8);\n                }\n                ptr+=2 * (oggInfo.channels);\n              }\n            }\n            int bytesToWrite=2 * oggInfo.channels * bout;\n            if (bytesToWrite > pcmBuffer.remaining()) {\n              throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n            }\n else {\n              pcmBuffer.put(convbuffer,0,bytesToWrite);\n            }\n            wrote=true;\n            dspState.synthesis_read(bout);\n          }\n        }\n      }\n      if (page.eos() != 0) {\n        endOfBitStream=true;\n      }\n      if ((!endOfBitStream) && (wrote)) {\n        return;\n      }\n    }\n  }\n  if (!endOfBitStream) {\n    bytes=0;\n    int index=syncState.buffer(BUFFER_SIZE);\n    if (index >= 0) {\n      buffer=syncState.data;\n      try {\n        bytes=input.read(buffer,index,BUFFER_SIZE);\n      }\n catch (      Exception e) {\n        throw new GdxRuntimeException(\"Error during Vorbis decoding.\",e);\n      }\n    }\n else {\n      bytes=0;\n    }\n    syncState.wrote(bytes);\n    if (bytes == 0) {\n      endOfBitStream=true;\n    }\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 391,
      "astHeight" : 24
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 4259,
        "startLineNumber" : 290,
        "startColumnNumber" : 15,
        "endLineNumber" : 425,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (endOfBitStream) {\n    if (!getPageAndPacket()) {\n      break;\n    }\n    endOfBitStream=false;\n  }\n  if (!inited) {\n    inited=true;\n    return;\n  }\n  float[][][] _pcm=new float[1][][];\n  int[] _index=new int[oggInfo.channels];\n  while (!endOfBitStream) {\n    while (!endOfBitStream) {\n      int result=syncState.pageout(page);\n      if (result == 0) {\n        break;\n      }\n      if (result == -1) {\n        Gdx.app.log(\"gdx-audio\",\"Error reading OGG: Corrupt or missing data in bitstream.\");\n      }\n else {\n        streamState.pagein(page);\n        while (true) {\n          result=streamState.packetout(packet);\n          if (result == 0)           break;\n          if (result == -1) {\n          }\n else {\n            int samples;\n            if (vorbisBlock.synthesis(packet) == 0) {\n              dspState.synthesis_blockin(vorbisBlock);\n            }\n            while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n              float[][] pcm=_pcm[0];\n              int bout=(samples < convsize ? samples : convsize);\n              for (int i=0; i < oggInfo.channels; i++) {\n                int ptr=i * 2;\n                int mono=_index[i];\n                for (int j=0; j < bout; j++) {\n                  int val=(int)(pcm[i][mono + j] * 32767.);\n                  if (val > 32767) {\n                    val=32767;\n                  }\n                  if (val < -32768) {\n                    val=-32768;\n                  }\n                  if (val < 0)                   val=val | 0x8000;\n                  if (bigEndian) {\n                    convbuffer[ptr]=(byte)(val >>> 8);\n                    convbuffer[ptr + 1]=(byte)(val);\n                  }\n else {\n                    convbuffer[ptr]=(byte)(val);\n                    convbuffer[ptr + 1]=(byte)(val >>> 8);\n                  }\n                  ptr+=2 * (oggInfo.channels);\n                }\n              }\n              int bytesToWrite=2 * oggInfo.channels * bout;\n              if (bytesToWrite > pcmBuffer.remaining()) {\n                throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n              }\n else {\n                pcmBuffer.put(convbuffer,0,bytesToWrite);\n              }\n              wrote=true;\n              dspState.synthesis_read(bout);\n            }\n          }\n        }\n        if (page.eos() != 0) {\n          endOfBitStream=true;\n        }\n        if ((!endOfBitStream) && (wrote)) {\n          return;\n        }\n      }\n    }\n    if (!endOfBitStream) {\n      bytes=0;\n      int index=syncState.buffer(BUFFER_SIZE);\n      if (index >= 0) {\n        buffer=syncState.data;\n        try {\n          bytes=input.read(buffer,index,BUFFER_SIZE);\n        }\n catch (        Exception e) {\n          throw new GdxRuntimeException(\"Error during Vorbis decoding.\",e);\n        }\n      }\n else {\n        bytes=0;\n      }\n      syncState.wrote(bytes);\n      if (bytes == 0) {\n        endOfBitStream=true;\n      }\n    }\n  }\n  streamState.clear();\n  vorbisBlock.clear();\n  dspState.clear();\n  oggInfo.clear();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 458,
      "astHeight" : 25
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4272,
        "startLineNumber" : 290,
        "startColumnNumber" : 2,
        "endLineNumber" : 425,
        "endColumnNumber" : 3
      },
      "nodeContext" : "while (true) {\n  if (endOfBitStream) {\n    if (!getPageAndPacket()) {\n      break;\n    }\n    endOfBitStream=false;\n  }\n  if (!inited) {\n    inited=true;\n    return;\n  }\n  float[][][] _pcm=new float[1][][];\n  int[] _index=new int[oggInfo.channels];\n  while (!endOfBitStream) {\n    while (!endOfBitStream) {\n      int result=syncState.pageout(page);\n      if (result == 0) {\n        break;\n      }\n      if (result == -1) {\n        Gdx.app.log(\"gdx-audio\",\"Error reading OGG: Corrupt or missing data in bitstream.\");\n      }\n else {\n        streamState.pagein(page);\n        while (true) {\n          result=streamState.packetout(packet);\n          if (result == 0)           break;\n          if (result == -1) {\n          }\n else {\n            int samples;\n            if (vorbisBlock.synthesis(packet) == 0) {\n              dspState.synthesis_blockin(vorbisBlock);\n            }\n            while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n              float[][] pcm=_pcm[0];\n              int bout=(samples < convsize ? samples : convsize);\n              for (int i=0; i < oggInfo.channels; i++) {\n                int ptr=i * 2;\n                int mono=_index[i];\n                for (int j=0; j < bout; j++) {\n                  int val=(int)(pcm[i][mono + j] * 32767.);\n                  if (val > 32767) {\n                    val=32767;\n                  }\n                  if (val < -32768) {\n                    val=-32768;\n                  }\n                  if (val < 0)                   val=val | 0x8000;\n                  if (bigEndian) {\n                    convbuffer[ptr]=(byte)(val >>> 8);\n                    convbuffer[ptr + 1]=(byte)(val);\n                  }\n else {\n                    convbuffer[ptr]=(byte)(val);\n                    convbuffer[ptr + 1]=(byte)(val >>> 8);\n                  }\n                  ptr+=2 * (oggInfo.channels);\n                }\n              }\n              int bytesToWrite=2 * oggInfo.channels * bout;\n              if (bytesToWrite > pcmBuffer.remaining()) {\n                throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n              }\n else {\n                pcmBuffer.put(convbuffer,0,bytesToWrite);\n              }\n              wrote=true;\n              dspState.synthesis_read(bout);\n            }\n          }\n        }\n        if (page.eos() != 0) {\n          endOfBitStream=true;\n        }\n        if ((!endOfBitStream) && (wrote)) {\n          return;\n        }\n      }\n    }\n    if (!endOfBitStream) {\n      bytes=0;\n      int index=syncState.buffer(BUFFER_SIZE);\n      if (index >= 0) {\n        buffer=syncState.data;\n        try {\n          bytes=input.read(buffer,index,BUFFER_SIZE);\n        }\n catch (        Exception e) {\n          throw new GdxRuntimeException(\"Error during Vorbis decoding.\",e);\n        }\n      }\n else {\n        bytes=0;\n      }\n      syncState.wrote(bytes);\n      if (bytes == 0) {\n        endOfBitStream=true;\n      }\n    }\n  }\n  streamState.clear();\n  vorbisBlock.clear();\n  dspState.clear();\n  oggInfo.clear();\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 460,
      "astHeight" : 26
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4386,
        "startLineNumber" : 287,
        "startColumnNumber" : 25,
        "endLineNumber" : 430,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  boolean wrote=false;\n  while (true) {\n    if (endOfBitStream) {\n      if (!getPageAndPacket()) {\n        break;\n      }\n      endOfBitStream=false;\n    }\n    if (!inited) {\n      inited=true;\n      return;\n    }\n    float[][][] _pcm=new float[1][][];\n    int[] _index=new int[oggInfo.channels];\n    while (!endOfBitStream) {\n      while (!endOfBitStream) {\n        int result=syncState.pageout(page);\n        if (result == 0) {\n          break;\n        }\n        if (result == -1) {\n          Gdx.app.log(\"gdx-audio\",\"Error reading OGG: Corrupt or missing data in bitstream.\");\n        }\n else {\n          streamState.pagein(page);\n          while (true) {\n            result=streamState.packetout(packet);\n            if (result == 0)             break;\n            if (result == -1) {\n            }\n else {\n              int samples;\n              if (vorbisBlock.synthesis(packet) == 0) {\n                dspState.synthesis_blockin(vorbisBlock);\n              }\n              while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n                float[][] pcm=_pcm[0];\n                int bout=(samples < convsize ? samples : convsize);\n                for (int i=0; i < oggInfo.channels; i++) {\n                  int ptr=i * 2;\n                  int mono=_index[i];\n                  for (int j=0; j < bout; j++) {\n                    int val=(int)(pcm[i][mono + j] * 32767.);\n                    if (val > 32767) {\n                      val=32767;\n                    }\n                    if (val < -32768) {\n                      val=-32768;\n                    }\n                    if (val < 0)                     val=val | 0x8000;\n                    if (bigEndian) {\n                      convbuffer[ptr]=(byte)(val >>> 8);\n                      convbuffer[ptr + 1]=(byte)(val);\n                    }\n else {\n                      convbuffer[ptr]=(byte)(val);\n                      convbuffer[ptr + 1]=(byte)(val >>> 8);\n                    }\n                    ptr+=2 * (oggInfo.channels);\n                  }\n                }\n                int bytesToWrite=2 * oggInfo.channels * bout;\n                if (bytesToWrite > pcmBuffer.remaining()) {\n                  throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n                }\n else {\n                  pcmBuffer.put(convbuffer,0,bytesToWrite);\n                }\n                wrote=true;\n                dspState.synthesis_read(bout);\n              }\n            }\n          }\n          if (page.eos() != 0) {\n            endOfBitStream=true;\n          }\n          if ((!endOfBitStream) && (wrote)) {\n            return;\n          }\n        }\n      }\n      if (!endOfBitStream) {\n        bytes=0;\n        int index=syncState.buffer(BUFFER_SIZE);\n        if (index >= 0) {\n          buffer=syncState.data;\n          try {\n            bytes=input.read(buffer,index,BUFFER_SIZE);\n          }\n catch (          Exception e) {\n            throw new GdxRuntimeException(\"Error during Vorbis decoding.\",e);\n          }\n        }\n else {\n          bytes=0;\n        }\n        syncState.wrote(bytes);\n        if (bytes == 0) {\n          endOfBitStream=true;\n        }\n      }\n    }\n    streamState.clear();\n    vorbisBlock.clear();\n    dspState.clear();\n    oggInfo.clear();\n  }\n  syncState.clear();\n  endOfStream=true;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 474,
      "astHeight" : 27
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4476,
        "startLineNumber" : 286,
        "startColumnNumber" : 1,
        "endLineNumber" : 430,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * Decode the OGG file as shown in the jogg/jorbis examples \n */\nprivate void readPCM(){\n  boolean wrote=false;\n  while (true) {\n    if (endOfBitStream) {\n      if (!getPageAndPacket()) {\n        break;\n      }\n      endOfBitStream=false;\n    }\n    if (!inited) {\n      inited=true;\n      return;\n    }\n    float[][][] _pcm=new float[1][][];\n    int[] _index=new int[oggInfo.channels];\n    while (!endOfBitStream) {\n      while (!endOfBitStream) {\n        int result=syncState.pageout(page);\n        if (result == 0) {\n          break;\n        }\n        if (result == -1) {\n          Gdx.app.log(\"gdx-audio\",\"Error reading OGG: Corrupt or missing data in bitstream.\");\n        }\n else {\n          streamState.pagein(page);\n          while (true) {\n            result=streamState.packetout(packet);\n            if (result == 0)             break;\n            if (result == -1) {\n            }\n else {\n              int samples;\n              if (vorbisBlock.synthesis(packet) == 0) {\n                dspState.synthesis_blockin(vorbisBlock);\n              }\n              while ((samples=dspState.synthesis_pcmout(_pcm,_index)) > 0) {\n                float[][] pcm=_pcm[0];\n                int bout=(samples < convsize ? samples : convsize);\n                for (int i=0; i < oggInfo.channels; i++) {\n                  int ptr=i * 2;\n                  int mono=_index[i];\n                  for (int j=0; j < bout; j++) {\n                    int val=(int)(pcm[i][mono + j] * 32767.);\n                    if (val > 32767) {\n                      val=32767;\n                    }\n                    if (val < -32768) {\n                      val=-32768;\n                    }\n                    if (val < 0)                     val=val | 0x8000;\n                    if (bigEndian) {\n                      convbuffer[ptr]=(byte)(val >>> 8);\n                      convbuffer[ptr + 1]=(byte)(val);\n                    }\n else {\n                      convbuffer[ptr]=(byte)(val);\n                      convbuffer[ptr + 1]=(byte)(val >>> 8);\n                    }\n                    ptr+=2 * (oggInfo.channels);\n                  }\n                }\n                int bytesToWrite=2 * oggInfo.channels * bout;\n                if (bytesToWrite > pcmBuffer.remaining()) {\n                  throw new GdxRuntimeException(\"Ogg block too big to be buffered: \" + bytesToWrite + \" :: \"+ pcmBuffer.remaining());\n                }\n else {\n                  pcmBuffer.put(convbuffer,0,bytesToWrite);\n                }\n                wrote=true;\n                dspState.synthesis_read(bout);\n              }\n            }\n          }\n          if (page.eos() != 0) {\n            endOfBitStream=true;\n          }\n          if ((!endOfBitStream) && (wrote)) {\n            return;\n          }\n        }\n      }\n      if (!endOfBitStream) {\n        bytes=0;\n        int index=syncState.buffer(BUFFER_SIZE);\n        if (index >= 0) {\n          buffer=syncState.data;\n          try {\n            bytes=input.read(buffer,index,BUFFER_SIZE);\n          }\n catch (          Exception e) {\n            throw new GdxRuntimeException(\"Error during Vorbis decoding.\",e);\n          }\n        }\n else {\n          bytes=0;\n        }\n        syncState.wrote(bytes);\n        if (bytes == 0) {\n          endOfBitStream=true;\n        }\n      }\n    }\n    streamState.clear();\n    vorbisBlock.clear();\n    dspState.clear();\n    oggInfo.clear();\n  }\n  syncState.clear();\n  endOfStream=true;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 479,
      "astHeight" : 28
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 60,
        "startLineNumber" : 355,
        "startColumnNumber" : 11,
        "endLineNumber" : 357,
        "endColumnNumber" : 12
      },
      "nodeContext" : "if (val < -32768) {\n  val=-32768;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 11,
      "astHeight" : 6
    },
    "tokenLength" : 3,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 12,
    "startLineNumber" : 355,
    "startColumnNumber" : 15,
    "endLineNumber" : 355,
    "endColumnNumber" : 27
  } ],
  "layoutRelationDataList" : [ ]
}