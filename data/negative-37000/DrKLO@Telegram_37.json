{
  "id" : 37,
  "expression" : "pickerDelegate.pickerEnd",
  "projectName" : "DrKLO@Telegram",
  "commitID" : "11fbfb1329df700b203e1852a71c4c11b5ab12f4",
  "filePath" : "/TMessagesProj/src/main/java/org/telegram/ui/Charts/StackLinearChartView.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "pickerDelegate.pickerEnd",
    "nodeType" : "QualifiedName",
    "nodePosition" : {
      "charLength" : 24,
      "startLineNumber" : 41,
      "startColumnNumber" : 45,
      "endLineNumber" : 41,
      "endColumnNumber" : 69
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 41,
        "startColumnNumber" : 45,
        "endLineNumber" : 41,
        "endColumnNumber" : 98
      },
      "nodeContext" : "pickerDelegate.pickerEnd - pickerDelegate.pickerStart",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 41,
        "startColumnNumber" : 44,
        "endLineNumber" : 41,
        "endColumnNumber" : 99
      },
      "nodeContext" : "(pickerDelegate.pickerEnd - pickerDelegate.pickerStart)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 41,
        "startColumnNumber" : 31,
        "endLineNumber" : 41,
        "endColumnNumber" : 99
      },
      "nodeContext" : "chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 70,
        "startLineNumber" : 41,
        "startColumnNumber" : 30,
        "endLineNumber" : 41,
        "endColumnNumber" : 100
      },
      "nodeContext" : "(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart))",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 11,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 82,
        "startLineNumber" : 41,
        "startColumnNumber" : 18,
        "endLineNumber" : 41,
        "endColumnNumber" : 100
      },
      "nodeContext" : "fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart))",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 13,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 89,
        "startLineNumber" : 41,
        "startColumnNumber" : 12,
        "endLineNumber" : 41,
        "endColumnNumber" : 101
      },
      "nodeContext" : "float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 15,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 15771,
        "startLineNumber" : 40,
        "startColumnNumber" : 31,
        "endLineNumber" : 375,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n  float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n  float cX=chartArea.centerX();\n  float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n  for (int k=0; k < lines.size(); k++) {\n    lines.get(k).chartPath.reset();\n    lines.get(k).chartPathPicker.reset();\n  }\n  canvas.save();\n  if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n    skipPoints=new boolean[chartData.lines.size()];\n    startFromY=new float[chartData.lines.size()];\n  }\n  boolean hasEmptyPoint=false;\n  int transitionAlpha=255;\n  float transitionProgressHalf=0;\n  if (transitionMode == TRANSITION_MODE_PARENT) {\n    transitionProgressHalf=transitionParams.progress / 0.6f;\n    if (transitionProgressHalf > 1f) {\n      transitionProgressHalf=1f;\n    }\n    ovalPath.reset();\n    float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n    float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n    float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n    RectF rectF=new RectF();\n    rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n    ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n    canvas.clipPath(ovalPath);\n  }\n else   if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n    transitionAlpha=(int)(transitionParams.progress * 255);\n  }\n  float dX=0;\n  float dY=0;\n  float x1=0;\n  float y1=0;\n  float p;\n  if (chartData.xPercentage.length < 2) {\n    p=1f;\n  }\n else {\n    p=chartData.xPercentage[1] * fullWidth;\n  }\n  int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n  int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n  int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n  float startXPoint=0;\n  float endXPoint=0;\n  for (int i=localStart; i <= localEnd; i++) {\n    float stackOffset=0;\n    float sum=0;\n    int lastEnabled=0;\n    int drawingLinesCount=0;\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      if (line.line.y[i] > 0) {\n        sum+=line.line.y[i] * line.alpha;\n        drawingLinesCount++;\n      }\n      lastEnabled=k;\n    }\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      int[] y=line.line.y;\n      float yPercentage;\n      if (drawingLinesCount == 1) {\n        if (y[i] == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=line.alpha;\n        }\n      }\n else {\n        if (sum == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=y[i] * line.alpha / sum;\n        }\n      }\n      float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n      float nextXPoint;\n      if (i == localEnd) {\n        nextXPoint=getMeasuredWidth();\n      }\n else {\n        nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n      }\n      if (yPercentage == 0 && k == lastEnabled) {\n        hasEmptyPoint=true;\n      }\n      float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n      float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n      startFromY[k]=yPoint;\n      float angle=0;\n      float yPointZero=getMeasuredHeight() - chartBottom;\n      float xPointZero=xPoint;\n      if (i == localEnd) {\n        endXPoint=xPoint;\n      }\n else       if (i == localStart) {\n        startXPoint=xPoint;\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        if (xPoint < cX) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n        }\n else {\n          x1=transitionParams.endX[k];\n          y1=transitionParams.endY[k];\n        }\n        dX=cX - x1;\n        dY=cY - y1;\n        float yTo=dY * (xPoint - x1) / dX + y1;\n        yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        if (xPoint >= cX) {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (xPoint < cX)           xPoint=cX;\n          mapPoints[0]=xPointZero;\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          yPointZero=mapPoints[1];\n          if (xPointZero < cX)           xPointZero=cX;\n        }\n else {\n          if (nextXPoint >= cX) {\n            xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n            yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n          }\n else {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (nextXPoint >= cX) {\n              mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n            }\n else {\n              mapPoints[0]=xPointZero;\n            }\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPointZero=mapPoints[0];\n            yPointZero=mapPoints[1];\n          }\n        }\n      }\n      if (i == localStart) {\n        float localX=0;\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX - cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n        line.chartPath.moveTo(localX,localY);\n        skipPoints[k]=false;\n      }\n      float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n      if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n        if (!skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        skipPoints[k]=true;\n      }\n else {\n        if (skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPoint,yPoint);\n        }\n        skipPoints[k]=false;\n      }\n      if (i == localEnd) {\n        float localX=getMeasuredWidth();\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX + cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n else {\n          line.chartPath.lineTo(localX,localY);\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n          dX=cX - x1;\n          dY=cY - y1;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          localX=transitionParams.startX[k];\n          localY=transitionParams.startY[k];\n          mapPoints[0]=localX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n          int endQuarter;\n          int startQuarter;\n          if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n            if (transitionParams.angle[k] == -180f) {\n              endQuarter=0;\n              startQuarter=0;\n            }\n else {\n              endQuarter=0;\n              startQuarter=3;\n            }\n          }\n else {\n            endQuarter=quarterForPoint(xPoint,yPoint);\n            startQuarter=quarterForPoint(localX,localY);\n          }\n          for (int q=endQuarter; q <= startQuarter; q++) {\n            if (q == 0) {\n              line.chartPath.lineTo(getMeasuredWidth(),0);\n            }\n else             if (q == 1) {\n              line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n            }\n else             if (q == 2) {\n              line.chartPath.lineTo(0,getMeasuredHeight());\n            }\n else {\n              line.chartPath.lineTo(0,0);\n            }\n          }\n        }\n      }\n      stackOffset+=height;\n    }\n  }\n  canvas.save();\n  canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n  if (hasEmptyPoint) {\n    canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n  }\n  for (int k=lines.size() - 1; k >= 0; k--) {\n    LineViewData line=lines.get(k);\n    line.paint.setAlpha(transitionAlpha);\n    canvas.drawPath(line.chartPath,line.paint);\n    line.paint.setAlpha(255);\n  }\n  canvas.restore();\n  canvas.restore();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1828,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 15794,
        "startLineNumber" : 40,
        "startColumnNumber" : 8,
        "endLineNumber" : 375,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (chartData != null) {\n  float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n  float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n  float cX=chartArea.centerX();\n  float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n  for (int k=0; k < lines.size(); k++) {\n    lines.get(k).chartPath.reset();\n    lines.get(k).chartPathPicker.reset();\n  }\n  canvas.save();\n  if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n    skipPoints=new boolean[chartData.lines.size()];\n    startFromY=new float[chartData.lines.size()];\n  }\n  boolean hasEmptyPoint=false;\n  int transitionAlpha=255;\n  float transitionProgressHalf=0;\n  if (transitionMode == TRANSITION_MODE_PARENT) {\n    transitionProgressHalf=transitionParams.progress / 0.6f;\n    if (transitionProgressHalf > 1f) {\n      transitionProgressHalf=1f;\n    }\n    ovalPath.reset();\n    float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n    float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n    float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n    RectF rectF=new RectF();\n    rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n    ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n    canvas.clipPath(ovalPath);\n  }\n else   if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n    transitionAlpha=(int)(transitionParams.progress * 255);\n  }\n  float dX=0;\n  float dY=0;\n  float x1=0;\n  float y1=0;\n  float p;\n  if (chartData.xPercentage.length < 2) {\n    p=1f;\n  }\n else {\n    p=chartData.xPercentage[1] * fullWidth;\n  }\n  int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n  int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n  int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n  float startXPoint=0;\n  float endXPoint=0;\n  for (int i=localStart; i <= localEnd; i++) {\n    float stackOffset=0;\n    float sum=0;\n    int lastEnabled=0;\n    int drawingLinesCount=0;\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      if (line.line.y[i] > 0) {\n        sum+=line.line.y[i] * line.alpha;\n        drawingLinesCount++;\n      }\n      lastEnabled=k;\n    }\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      int[] y=line.line.y;\n      float yPercentage;\n      if (drawingLinesCount == 1) {\n        if (y[i] == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=line.alpha;\n        }\n      }\n else {\n        if (sum == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=y[i] * line.alpha / sum;\n        }\n      }\n      float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n      float nextXPoint;\n      if (i == localEnd) {\n        nextXPoint=getMeasuredWidth();\n      }\n else {\n        nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n      }\n      if (yPercentage == 0 && k == lastEnabled) {\n        hasEmptyPoint=true;\n      }\n      float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n      float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n      startFromY[k]=yPoint;\n      float angle=0;\n      float yPointZero=getMeasuredHeight() - chartBottom;\n      float xPointZero=xPoint;\n      if (i == localEnd) {\n        endXPoint=xPoint;\n      }\n else       if (i == localStart) {\n        startXPoint=xPoint;\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        if (xPoint < cX) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n        }\n else {\n          x1=transitionParams.endX[k];\n          y1=transitionParams.endY[k];\n        }\n        dX=cX - x1;\n        dY=cY - y1;\n        float yTo=dY * (xPoint - x1) / dX + y1;\n        yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        if (xPoint >= cX) {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (xPoint < cX)           xPoint=cX;\n          mapPoints[0]=xPointZero;\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          yPointZero=mapPoints[1];\n          if (xPointZero < cX)           xPointZero=cX;\n        }\n else {\n          if (nextXPoint >= cX) {\n            xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n            yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n          }\n else {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (nextXPoint >= cX) {\n              mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n            }\n else {\n              mapPoints[0]=xPointZero;\n            }\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPointZero=mapPoints[0];\n            yPointZero=mapPoints[1];\n          }\n        }\n      }\n      if (i == localStart) {\n        float localX=0;\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX - cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n        line.chartPath.moveTo(localX,localY);\n        skipPoints[k]=false;\n      }\n      float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n      if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n        if (!skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        skipPoints[k]=true;\n      }\n else {\n        if (skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPoint,yPoint);\n        }\n        skipPoints[k]=false;\n      }\n      if (i == localEnd) {\n        float localX=getMeasuredWidth();\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX + cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n else {\n          line.chartPath.lineTo(localX,localY);\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n          dX=cX - x1;\n          dY=cY - y1;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          localX=transitionParams.startX[k];\n          localY=transitionParams.startY[k];\n          mapPoints[0]=localX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n          int endQuarter;\n          int startQuarter;\n          if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n            if (transitionParams.angle[k] == -180f) {\n              endQuarter=0;\n              startQuarter=0;\n            }\n else {\n              endQuarter=0;\n              startQuarter=3;\n            }\n          }\n else {\n            endQuarter=quarterForPoint(xPoint,yPoint);\n            startQuarter=quarterForPoint(localX,localY);\n          }\n          for (int q=endQuarter; q <= startQuarter; q++) {\n            if (q == 0) {\n              line.chartPath.lineTo(getMeasuredWidth(),0);\n            }\n else             if (q == 1) {\n              line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n            }\n else             if (q == 2) {\n              line.chartPath.lineTo(0,getMeasuredHeight());\n            }\n else {\n              line.chartPath.lineTo(0,0);\n            }\n          }\n        }\n      }\n      stackOffset+=height;\n    }\n  }\n  canvas.save();\n  canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n  if (hasEmptyPoint) {\n    canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n  }\n  for (int k=lines.size() - 1; k >= 0; k--) {\n    LineViewData line=lines.get(k);\n    line.paint.setAlpha(transitionAlpha);\n    canvas.drawPath(line.chartPath,line.paint);\n    line.paint.setAlpha(255);\n  }\n  canvas.restore();\n  canvas.restore();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1832,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 15810,
        "startLineNumber" : 39,
        "startColumnNumber" : 44,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (chartData != null) {\n    float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n    float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n    float cX=chartArea.centerX();\n    float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n    for (int k=0; k < lines.size(); k++) {\n      lines.get(k).chartPath.reset();\n      lines.get(k).chartPathPicker.reset();\n    }\n    canvas.save();\n    if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n      skipPoints=new boolean[chartData.lines.size()];\n      startFromY=new float[chartData.lines.size()];\n    }\n    boolean hasEmptyPoint=false;\n    int transitionAlpha=255;\n    float transitionProgressHalf=0;\n    if (transitionMode == TRANSITION_MODE_PARENT) {\n      transitionProgressHalf=transitionParams.progress / 0.6f;\n      if (transitionProgressHalf > 1f) {\n        transitionProgressHalf=1f;\n      }\n      ovalPath.reset();\n      float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n      float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n      float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n      RectF rectF=new RectF();\n      rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n      ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n      canvas.clipPath(ovalPath);\n    }\n else     if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n      transitionAlpha=(int)(transitionParams.progress * 255);\n    }\n    float dX=0;\n    float dY=0;\n    float x1=0;\n    float y1=0;\n    float p;\n    if (chartData.xPercentage.length < 2) {\n      p=1f;\n    }\n else {\n      p=chartData.xPercentage[1] * fullWidth;\n    }\n    int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n    int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n    int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n    float startXPoint=0;\n    float endXPoint=0;\n    for (int i=localStart; i <= localEnd; i++) {\n      float stackOffset=0;\n      float sum=0;\n      int lastEnabled=0;\n      int drawingLinesCount=0;\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        if (line.line.y[i] > 0) {\n          sum+=line.line.y[i] * line.alpha;\n          drawingLinesCount++;\n        }\n        lastEnabled=k;\n      }\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        int[] y=line.line.y;\n        float yPercentage;\n        if (drawingLinesCount == 1) {\n          if (y[i] == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=line.alpha;\n          }\n        }\n else {\n          if (sum == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=y[i] * line.alpha / sum;\n          }\n        }\n        float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n        float nextXPoint;\n        if (i == localEnd) {\n          nextXPoint=getMeasuredWidth();\n        }\n else {\n          nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n        }\n        if (yPercentage == 0 && k == lastEnabled) {\n          hasEmptyPoint=true;\n        }\n        float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n        float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n        startFromY[k]=yPoint;\n        float angle=0;\n        float yPointZero=getMeasuredHeight() - chartBottom;\n        float xPointZero=xPoint;\n        if (i == localEnd) {\n          endXPoint=xPoint;\n        }\n else         if (i == localStart) {\n          startXPoint=xPoint;\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          if (xPoint < cX) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n          }\n else {\n            x1=transitionParams.endX[k];\n            y1=transitionParams.endY[k];\n          }\n          dX=cX - x1;\n          dY=cY - y1;\n          float yTo=dY * (xPoint - x1) / dX + y1;\n          yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          if (xPoint >= cX) {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (xPoint < cX)             xPoint=cX;\n            mapPoints[0]=xPointZero;\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            yPointZero=mapPoints[1];\n            if (xPointZero < cX)             xPointZero=cX;\n          }\n else {\n            if (nextXPoint >= cX) {\n              xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n              yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n            }\n else {\n              mapPoints[0]=xPoint;\n              mapPoints[1]=yPoint;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPoint=mapPoints[0];\n              yPoint=mapPoints[1];\n              if (nextXPoint >= cX) {\n                mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n              }\n else {\n                mapPoints[0]=xPointZero;\n              }\n              mapPoints[1]=yPointZero;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPointZero=mapPoints[0];\n              yPointZero=mapPoints[1];\n            }\n          }\n        }\n        if (i == localStart) {\n          float localX=0;\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX - cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n          line.chartPath.moveTo(localX,localY);\n          skipPoints[k]=false;\n        }\n        float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n        if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n          if (!skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          skipPoints[k]=true;\n        }\n else {\n          if (skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPoint,yPoint);\n          }\n          skipPoints[k]=false;\n        }\n        if (i == localEnd) {\n          float localX=getMeasuredWidth();\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX + cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n else {\n            line.chartPath.lineTo(localX,localY);\n          }\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n            dX=cX - x1;\n            dY=cY - y1;\n            float angleK=dY / dX;\n            if (angleK > 0) {\n              angle=(float)Math.toDegrees(-Math.atan(angleK));\n            }\n else {\n              angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n            }\n            angle-=90;\n            localX=transitionParams.startX[k];\n            localY=transitionParams.startY[k];\n            mapPoints[0]=localX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n            int endQuarter;\n            int startQuarter;\n            if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n              if (transitionParams.angle[k] == -180f) {\n                endQuarter=0;\n                startQuarter=0;\n              }\n else {\n                endQuarter=0;\n                startQuarter=3;\n              }\n            }\n else {\n              endQuarter=quarterForPoint(xPoint,yPoint);\n              startQuarter=quarterForPoint(localX,localY);\n            }\n            for (int q=endQuarter; q <= startQuarter; q++) {\n              if (q == 0) {\n                line.chartPath.lineTo(getMeasuredWidth(),0);\n              }\n else               if (q == 1) {\n                line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n              }\n else               if (q == 2) {\n                line.chartPath.lineTo(0,getMeasuredHeight());\n              }\n else {\n                line.chartPath.lineTo(0,0);\n              }\n            }\n          }\n        }\n        stackOffset+=height;\n      }\n    }\n    canvas.save();\n    canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n    if (hasEmptyPoint) {\n      canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n    }\n    for (int k=lines.size() - 1; k >= 0; k--) {\n      LineViewData line=lines.get(k);\n      line.paint.setAlpha(transitionAlpha);\n      canvas.drawPath(line.chartPath,line.paint);\n      line.paint.setAlpha(255);\n    }\n    canvas.restore();\n    canvas.restore();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1833,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 15864,
        "startLineNumber" : 38,
        "startColumnNumber" : 4,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@Override protected void drawChart(Canvas canvas){\n  if (chartData != null) {\n    float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n    float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n    float cX=chartArea.centerX();\n    float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n    for (int k=0; k < lines.size(); k++) {\n      lines.get(k).chartPath.reset();\n      lines.get(k).chartPathPicker.reset();\n    }\n    canvas.save();\n    if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n      skipPoints=new boolean[chartData.lines.size()];\n      startFromY=new float[chartData.lines.size()];\n    }\n    boolean hasEmptyPoint=false;\n    int transitionAlpha=255;\n    float transitionProgressHalf=0;\n    if (transitionMode == TRANSITION_MODE_PARENT) {\n      transitionProgressHalf=transitionParams.progress / 0.6f;\n      if (transitionProgressHalf > 1f) {\n        transitionProgressHalf=1f;\n      }\n      ovalPath.reset();\n      float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n      float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n      float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n      RectF rectF=new RectF();\n      rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n      ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n      canvas.clipPath(ovalPath);\n    }\n else     if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n      transitionAlpha=(int)(transitionParams.progress * 255);\n    }\n    float dX=0;\n    float dY=0;\n    float x1=0;\n    float y1=0;\n    float p;\n    if (chartData.xPercentage.length < 2) {\n      p=1f;\n    }\n else {\n      p=chartData.xPercentage[1] * fullWidth;\n    }\n    int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n    int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n    int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n    float startXPoint=0;\n    float endXPoint=0;\n    for (int i=localStart; i <= localEnd; i++) {\n      float stackOffset=0;\n      float sum=0;\n      int lastEnabled=0;\n      int drawingLinesCount=0;\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        if (line.line.y[i] > 0) {\n          sum+=line.line.y[i] * line.alpha;\n          drawingLinesCount++;\n        }\n        lastEnabled=k;\n      }\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        int[] y=line.line.y;\n        float yPercentage;\n        if (drawingLinesCount == 1) {\n          if (y[i] == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=line.alpha;\n          }\n        }\n else {\n          if (sum == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=y[i] * line.alpha / sum;\n          }\n        }\n        float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n        float nextXPoint;\n        if (i == localEnd) {\n          nextXPoint=getMeasuredWidth();\n        }\n else {\n          nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n        }\n        if (yPercentage == 0 && k == lastEnabled) {\n          hasEmptyPoint=true;\n        }\n        float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n        float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n        startFromY[k]=yPoint;\n        float angle=0;\n        float yPointZero=getMeasuredHeight() - chartBottom;\n        float xPointZero=xPoint;\n        if (i == localEnd) {\n          endXPoint=xPoint;\n        }\n else         if (i == localStart) {\n          startXPoint=xPoint;\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          if (xPoint < cX) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n          }\n else {\n            x1=transitionParams.endX[k];\n            y1=transitionParams.endY[k];\n          }\n          dX=cX - x1;\n          dY=cY - y1;\n          float yTo=dY * (xPoint - x1) / dX + y1;\n          yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          if (xPoint >= cX) {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (xPoint < cX)             xPoint=cX;\n            mapPoints[0]=xPointZero;\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            yPointZero=mapPoints[1];\n            if (xPointZero < cX)             xPointZero=cX;\n          }\n else {\n            if (nextXPoint >= cX) {\n              xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n              yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n            }\n else {\n              mapPoints[0]=xPoint;\n              mapPoints[1]=yPoint;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPoint=mapPoints[0];\n              yPoint=mapPoints[1];\n              if (nextXPoint >= cX) {\n                mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n              }\n else {\n                mapPoints[0]=xPointZero;\n              }\n              mapPoints[1]=yPointZero;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPointZero=mapPoints[0];\n              yPointZero=mapPoints[1];\n            }\n          }\n        }\n        if (i == localStart) {\n          float localX=0;\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX - cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n          line.chartPath.moveTo(localX,localY);\n          skipPoints[k]=false;\n        }\n        float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n        if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n          if (!skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          skipPoints[k]=true;\n        }\n else {\n          if (skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPoint,yPoint);\n          }\n          skipPoints[k]=false;\n        }\n        if (i == localEnd) {\n          float localX=getMeasuredWidth();\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX + cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n else {\n            line.chartPath.lineTo(localX,localY);\n          }\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n            dX=cX - x1;\n            dY=cY - y1;\n            float angleK=dY / dX;\n            if (angleK > 0) {\n              angle=(float)Math.toDegrees(-Math.atan(angleK));\n            }\n else {\n              angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n            }\n            angle-=90;\n            localX=transitionParams.startX[k];\n            localY=transitionParams.startY[k];\n            mapPoints[0]=localX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n            int endQuarter;\n            int startQuarter;\n            if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n              if (transitionParams.angle[k] == -180f) {\n                endQuarter=0;\n                startQuarter=0;\n              }\n else {\n                endQuarter=0;\n                startQuarter=3;\n              }\n            }\n else {\n              endQuarter=quarterForPoint(xPoint,yPoint);\n              startQuarter=quarterForPoint(localX,localY);\n            }\n            for (int q=endQuarter; q <= startQuarter; q++) {\n              if (q == 0) {\n                line.chartPath.lineTo(getMeasuredWidth(),0);\n              }\n else               if (q == 1) {\n                line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n              }\n else               if (q == 2) {\n                line.chartPath.lineTo(0,getMeasuredHeight());\n              }\n else {\n                line.chartPath.lineTo(0,0);\n              }\n            }\n          }\n        }\n        stackOffset+=height;\n      }\n    }\n    canvas.save();\n    canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n    if (hasEmptyPoint) {\n      canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n    }\n    for (int k=lines.size() - 1; k >= 0; k--) {\n      LineViewData line=lines.get(k);\n      line.paint.setAlpha(transitionAlpha);\n      canvas.drawPath(line.chartPath,line.paint);\n      line.paint.setAlpha(255);\n    }\n    canvas.restore();\n    canvas.restore();\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1843,
      "astHeight" : 24
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 89,
        "startLineNumber" : 41,
        "startColumnNumber" : 12,
        "endLineNumber" : 41,
        "endColumnNumber" : 101
      },
      "nodeContext" : "float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 15,
      "astHeight" : 8
    },
    "tokenLength" : 2,
    "type" : "float"
  } ],
  "positionList" : [ {
    "charLength" : 24,
    "startLineNumber" : 41,
    "startColumnNumber" : 45,
    "endLineNumber" : 41,
    "endColumnNumber" : 69
  } ],
  "layoutRelationDataList" : [ ]
}