{
  "id" : 413,
  "expression" : "setTransitions",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/tool/src/org/antlr/v4/automata/ATNOptimizer.java",
  "occurrences" : 3,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "setTransitions",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 14,
      "startLineNumber" : 83,
      "startColumnNumber" : 5,
      "endLineNumber" : 83,
      "endColumnNumber" : 19
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 83,
        "startColumnNumber" : 5,
        "endLineNumber" : 83,
        "endColumnNumber" : 26
      },
      "nodeContext" : "setTransitions.add(i)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 83,
        "startColumnNumber" : 5,
        "endLineNumber" : 83,
        "endColumnNumber" : 27
      },
      "nodeContext" : "setTransitions.add(i);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 82,
        "startColumnNumber" : 4,
        "endLineNumber" : 84,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  setTransitions.add(i);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 176,
        "startLineNumber" : 79,
        "startColumnNumber" : 4,
        "endLineNumber" : 84,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n  setTransitions.add(i);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 20,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 675,
        "startLineNumber" : 59,
        "startColumnNumber" : 63,
        "endLineNumber" : 85,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  Transition epsTransition=decision.transition(i);\n  if (!(epsTransition instanceof EpsilonTransition)) {\n    continue;\n  }\n  if (epsTransition.target.getNumberOfTransitions() != 1) {\n    continue;\n  }\n  Transition transition=epsTransition.target.transition(0);\n  if (!(transition.target instanceof BlockEndState)) {\n    continue;\n  }\n  if (transition instanceof NotSetTransition) {\n    continue;\n  }\n  if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n    setTransitions.add(i);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 78,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 735,
        "startLineNumber" : 59,
        "startColumnNumber" : 3,
        "endLineNumber" : 85,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n  Transition epsTransition=decision.transition(i);\n  if (!(epsTransition instanceof EpsilonTransition)) {\n    continue;\n  }\n  if (epsTransition.target.getNumberOfTransitions() != 1) {\n    continue;\n  }\n  Transition transition=epsTransition.target.transition(0);\n  if (!(transition.target instanceof BlockEndState)) {\n    continue;\n  }\n  if (transition instanceof NotSetTransition) {\n    continue;\n  }\n  if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n    setTransitions.add(i);\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 91,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 3306,
        "startLineNumber" : 49,
        "startColumnNumber" : 43,
        "endLineNumber" : 145,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (decision.ruleIndex >= 0) {\n    Rule rule=g.getRule(decision.ruleIndex);\n    if (Character.isLowerCase(rule.name.charAt(0))) {\n      continue;\n    }\n  }\n  IntervalSet setTransitions=new IntervalSet();\n  for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n    Transition epsTransition=decision.transition(i);\n    if (!(epsTransition instanceof EpsilonTransition)) {\n      continue;\n    }\n    if (epsTransition.target.getNumberOfTransitions() != 1) {\n      continue;\n    }\n    Transition transition=epsTransition.target.transition(0);\n    if (!(transition.target instanceof BlockEndState)) {\n      continue;\n    }\n    if (transition instanceof NotSetTransition) {\n      continue;\n    }\n    if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n      setTransitions.add(i);\n    }\n  }\n  for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n    Interval interval=setTransitions.getIntervals().get(i);\n    if (interval.length() <= 1) {\n      continue;\n    }\n    ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n    IntervalSet matchSet=new IntervalSet();\n    for (int j=interval.a; j <= interval.b; j++) {\n      Transition matchTransition=decision.transition(j).target.transition(0);\n      if (matchTransition instanceof NotSetTransition) {\n        throw new UnsupportedOperationException(\"Not yet implemented.\");\n      }\n      IntervalSet set=matchTransition.label();\n      List<Interval> intervals=set.getIntervals();\n      int n=intervals.size();\n      for (int k=0; k < n; k++) {\n        Interval setInterval=intervals.get(k);\n        int a=setInterval.a;\n        int b=setInterval.b;\n        if (a != -1 && b != -1) {\n          for (int v=a; v <= b; v++) {\n            if (matchSet.contains(v)) {\n              g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n              break;\n            }\n          }\n        }\n      }\n      matchSet.addAll(set);\n    }\n    Transition newTransition;\n    if (matchSet.getIntervals().size() == 1) {\n      if (matchSet.size() == 1) {\n        newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n      }\n else {\n        Interval matchInterval=matchSet.getIntervals().get(0);\n        newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n      }\n    }\n else {\n      newTransition=new SetTransition(blockEndState,matchSet);\n    }\n    decision.transition(interval.a).target.setTransition(0,newTransition);\n    for (int j=interval.a + 1; j <= interval.b; j++) {\n      Transition removed=decision.removeTransition(interval.a + 1);\n      atn.removeState(removed.target);\n      removedStates++;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 472,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3347,
        "startLineNumber" : 49,
        "startColumnNumber" : 2,
        "endLineNumber" : 145,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (DecisionState decision : decisions) {\n  if (decision.ruleIndex >= 0) {\n    Rule rule=g.getRule(decision.ruleIndex);\n    if (Character.isLowerCase(rule.name.charAt(0))) {\n      continue;\n    }\n  }\n  IntervalSet setTransitions=new IntervalSet();\n  for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n    Transition epsTransition=decision.transition(i);\n    if (!(epsTransition instanceof EpsilonTransition)) {\n      continue;\n    }\n    if (epsTransition.target.getNumberOfTransitions() != 1) {\n      continue;\n    }\n    Transition transition=epsTransition.target.transition(0);\n    if (!(transition.target instanceof BlockEndState)) {\n      continue;\n    }\n    if (transition instanceof NotSetTransition) {\n      continue;\n    }\n    if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n      setTransitions.add(i);\n    }\n  }\n  for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n    Interval interval=setTransitions.getIntervals().get(i);\n    if (interval.length() <= 1) {\n      continue;\n    }\n    ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n    IntervalSet matchSet=new IntervalSet();\n    for (int j=interval.a; j <= interval.b; j++) {\n      Transition matchTransition=decision.transition(j).target.transition(0);\n      if (matchTransition instanceof NotSetTransition) {\n        throw new UnsupportedOperationException(\"Not yet implemented.\");\n      }\n      IntervalSet set=matchTransition.label();\n      List<Interval> intervals=set.getIntervals();\n      int n=intervals.size();\n      for (int k=0; k < n; k++) {\n        Interval setInterval=intervals.get(k);\n        int a=setInterval.a;\n        int b=setInterval.b;\n        if (a != -1 && b != -1) {\n          for (int v=a; v <= b; v++) {\n            if (matchSet.contains(v)) {\n              g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n              break;\n            }\n          }\n        }\n      }\n      matchSet.addAll(set);\n    }\n    Transition newTransition;\n    if (matchSet.getIntervals().size() == 1) {\n      if (matchSet.size() == 1) {\n        newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n      }\n else {\n        Interval matchInterval=matchSet.getIntervals().get(0);\n        newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n      }\n    }\n else {\n      newTransition=new SetTransition(blockEndState,matchSet);\n    }\n    decision.transition(interval.a).target.setTransition(0,newTransition);\n    for (int j=interval.a + 1; j <= interval.b; j++) {\n      Transition removed=decision.removeTransition(interval.a + 1);\n      atn.removeState(removed.target);\n      removedStates++;\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 478,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3643,
        "startLineNumber" : 41,
        "startColumnNumber" : 54,
        "endLineNumber" : 148,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (g.isParser()) {\n    return;\n  }\n  int removedStates=0;\n  List<DecisionState> decisions=atn.decisionToState;\n  for (  DecisionState decision : decisions) {\n    if (decision.ruleIndex >= 0) {\n      Rule rule=g.getRule(decision.ruleIndex);\n      if (Character.isLowerCase(rule.name.charAt(0))) {\n        continue;\n      }\n    }\n    IntervalSet setTransitions=new IntervalSet();\n    for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n      Transition epsTransition=decision.transition(i);\n      if (!(epsTransition instanceof EpsilonTransition)) {\n        continue;\n      }\n      if (epsTransition.target.getNumberOfTransitions() != 1) {\n        continue;\n      }\n      Transition transition=epsTransition.target.transition(0);\n      if (!(transition.target instanceof BlockEndState)) {\n        continue;\n      }\n      if (transition instanceof NotSetTransition) {\n        continue;\n      }\n      if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n        setTransitions.add(i);\n      }\n    }\n    for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n      Interval interval=setTransitions.getIntervals().get(i);\n      if (interval.length() <= 1) {\n        continue;\n      }\n      ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n      IntervalSet matchSet=new IntervalSet();\n      for (int j=interval.a; j <= interval.b; j++) {\n        Transition matchTransition=decision.transition(j).target.transition(0);\n        if (matchTransition instanceof NotSetTransition) {\n          throw new UnsupportedOperationException(\"Not yet implemented.\");\n        }\n        IntervalSet set=matchTransition.label();\n        List<Interval> intervals=set.getIntervals();\n        int n=intervals.size();\n        for (int k=0; k < n; k++) {\n          Interval setInterval=intervals.get(k);\n          int a=setInterval.a;\n          int b=setInterval.b;\n          if (a != -1 && b != -1) {\n            for (int v=a; v <= b; v++) {\n              if (matchSet.contains(v)) {\n                g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n                break;\n              }\n            }\n          }\n        }\n        matchSet.addAll(set);\n      }\n      Transition newTransition;\n      if (matchSet.getIntervals().size() == 1) {\n        if (matchSet.size() == 1) {\n          newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n        }\n else {\n          Interval matchInterval=matchSet.getIntervals().get(0);\n          newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n        }\n      }\n else {\n        newTransition=new SetTransition(blockEndState,matchSet);\n      }\n      decision.transition(interval.a).target.setTransition(0,newTransition);\n      for (int j=interval.a + 1; j <= interval.b; j++) {\n        Transition removed=decision.removeTransition(interval.a + 1);\n        atn.removeState(removed.target);\n        removedStates++;\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 501,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3696,
        "startLineNumber" : 41,
        "startColumnNumber" : 1,
        "endLineNumber" : 148,
        "endColumnNumber" : 2
      },
      "nodeContext" : "private static void optimizeSets(Grammar g,ATN atn){\n  if (g.isParser()) {\n    return;\n  }\n  int removedStates=0;\n  List<DecisionState> decisions=atn.decisionToState;\n  for (  DecisionState decision : decisions) {\n    if (decision.ruleIndex >= 0) {\n      Rule rule=g.getRule(decision.ruleIndex);\n      if (Character.isLowerCase(rule.name.charAt(0))) {\n        continue;\n      }\n    }\n    IntervalSet setTransitions=new IntervalSet();\n    for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n      Transition epsTransition=decision.transition(i);\n      if (!(epsTransition instanceof EpsilonTransition)) {\n        continue;\n      }\n      if (epsTransition.target.getNumberOfTransitions() != 1) {\n        continue;\n      }\n      Transition transition=epsTransition.target.transition(0);\n      if (!(transition.target instanceof BlockEndState)) {\n        continue;\n      }\n      if (transition instanceof NotSetTransition) {\n        continue;\n      }\n      if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n        setTransitions.add(i);\n      }\n    }\n    for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n      Interval interval=setTransitions.getIntervals().get(i);\n      if (interval.length() <= 1) {\n        continue;\n      }\n      ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n      IntervalSet matchSet=new IntervalSet();\n      for (int j=interval.a; j <= interval.b; j++) {\n        Transition matchTransition=decision.transition(j).target.transition(0);\n        if (matchTransition instanceof NotSetTransition) {\n          throw new UnsupportedOperationException(\"Not yet implemented.\");\n        }\n        IntervalSet set=matchTransition.label();\n        List<Interval> intervals=set.getIntervals();\n        int n=intervals.size();\n        for (int k=0; k < n; k++) {\n          Interval setInterval=intervals.get(k);\n          int a=setInterval.a;\n          int b=setInterval.b;\n          if (a != -1 && b != -1) {\n            for (int v=a; v <= b; v++) {\n              if (matchSet.contains(v)) {\n                g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n                break;\n              }\n            }\n          }\n        }\n        matchSet.addAll(set);\n      }\n      Transition newTransition;\n      if (matchSet.getIntervals().size() == 1) {\n        if (matchSet.size() == 1) {\n          newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n        }\n else {\n          Interval matchInterval=matchSet.getIntervals().get(0);\n          newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n        }\n      }\n else {\n        newTransition=new SetTransition(blockEndState,matchSet);\n      }\n      decision.transition(interval.a).target.setTransition(0,newTransition);\n      for (int j=interval.a + 1; j <= interval.b; j++) {\n        Transition removed=decision.removeTransition(interval.a + 1);\n        atn.removeState(removed.target);\n        removedStates++;\n      }\n    }\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 514,
      "astHeight" : 21
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 83,
        "startColumnNumber" : 5,
        "endLineNumber" : 83,
        "endColumnNumber" : 27
      },
      "nodeContext" : "setTransitions.add(i);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "org.antlr.v4.runtime.misc.IntervalSet"
  }, {
    "nodeContext" : "setTransitions",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 14,
      "startLineNumber" : 88,
      "startColumnNumber" : 16,
      "endLineNumber" : 88,
      "endColumnNumber" : 30
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 88,
        "startColumnNumber" : 16,
        "endLineNumber" : 88,
        "endColumnNumber" : 45
      },
      "nodeContext" : "setTransitions.getIntervals()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 36,
        "startLineNumber" : 88,
        "startColumnNumber" : 16,
        "endLineNumber" : 88,
        "endColumnNumber" : 52
      },
      "nodeContext" : "setTransitions.getIntervals().size()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 88,
        "startColumnNumber" : 16,
        "endLineNumber" : 88,
        "endColumnNumber" : 56
      },
      "nodeContext" : "setTransitions.getIntervals().size() - 1",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationExpression,fragments]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 88,
        "startColumnNumber" : 12,
        "endLineNumber" : 88,
        "endColumnNumber" : 56
      },
      "nodeContext" : "i=setTransitions.getIntervals().size() - 1",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 88,
        "startColumnNumber" : 8,
        "endLineNumber" : 88,
        "endColumnNumber" : 56
      },
      "nodeContext" : "int i=setTransitions.getIntervals().size() - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 11,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2191,
        "startLineNumber" : 88,
        "startColumnNumber" : 3,
        "endLineNumber" : 144,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n  Interval interval=setTransitions.getIntervals().get(i);\n  if (interval.length() <= 1) {\n    continue;\n  }\n  ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n  IntervalSet matchSet=new IntervalSet();\n  for (int j=interval.a; j <= interval.b; j++) {\n    Transition matchTransition=decision.transition(j).target.transition(0);\n    if (matchTransition instanceof NotSetTransition) {\n      throw new UnsupportedOperationException(\"Not yet implemented.\");\n    }\n    IntervalSet set=matchTransition.label();\n    List<Interval> intervals=set.getIntervals();\n    int n=intervals.size();\n    for (int k=0; k < n; k++) {\n      Interval setInterval=intervals.get(k);\n      int a=setInterval.a;\n      int b=setInterval.b;\n      if (a != -1 && b != -1) {\n        for (int v=a; v <= b; v++) {\n          if (matchSet.contains(v)) {\n            g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n            break;\n          }\n        }\n      }\n    }\n    matchSet.addAll(set);\n  }\n  Transition newTransition;\n  if (matchSet.getIntervals().size() == 1) {\n    if (matchSet.size() == 1) {\n      newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n    }\n else {\n      Interval matchInterval=matchSet.getIntervals().get(0);\n      newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n    }\n  }\n else {\n    newTransition=new SetTransition(blockEndState,matchSet);\n  }\n  decision.transition(interval.a).target.setTransition(0,newTransition);\n  for (int j=interval.a + 1; j <= interval.b; j++) {\n    Transition removed=decision.removeTransition(interval.a + 1);\n    atn.removeState(removed.target);\n    removedStates++;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 342,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 3306,
        "startLineNumber" : 49,
        "startColumnNumber" : 43,
        "endLineNumber" : 145,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (decision.ruleIndex >= 0) {\n    Rule rule=g.getRule(decision.ruleIndex);\n    if (Character.isLowerCase(rule.name.charAt(0))) {\n      continue;\n    }\n  }\n  IntervalSet setTransitions=new IntervalSet();\n  for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n    Transition epsTransition=decision.transition(i);\n    if (!(epsTransition instanceof EpsilonTransition)) {\n      continue;\n    }\n    if (epsTransition.target.getNumberOfTransitions() != 1) {\n      continue;\n    }\n    Transition transition=epsTransition.target.transition(0);\n    if (!(transition.target instanceof BlockEndState)) {\n      continue;\n    }\n    if (transition instanceof NotSetTransition) {\n      continue;\n    }\n    if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n      setTransitions.add(i);\n    }\n  }\n  for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n    Interval interval=setTransitions.getIntervals().get(i);\n    if (interval.length() <= 1) {\n      continue;\n    }\n    ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n    IntervalSet matchSet=new IntervalSet();\n    for (int j=interval.a; j <= interval.b; j++) {\n      Transition matchTransition=decision.transition(j).target.transition(0);\n      if (matchTransition instanceof NotSetTransition) {\n        throw new UnsupportedOperationException(\"Not yet implemented.\");\n      }\n      IntervalSet set=matchTransition.label();\n      List<Interval> intervals=set.getIntervals();\n      int n=intervals.size();\n      for (int k=0; k < n; k++) {\n        Interval setInterval=intervals.get(k);\n        int a=setInterval.a;\n        int b=setInterval.b;\n        if (a != -1 && b != -1) {\n          for (int v=a; v <= b; v++) {\n            if (matchSet.contains(v)) {\n              g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n              break;\n            }\n          }\n        }\n      }\n      matchSet.addAll(set);\n    }\n    Transition newTransition;\n    if (matchSet.getIntervals().size() == 1) {\n      if (matchSet.size() == 1) {\n        newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n      }\n else {\n        Interval matchInterval=matchSet.getIntervals().get(0);\n        newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n      }\n    }\n else {\n      newTransition=new SetTransition(blockEndState,matchSet);\n    }\n    decision.transition(interval.a).target.setTransition(0,newTransition);\n    for (int j=interval.a + 1; j <= interval.b; j++) {\n      Transition removed=decision.removeTransition(interval.a + 1);\n      atn.removeState(removed.target);\n      removedStates++;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 472,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3347,
        "startLineNumber" : 49,
        "startColumnNumber" : 2,
        "endLineNumber" : 145,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (DecisionState decision : decisions) {\n  if (decision.ruleIndex >= 0) {\n    Rule rule=g.getRule(decision.ruleIndex);\n    if (Character.isLowerCase(rule.name.charAt(0))) {\n      continue;\n    }\n  }\n  IntervalSet setTransitions=new IntervalSet();\n  for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n    Transition epsTransition=decision.transition(i);\n    if (!(epsTransition instanceof EpsilonTransition)) {\n      continue;\n    }\n    if (epsTransition.target.getNumberOfTransitions() != 1) {\n      continue;\n    }\n    Transition transition=epsTransition.target.transition(0);\n    if (!(transition.target instanceof BlockEndState)) {\n      continue;\n    }\n    if (transition instanceof NotSetTransition) {\n      continue;\n    }\n    if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n      setTransitions.add(i);\n    }\n  }\n  for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n    Interval interval=setTransitions.getIntervals().get(i);\n    if (interval.length() <= 1) {\n      continue;\n    }\n    ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n    IntervalSet matchSet=new IntervalSet();\n    for (int j=interval.a; j <= interval.b; j++) {\n      Transition matchTransition=decision.transition(j).target.transition(0);\n      if (matchTransition instanceof NotSetTransition) {\n        throw new UnsupportedOperationException(\"Not yet implemented.\");\n      }\n      IntervalSet set=matchTransition.label();\n      List<Interval> intervals=set.getIntervals();\n      int n=intervals.size();\n      for (int k=0; k < n; k++) {\n        Interval setInterval=intervals.get(k);\n        int a=setInterval.a;\n        int b=setInterval.b;\n        if (a != -1 && b != -1) {\n          for (int v=a; v <= b; v++) {\n            if (matchSet.contains(v)) {\n              g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n              break;\n            }\n          }\n        }\n      }\n      matchSet.addAll(set);\n    }\n    Transition newTransition;\n    if (matchSet.getIntervals().size() == 1) {\n      if (matchSet.size() == 1) {\n        newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n      }\n else {\n        Interval matchInterval=matchSet.getIntervals().get(0);\n        newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n      }\n    }\n else {\n      newTransition=new SetTransition(blockEndState,matchSet);\n    }\n    decision.transition(interval.a).target.setTransition(0,newTransition);\n    for (int j=interval.a + 1; j <= interval.b; j++) {\n      Transition removed=decision.removeTransition(interval.a + 1);\n      atn.removeState(removed.target);\n      removedStates++;\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 478,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3643,
        "startLineNumber" : 41,
        "startColumnNumber" : 54,
        "endLineNumber" : 148,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (g.isParser()) {\n    return;\n  }\n  int removedStates=0;\n  List<DecisionState> decisions=atn.decisionToState;\n  for (  DecisionState decision : decisions) {\n    if (decision.ruleIndex >= 0) {\n      Rule rule=g.getRule(decision.ruleIndex);\n      if (Character.isLowerCase(rule.name.charAt(0))) {\n        continue;\n      }\n    }\n    IntervalSet setTransitions=new IntervalSet();\n    for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n      Transition epsTransition=decision.transition(i);\n      if (!(epsTransition instanceof EpsilonTransition)) {\n        continue;\n      }\n      if (epsTransition.target.getNumberOfTransitions() != 1) {\n        continue;\n      }\n      Transition transition=epsTransition.target.transition(0);\n      if (!(transition.target instanceof BlockEndState)) {\n        continue;\n      }\n      if (transition instanceof NotSetTransition) {\n        continue;\n      }\n      if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n        setTransitions.add(i);\n      }\n    }\n    for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n      Interval interval=setTransitions.getIntervals().get(i);\n      if (interval.length() <= 1) {\n        continue;\n      }\n      ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n      IntervalSet matchSet=new IntervalSet();\n      for (int j=interval.a; j <= interval.b; j++) {\n        Transition matchTransition=decision.transition(j).target.transition(0);\n        if (matchTransition instanceof NotSetTransition) {\n          throw new UnsupportedOperationException(\"Not yet implemented.\");\n        }\n        IntervalSet set=matchTransition.label();\n        List<Interval> intervals=set.getIntervals();\n        int n=intervals.size();\n        for (int k=0; k < n; k++) {\n          Interval setInterval=intervals.get(k);\n          int a=setInterval.a;\n          int b=setInterval.b;\n          if (a != -1 && b != -1) {\n            for (int v=a; v <= b; v++) {\n              if (matchSet.contains(v)) {\n                g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n                break;\n              }\n            }\n          }\n        }\n        matchSet.addAll(set);\n      }\n      Transition newTransition;\n      if (matchSet.getIntervals().size() == 1) {\n        if (matchSet.size() == 1) {\n          newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n        }\n else {\n          Interval matchInterval=matchSet.getIntervals().get(0);\n          newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n        }\n      }\n else {\n        newTransition=new SetTransition(blockEndState,matchSet);\n      }\n      decision.transition(interval.a).target.setTransition(0,newTransition);\n      for (int j=interval.a + 1; j <= interval.b; j++) {\n        Transition removed=decision.removeTransition(interval.a + 1);\n        atn.removeState(removed.target);\n        removedStates++;\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 501,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3696,
        "startLineNumber" : 41,
        "startColumnNumber" : 1,
        "endLineNumber" : 148,
        "endColumnNumber" : 2
      },
      "nodeContext" : "private static void optimizeSets(Grammar g,ATN atn){\n  if (g.isParser()) {\n    return;\n  }\n  int removedStates=0;\n  List<DecisionState> decisions=atn.decisionToState;\n  for (  DecisionState decision : decisions) {\n    if (decision.ruleIndex >= 0) {\n      Rule rule=g.getRule(decision.ruleIndex);\n      if (Character.isLowerCase(rule.name.charAt(0))) {\n        continue;\n      }\n    }\n    IntervalSet setTransitions=new IntervalSet();\n    for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n      Transition epsTransition=decision.transition(i);\n      if (!(epsTransition instanceof EpsilonTransition)) {\n        continue;\n      }\n      if (epsTransition.target.getNumberOfTransitions() != 1) {\n        continue;\n      }\n      Transition transition=epsTransition.target.transition(0);\n      if (!(transition.target instanceof BlockEndState)) {\n        continue;\n      }\n      if (transition instanceof NotSetTransition) {\n        continue;\n      }\n      if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n        setTransitions.add(i);\n      }\n    }\n    for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n      Interval interval=setTransitions.getIntervals().get(i);\n      if (interval.length() <= 1) {\n        continue;\n      }\n      ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n      IntervalSet matchSet=new IntervalSet();\n      for (int j=interval.a; j <= interval.b; j++) {\n        Transition matchTransition=decision.transition(j).target.transition(0);\n        if (matchTransition instanceof NotSetTransition) {\n          throw new UnsupportedOperationException(\"Not yet implemented.\");\n        }\n        IntervalSet set=matchTransition.label();\n        List<Interval> intervals=set.getIntervals();\n        int n=intervals.size();\n        for (int k=0; k < n; k++) {\n          Interval setInterval=intervals.get(k);\n          int a=setInterval.a;\n          int b=setInterval.b;\n          if (a != -1 && b != -1) {\n            for (int v=a; v <= b; v++) {\n              if (matchSet.contains(v)) {\n                g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n                break;\n              }\n            }\n          }\n        }\n        matchSet.addAll(set);\n      }\n      Transition newTransition;\n      if (matchSet.getIntervals().size() == 1) {\n        if (matchSet.size() == 1) {\n          newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n        }\n else {\n          Interval matchInterval=matchSet.getIntervals().get(0);\n          newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n        }\n      }\n else {\n        newTransition=new SetTransition(blockEndState,matchSet);\n      }\n      decision.transition(interval.a).target.setTransition(0,newTransition);\n      for (int j=interval.a + 1; j <= interval.b; j++) {\n        Transition removed=decision.removeTransition(interval.a + 1);\n        atn.removeState(removed.target);\n        removedStates++;\n      }\n    }\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 514,
      "astHeight" : 21
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 88,
        "startColumnNumber" : 8,
        "endLineNumber" : 88,
        "endColumnNumber" : 56
      },
      "nodeContext" : "int i=setTransitions.getIntervals().size() - 1",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 11,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "org.antlr.v4.runtime.misc.IntervalSet"
  }, {
    "nodeContext" : "setTransitions",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 14,
      "startLineNumber" : 89,
      "startColumnNumber" : 24,
      "endLineNumber" : 89,
      "endColumnNumber" : 38
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 29,
        "startLineNumber" : 89,
        "startColumnNumber" : 24,
        "endLineNumber" : 89,
        "endColumnNumber" : 53
      },
      "nodeContext" : "setTransitions.getIntervals()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 36,
        "startLineNumber" : 89,
        "startColumnNumber" : 24,
        "endLineNumber" : 89,
        "endColumnNumber" : 60
      },
      "nodeContext" : "setTransitions.getIntervals().get(i)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 89,
        "startColumnNumber" : 13,
        "endLineNumber" : 89,
        "endColumnNumber" : 60
      },
      "nodeContext" : "interval=setTransitions.getIntervals().get(i)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 89,
        "startColumnNumber" : 4,
        "endLineNumber" : 89,
        "endColumnNumber" : 61
      },
      "nodeContext" : "Interval interval=setTransitions.getIntervals().get(i);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2123,
        "startLineNumber" : 88,
        "startColumnNumber" : 71,
        "endLineNumber" : 144,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  Interval interval=setTransitions.getIntervals().get(i);\n  if (interval.length() <= 1) {\n    continue;\n  }\n  ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n  IntervalSet matchSet=new IntervalSet();\n  for (int j=interval.a; j <= interval.b; j++) {\n    Transition matchTransition=decision.transition(j).target.transition(0);\n    if (matchTransition instanceof NotSetTransition) {\n      throw new UnsupportedOperationException(\"Not yet implemented.\");\n    }\n    IntervalSet set=matchTransition.label();\n    List<Interval> intervals=set.getIntervals();\n    int n=intervals.size();\n    for (int k=0; k < n; k++) {\n      Interval setInterval=intervals.get(k);\n      int a=setInterval.a;\n      int b=setInterval.b;\n      if (a != -1 && b != -1) {\n        for (int v=a; v <= b; v++) {\n          if (matchSet.contains(v)) {\n            g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n            break;\n          }\n        }\n      }\n    }\n    matchSet.addAll(set);\n  }\n  Transition newTransition;\n  if (matchSet.getIntervals().size() == 1) {\n    if (matchSet.size() == 1) {\n      newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n    }\n else {\n      Interval matchInterval=matchSet.getIntervals().get(0);\n      newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n    }\n  }\n else {\n    newTransition=new SetTransition(blockEndState,matchSet);\n  }\n  decision.transition(interval.a).target.setTransition(0,newTransition);\n  for (int j=interval.a + 1; j <= interval.b; j++) {\n    Transition removed=decision.removeTransition(interval.a + 1);\n    atn.removeState(removed.target);\n    removedStates++;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 325,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2191,
        "startLineNumber" : 88,
        "startColumnNumber" : 3,
        "endLineNumber" : 144,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n  Interval interval=setTransitions.getIntervals().get(i);\n  if (interval.length() <= 1) {\n    continue;\n  }\n  ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n  IntervalSet matchSet=new IntervalSet();\n  for (int j=interval.a; j <= interval.b; j++) {\n    Transition matchTransition=decision.transition(j).target.transition(0);\n    if (matchTransition instanceof NotSetTransition) {\n      throw new UnsupportedOperationException(\"Not yet implemented.\");\n    }\n    IntervalSet set=matchTransition.label();\n    List<Interval> intervals=set.getIntervals();\n    int n=intervals.size();\n    for (int k=0; k < n; k++) {\n      Interval setInterval=intervals.get(k);\n      int a=setInterval.a;\n      int b=setInterval.b;\n      if (a != -1 && b != -1) {\n        for (int v=a; v <= b; v++) {\n          if (matchSet.contains(v)) {\n            g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n            break;\n          }\n        }\n      }\n    }\n    matchSet.addAll(set);\n  }\n  Transition newTransition;\n  if (matchSet.getIntervals().size() == 1) {\n    if (matchSet.size() == 1) {\n      newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n    }\n else {\n      Interval matchInterval=matchSet.getIntervals().get(0);\n      newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n    }\n  }\n else {\n    newTransition=new SetTransition(blockEndState,matchSet);\n  }\n  decision.transition(interval.a).target.setTransition(0,newTransition);\n  for (int j=interval.a + 1; j <= interval.b; j++) {\n    Transition removed=decision.removeTransition(interval.a + 1);\n    atn.removeState(removed.target);\n    removedStates++;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 342,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 3306,
        "startLineNumber" : 49,
        "startColumnNumber" : 43,
        "endLineNumber" : 145,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (decision.ruleIndex >= 0) {\n    Rule rule=g.getRule(decision.ruleIndex);\n    if (Character.isLowerCase(rule.name.charAt(0))) {\n      continue;\n    }\n  }\n  IntervalSet setTransitions=new IntervalSet();\n  for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n    Transition epsTransition=decision.transition(i);\n    if (!(epsTransition instanceof EpsilonTransition)) {\n      continue;\n    }\n    if (epsTransition.target.getNumberOfTransitions() != 1) {\n      continue;\n    }\n    Transition transition=epsTransition.target.transition(0);\n    if (!(transition.target instanceof BlockEndState)) {\n      continue;\n    }\n    if (transition instanceof NotSetTransition) {\n      continue;\n    }\n    if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n      setTransitions.add(i);\n    }\n  }\n  for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n    Interval interval=setTransitions.getIntervals().get(i);\n    if (interval.length() <= 1) {\n      continue;\n    }\n    ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n    IntervalSet matchSet=new IntervalSet();\n    for (int j=interval.a; j <= interval.b; j++) {\n      Transition matchTransition=decision.transition(j).target.transition(0);\n      if (matchTransition instanceof NotSetTransition) {\n        throw new UnsupportedOperationException(\"Not yet implemented.\");\n      }\n      IntervalSet set=matchTransition.label();\n      List<Interval> intervals=set.getIntervals();\n      int n=intervals.size();\n      for (int k=0; k < n; k++) {\n        Interval setInterval=intervals.get(k);\n        int a=setInterval.a;\n        int b=setInterval.b;\n        if (a != -1 && b != -1) {\n          for (int v=a; v <= b; v++) {\n            if (matchSet.contains(v)) {\n              g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n              break;\n            }\n          }\n        }\n      }\n      matchSet.addAll(set);\n    }\n    Transition newTransition;\n    if (matchSet.getIntervals().size() == 1) {\n      if (matchSet.size() == 1) {\n        newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n      }\n else {\n        Interval matchInterval=matchSet.getIntervals().get(0);\n        newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n      }\n    }\n else {\n      newTransition=new SetTransition(blockEndState,matchSet);\n    }\n    decision.transition(interval.a).target.setTransition(0,newTransition);\n    for (int j=interval.a + 1; j <= interval.b; j++) {\n      Transition removed=decision.removeTransition(interval.a + 1);\n      atn.removeState(removed.target);\n      removedStates++;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 472,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3347,
        "startLineNumber" : 49,
        "startColumnNumber" : 2,
        "endLineNumber" : 145,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (DecisionState decision : decisions) {\n  if (decision.ruleIndex >= 0) {\n    Rule rule=g.getRule(decision.ruleIndex);\n    if (Character.isLowerCase(rule.name.charAt(0))) {\n      continue;\n    }\n  }\n  IntervalSet setTransitions=new IntervalSet();\n  for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n    Transition epsTransition=decision.transition(i);\n    if (!(epsTransition instanceof EpsilonTransition)) {\n      continue;\n    }\n    if (epsTransition.target.getNumberOfTransitions() != 1) {\n      continue;\n    }\n    Transition transition=epsTransition.target.transition(0);\n    if (!(transition.target instanceof BlockEndState)) {\n      continue;\n    }\n    if (transition instanceof NotSetTransition) {\n      continue;\n    }\n    if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n      setTransitions.add(i);\n    }\n  }\n  for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n    Interval interval=setTransitions.getIntervals().get(i);\n    if (interval.length() <= 1) {\n      continue;\n    }\n    ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n    IntervalSet matchSet=new IntervalSet();\n    for (int j=interval.a; j <= interval.b; j++) {\n      Transition matchTransition=decision.transition(j).target.transition(0);\n      if (matchTransition instanceof NotSetTransition) {\n        throw new UnsupportedOperationException(\"Not yet implemented.\");\n      }\n      IntervalSet set=matchTransition.label();\n      List<Interval> intervals=set.getIntervals();\n      int n=intervals.size();\n      for (int k=0; k < n; k++) {\n        Interval setInterval=intervals.get(k);\n        int a=setInterval.a;\n        int b=setInterval.b;\n        if (a != -1 && b != -1) {\n          for (int v=a; v <= b; v++) {\n            if (matchSet.contains(v)) {\n              g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n              break;\n            }\n          }\n        }\n      }\n      matchSet.addAll(set);\n    }\n    Transition newTransition;\n    if (matchSet.getIntervals().size() == 1) {\n      if (matchSet.size() == 1) {\n        newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n      }\n else {\n        Interval matchInterval=matchSet.getIntervals().get(0);\n        newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n      }\n    }\n else {\n      newTransition=new SetTransition(blockEndState,matchSet);\n    }\n    decision.transition(interval.a).target.setTransition(0,newTransition);\n    for (int j=interval.a + 1; j <= interval.b; j++) {\n      Transition removed=decision.removeTransition(interval.a + 1);\n      atn.removeState(removed.target);\n      removedStates++;\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 478,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3643,
        "startLineNumber" : 41,
        "startColumnNumber" : 54,
        "endLineNumber" : 148,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  if (g.isParser()) {\n    return;\n  }\n  int removedStates=0;\n  List<DecisionState> decisions=atn.decisionToState;\n  for (  DecisionState decision : decisions) {\n    if (decision.ruleIndex >= 0) {\n      Rule rule=g.getRule(decision.ruleIndex);\n      if (Character.isLowerCase(rule.name.charAt(0))) {\n        continue;\n      }\n    }\n    IntervalSet setTransitions=new IntervalSet();\n    for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n      Transition epsTransition=decision.transition(i);\n      if (!(epsTransition instanceof EpsilonTransition)) {\n        continue;\n      }\n      if (epsTransition.target.getNumberOfTransitions() != 1) {\n        continue;\n      }\n      Transition transition=epsTransition.target.transition(0);\n      if (!(transition.target instanceof BlockEndState)) {\n        continue;\n      }\n      if (transition instanceof NotSetTransition) {\n        continue;\n      }\n      if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n        setTransitions.add(i);\n      }\n    }\n    for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n      Interval interval=setTransitions.getIntervals().get(i);\n      if (interval.length() <= 1) {\n        continue;\n      }\n      ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n      IntervalSet matchSet=new IntervalSet();\n      for (int j=interval.a; j <= interval.b; j++) {\n        Transition matchTransition=decision.transition(j).target.transition(0);\n        if (matchTransition instanceof NotSetTransition) {\n          throw new UnsupportedOperationException(\"Not yet implemented.\");\n        }\n        IntervalSet set=matchTransition.label();\n        List<Interval> intervals=set.getIntervals();\n        int n=intervals.size();\n        for (int k=0; k < n; k++) {\n          Interval setInterval=intervals.get(k);\n          int a=setInterval.a;\n          int b=setInterval.b;\n          if (a != -1 && b != -1) {\n            for (int v=a; v <= b; v++) {\n              if (matchSet.contains(v)) {\n                g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n                break;\n              }\n            }\n          }\n        }\n        matchSet.addAll(set);\n      }\n      Transition newTransition;\n      if (matchSet.getIntervals().size() == 1) {\n        if (matchSet.size() == 1) {\n          newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n        }\n else {\n          Interval matchInterval=matchSet.getIntervals().get(0);\n          newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n        }\n      }\n else {\n        newTransition=new SetTransition(blockEndState,matchSet);\n      }\n      decision.transition(interval.a).target.setTransition(0,newTransition);\n      for (int j=interval.a + 1; j <= interval.b; j++) {\n        Transition removed=decision.removeTransition(interval.a + 1);\n        atn.removeState(removed.target);\n        removedStates++;\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 501,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3696,
        "startLineNumber" : 41,
        "startColumnNumber" : 1,
        "endLineNumber" : 148,
        "endColumnNumber" : 2
      },
      "nodeContext" : "private static void optimizeSets(Grammar g,ATN atn){\n  if (g.isParser()) {\n    return;\n  }\n  int removedStates=0;\n  List<DecisionState> decisions=atn.decisionToState;\n  for (  DecisionState decision : decisions) {\n    if (decision.ruleIndex >= 0) {\n      Rule rule=g.getRule(decision.ruleIndex);\n      if (Character.isLowerCase(rule.name.charAt(0))) {\n        continue;\n      }\n    }\n    IntervalSet setTransitions=new IntervalSet();\n    for (int i=0; i < decision.getNumberOfTransitions(); i++) {\n      Transition epsTransition=decision.transition(i);\n      if (!(epsTransition instanceof EpsilonTransition)) {\n        continue;\n      }\n      if (epsTransition.target.getNumberOfTransitions() != 1) {\n        continue;\n      }\n      Transition transition=epsTransition.target.transition(0);\n      if (!(transition.target instanceof BlockEndState)) {\n        continue;\n      }\n      if (transition instanceof NotSetTransition) {\n        continue;\n      }\n      if (transition instanceof AtomTransition || transition instanceof RangeTransition || transition instanceof SetTransition) {\n        setTransitions.add(i);\n      }\n    }\n    for (int i=setTransitions.getIntervals().size() - 1; i >= 0; i--) {\n      Interval interval=setTransitions.getIntervals().get(i);\n      if (interval.length() <= 1) {\n        continue;\n      }\n      ATNState blockEndState=decision.transition(interval.a).target.transition(0).target;\n      IntervalSet matchSet=new IntervalSet();\n      for (int j=interval.a; j <= interval.b; j++) {\n        Transition matchTransition=decision.transition(j).target.transition(0);\n        if (matchTransition instanceof NotSetTransition) {\n          throw new UnsupportedOperationException(\"Not yet implemented.\");\n        }\n        IntervalSet set=matchTransition.label();\n        List<Interval> intervals=set.getIntervals();\n        int n=intervals.size();\n        for (int k=0; k < n; k++) {\n          Interval setInterval=intervals.get(k);\n          int a=setInterval.a;\n          int b=setInterval.b;\n          if (a != -1 && b != -1) {\n            for (int v=a; v <= b; v++) {\n              if (matchSet.contains(v)) {\n                g.tool.errMgr.grammarError(ErrorType.CHARACTERS_COLLISION_IN_SET,g.fileName,null,CharSupport.getANTLRCharLiteralForChar(v),CharSupport.getIntervalSetEscapedString(matchSet));\n                break;\n              }\n            }\n          }\n        }\n        matchSet.addAll(set);\n      }\n      Transition newTransition;\n      if (matchSet.getIntervals().size() == 1) {\n        if (matchSet.size() == 1) {\n          newTransition=CodePointTransitions.createWithCodePoint(blockEndState,matchSet.getMinElement());\n        }\n else {\n          Interval matchInterval=matchSet.getIntervals().get(0);\n          newTransition=CodePointTransitions.createWithCodePointRange(blockEndState,matchInterval.a,matchInterval.b);\n        }\n      }\n else {\n        newTransition=new SetTransition(blockEndState,matchSet);\n      }\n      decision.transition(interval.a).target.setTransition(0,newTransition);\n      for (int j=interval.a + 1; j <= interval.b; j++) {\n        Transition removed=decision.removeTransition(interval.a + 1);\n        atn.removeState(removed.target);\n        removedStates++;\n      }\n    }\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 514,
      "astHeight" : 21
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 89,
        "startColumnNumber" : 4,
        "endLineNumber" : 89,
        "endColumnNumber" : 61
      },
      "nodeContext" : "Interval interval=setTransitions.getIntervals().get(i);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "org.antlr.v4.runtime.misc.IntervalSet"
  } ],
  "positionList" : [ {
    "charLength" : 14,
    "startLineNumber" : 83,
    "startColumnNumber" : 5,
    "endLineNumber" : 83,
    "endColumnNumber" : 19
  }, {
    "charLength" : 14,
    "startLineNumber" : 88,
    "startColumnNumber" : 16,
    "endLineNumber" : 88,
    "endColumnNumber" : 30
  }, {
    "charLength" : 14,
    "startLineNumber" : 89,
    "startColumnNumber" : 24,
    "endLineNumber" : 89,
    "endColumnNumber" : 38
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 6
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 6
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 5
  } ]
}