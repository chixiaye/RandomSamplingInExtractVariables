{
  "id" : 57,
  "expression" : "toExplicitlyRevoke",
  "projectName" : "apache@kafka",
  "commitID" : "539f006e65d9060cd46a4052d1b70f2312d8ca34",
  "filePath" : "/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/IncrementalCooperativeAssignor.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "toExplicitlyRevoke",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 18,
      "startLineNumber" : 273,
      "startColumnNumber" : 12,
      "endLineNumber" : 273,
      "endColumnNumber" : 30
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 421,
        "startLineNumber" : 273,
        "startColumnNumber" : 12,
        "endLineNumber" : 281,
        "endColumnNumber" : 13
      },
      "nodeContext" : "toExplicitlyRevoke.forEach((worker,assignment) -> {\n  ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n  existing.connectors().addAll(assignment.connectors());\n  existing.tasks().addAll(assignment.tasks());\n}\n)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 46,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 422,
        "startLineNumber" : 273,
        "startColumnNumber" : 12,
        "endLineNumber" : 281,
        "endColumnNumber" : 14
      },
      "nodeContext" : "toExplicitlyRevoke.forEach((worker,assignment) -> {\n  ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n  existing.connectors().addAll(assignment.connectors());\n  existing.tasks().addAll(assignment.tasks());\n}\n);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 47,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 737,
        "startLineNumber" : 267,
        "startColumnNumber" : 23,
        "endLineNumber" : 283,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Map<String,ConnectorsAndTasks> toExplicitlyRevoke=performTaskRevocation(activeAssignments,currentWorkerAssignment);\n  log.debug(\"Connector and task to revoke assignments: {}\",toRevoke);\n  toExplicitlyRevoke.forEach((worker,assignment) -> {\n    ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n    existing.connectors().addAll(assignment.connectors());\n    existing.tasks().addAll(assignment.tasks());\n  }\n);\n  canRevoke=toExplicitlyRevoke.size() == 0;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 76,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 805,
        "startLineNumber" : 267,
        "startColumnNumber" : 8,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (canRevoke) {\n  Map<String,ConnectorsAndTasks> toExplicitlyRevoke=performTaskRevocation(activeAssignments,currentWorkerAssignment);\n  log.debug(\"Connector and task to revoke assignments: {}\",toRevoke);\n  toExplicitlyRevoke.forEach((worker,assignment) -> {\n    ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n    existing.connectors().addAll(assignment.connectors());\n    existing.tasks().addAll(assignment.tasks());\n  }\n);\n  canRevoke=toExplicitlyRevoke.size() == 0;\n}\n else {\n  canRevoke=delay == 0;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 85,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 9533,
        "startLineNumber" : 159,
        "startColumnNumber" : 114,
        "endLineNumber" : 315,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  log.debug(\"Performing task assignment during generation: {} with memberId: {}\",coordinator.generationId(),coordinator.memberId());\n  log.debug(\"Previous assignments: {}\",previousAssignment);\n  int lastCompletedGenerationId=coordinator.lastCompletedGenerationId();\n  if (previousGenerationId != lastCompletedGenerationId) {\n    log.debug(\"Clearing the view of previous assignments due to generation mismatch between \" + \"previous generation ID {} and last completed generation ID {}. This can \" + \"happen if the leader fails to sync the assignment within a rebalancing round. \"+ \"The following view of previous assignments might be outdated and will be \"+ \"ignored by the leader in the current computation of new assignments. \"+ \"Possibly outdated previous assignments: {}\",previousGenerationId,lastCompletedGenerationId,previousAssignment);\n    this.previousAssignment=ConnectorsAndTasks.EMPTY;\n  }\n  ClusterConfigState snapshot=coordinator.configSnapshot();\n  Set<String> configuredConnectors=new TreeSet<>(snapshot.connectors());\n  Set<ConnectorTaskId> configuredTasks=configuredConnectors.stream().flatMap(c -> snapshot.tasks(c).stream()).collect(Collectors.toSet());\n  ConnectorsAndTasks configured=new ConnectorsAndTasks.Builder().with(configuredConnectors,configuredTasks).build();\n  log.debug(\"Configured assignments: {}\",configured);\n  ConnectorsAndTasks activeAssignments=assignment(memberConfigs);\n  log.debug(\"Active assignments: {}\",activeAssignments);\n  if (!previousRevocation.isEmpty()) {\n    if (previousRevocation.connectors().stream().anyMatch(c -> activeAssignments.connectors().contains(c)) || previousRevocation.tasks().stream().anyMatch(t -> activeAssignments.tasks().contains(t))) {\n      previousAssignment=activeAssignments;\n      canRevoke=true;\n    }\n    previousRevocation.connectors().clear();\n    previousRevocation.tasks().clear();\n  }\n  ConnectorsAndTasks deleted=diff(previousAssignment,configured);\n  log.debug(\"Deleted assignments: {}\",deleted);\n  ConnectorsAndTasks remainingActive=diff(activeAssignments,deleted);\n  log.debug(\"Remaining (excluding deleted) active assignments: {}\",remainingActive);\n  ConnectorsAndTasks lostAssignments=diff(previousAssignment,activeAssignments,deleted);\n  log.debug(\"Lost assignments: {}\",lostAssignments);\n  ConnectorsAndTasks newSubmissions=diff(configured,previousAssignment,activeAssignments);\n  log.debug(\"New assignments: {}\",newSubmissions);\n  List<WorkerLoad> completeWorkerAssignment=workerAssignment(memberConfigs,ConnectorsAndTasks.EMPTY);\n  log.debug(\"Complete (ignoring deletions) worker assignments: {}\",completeWorkerAssignment);\n  Map<String,Collection<String>> connectorAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  log.debug(\"Complete (ignoring deletions) connector assignments: {}\",connectorAssignments);\n  Map<String,Collection<ConnectorTaskId>> taskAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  log.debug(\"Complete (ignoring deletions) task assignments: {}\",taskAssignments);\n  List<WorkerLoad> currentWorkerAssignment=workerAssignment(memberConfigs,deleted);\n  Map<String,ConnectorsAndTasks> toRevoke=computeDeleted(deleted,connectorAssignments,taskAssignments);\n  log.debug(\"Connector and task to delete assignments: {}\",toRevoke);\n  toRevoke.putAll(computeDuplicatedAssignments(memberConfigs,connectorAssignments,taskAssignments));\n  log.debug(\"Connector and task to revoke assignments (include duplicated assignments): {}\",toRevoke);\n  completeWorkerAssignment=workerAssignment(memberConfigs,deleted);\n  connectorAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  taskAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  handleLostAssignments(lostAssignments,newSubmissions,completeWorkerAssignment,memberConfigs);\n  canRevoke=delay == 0 && canRevoke;\n  log.debug(\"Can leader revoke tasks in this assignment? {} (delay: {})\",canRevoke,delay);\n  if (canRevoke) {\n    Map<String,ConnectorsAndTasks> toExplicitlyRevoke=performTaskRevocation(activeAssignments,currentWorkerAssignment);\n    log.debug(\"Connector and task to revoke assignments: {}\",toRevoke);\n    toExplicitlyRevoke.forEach((worker,assignment) -> {\n      ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n      existing.connectors().addAll(assignment.connectors());\n      existing.tasks().addAll(assignment.tasks());\n    }\n);\n    canRevoke=toExplicitlyRevoke.size() == 0;\n  }\n else {\n    canRevoke=delay == 0;\n  }\n  assignConnectors(completeWorkerAssignment,newSubmissions.connectors());\n  assignTasks(completeWorkerAssignment,newSubmissions.tasks());\n  log.debug(\"Current complete assignments: {}\",currentWorkerAssignment);\n  log.debug(\"New complete assignments: {}\",completeWorkerAssignment);\n  Map<String,Collection<String>> currentConnectorAssignments=currentWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  Map<String,Collection<ConnectorTaskId>> currentTaskAssignments=currentWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  Map<String,Collection<String>> incrementalConnectorAssignments=diff(connectorAssignments,currentConnectorAssignments);\n  Map<String,Collection<ConnectorTaskId>> incrementalTaskAssignments=diff(taskAssignments,currentTaskAssignments);\n  log.debug(\"Incremental connector assignments: {}\",incrementalConnectorAssignments);\n  log.debug(\"Incremental task assignments: {}\",incrementalTaskAssignments);\n  coordinator.leaderState(new LeaderState(memberConfigs,connectorAssignments,taskAssignments));\n  Map<String,ExtendedAssignment> assignments=fillAssignments(memberConfigs.keySet(),Assignment.NO_ERROR,leaderId,memberConfigs.get(leaderId).url(),maxOffset,incrementalConnectorAssignments,incrementalTaskAssignments,toRevoke,delay,protocolVersion);\n  previousAssignment=computePreviousAssignment(toRevoke,connectorAssignments,taskAssignments,lostAssignments);\n  previousGenerationId=coordinator.generationId();\n  previousMembers=memberConfigs.keySet();\n  log.debug(\"Actual assignments: {}\",assignments);\n  return serializeAssignments(assignments);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 741,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 10724,
        "startLineNumber" : 142,
        "startColumnNumber" : 4,
        "endLineNumber" : 315,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Performs task assignment based on the incremental cooperative connect protocol. Read more on the design and implementation in: {@see https://cwiki.apache.org/confluence/display/KAFKA/KIP-415%3A+Incremental+Cooperative+Rebalancing+in+Kafka+Connect}\n * @param leaderId the ID of the group leader\n * @param maxOffset the latest known offset of the configuration topic\n * @param memberConfigs the metadata of all the members of the group as gather in the currentround of rebalancing\n * @param coordinator the worker coordinator instance that provide the configuration snapshotand get assigned the leader state during this assignment\n * @param protocolVersion the Connect subprotocol version\n * @return the serialized assignment of tasks to the whole group, including assigned orrevoked tasks\n */\nprotected Map<String,ByteBuffer> performTaskAssignment(String leaderId,long maxOffset,Map<String,ExtendedWorkerState> memberConfigs,WorkerCoordinator coordinator,short protocolVersion){\n  log.debug(\"Performing task assignment during generation: {} with memberId: {}\",coordinator.generationId(),coordinator.memberId());\n  log.debug(\"Previous assignments: {}\",previousAssignment);\n  int lastCompletedGenerationId=coordinator.lastCompletedGenerationId();\n  if (previousGenerationId != lastCompletedGenerationId) {\n    log.debug(\"Clearing the view of previous assignments due to generation mismatch between \" + \"previous generation ID {} and last completed generation ID {}. This can \" + \"happen if the leader fails to sync the assignment within a rebalancing round. \"+ \"The following view of previous assignments might be outdated and will be \"+ \"ignored by the leader in the current computation of new assignments. \"+ \"Possibly outdated previous assignments: {}\",previousGenerationId,lastCompletedGenerationId,previousAssignment);\n    this.previousAssignment=ConnectorsAndTasks.EMPTY;\n  }\n  ClusterConfigState snapshot=coordinator.configSnapshot();\n  Set<String> configuredConnectors=new TreeSet<>(snapshot.connectors());\n  Set<ConnectorTaskId> configuredTasks=configuredConnectors.stream().flatMap(c -> snapshot.tasks(c).stream()).collect(Collectors.toSet());\n  ConnectorsAndTasks configured=new ConnectorsAndTasks.Builder().with(configuredConnectors,configuredTasks).build();\n  log.debug(\"Configured assignments: {}\",configured);\n  ConnectorsAndTasks activeAssignments=assignment(memberConfigs);\n  log.debug(\"Active assignments: {}\",activeAssignments);\n  if (!previousRevocation.isEmpty()) {\n    if (previousRevocation.connectors().stream().anyMatch(c -> activeAssignments.connectors().contains(c)) || previousRevocation.tasks().stream().anyMatch(t -> activeAssignments.tasks().contains(t))) {\n      previousAssignment=activeAssignments;\n      canRevoke=true;\n    }\n    previousRevocation.connectors().clear();\n    previousRevocation.tasks().clear();\n  }\n  ConnectorsAndTasks deleted=diff(previousAssignment,configured);\n  log.debug(\"Deleted assignments: {}\",deleted);\n  ConnectorsAndTasks remainingActive=diff(activeAssignments,deleted);\n  log.debug(\"Remaining (excluding deleted) active assignments: {}\",remainingActive);\n  ConnectorsAndTasks lostAssignments=diff(previousAssignment,activeAssignments,deleted);\n  log.debug(\"Lost assignments: {}\",lostAssignments);\n  ConnectorsAndTasks newSubmissions=diff(configured,previousAssignment,activeAssignments);\n  log.debug(\"New assignments: {}\",newSubmissions);\n  List<WorkerLoad> completeWorkerAssignment=workerAssignment(memberConfigs,ConnectorsAndTasks.EMPTY);\n  log.debug(\"Complete (ignoring deletions) worker assignments: {}\",completeWorkerAssignment);\n  Map<String,Collection<String>> connectorAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  log.debug(\"Complete (ignoring deletions) connector assignments: {}\",connectorAssignments);\n  Map<String,Collection<ConnectorTaskId>> taskAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  log.debug(\"Complete (ignoring deletions) task assignments: {}\",taskAssignments);\n  List<WorkerLoad> currentWorkerAssignment=workerAssignment(memberConfigs,deleted);\n  Map<String,ConnectorsAndTasks> toRevoke=computeDeleted(deleted,connectorAssignments,taskAssignments);\n  log.debug(\"Connector and task to delete assignments: {}\",toRevoke);\n  toRevoke.putAll(computeDuplicatedAssignments(memberConfigs,connectorAssignments,taskAssignments));\n  log.debug(\"Connector and task to revoke assignments (include duplicated assignments): {}\",toRevoke);\n  completeWorkerAssignment=workerAssignment(memberConfigs,deleted);\n  connectorAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  taskAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  handleLostAssignments(lostAssignments,newSubmissions,completeWorkerAssignment,memberConfigs);\n  canRevoke=delay == 0 && canRevoke;\n  log.debug(\"Can leader revoke tasks in this assignment? {} (delay: {})\",canRevoke,delay);\n  if (canRevoke) {\n    Map<String,ConnectorsAndTasks> toExplicitlyRevoke=performTaskRevocation(activeAssignments,currentWorkerAssignment);\n    log.debug(\"Connector and task to revoke assignments: {}\",toRevoke);\n    toExplicitlyRevoke.forEach((worker,assignment) -> {\n      ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n      existing.connectors().addAll(assignment.connectors());\n      existing.tasks().addAll(assignment.tasks());\n    }\n);\n    canRevoke=toExplicitlyRevoke.size() == 0;\n  }\n else {\n    canRevoke=delay == 0;\n  }\n  assignConnectors(completeWorkerAssignment,newSubmissions.connectors());\n  assignTasks(completeWorkerAssignment,newSubmissions.tasks());\n  log.debug(\"Current complete assignments: {}\",currentWorkerAssignment);\n  log.debug(\"New complete assignments: {}\",completeWorkerAssignment);\n  Map<String,Collection<String>> currentConnectorAssignments=currentWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  Map<String,Collection<ConnectorTaskId>> currentTaskAssignments=currentWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  Map<String,Collection<String>> incrementalConnectorAssignments=diff(connectorAssignments,currentConnectorAssignments);\n  Map<String,Collection<ConnectorTaskId>> incrementalTaskAssignments=diff(taskAssignments,currentTaskAssignments);\n  log.debug(\"Incremental connector assignments: {}\",incrementalConnectorAssignments);\n  log.debug(\"Incremental task assignments: {}\",incrementalTaskAssignments);\n  coordinator.leaderState(new LeaderState(memberConfigs,connectorAssignments,taskAssignments));\n  Map<String,ExtendedAssignment> assignments=fillAssignments(memberConfigs.keySet(),Assignment.NO_ERROR,leaderId,memberConfigs.get(leaderId).url(),maxOffset,incrementalConnectorAssignments,incrementalTaskAssignments,toRevoke,delay,protocolVersion);\n  previousAssignment=computePreviousAssignment(toRevoke,connectorAssignments,taskAssignments,lostAssignments);\n  previousGenerationId=coordinator.generationId();\n  previousMembers=memberConfigs.keySet();\n  log.debug(\"Actual assignments: {}\",assignments);\n  return serializeAssignments(assignments);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 775,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 421,
        "startLineNumber" : 273,
        "startColumnNumber" : 12,
        "endLineNumber" : 281,
        "endColumnNumber" : 13
      },
      "nodeContext" : "toExplicitlyRevoke.forEach((worker,assignment) -> {\n  ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n  existing.connectors().addAll(assignment.connectors());\n  existing.tasks().addAll(assignment.tasks());\n}\n)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 46,
      "astHeight" : 12
    },
    "tokenLength" : 1,
    "type" : "java.util.Map<java.lang.String,org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks>"
  }, {
    "nodeContext" : "toExplicitlyRevoke",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 18,
      "startLineNumber" : 282,
      "startColumnNumber" : 24,
      "endLineNumber" : 282,
      "endColumnNumber" : 42
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 282,
        "startColumnNumber" : 24,
        "endLineNumber" : 282,
        "endColumnNumber" : 49
      },
      "nodeContext" : "toExplicitlyRevoke.size()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 30,
        "startLineNumber" : 282,
        "startColumnNumber" : 24,
        "endLineNumber" : 282,
        "endColumnNumber" : 54
      },
      "nodeContext" : "toExplicitlyRevoke.size() == 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 282,
        "startColumnNumber" : 12,
        "endLineNumber" : 282,
        "endColumnNumber" : 54
      },
      "nodeContext" : "canRevoke=toExplicitlyRevoke.size() == 0",
      "nodeType" : "Assignment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 282,
        "startColumnNumber" : 12,
        "endLineNumber" : 282,
        "endColumnNumber" : 55
      },
      "nodeContext" : "canRevoke=toExplicitlyRevoke.size() == 0;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 737,
        "startLineNumber" : 267,
        "startColumnNumber" : 23,
        "endLineNumber" : 283,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Map<String,ConnectorsAndTasks> toExplicitlyRevoke=performTaskRevocation(activeAssignments,currentWorkerAssignment);\n  log.debug(\"Connector and task to revoke assignments: {}\",toRevoke);\n  toExplicitlyRevoke.forEach((worker,assignment) -> {\n    ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n    existing.connectors().addAll(assignment.connectors());\n    existing.tasks().addAll(assignment.tasks());\n  }\n);\n  canRevoke=toExplicitlyRevoke.size() == 0;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 76,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 805,
        "startLineNumber" : 267,
        "startColumnNumber" : 8,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (canRevoke) {\n  Map<String,ConnectorsAndTasks> toExplicitlyRevoke=performTaskRevocation(activeAssignments,currentWorkerAssignment);\n  log.debug(\"Connector and task to revoke assignments: {}\",toRevoke);\n  toExplicitlyRevoke.forEach((worker,assignment) -> {\n    ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n    existing.connectors().addAll(assignment.connectors());\n    existing.tasks().addAll(assignment.tasks());\n  }\n);\n  canRevoke=toExplicitlyRevoke.size() == 0;\n}\n else {\n  canRevoke=delay == 0;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 85,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 9533,
        "startLineNumber" : 159,
        "startColumnNumber" : 114,
        "endLineNumber" : 315,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  log.debug(\"Performing task assignment during generation: {} with memberId: {}\",coordinator.generationId(),coordinator.memberId());\n  log.debug(\"Previous assignments: {}\",previousAssignment);\n  int lastCompletedGenerationId=coordinator.lastCompletedGenerationId();\n  if (previousGenerationId != lastCompletedGenerationId) {\n    log.debug(\"Clearing the view of previous assignments due to generation mismatch between \" + \"previous generation ID {} and last completed generation ID {}. This can \" + \"happen if the leader fails to sync the assignment within a rebalancing round. \"+ \"The following view of previous assignments might be outdated and will be \"+ \"ignored by the leader in the current computation of new assignments. \"+ \"Possibly outdated previous assignments: {}\",previousGenerationId,lastCompletedGenerationId,previousAssignment);\n    this.previousAssignment=ConnectorsAndTasks.EMPTY;\n  }\n  ClusterConfigState snapshot=coordinator.configSnapshot();\n  Set<String> configuredConnectors=new TreeSet<>(snapshot.connectors());\n  Set<ConnectorTaskId> configuredTasks=configuredConnectors.stream().flatMap(c -> snapshot.tasks(c).stream()).collect(Collectors.toSet());\n  ConnectorsAndTasks configured=new ConnectorsAndTasks.Builder().with(configuredConnectors,configuredTasks).build();\n  log.debug(\"Configured assignments: {}\",configured);\n  ConnectorsAndTasks activeAssignments=assignment(memberConfigs);\n  log.debug(\"Active assignments: {}\",activeAssignments);\n  if (!previousRevocation.isEmpty()) {\n    if (previousRevocation.connectors().stream().anyMatch(c -> activeAssignments.connectors().contains(c)) || previousRevocation.tasks().stream().anyMatch(t -> activeAssignments.tasks().contains(t))) {\n      previousAssignment=activeAssignments;\n      canRevoke=true;\n    }\n    previousRevocation.connectors().clear();\n    previousRevocation.tasks().clear();\n  }\n  ConnectorsAndTasks deleted=diff(previousAssignment,configured);\n  log.debug(\"Deleted assignments: {}\",deleted);\n  ConnectorsAndTasks remainingActive=diff(activeAssignments,deleted);\n  log.debug(\"Remaining (excluding deleted) active assignments: {}\",remainingActive);\n  ConnectorsAndTasks lostAssignments=diff(previousAssignment,activeAssignments,deleted);\n  log.debug(\"Lost assignments: {}\",lostAssignments);\n  ConnectorsAndTasks newSubmissions=diff(configured,previousAssignment,activeAssignments);\n  log.debug(\"New assignments: {}\",newSubmissions);\n  List<WorkerLoad> completeWorkerAssignment=workerAssignment(memberConfigs,ConnectorsAndTasks.EMPTY);\n  log.debug(\"Complete (ignoring deletions) worker assignments: {}\",completeWorkerAssignment);\n  Map<String,Collection<String>> connectorAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  log.debug(\"Complete (ignoring deletions) connector assignments: {}\",connectorAssignments);\n  Map<String,Collection<ConnectorTaskId>> taskAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  log.debug(\"Complete (ignoring deletions) task assignments: {}\",taskAssignments);\n  List<WorkerLoad> currentWorkerAssignment=workerAssignment(memberConfigs,deleted);\n  Map<String,ConnectorsAndTasks> toRevoke=computeDeleted(deleted,connectorAssignments,taskAssignments);\n  log.debug(\"Connector and task to delete assignments: {}\",toRevoke);\n  toRevoke.putAll(computeDuplicatedAssignments(memberConfigs,connectorAssignments,taskAssignments));\n  log.debug(\"Connector and task to revoke assignments (include duplicated assignments): {}\",toRevoke);\n  completeWorkerAssignment=workerAssignment(memberConfigs,deleted);\n  connectorAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  taskAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  handleLostAssignments(lostAssignments,newSubmissions,completeWorkerAssignment,memberConfigs);\n  canRevoke=delay == 0 && canRevoke;\n  log.debug(\"Can leader revoke tasks in this assignment? {} (delay: {})\",canRevoke,delay);\n  if (canRevoke) {\n    Map<String,ConnectorsAndTasks> toExplicitlyRevoke=performTaskRevocation(activeAssignments,currentWorkerAssignment);\n    log.debug(\"Connector and task to revoke assignments: {}\",toRevoke);\n    toExplicitlyRevoke.forEach((worker,assignment) -> {\n      ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n      existing.connectors().addAll(assignment.connectors());\n      existing.tasks().addAll(assignment.tasks());\n    }\n);\n    canRevoke=toExplicitlyRevoke.size() == 0;\n  }\n else {\n    canRevoke=delay == 0;\n  }\n  assignConnectors(completeWorkerAssignment,newSubmissions.connectors());\n  assignTasks(completeWorkerAssignment,newSubmissions.tasks());\n  log.debug(\"Current complete assignments: {}\",currentWorkerAssignment);\n  log.debug(\"New complete assignments: {}\",completeWorkerAssignment);\n  Map<String,Collection<String>> currentConnectorAssignments=currentWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  Map<String,Collection<ConnectorTaskId>> currentTaskAssignments=currentWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  Map<String,Collection<String>> incrementalConnectorAssignments=diff(connectorAssignments,currentConnectorAssignments);\n  Map<String,Collection<ConnectorTaskId>> incrementalTaskAssignments=diff(taskAssignments,currentTaskAssignments);\n  log.debug(\"Incremental connector assignments: {}\",incrementalConnectorAssignments);\n  log.debug(\"Incremental task assignments: {}\",incrementalTaskAssignments);\n  coordinator.leaderState(new LeaderState(memberConfigs,connectorAssignments,taskAssignments));\n  Map<String,ExtendedAssignment> assignments=fillAssignments(memberConfigs.keySet(),Assignment.NO_ERROR,leaderId,memberConfigs.get(leaderId).url(),maxOffset,incrementalConnectorAssignments,incrementalTaskAssignments,toRevoke,delay,protocolVersion);\n  previousAssignment=computePreviousAssignment(toRevoke,connectorAssignments,taskAssignments,lostAssignments);\n  previousGenerationId=coordinator.generationId();\n  previousMembers=memberConfigs.keySet();\n  log.debug(\"Actual assignments: {}\",assignments);\n  return serializeAssignments(assignments);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 741,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 10724,
        "startLineNumber" : 142,
        "startColumnNumber" : 4,
        "endLineNumber" : 315,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Performs task assignment based on the incremental cooperative connect protocol. Read more on the design and implementation in: {@see https://cwiki.apache.org/confluence/display/KAFKA/KIP-415%3A+Incremental+Cooperative+Rebalancing+in+Kafka+Connect}\n * @param leaderId the ID of the group leader\n * @param maxOffset the latest known offset of the configuration topic\n * @param memberConfigs the metadata of all the members of the group as gather in the currentround of rebalancing\n * @param coordinator the worker coordinator instance that provide the configuration snapshotand get assigned the leader state during this assignment\n * @param protocolVersion the Connect subprotocol version\n * @return the serialized assignment of tasks to the whole group, including assigned orrevoked tasks\n */\nprotected Map<String,ByteBuffer> performTaskAssignment(String leaderId,long maxOffset,Map<String,ExtendedWorkerState> memberConfigs,WorkerCoordinator coordinator,short protocolVersion){\n  log.debug(\"Performing task assignment during generation: {} with memberId: {}\",coordinator.generationId(),coordinator.memberId());\n  log.debug(\"Previous assignments: {}\",previousAssignment);\n  int lastCompletedGenerationId=coordinator.lastCompletedGenerationId();\n  if (previousGenerationId != lastCompletedGenerationId) {\n    log.debug(\"Clearing the view of previous assignments due to generation mismatch between \" + \"previous generation ID {} and last completed generation ID {}. This can \" + \"happen if the leader fails to sync the assignment within a rebalancing round. \"+ \"The following view of previous assignments might be outdated and will be \"+ \"ignored by the leader in the current computation of new assignments. \"+ \"Possibly outdated previous assignments: {}\",previousGenerationId,lastCompletedGenerationId,previousAssignment);\n    this.previousAssignment=ConnectorsAndTasks.EMPTY;\n  }\n  ClusterConfigState snapshot=coordinator.configSnapshot();\n  Set<String> configuredConnectors=new TreeSet<>(snapshot.connectors());\n  Set<ConnectorTaskId> configuredTasks=configuredConnectors.stream().flatMap(c -> snapshot.tasks(c).stream()).collect(Collectors.toSet());\n  ConnectorsAndTasks configured=new ConnectorsAndTasks.Builder().with(configuredConnectors,configuredTasks).build();\n  log.debug(\"Configured assignments: {}\",configured);\n  ConnectorsAndTasks activeAssignments=assignment(memberConfigs);\n  log.debug(\"Active assignments: {}\",activeAssignments);\n  if (!previousRevocation.isEmpty()) {\n    if (previousRevocation.connectors().stream().anyMatch(c -> activeAssignments.connectors().contains(c)) || previousRevocation.tasks().stream().anyMatch(t -> activeAssignments.tasks().contains(t))) {\n      previousAssignment=activeAssignments;\n      canRevoke=true;\n    }\n    previousRevocation.connectors().clear();\n    previousRevocation.tasks().clear();\n  }\n  ConnectorsAndTasks deleted=diff(previousAssignment,configured);\n  log.debug(\"Deleted assignments: {}\",deleted);\n  ConnectorsAndTasks remainingActive=diff(activeAssignments,deleted);\n  log.debug(\"Remaining (excluding deleted) active assignments: {}\",remainingActive);\n  ConnectorsAndTasks lostAssignments=diff(previousAssignment,activeAssignments,deleted);\n  log.debug(\"Lost assignments: {}\",lostAssignments);\n  ConnectorsAndTasks newSubmissions=diff(configured,previousAssignment,activeAssignments);\n  log.debug(\"New assignments: {}\",newSubmissions);\n  List<WorkerLoad> completeWorkerAssignment=workerAssignment(memberConfigs,ConnectorsAndTasks.EMPTY);\n  log.debug(\"Complete (ignoring deletions) worker assignments: {}\",completeWorkerAssignment);\n  Map<String,Collection<String>> connectorAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  log.debug(\"Complete (ignoring deletions) connector assignments: {}\",connectorAssignments);\n  Map<String,Collection<ConnectorTaskId>> taskAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  log.debug(\"Complete (ignoring deletions) task assignments: {}\",taskAssignments);\n  List<WorkerLoad> currentWorkerAssignment=workerAssignment(memberConfigs,deleted);\n  Map<String,ConnectorsAndTasks> toRevoke=computeDeleted(deleted,connectorAssignments,taskAssignments);\n  log.debug(\"Connector and task to delete assignments: {}\",toRevoke);\n  toRevoke.putAll(computeDuplicatedAssignments(memberConfigs,connectorAssignments,taskAssignments));\n  log.debug(\"Connector and task to revoke assignments (include duplicated assignments): {}\",toRevoke);\n  completeWorkerAssignment=workerAssignment(memberConfigs,deleted);\n  connectorAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  taskAssignments=completeWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  handleLostAssignments(lostAssignments,newSubmissions,completeWorkerAssignment,memberConfigs);\n  canRevoke=delay == 0 && canRevoke;\n  log.debug(\"Can leader revoke tasks in this assignment? {} (delay: {})\",canRevoke,delay);\n  if (canRevoke) {\n    Map<String,ConnectorsAndTasks> toExplicitlyRevoke=performTaskRevocation(activeAssignments,currentWorkerAssignment);\n    log.debug(\"Connector and task to revoke assignments: {}\",toRevoke);\n    toExplicitlyRevoke.forEach((worker,assignment) -> {\n      ConnectorsAndTasks existing=toRevoke.computeIfAbsent(worker,v -> new ConnectorsAndTasks.Builder().build());\n      existing.connectors().addAll(assignment.connectors());\n      existing.tasks().addAll(assignment.tasks());\n    }\n);\n    canRevoke=toExplicitlyRevoke.size() == 0;\n  }\n else {\n    canRevoke=delay == 0;\n  }\n  assignConnectors(completeWorkerAssignment,newSubmissions.connectors());\n  assignTasks(completeWorkerAssignment,newSubmissions.tasks());\n  log.debug(\"Current complete assignments: {}\",currentWorkerAssignment);\n  log.debug(\"New complete assignments: {}\",completeWorkerAssignment);\n  Map<String,Collection<String>> currentConnectorAssignments=currentWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::connectors));\n  Map<String,Collection<ConnectorTaskId>> currentTaskAssignments=currentWorkerAssignment.stream().collect(Collectors.toMap(WorkerLoad::worker,WorkerLoad::tasks));\n  Map<String,Collection<String>> incrementalConnectorAssignments=diff(connectorAssignments,currentConnectorAssignments);\n  Map<String,Collection<ConnectorTaskId>> incrementalTaskAssignments=diff(taskAssignments,currentTaskAssignments);\n  log.debug(\"Incremental connector assignments: {}\",incrementalConnectorAssignments);\n  log.debug(\"Incremental task assignments: {}\",incrementalTaskAssignments);\n  coordinator.leaderState(new LeaderState(memberConfigs,connectorAssignments,taskAssignments));\n  Map<String,ExtendedAssignment> assignments=fillAssignments(memberConfigs.keySet(),Assignment.NO_ERROR,leaderId,memberConfigs.get(leaderId).url(),maxOffset,incrementalConnectorAssignments,incrementalTaskAssignments,toRevoke,delay,protocolVersion);\n  previousAssignment=computePreviousAssignment(toRevoke,connectorAssignments,taskAssignments,lostAssignments);\n  previousGenerationId=coordinator.generationId();\n  previousMembers=memberConfigs.keySet();\n  log.debug(\"Actual assignments: {}\",assignments);\n  return serializeAssignments(assignments);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 775,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 282,
        "startColumnNumber" : 12,
        "endLineNumber" : 282,
        "endColumnNumber" : 55
      },
      "nodeContext" : "canRevoke=toExplicitlyRevoke.size() == 0;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "java.util.Map<java.lang.String,org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks>"
  } ],
  "positionList" : [ {
    "charLength" : 18,
    "startLineNumber" : 273,
    "startColumnNumber" : 12,
    "endLineNumber" : 273,
    "endColumnNumber" : 30
  }, {
    "charLength" : 18,
    "startLineNumber" : 282,
    "startColumnNumber" : 24,
    "endLineNumber" : 282,
    "endColumnNumber" : 42
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 4
  } ]
}