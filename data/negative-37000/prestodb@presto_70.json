{
  "id" : 70,
  "expression" : "block",
  "projectName" : "prestodb@presto",
  "commitID" : "eff77883d0d24dc6022ecde252612d1430c9fbac",
  "filePath" : "/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapTransformKeyFunction.java",
  "occurrences" : 6,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "block",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 5,
      "startLineNumber" : 167,
      "startColumnNumber" : 52,
      "endLineNumber" : 167,
      "endColumnNumber" : 57
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 167,
        "startColumnNumber" : 16,
        "endLineNumber" : 167,
        "endColumnNumber" : 68
      },
      "nodeContext" : "ImmutableList.of(state,properties,block,function)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 194,
        "startLineNumber" : 163,
        "startColumnNumber" : 34,
        "endLineNumber" : 167,
        "endColumnNumber" : 69
      },
      "nodeContext" : "definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 20,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 203,
        "startLineNumber" : 163,
        "startColumnNumber" : 25,
        "endLineNumber" : 167,
        "endColumnNumber" : 69
      },
      "nodeContext" : "method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function))",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 22,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 221,
        "startLineNumber" : 163,
        "startColumnNumber" : 8,
        "endLineNumber" : 167,
        "endColumnNumber" : 70
      },
      "nodeContext" : "MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 25,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8917,
        "startLineNumber" : 147,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 924,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 9045,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private static MethodHandle generateTransformKey(Type keyType,Type transformedKeyType,Type valueType,Type resultMapType){\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 167,
        "startColumnNumber" : 16,
        "endLineNumber" : 167,
        "endColumnNumber" : 68
      },
      "nodeContext" : "ImmutableList.of(state,properties,block,function)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "com.facebook.presto.bytecode.Parameter"
  }, {
    "nodeContext" : "block",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 5,
      "startLineNumber" : 182,
      "startColumnNumber" : 38,
      "endLineNumber" : 182,
      "endColumnNumber" : 43
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 182,
        "startColumnNumber" : 38,
        "endLineNumber" : 182,
        "endColumnNumber" : 81
      },
      "nodeContext" : "block.invoke(\"getPositionCount\",int.class)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 62,
        "startLineNumber" : 182,
        "startColumnNumber" : 20,
        "endLineNumber" : 182,
        "endColumnNumber" : 82
      },
      "nodeContext" : "positionCount.set(block.invoke(\"getPositionCount\",int.class))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 75,
        "startLineNumber" : 182,
        "startColumnNumber" : 8,
        "endLineNumber" : 182,
        "endColumnNumber" : 83
      },
      "nodeContext" : "body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 182,
        "startColumnNumber" : 8,
        "endLineNumber" : 182,
        "endColumnNumber" : 84
      },
      "nodeContext" : "body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8917,
        "startLineNumber" : 147,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 924,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 9045,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private static MethodHandle generateTransformKey(Type keyType,Type transformedKeyType,Type valueType,Type resultMapType){\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 76,
        "startLineNumber" : 182,
        "startColumnNumber" : 8,
        "endLineNumber" : 182,
        "endColumnNumber" : 84
      },
      "nodeContext" : "body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "com.facebook.presto.bytecode.Parameter"
  }, {
    "nodeContext" : "block",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 5,
      "startLineNumber" : 210,
      "startColumnNumber" : 91,
      "endLineNumber" : 210,
      "endColumnNumber" : 96
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 36,
        "startLineNumber" : 210,
        "startColumnNumber" : 71,
        "endLineNumber" : 210,
        "endColumnNumber" : 107
      },
      "nodeContext" : "keySqlType.getValue(block,position)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 5,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 210,
        "startColumnNumber" : 71,
        "endLineNumber" : 210,
        "endColumnNumber" : 125
      },
      "nodeContext" : "keySqlType.getValue(block,position).cast(keyJavaType)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 70,
        "startLineNumber" : 210,
        "startColumnNumber" : 56,
        "endLineNumber" : 210,
        "endColumnNumber" : 126
      },
      "nodeContext" : "keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 98,
        "startLineNumber" : 210,
        "startColumnNumber" : 29,
        "endLineNumber" : 210,
        "endColumnNumber" : 127
      },
      "nodeContext" : "new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 16,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 115,
        "startLineNumber" : 210,
        "startColumnNumber" : 12,
        "endLineNumber" : 210,
        "endColumnNumber" : 127
      },
      "nodeContext" : "loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)))",
      "nodeType" : "Assignment",
      "astNodeNumber" : 18,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 116,
        "startLineNumber" : 210,
        "startColumnNumber" : 12,
        "endLineNumber" : 210,
        "endColumnNumber" : 128
      },
      "nodeContext" : "loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 140,
        "startLineNumber" : 209,
        "startColumnNumber" : 38,
        "endLineNumber" : 211,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 20,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 795,
        "startLineNumber" : 209,
        "startColumnNumber" : 8,
        "endLineNumber" : 221,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (!keyType.equals(UNKNOWN)) {\n  loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n}\n else {\n  loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 55,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8917,
        "startLineNumber" : 147,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 924,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 9045,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private static MethodHandle generateTransformKey(Type keyType,Type transformedKeyType,Type valueType,Type resultMapType){\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 116,
        "startLineNumber" : 210,
        "startColumnNumber" : 12,
        "endLineNumber" : 210,
        "endColumnNumber" : 128
      },
      "nodeContext" : "loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 19,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "com.facebook.presto.bytecode.Parameter"
  }, {
    "nodeContext" : "block",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 5,
      "startLineNumber" : 227,
      "startColumnNumber" : 31,
      "endLineNumber" : 227,
      "endColumnNumber" : 36
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 227,
        "startColumnNumber" : 31,
        "endLineNumber" : 227,
        "endColumnNumber" : 99
      },
      "nodeContext" : "block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 118,
        "startLineNumber" : 226,
        "startColumnNumber" : 31,
        "endLineNumber" : 227,
        "endColumnNumber" : 100
      },
      "nodeContext" : "new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1))))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 17,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 193,
        "startLineNumber" : 226,
        "startColumnNumber" : 31,
        "endLineNumber" : 228,
        "endColumnNumber" : 74
      },
      "nodeContext" : "new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 25,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 321,
        "startLineNumber" : 226,
        "startColumnNumber" : 31,
        "endLineNumber" : 229,
        "endColumnNumber" : 127
      },
      "nodeContext" : "new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 43,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 340,
        "startLineNumber" : 226,
        "startColumnNumber" : 12,
        "endLineNumber" : 229,
        "endColumnNumber" : 127
      },
      "nodeContext" : "loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)))",
      "nodeType" : "Assignment",
      "astNodeNumber" : 45,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 341,
        "startLineNumber" : 226,
        "startColumnNumber" : 12,
        "endLineNumber" : 229,
        "endColumnNumber" : 128
      },
      "nodeContext" : "loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 46,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 365,
        "startLineNumber" : 225,
        "startColumnNumber" : 40,
        "endLineNumber" : 230,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 47,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 618,
        "startLineNumber" : 225,
        "startColumnNumber" : 8,
        "endLineNumber" : 234,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (!valueType.equals(UNKNOWN)) {\n  loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n}\n else {\n  loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8917,
        "startLineNumber" : 147,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 924,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 9045,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private static MethodHandle generateTransformKey(Type keyType,Type transformedKeyType,Type valueType,Type resultMapType){\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 227,
        "startColumnNumber" : 31,
        "endLineNumber" : 227,
        "endColumnNumber" : 99
      },
      "nodeContext" : "block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.facebook.presto.bytecode.Parameter"
  }, {
    "nodeContext" : "block",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 5,
      "startLineNumber" : 229,
      "startColumnNumber" : 68,
      "endLineNumber" : 229,
      "endColumnNumber" : 73
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodInvocation,expression]",
      "nodePosition" : {
        "charLength" : 59,
        "startLineNumber" : 229,
        "startColumnNumber" : 46,
        "endLineNumber" : 229,
        "endColumnNumber" : 105
      },
      "nodeContext" : "valueSqlType.getValue(block,add(position,constantInt(1)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 79,
        "startLineNumber" : 229,
        "startColumnNumber" : 46,
        "endLineNumber" : 229,
        "endColumnNumber" : 125
      },
      "nodeContext" : "valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 97,
        "startLineNumber" : 229,
        "startColumnNumber" : 29,
        "endLineNumber" : 229,
        "endColumnNumber" : 126
      },
      "nodeContext" : "valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 321,
        "startLineNumber" : 226,
        "startColumnNumber" : 31,
        "endLineNumber" : 229,
        "endColumnNumber" : 127
      },
      "nodeContext" : "new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 43,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 340,
        "startLineNumber" : 226,
        "startColumnNumber" : 12,
        "endLineNumber" : 229,
        "endColumnNumber" : 127
      },
      "nodeContext" : "loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)))",
      "nodeType" : "Assignment",
      "astNodeNumber" : 45,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 341,
        "startLineNumber" : 226,
        "startColumnNumber" : 12,
        "endLineNumber" : 229,
        "endColumnNumber" : 128
      },
      "nodeContext" : "loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 46,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 365,
        "startLineNumber" : 225,
        "startColumnNumber" : 40,
        "endLineNumber" : 230,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 47,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 618,
        "startLineNumber" : 225,
        "startColumnNumber" : 8,
        "endLineNumber" : 234,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (!valueType.equals(UNKNOWN)) {\n  loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n}\n else {\n  loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 68,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8917,
        "startLineNumber" : 147,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 924,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 9045,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private static MethodHandle generateTransformKey(Type keyType,Type transformedKeyType,Type valueType,Type resultMapType){\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 97,
        "startLineNumber" : 229,
        "startColumnNumber" : 29,
        "endLineNumber" : 229,
        "endColumnNumber" : 126
      },
      "nodeContext" : "valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 16,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "com.facebook.presto.bytecode.Parameter"
  }, {
    "nodeContext" : "block",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 5,
      "startLineNumber" : 247,
      "startColumnNumber" : 88,
      "endLineNumber" : 247,
      "endColumnNumber" : 93
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 95,
        "startLineNumber" : 247,
        "startColumnNumber" : 44,
        "endLineNumber" : 247,
        "endColumnNumber" : 139
      },
      "nodeContext" : "valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 333,
        "startLineNumber" : 245,
        "startColumnNumber" : 37,
        "endLineNumber" : 247,
        "endColumnNumber" : 140
      },
      "nodeContext" : "new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 34,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 555,
        "startLineNumber" : 242,
        "startColumnNumber" : 28,
        "endLineNumber" : 247,
        "endColumnNumber" : 141
      },
      "nodeContext" : "new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder)))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 50,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 792,
        "startLineNumber" : 240,
        "startColumnNumber" : 30,
        "endLineNumber" : 247,
        "endColumnNumber" : 142
      },
      "nodeContext" : "new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 82,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 810,
        "startLineNumber" : 240,
        "startColumnNumber" : 12,
        "endLineNumber" : 247,
        "endColumnNumber" : 142
      },
      "nodeContext" : "writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))))",
      "nodeType" : "Assignment",
      "astNodeNumber" : 84,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 811,
        "startLineNumber" : 240,
        "startColumnNumber" : 12,
        "endLineNumber" : 247,
        "endColumnNumber" : 143
      },
      "nodeContext" : "writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 85,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1809,
        "startLineNumber" : 239,
        "startColumnNumber" : 49,
        "endLineNumber" : 262,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n  throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 162,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2103,
        "startLineNumber" : 239,
        "startColumnNumber" : 8,
        "endLineNumber" : 268,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (!transformedKeyType.equals(UNKNOWN)) {\n  writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n  throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n}\n else {\n  writeKeyElement=throwNullKeyException;\n  throwDuplicatedKeyException=throwNullKeyException;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 177,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8917,
        "startLineNumber" : 147,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 924,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 9045,
        "startLineNumber" : 146,
        "startColumnNumber" : 4,
        "endLineNumber" : 298,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private static MethodHandle generateTransformKey(Type keyType,Type transformedKeyType,Type valueType,Type resultMapType){\n  CallSiteBinder binder=new CallSiteBinder();\n  Class<?> keyJavaType=Primitives.wrap(keyType.getJavaType());\n  Class<?> transformedKeyJavaType=Primitives.wrap(transformedKeyType.getJavaType());\n  Class<?> valueJavaType=Primitives.wrap(valueType.getJavaType());\n  ClassDefinition definition=new ClassDefinition(a(PUBLIC,FINAL),makeClassName(\"MapTransformKey\"),type(Object.class));\n  definition.declareDefaultConstructor(a(PRIVATE));\n  Parameter state=arg(\"state\",Object.class);\n  Parameter properties=arg(\"properties\",SqlFunctionProperties.class);\n  Parameter block=arg(\"block\",Block.class);\n  Parameter function=arg(\"function\",BinaryFunctionInterface.class);\n  MethodDefinition method=definition.declareMethod(a(PUBLIC,STATIC),\"transform\",type(Block.class),ImmutableList.of(state,properties,block,function));\n  BytecodeBlock body=method.getBody();\n  Scope scope=method.getScope();\n  Variable positionCount=scope.declareVariable(int.class,\"positionCount\");\n  Variable position=scope.declareVariable(int.class,\"position\");\n  Variable pageBuilder=scope.declareVariable(PageBuilder.class,\"pageBuilder\");\n  Variable mapBlockBuilder=scope.declareVariable(BlockBuilder.class,\"mapBlockBuilder\");\n  Variable blockBuilder=scope.declareVariable(BlockBuilder.class,\"blockBuilder\");\n  Variable typedSet=scope.declareVariable(TypedSet.class,\"typeSet\");\n  Variable keyElement=scope.declareVariable(keyJavaType,\"keyElement\");\n  Variable transformedKeyElement=scope.declareVariable(transformedKeyJavaType,\"transformedKeyElement\");\n  Variable valueElement=scope.declareVariable(valueJavaType,\"valueElement\");\n  body.append(positionCount.set(block.invoke(\"getPositionCount\",int.class)));\n  body.append(pageBuilder.set(state.cast(PageBuilder.class)));\n  body.append(new IfStatement().condition(pageBuilder.invoke(\"isFull\",boolean.class)).ifTrue(pageBuilder.invoke(\"reset\",void.class)));\n  body.append(mapBlockBuilder.set(pageBuilder.invoke(\"getBlockBuilder\",BlockBuilder.class,constantInt(0))));\n  body.append(blockBuilder.set(mapBlockBuilder.invoke(\"beginBlockEntry\",BlockBuilder.class)));\n  body.append(typedSet.set(newInstance(TypedSet.class,constantType(binder,transformedKeyType),divide(positionCount,constantInt(2)),constantString(MAP_TRANSFORM_KEY_FUNCTION.getSignature().getNameSuffix()))));\n  BytecodeNode throwNullKeyException=new BytecodeBlock().append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),constantString(\"map key cannot be null\"))).throwObject();\n  SqlTypeBytecodeExpression keySqlType=constantType(binder,keyType);\n  BytecodeNode loadKeyElement;\n  if (!keyType.equals(UNKNOWN)) {\n    loadKeyElement=new BytecodeBlock().append(keyElement.set(keySqlType.getValue(block,position).cast(keyJavaType)));\n  }\n else {\n    loadKeyElement=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(keyElement.set(constantNull(keyJavaType))).append(throwNullKeyException);\n  }\n  SqlTypeBytecodeExpression valueSqlType=constantType(binder,valueType);\n  BytecodeNode loadValueElement;\n  if (!valueType.equals(UNKNOWN)) {\n    loadValueElement=new IfStatement().condition(block.invoke(\"isNull\",boolean.class,add(position,constantInt(1)))).ifTrue(valueElement.set(constantNull(valueJavaType))).ifFalse(valueElement.set(valueSqlType.getValue(block,add(position,constantInt(1))).cast(valueJavaType)));\n  }\n else {\n    loadValueElement=new BytecodeBlock().append(valueElement.set(constantNull(valueJavaType)));\n  }\n  SqlTypeBytecodeExpression transformedKeySqlType=constantType(binder,transformedKeyType);\n  BytecodeNode writeKeyElement;\n  BytecodeNode throwDuplicatedKeyException;\n  if (!transformedKeyType.equals(UNKNOWN)) {\n    writeKeyElement=new BytecodeBlock().append(transformedKeyElement.set(function.invoke(\"apply\",Object.class,keyElement.cast(Object.class),valueElement.cast(Object.class)).cast(transformedKeyJavaType))).append(new IfStatement().condition(equal(transformedKeyElement,constantNull(transformedKeyJavaType))).ifTrue(throwNullKeyException).ifFalse(new BytecodeBlock().append(constantType(binder,transformedKeyType).writeValue(blockBuilder,transformedKeyElement.cast(transformedKeyType.getJavaType()))).append(valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder))));\n    throwDuplicatedKeyException=new BytecodeBlock().append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop()).append(newInstance(PrestoException.class,getStatic(INVALID_FUNCTION_ARGUMENT.getDeclaringClass(),\"INVALID_FUNCTION_ARGUMENT\").cast(ErrorCodeSupplier.class),invokeStatic(String.class,\"format\",String.class,constantString(\"Duplicate keys (%s) are not allowed\"),newArray(type(Object[].class),ImmutableList.of(transformedKeySqlType.invoke(\"getObjectValue\",Object.class,properties,blockBuilder.cast(Block.class),position)))))).throwObject();\n  }\n else {\n    writeKeyElement=throwNullKeyException;\n    throwDuplicatedKeyException=throwNullKeyException;\n  }\n  body.append(new ForLoop().initialize(position.set(constantInt(0))).condition(lessThan(position,positionCount)).update(incrementVariable(position,(byte)2)).body(new BytecodeBlock().append(loadKeyElement).append(loadValueElement).append(writeKeyElement).append(new IfStatement().condition(typedSet.invoke(\"contains\",boolean.class,blockBuilder.cast(Block.class),position)).ifTrue(throwDuplicatedKeyException).ifFalse(typedSet.invoke(\"add\",boolean.class,blockBuilder.cast(Block.class),position).pop()))));\n  body.append(mapBlockBuilder.invoke(\"closeEntry\",BlockBuilder.class).pop());\n  body.append(pageBuilder.invoke(\"declarePosition\",void.class));\n  body.append(constantType(binder,resultMapType).invoke(\"getObject\",Object.class,mapBlockBuilder.cast(Block.class),subtract(mapBlockBuilder.invoke(\"getPositionCount\",int.class),constantInt(1))).ret());\n  Class<?> generatedClass=defineClass(definition,Object.class,binder.getBindings(),MapTransformKeyFunction.class.getClassLoader());\n  return methodHandle(generatedClass,\"transform\",Object.class,SqlFunctionProperties.class,Block.class,BinaryFunctionInterface.class);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 95,
        "startLineNumber" : 247,
        "startColumnNumber" : 44,
        "endLineNumber" : 247,
        "endColumnNumber" : 139
      },
      "nodeContext" : "valueSqlType.invoke(\"appendTo\",void.class,block,add(position,constantInt(1)),blockBuilder)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 14,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "com.facebook.presto.bytecode.Parameter"
  } ],
  "positionList" : [ {
    "charLength" : 5,
    "startLineNumber" : 167,
    "startColumnNumber" : 52,
    "endLineNumber" : 167,
    "endColumnNumber" : 57
  }, {
    "charLength" : 5,
    "startLineNumber" : 182,
    "startColumnNumber" : 38,
    "endLineNumber" : 182,
    "endColumnNumber" : 43
  }, {
    "charLength" : 5,
    "startLineNumber" : 210,
    "startColumnNumber" : 91,
    "endLineNumber" : 210,
    "endColumnNumber" : 96
  }, {
    "charLength" : 5,
    "startLineNumber" : 227,
    "startColumnNumber" : 31,
    "endLineNumber" : 227,
    "endColumnNumber" : 36
  }, {
    "charLength" : 5,
    "startLineNumber" : 229,
    "startColumnNumber" : 68,
    "endLineNumber" : 229,
    "endColumnNumber" : 73
  }, {
    "charLength" : 5,
    "startLineNumber" : 247,
    "startColumnNumber" : 88,
    "endLineNumber" : 247,
    "endColumnNumber" : 93
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 8
  } ]
}