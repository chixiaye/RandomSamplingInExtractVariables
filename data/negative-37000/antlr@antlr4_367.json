{
  "id" : 367,
  "expression" : "new ArrayList<>()",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/runtime/Java/src/org/antlr/v4/runtime/ParserRuleContext.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "new ArrayList<>()",
    "nodeType" : "ClassInstanceCreation",
    "nodePosition" : {
      "charLength" : 17,
      "startLineNumber" : 102,
      "startColumnNumber" : 19,
      "endLineNumber" : 102,
      "endColumnNumber" : 36
    },
    "astNodeNumber" : 4,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 102,
        "startColumnNumber" : 3,
        "endLineNumber" : 102,
        "endColumnNumber" : 36
      },
      "nodeContext" : "this.children=new ArrayList<>()",
      "nodeType" : "Assignment",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 102,
        "startColumnNumber" : 3,
        "endLineNumber" : 102,
        "endColumnNumber" : 37
      },
      "nodeContext" : "this.children=new ArrayList<>();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 224,
        "startLineNumber" : 101,
        "startColumnNumber" : 28,
        "endLineNumber" : 109,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  this.children=new ArrayList<>();\n  for (  ParseTree child : ctx.children) {\n    if (child instanceof ErrorNode) {\n      addChild((ErrorNode)child);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 32,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 250,
        "startLineNumber" : 101,
        "startColumnNumber" : 2,
        "endLineNumber" : 109,
        "endColumnNumber" : 3
      },
      "nodeContext" : "if (ctx.children != null) {\n  this.children=new ArrayList<>();\n  for (  ParseTree child : ctx.children) {\n    if (child instanceof ErrorNode) {\n      addChild((ErrorNode)child);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 38,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 432,
        "startLineNumber" : 93,
        "startColumnNumber" : 45,
        "endLineNumber" : 110,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  this.parent=ctx.parent;\n  this.invokingState=ctx.invokingState;\n  this.start=ctx.start;\n  this.stop=ctx.stop;\n  if (ctx.children != null) {\n    this.children=new ArrayList<>();\n    for (    ParseTree child : ctx.children) {\n      if (child instanceof ErrorNode) {\n        addChild((ErrorNode)child);\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 71,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 1050,
        "startLineNumber" : 81,
        "startColumnNumber" : 1,
        "endLineNumber" : 110,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * COPY a ctx (I'm deliberately not using copy constructor) to avoid confusion with creating node with parent. Does not copy children (except error leaves). This is used in the generated parser code to flip a generic XContext node for rule X to a YContext for alt label Y. In that sense, it is not really a generic copy function. If we do an error sync() at start of a rule, we might add error nodes to the generic XContext so this function must copy those nodes to the YContext as well else they are lost!\n */\npublic void copyFrom(ParserRuleContext ctx){\n  this.parent=ctx.parent;\n  this.invokingState=ctx.invokingState;\n  this.start=ctx.start;\n  this.stop=ctx.stop;\n  if (ctx.children != null) {\n    this.children=new ArrayList<>();\n    for (    ParseTree child : ctx.children) {\n      if (child instanceof ErrorNode) {\n        addChild((ErrorNode)child);\n      }\n    }\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 80,
      "astHeight" : 13
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 102,
        "startColumnNumber" : 3,
        "endLineNumber" : 102,
        "endColumnNumber" : 37
      },
      "nodeContext" : "this.children=new ArrayList<>();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "java.util.ArrayList<org.antlr.v4.runtime.tree.ParseTree>"
  } ],
  "positionList" : [ {
    "charLength" : 17,
    "startLineNumber" : 102,
    "startColumnNumber" : 19,
    "endLineNumber" : 102,
    "endColumnNumber" : 36
  } ],
  "layoutRelationDataList" : [ ]
}