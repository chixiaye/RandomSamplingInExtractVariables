{
  "id" : 87,
  "expression" : "completableFuture",
  "projectName" : "apache@pulsar",
  "commitID" : "ded806fd52f6e2f182fa02052cbd82c2a6755098",
  "filePath" : "/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TransactionsBase.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "completableFuture",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 17,
      "startLineNumber" : 400,
      "startColumnNumber" : 56,
      "endLineNumber" : 400,
      "endColumnNumber" : 73
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 400,
        "startColumnNumber" : 24,
        "endLineNumber" : 400,
        "endColumnNumber" : 74
      },
      "nodeContext" : "getTransactionMetadata(txnMeta,completableFuture)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 400,
        "startColumnNumber" : 24,
        "endLineNumber" : 400,
        "endColumnNumber" : 75
      },
      "nodeContext" : "getTransactionMetadata(txnMeta,completableFuture);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 276,
        "startLineNumber" : 398,
        "startColumnNumber" : 57,
        "endLineNumber" : 402,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n  getTransactionMetadata(txnMeta,completableFuture);\n  completableFutures.add(completableFuture);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 23,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 313,
        "startLineNumber" : 398,
        "startColumnNumber" : 20,
        "endLineNumber" : 402,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (TxnMeta txnMeta : transactions) {\n  CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n  getTransactionMetadata(txnMeta,completableFuture);\n  completableFutures.add(completableFuture);\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 29,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2195,
        "startLineNumber" : 385,
        "startColumnNumber" : 43,
        "endLineNumber" : 421,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n  TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n  if (transactionMetadataStore == null) {\n    asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n    return;\n  }\n  List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n  List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n  for (  TxnMeta txnMeta : transactions) {\n    CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n    getTransactionMetadata(txnMeta,completableFuture);\n    completableFutures.add(completableFuture);\n  }\n  FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n    if (e != null) {\n      asyncResponse.resume(new RestException(e.getCause()));\n      return;\n    }\n    Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n    for (    CompletableFuture<TransactionMetadata> future : completableFutures) {\n      try {\n        transactionMetadata.put(future.get().txnId,future.get());\n      }\n catch (      Exception exception) {\n        asyncResponse.resume(new RestException(exception.getCause()));\n        return;\n      }\n    }\n    asyncResponse.resume(transactionMetadata);\n  }\n);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 190,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4898,
        "startLineNumber" : 385,
        "startColumnNumber" : 16,
        "endLineNumber" : 466,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (coordinatorId != null) {\n  validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n  TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n  if (transactionMetadataStore == null) {\n    asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n    return;\n  }\n  List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n  List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n  for (  TxnMeta txnMeta : transactions) {\n    CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n    getTransactionMetadata(txnMeta,completableFuture);\n    completableFutures.add(completableFuture);\n  }\n  FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n    if (e != null) {\n      asyncResponse.resume(new RestException(e.getCause()));\n      return;\n    }\n    Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n    for (    CompletableFuture<TransactionMetadata> future : completableFutures) {\n      try {\n        transactionMetadata.put(future.get().txnId,future.get());\n      }\n catch (      Exception exception) {\n        asyncResponse.resume(new RestException(exception.getCause()));\n        return;\n      }\n    }\n    asyncResponse.resume(transactionMetadata);\n  }\n);\n}\n else {\n  getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n    if (partitionMetadata.partitions == 0) {\n      asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n      return;\n    }\n    List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n    for (int i=0; i < partitionMetadata.partitions; i++) {\n      try {\n        completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n      }\n catch (      PulsarServerException e) {\n        asyncResponse.resume(new RestException(e));\n        return;\n      }\n    }\n    Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n    FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n      if (e != null) {\n        asyncResponse.resume(new RestException(e));\n        return;\n      }\n      for (      CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n        try {\n          transactionMetadataMaps.putAll(transactionMetadataMap.get());\n        }\n catch (        Exception exception) {\n          asyncResponse.resume(new RestException(exception.getCause()));\n          return;\n        }\n      }\n      asyncResponse.resume(transactionMetadataMaps);\n    }\n);\n  }\n).exceptionally(ex -> {\n    log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n    resumeAsyncResponseExceptionally(asyncResponse,ex);\n    return null;\n  }\n);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 405,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 4930,
        "startLineNumber" : 384,
        "startColumnNumber" : 72,
        "endLineNumber" : 467,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  if (coordinatorId != null) {\n    validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n    TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n    if (transactionMetadataStore == null) {\n      asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n      return;\n    }\n    List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n    List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n    for (    TxnMeta txnMeta : transactions) {\n      CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n      getTransactionMetadata(txnMeta,completableFuture);\n      completableFutures.add(completableFuture);\n    }\n    FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n      if (e != null) {\n        asyncResponse.resume(new RestException(e.getCause()));\n        return;\n      }\n      Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n      for (      CompletableFuture<TransactionMetadata> future : completableFutures) {\n        try {\n          transactionMetadata.put(future.get().txnId,future.get());\n        }\n catch (        Exception exception) {\n          asyncResponse.resume(new RestException(exception.getCause()));\n          return;\n        }\n      }\n      asyncResponse.resume(transactionMetadata);\n    }\n);\n  }\n else {\n    getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n      if (partitionMetadata.partitions == 0) {\n        asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n        return;\n      }\n      List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n      for (int i=0; i < partitionMetadata.partitions; i++) {\n        try {\n          completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n        }\n catch (        PulsarServerException e) {\n          asyncResponse.resume(new RestException(e));\n          return;\n        }\n      }\n      Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n      FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n        if (e != null) {\n          asyncResponse.resume(new RestException(e));\n          return;\n        }\n        for (        CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n          try {\n            transactionMetadataMaps.putAll(transactionMetadataMap.get());\n          }\n catch (          Exception exception) {\n            asyncResponse.resume(new RestException(exception.getCause()));\n            return;\n          }\n        }\n        asyncResponse.resume(transactionMetadataMaps);\n      }\n);\n    }\n).exceptionally(ex -> {\n      log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n      resumeAsyncResponseExceptionally(asyncResponse,ex);\n      return null;\n    }\n);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 406,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5126,
        "startLineNumber" : 384,
        "startColumnNumber" : 12,
        "endLineNumber" : 469,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n  if (coordinatorId != null) {\n    validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n    TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n    if (transactionMetadataStore == null) {\n      asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n      return;\n    }\n    List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n    List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n    for (    TxnMeta txnMeta : transactions) {\n      CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n      getTransactionMetadata(txnMeta,completableFuture);\n      completableFutures.add(completableFuture);\n    }\n    FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n      if (e != null) {\n        asyncResponse.resume(new RestException(e.getCause()));\n        return;\n      }\n      Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n      for (      CompletableFuture<TransactionMetadata> future : completableFutures) {\n        try {\n          transactionMetadata.put(future.get().txnId,future.get());\n        }\n catch (        Exception exception) {\n          asyncResponse.resume(new RestException(exception.getCause()));\n          return;\n        }\n      }\n      asyncResponse.resume(transactionMetadata);\n    }\n);\n  }\n else {\n    getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n      if (partitionMetadata.partitions == 0) {\n        asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n        return;\n      }\n      List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n      for (int i=0; i < partitionMetadata.partitions; i++) {\n        try {\n          completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n        }\n catch (        PulsarServerException e) {\n          asyncResponse.resume(new RestException(e));\n          return;\n        }\n      }\n      Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n      FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n        if (e != null) {\n          asyncResponse.resume(new RestException(e));\n          return;\n        }\n        for (        CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n          try {\n            transactionMetadataMaps.putAll(transactionMetadataMap.get());\n          }\n catch (          Exception exception) {\n            asyncResponse.resume(new RestException(exception.getCause()));\n            return;\n          }\n        }\n        asyncResponse.resume(transactionMetadataMaps);\n      }\n);\n    }\n).exceptionally(ex -> {\n      log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n      resumeAsyncResponseExceptionally(asyncResponse,ex);\n      return null;\n    }\n);\n  }\n}\n else {\n  asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 423,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5150,
        "startLineNumber" : 383,
        "startColumnNumber" : 12,
        "endLineNumber" : 470,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n    if (coordinatorId != null) {\n      validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n      TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n      if (transactionMetadataStore == null) {\n        asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n        return;\n      }\n      List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n      List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n      for (      TxnMeta txnMeta : transactions) {\n        CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n        getTransactionMetadata(txnMeta,completableFuture);\n        completableFutures.add(completableFuture);\n      }\n      FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n        if (e != null) {\n          asyncResponse.resume(new RestException(e.getCause()));\n          return;\n        }\n        Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n        for (        CompletableFuture<TransactionMetadata> future : completableFutures) {\n          try {\n            transactionMetadata.put(future.get().txnId,future.get());\n          }\n catch (          Exception exception) {\n            asyncResponse.resume(new RestException(exception.getCause()));\n            return;\n          }\n        }\n        asyncResponse.resume(transactionMetadata);\n      }\n);\n    }\n else {\n      getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n        if (partitionMetadata.partitions == 0) {\n          asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n          return;\n        }\n        List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n        for (int i=0; i < partitionMetadata.partitions; i++) {\n          try {\n            completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n          }\n catch (          PulsarServerException e) {\n            asyncResponse.resume(new RestException(e));\n            return;\n          }\n        }\n        Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n        FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n          if (e != null) {\n            asyncResponse.resume(new RestException(e));\n            return;\n          }\n          for (          CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n            try {\n              transactionMetadataMaps.putAll(transactionMetadataMap.get());\n            }\n catch (            Exception exception) {\n              asyncResponse.resume(new RestException(exception.getCause()));\n              return;\n            }\n          }\n          asyncResponse.resume(transactionMetadataMaps);\n        }\n);\n      }\n).exceptionally(ex -> {\n        log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n        resumeAsyncResponseExceptionally(asyncResponse,ex);\n        return null;\n      }\n);\n    }\n  }\n else {\n    asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 424,
      "astHeight" : 24
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5242,
        "startLineNumber" : 383,
        "startColumnNumber" : 8,
        "endLineNumber" : 472,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try {\n  if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n    if (coordinatorId != null) {\n      validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n      TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n      if (transactionMetadataStore == null) {\n        asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n        return;\n      }\n      List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n      List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n      for (      TxnMeta txnMeta : transactions) {\n        CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n        getTransactionMetadata(txnMeta,completableFuture);\n        completableFutures.add(completableFuture);\n      }\n      FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n        if (e != null) {\n          asyncResponse.resume(new RestException(e.getCause()));\n          return;\n        }\n        Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n        for (        CompletableFuture<TransactionMetadata> future : completableFutures) {\n          try {\n            transactionMetadata.put(future.get().txnId,future.get());\n          }\n catch (          Exception exception) {\n            asyncResponse.resume(new RestException(exception.getCause()));\n            return;\n          }\n        }\n        asyncResponse.resume(transactionMetadata);\n      }\n);\n    }\n else {\n      getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n        if (partitionMetadata.partitions == 0) {\n          asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n          return;\n        }\n        List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n        for (int i=0; i < partitionMetadata.partitions; i++) {\n          try {\n            completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n          }\n catch (          PulsarServerException e) {\n            asyncResponse.resume(new RestException(e));\n            return;\n          }\n        }\n        Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n        FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n          if (e != null) {\n            asyncResponse.resume(new RestException(e));\n            return;\n          }\n          for (          CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n            try {\n              transactionMetadataMaps.putAll(transactionMetadataMap.get());\n            }\n catch (            Exception exception) {\n              asyncResponse.resume(new RestException(exception.getCause()));\n              return;\n            }\n          }\n          asyncResponse.resume(transactionMetadataMaps);\n        }\n);\n      }\n).exceptionally(ex -> {\n        log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n        resumeAsyncResponseExceptionally(asyncResponse,ex);\n        return null;\n      }\n);\n    }\n  }\n else {\n    asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n  }\n}\n catch (Exception e) {\n  asyncResponse.resume(new RestException(e));\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 439,
      "astHeight" : 25
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5258,
        "startLineNumber" : 382,
        "startColumnNumber" : 107,
        "endLineNumber" : 473,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  try {\n    if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n      if (coordinatorId != null) {\n        validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n        TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n        if (transactionMetadataStore == null) {\n          asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n          return;\n        }\n        List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n        List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n        for (        TxnMeta txnMeta : transactions) {\n          CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n          getTransactionMetadata(txnMeta,completableFuture);\n          completableFutures.add(completableFuture);\n        }\n        FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n          if (e != null) {\n            asyncResponse.resume(new RestException(e.getCause()));\n            return;\n          }\n          Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n          for (          CompletableFuture<TransactionMetadata> future : completableFutures) {\n            try {\n              transactionMetadata.put(future.get().txnId,future.get());\n            }\n catch (            Exception exception) {\n              asyncResponse.resume(new RestException(exception.getCause()));\n              return;\n            }\n          }\n          asyncResponse.resume(transactionMetadata);\n        }\n);\n      }\n else {\n        getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n          if (partitionMetadata.partitions == 0) {\n            asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n            return;\n          }\n          List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n          for (int i=0; i < partitionMetadata.partitions; i++) {\n            try {\n              completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n            }\n catch (            PulsarServerException e) {\n              asyncResponse.resume(new RestException(e));\n              return;\n            }\n          }\n          Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n          FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n            if (e != null) {\n              asyncResponse.resume(new RestException(e));\n              return;\n            }\n            for (            CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n              try {\n                transactionMetadataMaps.putAll(transactionMetadataMap.get());\n              }\n catch (              Exception exception) {\n                asyncResponse.resume(new RestException(exception.getCause()));\n                return;\n              }\n            }\n            asyncResponse.resume(transactionMetadataMaps);\n          }\n);\n        }\n).exceptionally(ex -> {\n          log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n          resumeAsyncResponseExceptionally(asyncResponse,ex);\n          return null;\n        }\n);\n      }\n    }\n else {\n      asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n    }\n  }\n catch (  Exception e) {\n    asyncResponse.resume(new RestException(e));\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 440,
      "astHeight" : 26
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5437,
        "startLineNumber" : 381,
        "startColumnNumber" : 4,
        "endLineNumber" : 473,
        "endColumnNumber" : 5
      },
      "nodeContext" : "protected void internalGetSlowTransactions(AsyncResponse asyncResponse,boolean authoritative,long timeout,Integer coordinatorId){\n  try {\n    if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n      if (coordinatorId != null) {\n        validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n        TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n        if (transactionMetadataStore == null) {\n          asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n          return;\n        }\n        List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n        List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n        for (        TxnMeta txnMeta : transactions) {\n          CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n          getTransactionMetadata(txnMeta,completableFuture);\n          completableFutures.add(completableFuture);\n        }\n        FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n          if (e != null) {\n            asyncResponse.resume(new RestException(e.getCause()));\n            return;\n          }\n          Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n          for (          CompletableFuture<TransactionMetadata> future : completableFutures) {\n            try {\n              transactionMetadata.put(future.get().txnId,future.get());\n            }\n catch (            Exception exception) {\n              asyncResponse.resume(new RestException(exception.getCause()));\n              return;\n            }\n          }\n          asyncResponse.resume(transactionMetadata);\n        }\n);\n      }\n else {\n        getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n          if (partitionMetadata.partitions == 0) {\n            asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n            return;\n          }\n          List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n          for (int i=0; i < partitionMetadata.partitions; i++) {\n            try {\n              completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n            }\n catch (            PulsarServerException e) {\n              asyncResponse.resume(new RestException(e));\n              return;\n            }\n          }\n          Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n          FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n            if (e != null) {\n              asyncResponse.resume(new RestException(e));\n              return;\n            }\n            for (            CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n              try {\n                transactionMetadataMaps.putAll(transactionMetadataMap.get());\n              }\n catch (              Exception exception) {\n                asyncResponse.resume(new RestException(exception.getCause()));\n                return;\n              }\n            }\n            asyncResponse.resume(transactionMetadataMaps);\n          }\n);\n        }\n).exceptionally(ex -> {\n          log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n          resumeAsyncResponseExceptionally(asyncResponse,ex);\n          return null;\n        }\n);\n      }\n    }\n else {\n      asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n    }\n  }\n catch (  Exception e) {\n    asyncResponse.resume(new RestException(e));\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 458,
      "astHeight" : 27
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 400,
        "startColumnNumber" : 24,
        "endLineNumber" : 400,
        "endColumnNumber" : 75
      },
      "nodeContext" : "getTransactionMetadata(txnMeta,completableFuture);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.util.concurrent.CompletableFuture<org.apache.pulsar.common.policies.data.TransactionMetadata>"
  }, {
    "nodeContext" : "completableFuture",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 17,
      "startLineNumber" : 401,
      "startColumnNumber" : 47,
      "endLineNumber" : 401,
      "endColumnNumber" : 64
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 401,
        "startColumnNumber" : 24,
        "endLineNumber" : 401,
        "endColumnNumber" : 65
      },
      "nodeContext" : "completableFutures.add(completableFuture)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 401,
        "startColumnNumber" : 24,
        "endLineNumber" : 401,
        "endColumnNumber" : 66
      },
      "nodeContext" : "completableFutures.add(completableFuture);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 276,
        "startLineNumber" : 398,
        "startColumnNumber" : 57,
        "endLineNumber" : 402,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n  getTransactionMetadata(txnMeta,completableFuture);\n  completableFutures.add(completableFuture);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 23,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 313,
        "startLineNumber" : 398,
        "startColumnNumber" : 20,
        "endLineNumber" : 402,
        "endColumnNumber" : 21
      },
      "nodeContext" : "for (TxnMeta txnMeta : transactions) {\n  CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n  getTransactionMetadata(txnMeta,completableFuture);\n  completableFutures.add(completableFuture);\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 29,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2195,
        "startLineNumber" : 385,
        "startColumnNumber" : 43,
        "endLineNumber" : 421,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n  TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n  if (transactionMetadataStore == null) {\n    asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n    return;\n  }\n  List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n  List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n  for (  TxnMeta txnMeta : transactions) {\n    CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n    getTransactionMetadata(txnMeta,completableFuture);\n    completableFutures.add(completableFuture);\n  }\n  FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n    if (e != null) {\n      asyncResponse.resume(new RestException(e.getCause()));\n      return;\n    }\n    Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n    for (    CompletableFuture<TransactionMetadata> future : completableFutures) {\n      try {\n        transactionMetadata.put(future.get().txnId,future.get());\n      }\n catch (      Exception exception) {\n        asyncResponse.resume(new RestException(exception.getCause()));\n        return;\n      }\n    }\n    asyncResponse.resume(transactionMetadata);\n  }\n);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 190,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4898,
        "startLineNumber" : 385,
        "startColumnNumber" : 16,
        "endLineNumber" : 466,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (coordinatorId != null) {\n  validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n  TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n  if (transactionMetadataStore == null) {\n    asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n    return;\n  }\n  List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n  List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n  for (  TxnMeta txnMeta : transactions) {\n    CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n    getTransactionMetadata(txnMeta,completableFuture);\n    completableFutures.add(completableFuture);\n  }\n  FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n    if (e != null) {\n      asyncResponse.resume(new RestException(e.getCause()));\n      return;\n    }\n    Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n    for (    CompletableFuture<TransactionMetadata> future : completableFutures) {\n      try {\n        transactionMetadata.put(future.get().txnId,future.get());\n      }\n catch (      Exception exception) {\n        asyncResponse.resume(new RestException(exception.getCause()));\n        return;\n      }\n    }\n    asyncResponse.resume(transactionMetadata);\n  }\n);\n}\n else {\n  getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n    if (partitionMetadata.partitions == 0) {\n      asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n      return;\n    }\n    List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n    for (int i=0; i < partitionMetadata.partitions; i++) {\n      try {\n        completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n      }\n catch (      PulsarServerException e) {\n        asyncResponse.resume(new RestException(e));\n        return;\n      }\n    }\n    Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n    FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n      if (e != null) {\n        asyncResponse.resume(new RestException(e));\n        return;\n      }\n      for (      CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n        try {\n          transactionMetadataMaps.putAll(transactionMetadataMap.get());\n        }\n catch (        Exception exception) {\n          asyncResponse.resume(new RestException(exception.getCause()));\n          return;\n        }\n      }\n      asyncResponse.resume(transactionMetadataMaps);\n    }\n);\n  }\n).exceptionally(ex -> {\n    log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n    resumeAsyncResponseExceptionally(asyncResponse,ex);\n    return null;\n  }\n);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 405,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 4930,
        "startLineNumber" : 384,
        "startColumnNumber" : 72,
        "endLineNumber" : 467,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  if (coordinatorId != null) {\n    validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n    TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n    if (transactionMetadataStore == null) {\n      asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n      return;\n    }\n    List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n    List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n    for (    TxnMeta txnMeta : transactions) {\n      CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n      getTransactionMetadata(txnMeta,completableFuture);\n      completableFutures.add(completableFuture);\n    }\n    FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n      if (e != null) {\n        asyncResponse.resume(new RestException(e.getCause()));\n        return;\n      }\n      Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n      for (      CompletableFuture<TransactionMetadata> future : completableFutures) {\n        try {\n          transactionMetadata.put(future.get().txnId,future.get());\n        }\n catch (        Exception exception) {\n          asyncResponse.resume(new RestException(exception.getCause()));\n          return;\n        }\n      }\n      asyncResponse.resume(transactionMetadata);\n    }\n);\n  }\n else {\n    getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n      if (partitionMetadata.partitions == 0) {\n        asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n        return;\n      }\n      List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n      for (int i=0; i < partitionMetadata.partitions; i++) {\n        try {\n          completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n        }\n catch (        PulsarServerException e) {\n          asyncResponse.resume(new RestException(e));\n          return;\n        }\n      }\n      Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n      FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n        if (e != null) {\n          asyncResponse.resume(new RestException(e));\n          return;\n        }\n        for (        CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n          try {\n            transactionMetadataMaps.putAll(transactionMetadataMap.get());\n          }\n catch (          Exception exception) {\n            asyncResponse.resume(new RestException(exception.getCause()));\n            return;\n          }\n        }\n        asyncResponse.resume(transactionMetadataMaps);\n      }\n);\n    }\n).exceptionally(ex -> {\n      log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n      resumeAsyncResponseExceptionally(asyncResponse,ex);\n      return null;\n    }\n);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 406,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5126,
        "startLineNumber" : 384,
        "startColumnNumber" : 12,
        "endLineNumber" : 469,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n  if (coordinatorId != null) {\n    validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n    TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n    if (transactionMetadataStore == null) {\n      asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n      return;\n    }\n    List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n    List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n    for (    TxnMeta txnMeta : transactions) {\n      CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n      getTransactionMetadata(txnMeta,completableFuture);\n      completableFutures.add(completableFuture);\n    }\n    FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n      if (e != null) {\n        asyncResponse.resume(new RestException(e.getCause()));\n        return;\n      }\n      Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n      for (      CompletableFuture<TransactionMetadata> future : completableFutures) {\n        try {\n          transactionMetadata.put(future.get().txnId,future.get());\n        }\n catch (        Exception exception) {\n          asyncResponse.resume(new RestException(exception.getCause()));\n          return;\n        }\n      }\n      asyncResponse.resume(transactionMetadata);\n    }\n);\n  }\n else {\n    getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n      if (partitionMetadata.partitions == 0) {\n        asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n        return;\n      }\n      List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n      for (int i=0; i < partitionMetadata.partitions; i++) {\n        try {\n          completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n        }\n catch (        PulsarServerException e) {\n          asyncResponse.resume(new RestException(e));\n          return;\n        }\n      }\n      Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n      FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n        if (e != null) {\n          asyncResponse.resume(new RestException(e));\n          return;\n        }\n        for (        CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n          try {\n            transactionMetadataMaps.putAll(transactionMetadataMap.get());\n          }\n catch (          Exception exception) {\n            asyncResponse.resume(new RestException(exception.getCause()));\n            return;\n          }\n        }\n        asyncResponse.resume(transactionMetadataMaps);\n      }\n);\n    }\n).exceptionally(ex -> {\n      log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n      resumeAsyncResponseExceptionally(asyncResponse,ex);\n      return null;\n    }\n);\n  }\n}\n else {\n  asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 423,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5150,
        "startLineNumber" : 383,
        "startColumnNumber" : 12,
        "endLineNumber" : 470,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n    if (coordinatorId != null) {\n      validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n      TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n      if (transactionMetadataStore == null) {\n        asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n        return;\n      }\n      List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n      List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n      for (      TxnMeta txnMeta : transactions) {\n        CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n        getTransactionMetadata(txnMeta,completableFuture);\n        completableFutures.add(completableFuture);\n      }\n      FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n        if (e != null) {\n          asyncResponse.resume(new RestException(e.getCause()));\n          return;\n        }\n        Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n        for (        CompletableFuture<TransactionMetadata> future : completableFutures) {\n          try {\n            transactionMetadata.put(future.get().txnId,future.get());\n          }\n catch (          Exception exception) {\n            asyncResponse.resume(new RestException(exception.getCause()));\n            return;\n          }\n        }\n        asyncResponse.resume(transactionMetadata);\n      }\n);\n    }\n else {\n      getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n        if (partitionMetadata.partitions == 0) {\n          asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n          return;\n        }\n        List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n        for (int i=0; i < partitionMetadata.partitions; i++) {\n          try {\n            completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n          }\n catch (          PulsarServerException e) {\n            asyncResponse.resume(new RestException(e));\n            return;\n          }\n        }\n        Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n        FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n          if (e != null) {\n            asyncResponse.resume(new RestException(e));\n            return;\n          }\n          for (          CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n            try {\n              transactionMetadataMaps.putAll(transactionMetadataMap.get());\n            }\n catch (            Exception exception) {\n              asyncResponse.resume(new RestException(exception.getCause()));\n              return;\n            }\n          }\n          asyncResponse.resume(transactionMetadataMaps);\n        }\n);\n      }\n).exceptionally(ex -> {\n        log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n        resumeAsyncResponseExceptionally(asyncResponse,ex);\n        return null;\n      }\n);\n    }\n  }\n else {\n    asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 424,
      "astHeight" : 24
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5242,
        "startLineNumber" : 383,
        "startColumnNumber" : 8,
        "endLineNumber" : 472,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try {\n  if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n    if (coordinatorId != null) {\n      validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n      TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n      if (transactionMetadataStore == null) {\n        asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n        return;\n      }\n      List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n      List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n      for (      TxnMeta txnMeta : transactions) {\n        CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n        getTransactionMetadata(txnMeta,completableFuture);\n        completableFutures.add(completableFuture);\n      }\n      FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n        if (e != null) {\n          asyncResponse.resume(new RestException(e.getCause()));\n          return;\n        }\n        Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n        for (        CompletableFuture<TransactionMetadata> future : completableFutures) {\n          try {\n            transactionMetadata.put(future.get().txnId,future.get());\n          }\n catch (          Exception exception) {\n            asyncResponse.resume(new RestException(exception.getCause()));\n            return;\n          }\n        }\n        asyncResponse.resume(transactionMetadata);\n      }\n);\n    }\n else {\n      getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n        if (partitionMetadata.partitions == 0) {\n          asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n          return;\n        }\n        List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n        for (int i=0; i < partitionMetadata.partitions; i++) {\n          try {\n            completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n          }\n catch (          PulsarServerException e) {\n            asyncResponse.resume(new RestException(e));\n            return;\n          }\n        }\n        Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n        FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n          if (e != null) {\n            asyncResponse.resume(new RestException(e));\n            return;\n          }\n          for (          CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n            try {\n              transactionMetadataMaps.putAll(transactionMetadataMap.get());\n            }\n catch (            Exception exception) {\n              asyncResponse.resume(new RestException(exception.getCause()));\n              return;\n            }\n          }\n          asyncResponse.resume(transactionMetadataMaps);\n        }\n);\n      }\n).exceptionally(ex -> {\n        log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n        resumeAsyncResponseExceptionally(asyncResponse,ex);\n        return null;\n      }\n);\n    }\n  }\n else {\n    asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n  }\n}\n catch (Exception e) {\n  asyncResponse.resume(new RestException(e));\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 439,
      "astHeight" : 25
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5258,
        "startLineNumber" : 382,
        "startColumnNumber" : 107,
        "endLineNumber" : 473,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  try {\n    if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n      if (coordinatorId != null) {\n        validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n        TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n        if (transactionMetadataStore == null) {\n          asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n          return;\n        }\n        List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n        List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n        for (        TxnMeta txnMeta : transactions) {\n          CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n          getTransactionMetadata(txnMeta,completableFuture);\n          completableFutures.add(completableFuture);\n        }\n        FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n          if (e != null) {\n            asyncResponse.resume(new RestException(e.getCause()));\n            return;\n          }\n          Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n          for (          CompletableFuture<TransactionMetadata> future : completableFutures) {\n            try {\n              transactionMetadata.put(future.get().txnId,future.get());\n            }\n catch (            Exception exception) {\n              asyncResponse.resume(new RestException(exception.getCause()));\n              return;\n            }\n          }\n          asyncResponse.resume(transactionMetadata);\n        }\n);\n      }\n else {\n        getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n          if (partitionMetadata.partitions == 0) {\n            asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n            return;\n          }\n          List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n          for (int i=0; i < partitionMetadata.partitions; i++) {\n            try {\n              completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n            }\n catch (            PulsarServerException e) {\n              asyncResponse.resume(new RestException(e));\n              return;\n            }\n          }\n          Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n          FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n            if (e != null) {\n              asyncResponse.resume(new RestException(e));\n              return;\n            }\n            for (            CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n              try {\n                transactionMetadataMaps.putAll(transactionMetadataMap.get());\n              }\n catch (              Exception exception) {\n                asyncResponse.resume(new RestException(exception.getCause()));\n                return;\n              }\n            }\n            asyncResponse.resume(transactionMetadataMaps);\n          }\n);\n        }\n).exceptionally(ex -> {\n          log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n          resumeAsyncResponseExceptionally(asyncResponse,ex);\n          return null;\n        }\n);\n      }\n    }\n else {\n      asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n    }\n  }\n catch (  Exception e) {\n    asyncResponse.resume(new RestException(e));\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 440,
      "astHeight" : 26
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5437,
        "startLineNumber" : 381,
        "startColumnNumber" : 4,
        "endLineNumber" : 473,
        "endColumnNumber" : 5
      },
      "nodeContext" : "protected void internalGetSlowTransactions(AsyncResponse asyncResponse,boolean authoritative,long timeout,Integer coordinatorId){\n  try {\n    if (pulsar().getConfig().isTransactionCoordinatorEnabled()) {\n      if (coordinatorId != null) {\n        validateTopicOwnership(TopicName.TRANSACTION_COORDINATOR_ASSIGN.getPartition(coordinatorId),authoritative);\n        TransactionMetadataStore transactionMetadataStore=pulsar().getTransactionMetadataStoreService().getStores().get(TransactionCoordinatorID.get(coordinatorId));\n        if (transactionMetadataStore == null) {\n          asyncResponse.resume(new RestException(NOT_FOUND,\"Transaction coordinator not found! coordinator id : \" + coordinatorId));\n          return;\n        }\n        List<TxnMeta> transactions=transactionMetadataStore.getSlowTransactions(timeout);\n        List<CompletableFuture<TransactionMetadata>> completableFutures=new ArrayList<>();\n        for (        TxnMeta txnMeta : transactions) {\n          CompletableFuture<TransactionMetadata> completableFuture=new CompletableFuture<>();\n          getTransactionMetadata(txnMeta,completableFuture);\n          completableFutures.add(completableFuture);\n        }\n        FutureUtil.waitForAll(completableFutures).whenComplete((v,e) -> {\n          if (e != null) {\n            asyncResponse.resume(new RestException(e.getCause()));\n            return;\n          }\n          Map<String,TransactionMetadata> transactionMetadata=new HashMap<>();\n          for (          CompletableFuture<TransactionMetadata> future : completableFutures) {\n            try {\n              transactionMetadata.put(future.get().txnId,future.get());\n            }\n catch (            Exception exception) {\n              asyncResponse.resume(new RestException(exception.getCause()));\n              return;\n            }\n          }\n          asyncResponse.resume(transactionMetadata);\n        }\n);\n      }\n else {\n        getPartitionedTopicMetadataAsync(TopicName.TRANSACTION_COORDINATOR_ASSIGN,false,false).thenAccept(partitionMetadata -> {\n          if (partitionMetadata.partitions == 0) {\n            asyncResponse.resume(new RestException(Response.Status.NOT_FOUND,\"Transaction coordinator not found\"));\n            return;\n          }\n          List<CompletableFuture<Map<String,TransactionMetadata>>> completableFutures=Lists.newArrayList();\n          for (int i=0; i < partitionMetadata.partitions; i++) {\n            try {\n              completableFutures.add(pulsar().getAdminClient().transactions().getSlowTransactionsByCoordinatorIdAsync(i,timeout,TimeUnit.MILLISECONDS));\n            }\n catch (            PulsarServerException e) {\n              asyncResponse.resume(new RestException(e));\n              return;\n            }\n          }\n          Map<String,TransactionMetadata> transactionMetadataMaps=new HashMap<>();\n          FutureUtil.waitForAll(completableFutures).whenComplete((result,e) -> {\n            if (e != null) {\n              asyncResponse.resume(new RestException(e));\n              return;\n            }\n            for (            CompletableFuture<Map<String,TransactionMetadata>> transactionMetadataMap : completableFutures) {\n              try {\n                transactionMetadataMaps.putAll(transactionMetadataMap.get());\n              }\n catch (              Exception exception) {\n                asyncResponse.resume(new RestException(exception.getCause()));\n                return;\n              }\n            }\n            asyncResponse.resume(transactionMetadataMaps);\n          }\n);\n        }\n).exceptionally(ex -> {\n          log.error(\"[{}] Failed to get transaction coordinator state.\",clientAppId(),ex);\n          resumeAsyncResponseExceptionally(asyncResponse,ex);\n          return null;\n        }\n);\n      }\n    }\n else {\n      asyncResponse.resume(new RestException(SERVICE_UNAVAILABLE,\"Broker don't support transaction!\"));\n    }\n  }\n catch (  Exception e) {\n    asyncResponse.resume(new RestException(e));\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 458,
      "astHeight" : 27
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 401,
        "startColumnNumber" : 24,
        "endLineNumber" : 401,
        "endColumnNumber" : 66
      },
      "nodeContext" : "completableFutures.add(completableFuture);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.util.concurrent.CompletableFuture<org.apache.pulsar.common.policies.data.TransactionMetadata>"
  } ],
  "positionList" : [ {
    "charLength" : 17,
    "startLineNumber" : 400,
    "startColumnNumber" : 56,
    "endLineNumber" : 400,
    "endColumnNumber" : 73
  }, {
    "charLength" : 17,
    "startLineNumber" : 401,
    "startColumnNumber" : 47,
    "endLineNumber" : 401,
    "endColumnNumber" : 64
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 2
  } ]
}