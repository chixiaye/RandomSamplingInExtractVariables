{
  "id" : 290,
  "expression" : "\"struct \" + rec_name + \" {\\n\"",
  "projectName" : "apache@zookeeper",
  "commitID" : "c6639c9842973a7954c8baa412d6825cb833d51f",
  "filePath" : "/src/java/main/org/apache/jute/compiler/JRecord.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "\"struct \" + rec_name + \" {\\n\"",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 29,
      "startLineNumber" : 172,
      "startColumnNumber" : 10,
      "endLineNumber" : 172,
      "endColumnNumber" : 39
    },
    "astNodeNumber" : 4,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 172,
        "startColumnNumber" : 2,
        "endLineNumber" : 172,
        "endColumnNumber" : 40
      },
      "nodeContext" : "h.write(\"struct \" + rec_name + \" {\\n\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 172,
        "startColumnNumber" : 2,
        "endLineNumber" : 172,
        "endColumnNumber" : 41
      },
      "nodeContext" : "h.write(\"struct \" + rec_name + \" {\\n\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 5016,
        "startLineNumber" : 109,
        "startColumnNumber" : 72,
        "endLineNumber" : 213,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  for (  JField f : mFields) {\n    if (f.getType() instanceof JVector) {\n      JVector jv=(JVector)f.getType();\n      JType jvType=jv.getElementType();\n      String struct_name=JVector.extractVectorName(jvType);\n      if (vectorStructs.get(struct_name) == null) {\n        vectorStructs.put(struct_name,struct_name);\n        h.write(\"struct \" + struct_name + \" {\\n    int32_t count;\\n\"+ jv.getElementType().genCDecl(\"*data\")+ \";\\n};\\n\");\n        h.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \"+ struct_name+ \" *v);\\n\");\n        h.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \"+ struct_name+ \" *v);\\n\");\n        h.write(\"int allocate_\" + struct_name + \"(struct \"+ struct_name+ \" *v, int32_t len);\\n\");\n        h.write(\"int deallocate_\" + struct_name + \"(struct \"+ struct_name+ \" *v);\\n\");\n        c.write(\"int allocate_\" + struct_name + \"(struct \"+ struct_name+ \" *v, int32_t len) {\\n\");\n        c.write(\"    if (!len) {\\n\");\n        c.write(\"        v->count = 0;\\n\");\n        c.write(\"        v->data = 0;\\n\");\n        c.write(\"    } else {\\n\");\n        c.write(\"        v->count = len;\\n\");\n        c.write(\"        v->data = calloc(sizeof(*v->data), len);\\n\");\n        c.write(\"    }\\n\");\n        c.write(\"    return 0;\\n\");\n        c.write(\"}\\n\");\n        c.write(\"int deallocate_\" + struct_name + \"(struct \"+ struct_name+ \" *v) {\\n\");\n        c.write(\"    if (v->data) {\\n\");\n        c.write(\"        int32_t i;\\n\");\n        c.write(\"        for(i=0;i<v->count; i++) {\\n\");\n        c.write(\"            deallocate_\" + JRecord.extractMethodSuffix(jvType) + \"(&v->data[i]);\\n\");\n        c.write(\"        }\\n\");\n        c.write(\"        free(v->data);\\n\");\n        c.write(\"        v->data = 0;\\n\");\n        c.write(\"    }\\n\");\n        c.write(\"    return 0;\\n\");\n        c.write(\"}\\n\");\n        c.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \"+ struct_name+ \" *v)\\n\");\n        c.write(\"{\\n\");\n        c.write(\"    int32_t count = v->count;\\n\");\n        c.write(\"    int rc = 0;\\n\");\n        c.write(\"    int32_t i;\\n\");\n        c.write(\"    rc = out->start_vector(out, tag, &count);\\n\");\n        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n        genSerialize(c,jvType,\"data\",\"data[i]\");\n        c.write(\"    }\\n\");\n        c.write(\"    rc = rc ? : out->end_vector(out, tag);\\n\");\n        c.write(\"    return rc;\\n\");\n        c.write(\"}\\n\");\n        c.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \"+ struct_name+ \" *v)\\n\");\n        c.write(\"{\\n\");\n        c.write(\"    int rc = 0;\\n\");\n        c.write(\"    int32_t i;\\n\");\n        c.write(\"    rc = in->start_vector(in, tag, &v->count);\\n\");\n        c.write(\"    v->data = calloc(v->count, sizeof(*v->data));\\n\");\n        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n        genDeserialize(c,jvType,\"value\",\"data[i]\");\n        c.write(\"    }\\n\");\n        c.write(\"    rc = in->end_vector(in, tag);\\n\");\n        c.write(\"    return rc;\\n\");\n        c.write(\"}\\n\");\n      }\n    }\n  }\n  String rec_name=getName();\n  h.write(\"struct \" + rec_name + \" {\\n\");\n  for (  JField f : mFields) {\n    h.write(f.genCDecl());\n  }\n  h.write(\"};\\n\");\n  h.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \"+ rec_name+ \" *v);\\n\");\n  h.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \"+ rec_name+ \"*v);\\n\");\n  h.write(\"void deallocate_\" + rec_name + \"(struct \"+ rec_name+ \"*);\\n\");\n  c.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \"+ rec_name+ \" *v)\");\n  c.write(\"{\\n\");\n  c.write(\"    int rc;\\n\");\n  c.write(\"    rc = out->start_record(out, tag);\\n\");\n  for (  JField f : mFields) {\n    genSerialize(c,f.getType(),f.getTag(),f.getName());\n  }\n  c.write(\"    rc = rc ? : out->end_record(out, tag);\\n\");\n  c.write(\"    return rc;\\n\");\n  c.write(\"}\\n\");\n  c.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \"+ rec_name+ \"*v)\");\n  c.write(\"{\\n\");\n  c.write(\"    int rc;\\n\");\n  c.write(\"    rc = in->start_record(in, tag);\\n\");\n  for (  JField f : mFields) {\n    genDeserialize(c,f.getType(),f.getTag(),f.getName());\n  }\n  c.write(\"    rc = rc ? : in->end_record(in, tag);\\n\");\n  c.write(\"    return rc;\\n\");\n  c.write(\"}\\n\");\n  c.write(\"void deallocate_\" + rec_name + \"(struct \"+ rec_name+ \"*v)\");\n  c.write(\"{\\n\");\n  for (  JField f : mFields) {\n    if (f.getType() instanceof JRecord) {\n      c.write(\"    deallocate_\" + extractStructName(f.getType()) + \"(&v->\"+ f.getName()+ \");\\n\");\n    }\n else     if (f.getType() instanceof JVector) {\n      JVector vt=(JVector)f.getType();\n      c.write(\"    deallocate_\" + JVector.extractVectorName(vt.getElementType()) + \"(&v->\"+ f.getName()+ \");\\n\");\n    }\n else     if (f.getType() instanceof JCompType) {\n      c.write(\"    deallocate_\" + extractMethodSuffix(f.getType()) + \"(&v->\"+ f.getName()+ \");\\n\");\n    }\n  }\n  c.write(\"}\\n\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 663,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5084,
        "startLineNumber" : 109,
        "startColumnNumber" : 4,
        "endLineNumber" : 213,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void genCCode(FileWriter h,FileWriter c) throws IOException {\n  for (  JField f : mFields) {\n    if (f.getType() instanceof JVector) {\n      JVector jv=(JVector)f.getType();\n      JType jvType=jv.getElementType();\n      String struct_name=JVector.extractVectorName(jvType);\n      if (vectorStructs.get(struct_name) == null) {\n        vectorStructs.put(struct_name,struct_name);\n        h.write(\"struct \" + struct_name + \" {\\n    int32_t count;\\n\"+ jv.getElementType().genCDecl(\"*data\")+ \";\\n};\\n\");\n        h.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \"+ struct_name+ \" *v);\\n\");\n        h.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \"+ struct_name+ \" *v);\\n\");\n        h.write(\"int allocate_\" + struct_name + \"(struct \"+ struct_name+ \" *v, int32_t len);\\n\");\n        h.write(\"int deallocate_\" + struct_name + \"(struct \"+ struct_name+ \" *v);\\n\");\n        c.write(\"int allocate_\" + struct_name + \"(struct \"+ struct_name+ \" *v, int32_t len) {\\n\");\n        c.write(\"    if (!len) {\\n\");\n        c.write(\"        v->count = 0;\\n\");\n        c.write(\"        v->data = 0;\\n\");\n        c.write(\"    } else {\\n\");\n        c.write(\"        v->count = len;\\n\");\n        c.write(\"        v->data = calloc(sizeof(*v->data), len);\\n\");\n        c.write(\"    }\\n\");\n        c.write(\"    return 0;\\n\");\n        c.write(\"}\\n\");\n        c.write(\"int deallocate_\" + struct_name + \"(struct \"+ struct_name+ \" *v) {\\n\");\n        c.write(\"    if (v->data) {\\n\");\n        c.write(\"        int32_t i;\\n\");\n        c.write(\"        for(i=0;i<v->count; i++) {\\n\");\n        c.write(\"            deallocate_\" + JRecord.extractMethodSuffix(jvType) + \"(&v->data[i]);\\n\");\n        c.write(\"        }\\n\");\n        c.write(\"        free(v->data);\\n\");\n        c.write(\"        v->data = 0;\\n\");\n        c.write(\"    }\\n\");\n        c.write(\"    return 0;\\n\");\n        c.write(\"}\\n\");\n        c.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \"+ struct_name+ \" *v)\\n\");\n        c.write(\"{\\n\");\n        c.write(\"    int32_t count = v->count;\\n\");\n        c.write(\"    int rc = 0;\\n\");\n        c.write(\"    int32_t i;\\n\");\n        c.write(\"    rc = out->start_vector(out, tag, &count);\\n\");\n        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n        genSerialize(c,jvType,\"data\",\"data[i]\");\n        c.write(\"    }\\n\");\n        c.write(\"    rc = rc ? : out->end_vector(out, tag);\\n\");\n        c.write(\"    return rc;\\n\");\n        c.write(\"}\\n\");\n        c.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \"+ struct_name+ \" *v)\\n\");\n        c.write(\"{\\n\");\n        c.write(\"    int rc = 0;\\n\");\n        c.write(\"    int32_t i;\\n\");\n        c.write(\"    rc = in->start_vector(in, tag, &v->count);\\n\");\n        c.write(\"    v->data = calloc(v->count, sizeof(*v->data));\\n\");\n        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n        genDeserialize(c,jvType,\"value\",\"data[i]\");\n        c.write(\"    }\\n\");\n        c.write(\"    rc = in->end_vector(in, tag);\\n\");\n        c.write(\"    return rc;\\n\");\n        c.write(\"}\\n\");\n      }\n    }\n  }\n  String rec_name=getName();\n  h.write(\"struct \" + rec_name + \" {\\n\");\n  for (  JField f : mFields) {\n    h.write(f.genCDecl());\n  }\n  h.write(\"};\\n\");\n  h.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \"+ rec_name+ \" *v);\\n\");\n  h.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \"+ rec_name+ \"*v);\\n\");\n  h.write(\"void deallocate_\" + rec_name + \"(struct \"+ rec_name+ \"*);\\n\");\n  c.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \"+ rec_name+ \" *v)\");\n  c.write(\"{\\n\");\n  c.write(\"    int rc;\\n\");\n  c.write(\"    rc = out->start_record(out, tag);\\n\");\n  for (  JField f : mFields) {\n    genSerialize(c,f.getType(),f.getTag(),f.getName());\n  }\n  c.write(\"    rc = rc ? : out->end_record(out, tag);\\n\");\n  c.write(\"    return rc;\\n\");\n  c.write(\"}\\n\");\n  c.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \"+ rec_name+ \"*v)\");\n  c.write(\"{\\n\");\n  c.write(\"    int rc;\\n\");\n  c.write(\"    rc = in->start_record(in, tag);\\n\");\n  for (  JField f : mFields) {\n    genDeserialize(c,f.getType(),f.getTag(),f.getName());\n  }\n  c.write(\"    rc = rc ? : in->end_record(in, tag);\\n\");\n  c.write(\"    return rc;\\n\");\n  c.write(\"}\\n\");\n  c.write(\"void deallocate_\" + rec_name + \"(struct \"+ rec_name+ \"*v)\");\n  c.write(\"{\\n\");\n  for (  JField f : mFields) {\n    if (f.getType() instanceof JRecord) {\n      c.write(\"    deallocate_\" + extractStructName(f.getType()) + \"(&v->\"+ f.getName()+ \");\\n\");\n    }\n else     if (f.getType() instanceof JVector) {\n      JVector vt=(JVector)f.getType();\n      c.write(\"    deallocate_\" + JVector.extractVectorName(vt.getElementType()) + \"(&v->\"+ f.getName()+ \");\\n\");\n    }\n else     if (f.getType() instanceof JCompType) {\n      c.write(\"    deallocate_\" + extractMethodSuffix(f.getType()) + \"(&v->\"+ f.getName()+ \");\\n\");\n    }\n  }\n  c.write(\"}\\n\");\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 677,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 172,
        "startColumnNumber" : 2,
        "endLineNumber" : 172,
        "endColumnNumber" : 41
      },
      "nodeContext" : "h.write(\"struct \" + rec_name + \" {\\n\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 6,
    "type" : "java.lang.String"
  } ],
  "positionList" : [ {
    "charLength" : 29,
    "startLineNumber" : 172,
    "startColumnNumber" : 10,
    "endLineNumber" : 172,
    "endColumnNumber" : 39
  } ],
  "layoutRelationDataList" : [ ]
}