{
  "id" : 33,
  "expression" : "o instanceof OutputModelObject[]",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/tool/src/org/antlr/v4/codegen/OutputModelWalker.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "o instanceof OutputModelObject[]",
    "nodeType" : "InstanceofExpression",
    "nodePosition" : {
      "charLength" : 32,
      "startLineNumber" : 110,
      "startColumnNumber" : 41,
      "endLineNumber" : 110,
      "endColumnNumber" : 73
    },
    "astNodeNumber" : 6,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 59,
        "startLineNumber" : 110,
        "startColumnNumber" : 14,
        "endLineNumber" : 110,
        "endColumnNumber" : 73
      },
      "nodeContext" : "o instanceof Collection || o instanceof OutputModelObject[]",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 1140,
        "startLineNumber" : 110,
        "startColumnNumber" : 9,
        "endLineNumber" : 135,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (o instanceof Collection || o instanceof OutputModelObject[]) {\n  if (o instanceof OutputModelObject[]) {\n    o=Arrays.asList((OutputModelObject[])o);\n  }\n  Collection<?> nestedOmos=(Collection<?>)o;\n  for (  Object nestedOmo : nestedOmos) {\n    if (nestedOmo == null)     continue;\n    ST nestedST=walk((OutputModelObject)nestedOmo,header);\n    st.add(fieldName,nestedST);\n  }\n}\n else if (o instanceof Map) {\n  Map<?,?> nestedOmoMap=(Map<?,?>)o;\n  Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n  for (  Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n    ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n    m.put(entry.getKey(),nestedST);\n  }\n  st.add(fieldName,m);\n}\n else if (o != null) {\n  tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 174,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1452,
        "startLineNumber" : 104,
        "startColumnNumber" : 4,
        "endLineNumber" : 135,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (o instanceof OutputModelObject) {\n  OutputModelObject nestedOmo=(OutputModelObject)o;\n  ST nestedST=walk(nestedOmo,header);\n  st.add(fieldName,nestedST);\n}\n else if (o instanceof Collection || o instanceof OutputModelObject[]) {\n  if (o instanceof OutputModelObject[]) {\n    o=Arrays.asList((OutputModelObject[])o);\n  }\n  Collection<?> nestedOmos=(Collection<?>)o;\n  for (  Object nestedOmo : nestedOmos) {\n    if (nestedOmo == null)     continue;\n    ST nestedST=walk((OutputModelObject)nestedOmo,header);\n    st.add(fieldName,nestedST);\n  }\n}\n else if (o instanceof Map) {\n  Map<?,?> nestedOmoMap=(Map<?,?>)o;\n  Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n  for (  Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n    ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n    m.put(entry.getKey(),nestedST);\n  }\n  st.add(fieldName,m);\n}\n else if (o != null) {\n  tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 204,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 1494,
        "startLineNumber" : 102,
        "startColumnNumber" : 7,
        "endLineNumber" : 136,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  Object o=fi.get(omo);\n  if (o instanceof OutputModelObject) {\n    OutputModelObject nestedOmo=(OutputModelObject)o;\n    ST nestedST=walk(nestedOmo,header);\n    st.add(fieldName,nestedST);\n  }\n else   if (o instanceof Collection || o instanceof OutputModelObject[]) {\n    if (o instanceof OutputModelObject[]) {\n      o=Arrays.asList((OutputModelObject[])o);\n    }\n    Collection<?> nestedOmos=(Collection<?>)o;\n    for (    Object nestedOmo : nestedOmos) {\n      if (nestedOmo == null)       continue;\n      ST nestedST=walk((OutputModelObject)nestedOmo,header);\n      st.add(fieldName,nestedST);\n    }\n  }\n else   if (o instanceof Map) {\n    Map<?,?> nestedOmoMap=(Map<?,?>)o;\n    Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n    for (    Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n      ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n      m.put(entry.getKey(),nestedST);\n    }\n    st.add(fieldName,m);\n  }\n else   if (o != null) {\n    tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 214,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1633,
        "startLineNumber" : 102,
        "startColumnNumber" : 3,
        "endLineNumber" : 139,
        "endColumnNumber" : 4
      },
      "nodeContext" : "try {\n  Object o=fi.get(omo);\n  if (o instanceof OutputModelObject) {\n    OutputModelObject nestedOmo=(OutputModelObject)o;\n    ST nestedST=walk(nestedOmo,header);\n    st.add(fieldName,nestedST);\n  }\n else   if (o instanceof Collection || o instanceof OutputModelObject[]) {\n    if (o instanceof OutputModelObject[]) {\n      o=Arrays.asList((OutputModelObject[])o);\n    }\n    Collection<?> nestedOmos=(Collection<?>)o;\n    for (    Object nestedOmo : nestedOmos) {\n      if (nestedOmo == null)       continue;\n      ST nestedST=walk((OutputModelObject)nestedOmo,header);\n      st.add(fieldName,nestedST);\n    }\n  }\n else   if (o instanceof Map) {\n    Map<?,?> nestedOmoMap=(Map<?,?>)o;\n    Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n    for (    Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n      ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n      m.put(entry.getKey(),nestedST);\n    }\n    st.add(fieldName,m);\n  }\n else   if (o != null) {\n    tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n  }\n}\n catch (IllegalAccessException iae) {\n  tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 232,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 2150,
        "startLineNumber" : 86,
        "startColumnNumber" : 26,
        "endLineNumber" : 140,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  ModelElement annotation=fi.getAnnotation(ModelElement.class);\n  if (annotation == null) {\n    continue;\n  }\n  String fieldName=fi.getName();\n  if (!usedFieldNames.add(fieldName)) {\n    tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n    continue;\n  }\n  if (formalArgs.get(fieldName) == null)   continue;\n  try {\n    Object o=fi.get(omo);\n    if (o instanceof OutputModelObject) {\n      OutputModelObject nestedOmo=(OutputModelObject)o;\n      ST nestedST=walk(nestedOmo,header);\n      st.add(fieldName,nestedST);\n    }\n else     if (o instanceof Collection || o instanceof OutputModelObject[]) {\n      if (o instanceof OutputModelObject[]) {\n        o=Arrays.asList((OutputModelObject[])o);\n      }\n      Collection<?> nestedOmos=(Collection<?>)o;\n      for (      Object nestedOmo : nestedOmos) {\n        if (nestedOmo == null)         continue;\n        ST nestedST=walk((OutputModelObject)nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n    }\n else     if (o instanceof Map) {\n      Map<?,?> nestedOmoMap=(Map<?,?>)o;\n      Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n      for (      Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n        ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n        m.put(entry.getKey(),nestedST);\n      }\n      st.add(fieldName,m);\n    }\n else     if (o != null) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n    }\n  }\n catch (  IllegalAccessException iae) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 293,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2174,
        "startLineNumber" : 86,
        "startColumnNumber" : 2,
        "endLineNumber" : 140,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (Field fi : fields) {\n  ModelElement annotation=fi.getAnnotation(ModelElement.class);\n  if (annotation == null) {\n    continue;\n  }\n  String fieldName=fi.getName();\n  if (!usedFieldNames.add(fieldName)) {\n    tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n    continue;\n  }\n  if (formalArgs.get(fieldName) == null)   continue;\n  try {\n    Object o=fi.get(omo);\n    if (o instanceof OutputModelObject) {\n      OutputModelObject nestedOmo=(OutputModelObject)o;\n      ST nestedST=walk(nestedOmo,header);\n      st.add(fieldName,nestedST);\n    }\n else     if (o instanceof Collection || o instanceof OutputModelObject[]) {\n      if (o instanceof OutputModelObject[]) {\n        o=Arrays.asList((OutputModelObject[])o);\n      }\n      Collection<?> nestedOmos=(Collection<?>)o;\n      for (      Object nestedOmo : nestedOmos) {\n        if (nestedOmo == null)         continue;\n        ST nestedST=walk((OutputModelObject)nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n    }\n else     if (o instanceof Map) {\n      Map<?,?> nestedOmoMap=(Map<?,?>)o;\n      Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n      for (      Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n        ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n        m.put(entry.getKey(),nestedST);\n      }\n      st.add(fieldName,m);\n    }\n else     if (o != null) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n    }\n  }\n catch (  IllegalAccessException iae) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 299,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3463,
        "startLineNumber" : 54,
        "startColumnNumber" : 55,
        "endLineNumber" : 143,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  Class<? extends OutputModelObject> cl=omo.getClass();\n  String templateName=cl.getSimpleName();\n  if (templateName == null) {\n    tool.errMgr.toolError(ErrorType.NO_MODEL_TO_TEMPLATE_MAPPING,cl.getSimpleName());\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (header)   templateName+=\"Header\";\n  ST st=templates.getInstanceOf(templateName);\n  if (st == null) {\n    tool.errMgr.toolError(ErrorType.CODE_GEN_TEMPLATES_INCOMPLETE,templateName);\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (st.impl.formalArguments == null) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,\"<none>\");\n    return st;\n  }\n  Map<String,FormalArgument> formalArgs=st.impl.formalArguments;\n  Set<String> argNames=formalArgs.keySet();\n  Iterator<String> arg_it=argNames.iterator();\n  String modelArgName=arg_it.next();\n  st.add(modelArgName,omo);\n  Set<String> usedFieldNames=new HashSet<String>();\n  Field fields[]=cl.getFields();\n  for (  Field fi : fields) {\n    ModelElement annotation=fi.getAnnotation(ModelElement.class);\n    if (annotation == null) {\n      continue;\n    }\n    String fieldName=fi.getName();\n    if (!usedFieldNames.add(fieldName)) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n      continue;\n    }\n    if (formalArgs.get(fieldName) == null)     continue;\n    try {\n      Object o=fi.get(omo);\n      if (o instanceof OutputModelObject) {\n        OutputModelObject nestedOmo=(OutputModelObject)o;\n        ST nestedST=walk(nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n else       if (o instanceof Collection || o instanceof OutputModelObject[]) {\n        if (o instanceof OutputModelObject[]) {\n          o=Arrays.asList((OutputModelObject[])o);\n        }\n        Collection<?> nestedOmos=(Collection<?>)o;\n        for (        Object nestedOmo : nestedOmos) {\n          if (nestedOmo == null)           continue;\n          ST nestedST=walk((OutputModelObject)nestedOmo,header);\n          st.add(fieldName,nestedST);\n        }\n      }\n else       if (o instanceof Map) {\n        Map<?,?> nestedOmoMap=(Map<?,?>)o;\n        Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n        for (        Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n          ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n          m.put(entry.getKey(),nestedST);\n        }\n        st.add(fieldName,m);\n      }\n else       if (o != null) {\n        tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n      }\n    }\n catch (    IllegalAccessException iae) {\n      tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n    }\n  }\n  return st;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 481,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3517,
        "startLineNumber" : 54,
        "startColumnNumber" : 1,
        "endLineNumber" : 143,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public ST walk(OutputModelObject omo,boolean header){\n  Class<? extends OutputModelObject> cl=omo.getClass();\n  String templateName=cl.getSimpleName();\n  if (templateName == null) {\n    tool.errMgr.toolError(ErrorType.NO_MODEL_TO_TEMPLATE_MAPPING,cl.getSimpleName());\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (header)   templateName+=\"Header\";\n  ST st=templates.getInstanceOf(templateName);\n  if (st == null) {\n    tool.errMgr.toolError(ErrorType.CODE_GEN_TEMPLATES_INCOMPLETE,templateName);\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (st.impl.formalArguments == null) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,\"<none>\");\n    return st;\n  }\n  Map<String,FormalArgument> formalArgs=st.impl.formalArguments;\n  Set<String> argNames=formalArgs.keySet();\n  Iterator<String> arg_it=argNames.iterator();\n  String modelArgName=arg_it.next();\n  st.add(modelArgName,omo);\n  Set<String> usedFieldNames=new HashSet<String>();\n  Field fields[]=cl.getFields();\n  for (  Field fi : fields) {\n    ModelElement annotation=fi.getAnnotation(ModelElement.class);\n    if (annotation == null) {\n      continue;\n    }\n    String fieldName=fi.getName();\n    if (!usedFieldNames.add(fieldName)) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n      continue;\n    }\n    if (formalArgs.get(fieldName) == null)     continue;\n    try {\n      Object o=fi.get(omo);\n      if (o instanceof OutputModelObject) {\n        OutputModelObject nestedOmo=(OutputModelObject)o;\n        ST nestedST=walk(nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n else       if (o instanceof Collection || o instanceof OutputModelObject[]) {\n        if (o instanceof OutputModelObject[]) {\n          o=Arrays.asList((OutputModelObject[])o);\n        }\n        Collection<?> nestedOmos=(Collection<?>)o;\n        for (        Object nestedOmo : nestedOmos) {\n          if (nestedOmo == null)           continue;\n          ST nestedST=walk((OutputModelObject)nestedOmo,header);\n          st.add(fieldName,nestedST);\n        }\n      }\n else       if (o instanceof Map) {\n        Map<?,?> nestedOmoMap=(Map<?,?>)o;\n        Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n        for (        Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n          ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n          m.put(entry.getKey(),nestedST);\n        }\n        st.add(fieldName,m);\n      }\n else       if (o != null) {\n        tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n      }\n    }\n catch (    IllegalAccessException iae) {\n      tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n    }\n  }\n  return st;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 493,
      "astHeight" : 18
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 59,
        "startLineNumber" : 110,
        "startColumnNumber" : 14,
        "endLineNumber" : 110,
        "endColumnNumber" : 73
      },
      "nodeContext" : "o instanceof Collection || o instanceof OutputModelObject[]",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 5
    },
    "tokenLength" : 2,
    "type" : "boolean"
  }, {
    "nodeContext" : "o instanceof OutputModelObject[]",
    "nodeType" : "InstanceofExpression",
    "nodePosition" : {
      "charLength" : 32,
      "startLineNumber" : 112,
      "startColumnNumber" : 10,
      "endLineNumber" : 112,
      "endColumnNumber" : 42
    },
    "astNodeNumber" : 6,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 99,
        "startLineNumber" : 112,
        "startColumnNumber" : 5,
        "endLineNumber" : 114,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (o instanceof OutputModelObject[]) {\n  o=Arrays.asList((OutputModelObject[])o);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 20,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 483,
        "startLineNumber" : 110,
        "startColumnNumber" : 76,
        "endLineNumber" : 122,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (o instanceof OutputModelObject[]) {\n    o=Arrays.asList((OutputModelObject[])o);\n  }\n  Collection<?> nestedOmos=(Collection<?>)o;\n  for (  Object nestedOmo : nestedOmos) {\n    if (nestedOmo == null)     continue;\n    ST nestedST=walk((OutputModelObject)nestedOmo,header);\n    st.add(fieldName,nestedST);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 64,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 1140,
        "startLineNumber" : 110,
        "startColumnNumber" : 9,
        "endLineNumber" : 135,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (o instanceof Collection || o instanceof OutputModelObject[]) {\n  if (o instanceof OutputModelObject[]) {\n    o=Arrays.asList((OutputModelObject[])o);\n  }\n  Collection<?> nestedOmos=(Collection<?>)o;\n  for (  Object nestedOmo : nestedOmos) {\n    if (nestedOmo == null)     continue;\n    ST nestedST=walk((OutputModelObject)nestedOmo,header);\n    st.add(fieldName,nestedST);\n  }\n}\n else if (o instanceof Map) {\n  Map<?,?> nestedOmoMap=(Map<?,?>)o;\n  Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n  for (  Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n    ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n    m.put(entry.getKey(),nestedST);\n  }\n  st.add(fieldName,m);\n}\n else if (o != null) {\n  tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 174,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1452,
        "startLineNumber" : 104,
        "startColumnNumber" : 4,
        "endLineNumber" : 135,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (o instanceof OutputModelObject) {\n  OutputModelObject nestedOmo=(OutputModelObject)o;\n  ST nestedST=walk(nestedOmo,header);\n  st.add(fieldName,nestedST);\n}\n else if (o instanceof Collection || o instanceof OutputModelObject[]) {\n  if (o instanceof OutputModelObject[]) {\n    o=Arrays.asList((OutputModelObject[])o);\n  }\n  Collection<?> nestedOmos=(Collection<?>)o;\n  for (  Object nestedOmo : nestedOmos) {\n    if (nestedOmo == null)     continue;\n    ST nestedST=walk((OutputModelObject)nestedOmo,header);\n    st.add(fieldName,nestedST);\n  }\n}\n else if (o instanceof Map) {\n  Map<?,?> nestedOmoMap=(Map<?,?>)o;\n  Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n  for (  Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n    ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n    m.put(entry.getKey(),nestedST);\n  }\n  st.add(fieldName,m);\n}\n else if (o != null) {\n  tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 204,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 1494,
        "startLineNumber" : 102,
        "startColumnNumber" : 7,
        "endLineNumber" : 136,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  Object o=fi.get(omo);\n  if (o instanceof OutputModelObject) {\n    OutputModelObject nestedOmo=(OutputModelObject)o;\n    ST nestedST=walk(nestedOmo,header);\n    st.add(fieldName,nestedST);\n  }\n else   if (o instanceof Collection || o instanceof OutputModelObject[]) {\n    if (o instanceof OutputModelObject[]) {\n      o=Arrays.asList((OutputModelObject[])o);\n    }\n    Collection<?> nestedOmos=(Collection<?>)o;\n    for (    Object nestedOmo : nestedOmos) {\n      if (nestedOmo == null)       continue;\n      ST nestedST=walk((OutputModelObject)nestedOmo,header);\n      st.add(fieldName,nestedST);\n    }\n  }\n else   if (o instanceof Map) {\n    Map<?,?> nestedOmoMap=(Map<?,?>)o;\n    Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n    for (    Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n      ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n      m.put(entry.getKey(),nestedST);\n    }\n    st.add(fieldName,m);\n  }\n else   if (o != null) {\n    tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 214,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1633,
        "startLineNumber" : 102,
        "startColumnNumber" : 3,
        "endLineNumber" : 139,
        "endColumnNumber" : 4
      },
      "nodeContext" : "try {\n  Object o=fi.get(omo);\n  if (o instanceof OutputModelObject) {\n    OutputModelObject nestedOmo=(OutputModelObject)o;\n    ST nestedST=walk(nestedOmo,header);\n    st.add(fieldName,nestedST);\n  }\n else   if (o instanceof Collection || o instanceof OutputModelObject[]) {\n    if (o instanceof OutputModelObject[]) {\n      o=Arrays.asList((OutputModelObject[])o);\n    }\n    Collection<?> nestedOmos=(Collection<?>)o;\n    for (    Object nestedOmo : nestedOmos) {\n      if (nestedOmo == null)       continue;\n      ST nestedST=walk((OutputModelObject)nestedOmo,header);\n      st.add(fieldName,nestedST);\n    }\n  }\n else   if (o instanceof Map) {\n    Map<?,?> nestedOmoMap=(Map<?,?>)o;\n    Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n    for (    Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n      ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n      m.put(entry.getKey(),nestedST);\n    }\n    st.add(fieldName,m);\n  }\n else   if (o != null) {\n    tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n  }\n}\n catch (IllegalAccessException iae) {\n  tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 232,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 2150,
        "startLineNumber" : 86,
        "startColumnNumber" : 26,
        "endLineNumber" : 140,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  ModelElement annotation=fi.getAnnotation(ModelElement.class);\n  if (annotation == null) {\n    continue;\n  }\n  String fieldName=fi.getName();\n  if (!usedFieldNames.add(fieldName)) {\n    tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n    continue;\n  }\n  if (formalArgs.get(fieldName) == null)   continue;\n  try {\n    Object o=fi.get(omo);\n    if (o instanceof OutputModelObject) {\n      OutputModelObject nestedOmo=(OutputModelObject)o;\n      ST nestedST=walk(nestedOmo,header);\n      st.add(fieldName,nestedST);\n    }\n else     if (o instanceof Collection || o instanceof OutputModelObject[]) {\n      if (o instanceof OutputModelObject[]) {\n        o=Arrays.asList((OutputModelObject[])o);\n      }\n      Collection<?> nestedOmos=(Collection<?>)o;\n      for (      Object nestedOmo : nestedOmos) {\n        if (nestedOmo == null)         continue;\n        ST nestedST=walk((OutputModelObject)nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n    }\n else     if (o instanceof Map) {\n      Map<?,?> nestedOmoMap=(Map<?,?>)o;\n      Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n      for (      Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n        ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n        m.put(entry.getKey(),nestedST);\n      }\n      st.add(fieldName,m);\n    }\n else     if (o != null) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n    }\n  }\n catch (  IllegalAccessException iae) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 293,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2174,
        "startLineNumber" : 86,
        "startColumnNumber" : 2,
        "endLineNumber" : 140,
        "endColumnNumber" : 3
      },
      "nodeContext" : "for (Field fi : fields) {\n  ModelElement annotation=fi.getAnnotation(ModelElement.class);\n  if (annotation == null) {\n    continue;\n  }\n  String fieldName=fi.getName();\n  if (!usedFieldNames.add(fieldName)) {\n    tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n    continue;\n  }\n  if (formalArgs.get(fieldName) == null)   continue;\n  try {\n    Object o=fi.get(omo);\n    if (o instanceof OutputModelObject) {\n      OutputModelObject nestedOmo=(OutputModelObject)o;\n      ST nestedST=walk(nestedOmo,header);\n      st.add(fieldName,nestedST);\n    }\n else     if (o instanceof Collection || o instanceof OutputModelObject[]) {\n      if (o instanceof OutputModelObject[]) {\n        o=Arrays.asList((OutputModelObject[])o);\n      }\n      Collection<?> nestedOmos=(Collection<?>)o;\n      for (      Object nestedOmo : nestedOmos) {\n        if (nestedOmo == null)         continue;\n        ST nestedST=walk((OutputModelObject)nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n    }\n else     if (o instanceof Map) {\n      Map<?,?> nestedOmoMap=(Map<?,?>)o;\n      Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n      for (      Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n        ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n        m.put(entry.getKey(),nestedST);\n      }\n      st.add(fieldName,m);\n    }\n else     if (o != null) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n    }\n  }\n catch (  IllegalAccessException iae) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 299,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3463,
        "startLineNumber" : 54,
        "startColumnNumber" : 55,
        "endLineNumber" : 143,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  Class<? extends OutputModelObject> cl=omo.getClass();\n  String templateName=cl.getSimpleName();\n  if (templateName == null) {\n    tool.errMgr.toolError(ErrorType.NO_MODEL_TO_TEMPLATE_MAPPING,cl.getSimpleName());\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (header)   templateName+=\"Header\";\n  ST st=templates.getInstanceOf(templateName);\n  if (st == null) {\n    tool.errMgr.toolError(ErrorType.CODE_GEN_TEMPLATES_INCOMPLETE,templateName);\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (st.impl.formalArguments == null) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,\"<none>\");\n    return st;\n  }\n  Map<String,FormalArgument> formalArgs=st.impl.formalArguments;\n  Set<String> argNames=formalArgs.keySet();\n  Iterator<String> arg_it=argNames.iterator();\n  String modelArgName=arg_it.next();\n  st.add(modelArgName,omo);\n  Set<String> usedFieldNames=new HashSet<String>();\n  Field fields[]=cl.getFields();\n  for (  Field fi : fields) {\n    ModelElement annotation=fi.getAnnotation(ModelElement.class);\n    if (annotation == null) {\n      continue;\n    }\n    String fieldName=fi.getName();\n    if (!usedFieldNames.add(fieldName)) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n      continue;\n    }\n    if (formalArgs.get(fieldName) == null)     continue;\n    try {\n      Object o=fi.get(omo);\n      if (o instanceof OutputModelObject) {\n        OutputModelObject nestedOmo=(OutputModelObject)o;\n        ST nestedST=walk(nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n else       if (o instanceof Collection || o instanceof OutputModelObject[]) {\n        if (o instanceof OutputModelObject[]) {\n          o=Arrays.asList((OutputModelObject[])o);\n        }\n        Collection<?> nestedOmos=(Collection<?>)o;\n        for (        Object nestedOmo : nestedOmos) {\n          if (nestedOmo == null)           continue;\n          ST nestedST=walk((OutputModelObject)nestedOmo,header);\n          st.add(fieldName,nestedST);\n        }\n      }\n else       if (o instanceof Map) {\n        Map<?,?> nestedOmoMap=(Map<?,?>)o;\n        Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n        for (        Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n          ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n          m.put(entry.getKey(),nestedST);\n        }\n        st.add(fieldName,m);\n      }\n else       if (o != null) {\n        tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n      }\n    }\n catch (    IllegalAccessException iae) {\n      tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n    }\n  }\n  return st;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 481,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3517,
        "startLineNumber" : 54,
        "startColumnNumber" : 1,
        "endLineNumber" : 143,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public ST walk(OutputModelObject omo,boolean header){\n  Class<? extends OutputModelObject> cl=omo.getClass();\n  String templateName=cl.getSimpleName();\n  if (templateName == null) {\n    tool.errMgr.toolError(ErrorType.NO_MODEL_TO_TEMPLATE_MAPPING,cl.getSimpleName());\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (header)   templateName+=\"Header\";\n  ST st=templates.getInstanceOf(templateName);\n  if (st == null) {\n    tool.errMgr.toolError(ErrorType.CODE_GEN_TEMPLATES_INCOMPLETE,templateName);\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (st.impl.formalArguments == null) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,\"<none>\");\n    return st;\n  }\n  Map<String,FormalArgument> formalArgs=st.impl.formalArguments;\n  Set<String> argNames=formalArgs.keySet();\n  Iterator<String> arg_it=argNames.iterator();\n  String modelArgName=arg_it.next();\n  st.add(modelArgName,omo);\n  Set<String> usedFieldNames=new HashSet<String>();\n  Field fields[]=cl.getFields();\n  for (  Field fi : fields) {\n    ModelElement annotation=fi.getAnnotation(ModelElement.class);\n    if (annotation == null) {\n      continue;\n    }\n    String fieldName=fi.getName();\n    if (!usedFieldNames.add(fieldName)) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n      continue;\n    }\n    if (formalArgs.get(fieldName) == null)     continue;\n    try {\n      Object o=fi.get(omo);\n      if (o instanceof OutputModelObject) {\n        OutputModelObject nestedOmo=(OutputModelObject)o;\n        ST nestedST=walk(nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n else       if (o instanceof Collection || o instanceof OutputModelObject[]) {\n        if (o instanceof OutputModelObject[]) {\n          o=Arrays.asList((OutputModelObject[])o);\n        }\n        Collection<?> nestedOmos=(Collection<?>)o;\n        for (        Object nestedOmo : nestedOmos) {\n          if (nestedOmo == null)           continue;\n          ST nestedST=walk((OutputModelObject)nestedOmo,header);\n          st.add(fieldName,nestedST);\n        }\n      }\n else       if (o instanceof Map) {\n        Map<?,?> nestedOmoMap=(Map<?,?>)o;\n        Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n        for (        Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n          ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n          m.put(entry.getKey(),nestedST);\n        }\n        st.add(fieldName,m);\n      }\n else       if (o != null) {\n        tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n      }\n    }\n catch (    IllegalAccessException iae) {\n      tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n    }\n  }\n  return st;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 493,
      "astHeight" : 18
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 99,
        "startLineNumber" : 112,
        "startColumnNumber" : 5,
        "endLineNumber" : 114,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (o instanceof OutputModelObject[]) {\n  o=Arrays.asList((OutputModelObject[])o);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 20,
      "astHeight" : 9
    },
    "tokenLength" : 2,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 32,
    "startLineNumber" : 110,
    "startColumnNumber" : 41,
    "endLineNumber" : 110,
    "endColumnNumber" : 73
  }, {
    "charLength" : 32,
    "startLineNumber" : 112,
    "startColumnNumber" : 10,
    "endLineNumber" : 112,
    "endColumnNumber" : 42
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 1
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 2
  } ]
}