{
  "id" : 483,
  "expression" : "RedisCommands.CLUSTER_NODES",
  "projectName" : "redisson@redisson",
  "commitID" : "62b5e68c05b7475e1e0f98b4161aacb35d376b97",
  "filePath" : "/redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "RedisCommands.CLUSTER_NODES",
    "nodeType" : "QualifiedName",
    "nodePosition" : {
      "charLength" : 27,
      "startLineNumber" : 102,
      "startColumnNumber" : 38,
      "endLineNumber" : 102,
      "endColumnNumber" : 65
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 102,
        "startColumnNumber" : 16,
        "endLineNumber" : 102,
        "endColumnNumber" : 65
      },
      "nodeContext" : "clusterNodesCommand=RedisCommands.CLUSTER_NODES",
      "nodeType" : "Assignment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 102,
        "startColumnNumber" : 16,
        "endLineNumber" : 102,
        "endColumnNumber" : 66
      },
      "nodeContext" : "clusterNodesCommand=RedisCommands.CLUSTER_NODES;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 2142,
        "startLineNumber" : 95,
        "startColumnNumber" : 16,
        "endLineNumber" : 139,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  RedisConnection connection=connectionFuture.syncUninterruptibly().getNow();\n  if (cfg.getNodeAddresses().size() == 1 && NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null) {\n    configEndpointHostName=addr.getHost();\n  }\n  clusterNodesCommand=RedisCommands.CLUSTER_NODES;\n  if (addr.isSsl()) {\n    clusterNodesCommand=RedisCommands.CLUSTER_NODES_SSL;\n  }\n  List<ClusterNodeInfo> nodes=connection.sync(clusterNodesCommand);\n  StringBuilder nodesValue=new StringBuilder();\n  for (  ClusterNodeInfo clusterNodeInfo : nodes) {\n    nodesValue.append(clusterNodeInfo.getNodeInfo()).append(\"\\n\");\n  }\n  log.info(\"Redis cluster nodes configuration got from {}:\\n{}\",connection.getRedisClient().getAddr(),nodesValue);\n  lastClusterNode=addr;\n  Collection<ClusterPartition> partitions=parsePartitions(nodes);\n  List<RFuture<Void>> masterFutures=new ArrayList<>();\n  for (  ClusterPartition partition : partitions) {\n    if (partition.isMasterFail()) {\n      failedMasters.add(partition.getMasterAddress().toString());\n      continue;\n    }\n    if (partition.getMasterAddress() == null) {\n      throw new IllegalStateException(\"Master node: \" + partition.getNodeId() + \" doesn't have address.\");\n    }\n    RFuture<Void> masterFuture=addMasterEntry(partition,cfg);\n    masterFutures.add(masterFuture);\n  }\n  for (  RFuture<Void> masterFuture : masterFutures) {\n    masterFuture.awaitUninterruptibly();\n    if (!masterFuture.isSuccess()) {\n      lastException=masterFuture.cause();\n    }\n  }\n  break;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 213,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2259,
        "startLineNumber" : 95,
        "startColumnNumber" : 12,
        "endLineNumber" : 142,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  RedisConnection connection=connectionFuture.syncUninterruptibly().getNow();\n  if (cfg.getNodeAddresses().size() == 1 && NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null) {\n    configEndpointHostName=addr.getHost();\n  }\n  clusterNodesCommand=RedisCommands.CLUSTER_NODES;\n  if (addr.isSsl()) {\n    clusterNodesCommand=RedisCommands.CLUSTER_NODES_SSL;\n  }\n  List<ClusterNodeInfo> nodes=connection.sync(clusterNodesCommand);\n  StringBuilder nodesValue=new StringBuilder();\n  for (  ClusterNodeInfo clusterNodeInfo : nodes) {\n    nodesValue.append(clusterNodeInfo.getNodeInfo()).append(\"\\n\");\n  }\n  log.info(\"Redis cluster nodes configuration got from {}:\\n{}\",connection.getRedisClient().getAddr(),nodesValue);\n  lastClusterNode=addr;\n  Collection<ClusterPartition> partitions=parsePartitions(nodes);\n  List<RFuture<Void>> masterFutures=new ArrayList<>();\n  for (  ClusterPartition partition : partitions) {\n    if (partition.isMasterFail()) {\n      failedMasters.add(partition.getMasterAddress().toString());\n      continue;\n    }\n    if (partition.getMasterAddress() == null) {\n      throw new IllegalStateException(\"Master node: \" + partition.getNodeId() + \" doesn't have address.\");\n    }\n    RFuture<Void> masterFuture=addMasterEntry(partition,cfg);\n    masterFutures.add(masterFuture);\n  }\n  for (  RFuture<Void> masterFuture : masterFutures) {\n    masterFuture.awaitUninterruptibly();\n    if (!masterFuture.isSuccess()) {\n      lastException=masterFuture.cause();\n    }\n  }\n  break;\n}\n catch (Exception e) {\n  lastException=e;\n  log.warn(e.getMessage());\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 231,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 2438,
        "startLineNumber" : 92,
        "startColumnNumber" : 54,
        "endLineNumber" : 143,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  RedisURI addr=new RedisURI(address);\n  RFuture<RedisConnection> connectionFuture=connectToNode(cfg,addr,null,addr.getHost());\n  try {\n    RedisConnection connection=connectionFuture.syncUninterruptibly().getNow();\n    if (cfg.getNodeAddresses().size() == 1 && NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null) {\n      configEndpointHostName=addr.getHost();\n    }\n    clusterNodesCommand=RedisCommands.CLUSTER_NODES;\n    if (addr.isSsl()) {\n      clusterNodesCommand=RedisCommands.CLUSTER_NODES_SSL;\n    }\n    List<ClusterNodeInfo> nodes=connection.sync(clusterNodesCommand);\n    StringBuilder nodesValue=new StringBuilder();\n    for (    ClusterNodeInfo clusterNodeInfo : nodes) {\n      nodesValue.append(clusterNodeInfo.getNodeInfo()).append(\"\\n\");\n    }\n    log.info(\"Redis cluster nodes configuration got from {}:\\n{}\",connection.getRedisClient().getAddr(),nodesValue);\n    lastClusterNode=addr;\n    Collection<ClusterPartition> partitions=parsePartitions(nodes);\n    List<RFuture<Void>> masterFutures=new ArrayList<>();\n    for (    ClusterPartition partition : partitions) {\n      if (partition.isMasterFail()) {\n        failedMasters.add(partition.getMasterAddress().toString());\n        continue;\n      }\n      if (partition.getMasterAddress() == null) {\n        throw new IllegalStateException(\"Master node: \" + partition.getNodeId() + \" doesn't have address.\");\n      }\n      RFuture<Void> masterFuture=addMasterEntry(partition,cfg);\n      masterFutures.add(masterFuture);\n    }\n    for (    RFuture<Void> masterFuture : masterFutures) {\n      masterFuture.awaitUninterruptibly();\n      if (!masterFuture.isSuccess()) {\n        lastException=masterFuture.cause();\n      }\n    }\n    break;\n  }\n catch (  Exception e) {\n    lastException=e;\n    log.warn(e.getMessage());\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 257,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2484,
        "startLineNumber" : 92,
        "startColumnNumber" : 8,
        "endLineNumber" : 143,
        "endColumnNumber" : 9
      },
      "nodeContext" : "for (String address : cfg.getNodeAddresses()) {\n  RedisURI addr=new RedisURI(address);\n  RFuture<RedisConnection> connectionFuture=connectToNode(cfg,addr,null,addr.getHost());\n  try {\n    RedisConnection connection=connectionFuture.syncUninterruptibly().getNow();\n    if (cfg.getNodeAddresses().size() == 1 && NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null) {\n      configEndpointHostName=addr.getHost();\n    }\n    clusterNodesCommand=RedisCommands.CLUSTER_NODES;\n    if (addr.isSsl()) {\n      clusterNodesCommand=RedisCommands.CLUSTER_NODES_SSL;\n    }\n    List<ClusterNodeInfo> nodes=connection.sync(clusterNodesCommand);\n    StringBuilder nodesValue=new StringBuilder();\n    for (    ClusterNodeInfo clusterNodeInfo : nodes) {\n      nodesValue.append(clusterNodeInfo.getNodeInfo()).append(\"\\n\");\n    }\n    log.info(\"Redis cluster nodes configuration got from {}:\\n{}\",connection.getRedisClient().getAddr(),nodesValue);\n    lastClusterNode=addr;\n    Collection<ClusterPartition> partitions=parsePartitions(nodes);\n    List<RFuture<Void>> masterFutures=new ArrayList<>();\n    for (    ClusterPartition partition : partitions) {\n      if (partition.isMasterFail()) {\n        failedMasters.add(partition.getMasterAddress().toString());\n        continue;\n      }\n      if (partition.getMasterAddress() == null) {\n        throw new IllegalStateException(\"Master node: \" + partition.getNodeId() + \" doesn't have address.\");\n      }\n      RFuture<Void> masterFuture=addMasterEntry(partition,cfg);\n      masterFutures.add(masterFuture);\n    }\n    for (    RFuture<Void> masterFuture : masterFutures) {\n      masterFuture.awaitUninterruptibly();\n      if (!masterFuture.isSuccess()) {\n        lastException=masterFuture.cause();\n      }\n    }\n    break;\n  }\n catch (  Exception e) {\n    lastException=e;\n    log.warn(e.getMessage());\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 265,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4023,
        "startLineNumber" : 79,
        "startColumnNumber" : 86,
        "endLineNumber" : 164,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  super(config,id);\n  if (cfg.getNodeAddresses().isEmpty()) {\n    throw new IllegalArgumentException(\"At least one cluster node should be defined!\");\n  }\n  this.natMapper=cfg.getNatMapper();\n  this.config=create(cfg);\n  initTimer(this.config);\n  Throwable lastException=null;\n  List<String> failedMasters=new ArrayList<String>();\n  for (  String address : cfg.getNodeAddresses()) {\n    RedisURI addr=new RedisURI(address);\n    RFuture<RedisConnection> connectionFuture=connectToNode(cfg,addr,null,addr.getHost());\n    try {\n      RedisConnection connection=connectionFuture.syncUninterruptibly().getNow();\n      if (cfg.getNodeAddresses().size() == 1 && NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null) {\n        configEndpointHostName=addr.getHost();\n      }\n      clusterNodesCommand=RedisCommands.CLUSTER_NODES;\n      if (addr.isSsl()) {\n        clusterNodesCommand=RedisCommands.CLUSTER_NODES_SSL;\n      }\n      List<ClusterNodeInfo> nodes=connection.sync(clusterNodesCommand);\n      StringBuilder nodesValue=new StringBuilder();\n      for (      ClusterNodeInfo clusterNodeInfo : nodes) {\n        nodesValue.append(clusterNodeInfo.getNodeInfo()).append(\"\\n\");\n      }\n      log.info(\"Redis cluster nodes configuration got from {}:\\n{}\",connection.getRedisClient().getAddr(),nodesValue);\n      lastClusterNode=addr;\n      Collection<ClusterPartition> partitions=parsePartitions(nodes);\n      List<RFuture<Void>> masterFutures=new ArrayList<>();\n      for (      ClusterPartition partition : partitions) {\n        if (partition.isMasterFail()) {\n          failedMasters.add(partition.getMasterAddress().toString());\n          continue;\n        }\n        if (partition.getMasterAddress() == null) {\n          throw new IllegalStateException(\"Master node: \" + partition.getNodeId() + \" doesn't have address.\");\n        }\n        RFuture<Void> masterFuture=addMasterEntry(partition,cfg);\n        masterFutures.add(masterFuture);\n      }\n      for (      RFuture<Void> masterFuture : masterFutures) {\n        masterFuture.awaitUninterruptibly();\n        if (!masterFuture.isSuccess()) {\n          lastException=masterFuture.cause();\n        }\n      }\n      break;\n    }\n catch (    Exception e) {\n      lastException=e;\n      log.warn(e.getMessage());\n    }\n  }\n  if (lastPartitions.isEmpty()) {\n    stopThreads();\n    if (failedMasters.isEmpty()) {\n      throw new RedisConnectionException(\"Can't connect to servers!\",lastException);\n    }\n else {\n      throw new RedisConnectionException(\"Can't connect to servers! Failed masters according to cluster status: \" + failedMasters,lastException);\n    }\n  }\n  if (cfg.isCheckSlotsCoverage() && lastPartitions.size() != MAX_SLOT) {\n    stopThreads();\n    if (failedMasters.isEmpty()) {\n      throw new RedisConnectionException(\"Not all slots covered! Only \" + lastPartitions.size() + \" slots are available. Set checkSlotsCoverage = false to avoid this check.\",lastException);\n    }\n else {\n      throw new RedisConnectionException(\"Not all slots covered! Only \" + lastPartitions.size() + \" slots are available. Set checkSlotsCoverage = false to avoid this check. Failed masters according to cluster status: \"+ failedMasters,lastException);\n    }\n  }\n  scheduleClusterChangeCheck(cfg);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 398,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4105,
        "startLineNumber" : 79,
        "startColumnNumber" : 4,
        "endLineNumber" : 164,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public ClusterConnectionManager(ClusterServersConfig cfg,Config config,UUID id){\n  super(config,id);\n  if (cfg.getNodeAddresses().isEmpty()) {\n    throw new IllegalArgumentException(\"At least one cluster node should be defined!\");\n  }\n  this.natMapper=cfg.getNatMapper();\n  this.config=create(cfg);\n  initTimer(this.config);\n  Throwable lastException=null;\n  List<String> failedMasters=new ArrayList<String>();\n  for (  String address : cfg.getNodeAddresses()) {\n    RedisURI addr=new RedisURI(address);\n    RFuture<RedisConnection> connectionFuture=connectToNode(cfg,addr,null,addr.getHost());\n    try {\n      RedisConnection connection=connectionFuture.syncUninterruptibly().getNow();\n      if (cfg.getNodeAddresses().size() == 1 && NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null) {\n        configEndpointHostName=addr.getHost();\n      }\n      clusterNodesCommand=RedisCommands.CLUSTER_NODES;\n      if (addr.isSsl()) {\n        clusterNodesCommand=RedisCommands.CLUSTER_NODES_SSL;\n      }\n      List<ClusterNodeInfo> nodes=connection.sync(clusterNodesCommand);\n      StringBuilder nodesValue=new StringBuilder();\n      for (      ClusterNodeInfo clusterNodeInfo : nodes) {\n        nodesValue.append(clusterNodeInfo.getNodeInfo()).append(\"\\n\");\n      }\n      log.info(\"Redis cluster nodes configuration got from {}:\\n{}\",connection.getRedisClient().getAddr(),nodesValue);\n      lastClusterNode=addr;\n      Collection<ClusterPartition> partitions=parsePartitions(nodes);\n      List<RFuture<Void>> masterFutures=new ArrayList<>();\n      for (      ClusterPartition partition : partitions) {\n        if (partition.isMasterFail()) {\n          failedMasters.add(partition.getMasterAddress().toString());\n          continue;\n        }\n        if (partition.getMasterAddress() == null) {\n          throw new IllegalStateException(\"Master node: \" + partition.getNodeId() + \" doesn't have address.\");\n        }\n        RFuture<Void> masterFuture=addMasterEntry(partition,cfg);\n        masterFutures.add(masterFuture);\n      }\n      for (      RFuture<Void> masterFuture : masterFutures) {\n        masterFuture.awaitUninterruptibly();\n        if (!masterFuture.isSuccess()) {\n          lastException=masterFuture.cause();\n        }\n      }\n      break;\n    }\n catch (    Exception e) {\n      lastException=e;\n      log.warn(e.getMessage());\n    }\n  }\n  if (lastPartitions.isEmpty()) {\n    stopThreads();\n    if (failedMasters.isEmpty()) {\n      throw new RedisConnectionException(\"Can't connect to servers!\",lastException);\n    }\n else {\n      throw new RedisConnectionException(\"Can't connect to servers! Failed masters according to cluster status: \" + failedMasters,lastException);\n    }\n  }\n  if (cfg.isCheckSlotsCoverage() && lastPartitions.size() != MAX_SLOT) {\n    stopThreads();\n    if (failedMasters.isEmpty()) {\n      throw new RedisConnectionException(\"Not all slots covered! Only \" + lastPartitions.size() + \" slots are available. Set checkSlotsCoverage = false to avoid this check.\",lastException);\n    }\n else {\n      throw new RedisConnectionException(\"Not all slots covered! Only \" + lastPartitions.size() + \" slots are available. Set checkSlotsCoverage = false to avoid this check. Failed masters according to cluster status: \"+ failedMasters,lastException);\n    }\n  }\n  scheduleClusterChangeCheck(cfg);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 413,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 102,
        "startColumnNumber" : 16,
        "endLineNumber" : 102,
        "endColumnNumber" : 66
      },
      "nodeContext" : "clusterNodesCommand=RedisCommands.CLUSTER_NODES;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 6,
      "astHeight" : 4
    },
    "tokenLength" : 3,
    "type" : "org.redisson.client.protocol.RedisStrictCommand<java.util.List<org.redisson.cluster.ClusterNodeInfo>>"
  } ],
  "positionList" : [ {
    "charLength" : 27,
    "startLineNumber" : 102,
    "startColumnNumber" : 38,
    "endLineNumber" : 102,
    "endColumnNumber" : 65
  } ],
  "layoutRelationDataList" : [ ]
}