{
  "id" : 36,
  "expression" : "nextTokens",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/runtime/Java/src/org/antlr/v4/runtime/DefaultErrorStrategy.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "nextTokens",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 10,
      "startLineNumber" : 243,
      "startColumnNumber" : 6,
      "endLineNumber" : 243,
      "endColumnNumber" : 16
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 23,
        "startLineNumber" : 243,
        "startColumnNumber" : 6,
        "endLineNumber" : 243,
        "endColumnNumber" : 29
      },
      "nodeContext" : "nextTokens.contains(la)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 167,
        "startLineNumber" : 243,
        "startColumnNumber" : 2,
        "endLineNumber" : 248,
        "endColumnNumber" : 3
      },
      "nodeContext" : "if (nextTokens.contains(la)) {\n  nextTokensContext=null;\n  nextTokensState=ATNState.INVALID_STATE_NUMBER;\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 1852,
        "startLineNumber" : 230,
        "startColumnNumber" : 65,
        "endLineNumber" : 286,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  ATNState s=recognizer.getInterpreter().atn.states.get(recognizer.getState());\n  if (inErrorRecoveryMode(recognizer)) {\n    return;\n  }\n  TokenStream tokens=recognizer.getInputStream();\n  int la=tokens.LA(1);\n  IntervalSet nextTokens=recognizer.getATN().nextTokens(s);\n  if (nextTokens.contains(la)) {\n    nextTokensContext=null;\n    nextTokensState=ATNState.INVALID_STATE_NUMBER;\n    return;\n  }\n  if (nextTokens.contains(Token.EPSILON)) {\n    if (nextTokensContext == null) {\n      nextTokensContext=recognizer.getContext();\n      nextTokensState=recognizer.getState();\n    }\n    return;\n  }\nswitch (s.getStateType()) {\ncase ATNState.BLOCK_START:case ATNState.STAR_BLOCK_START:case ATNState.PLUS_BLOCK_START:case ATNState.STAR_LOOP_ENTRY:    if (singleTokenDeletion(recognizer) != null) {\n      return;\n    }\n  throw new InputMismatchException(recognizer);\ncase ATNState.PLUS_LOOP_BACK:case ATNState.STAR_LOOP_BACK:reportUnwantedToken(recognizer);\nIntervalSet expecting=recognizer.getExpectedTokens();\nIntervalSet whatFollowsLoopIterationOrRule=expecting.or(getErrorRecoverySet(recognizer));\nconsumeUntil(recognizer,whatFollowsLoopIterationOrRule);\nbreak;\ndefault:break;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3971,
        "startLineNumber" : 183,
        "startColumnNumber" : 1,
        "endLineNumber" : 286,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * The default implementation of  {@link ANTLRErrorStrategy#sync} makes surethat the current lookahead symbol is consistent with what were expecting at this point in the ATN. You can call this anytime but ANTLR only generates code to check before subrules/loops and each iteration. <p>Implements Jim Idle's magic sync mechanism in closures and optional subrules. E.g.,</p> <pre> a : sync ( stuff sync )* ; sync : {consume to what can follow sync} ; </pre> At the start of a sub rule upon error,  {@link #sync} performs singletoken deletion, if possible. If it can't do that, it bails on the current rule and uses the default error recovery, which consumes until the resynchronization set of the current rule. <p>If the sub rule is optional ( {@code (...)?},  {@code (...)*}, or block with an empty alternative), then the expected set includes what follows the subrule.</p> <p>During loop iteration, it consumes until it sees a token that can start a sub rule or what follows loop. Yes, that is pretty aggressive. We opt to stay in the loop as long as possible.</p> <p><strong>ORIGINS</strong></p> <p>Previous versions of ANTLR did a poor job of their recovery within loops. A single mismatch token or missing token would force the parser to bail out of the entire rules surrounding the loop. So, for rule</p> <pre> classDef : 'class' ID '{' member* '}' </pre> input with an extra token between members would force the parser to consume until it found the next class definition rather than the next member definition of the current class. <p>This functionality cost a little bit of effort because the parser has to compare token set at the start of the loop and at each iteration. If for some reason speed is suffering for you, you can turn off this functionality by simply overriding this method as a blank { }.</p>\n */\n@Override public void sync(Parser recognizer) throws RecognitionException {\n  ATNState s=recognizer.getInterpreter().atn.states.get(recognizer.getState());\n  if (inErrorRecoveryMode(recognizer)) {\n    return;\n  }\n  TokenStream tokens=recognizer.getInputStream();\n  int la=tokens.LA(1);\n  IntervalSet nextTokens=recognizer.getATN().nextTokens(s);\n  if (nextTokens.contains(la)) {\n    nextTokensContext=null;\n    nextTokensState=ATNState.INVALID_STATE_NUMBER;\n    return;\n  }\n  if (nextTokens.contains(Token.EPSILON)) {\n    if (nextTokensContext == null) {\n      nextTokensContext=recognizer.getContext();\n      nextTokensState=recognizer.getState();\n    }\n    return;\n  }\nswitch (s.getStateType()) {\ncase ATNState.BLOCK_START:case ATNState.STAR_BLOCK_START:case ATNState.PLUS_BLOCK_START:case ATNState.STAR_LOOP_ENTRY:    if (singleTokenDeletion(recognizer) != null) {\n      return;\n    }\n  throw new InputMismatchException(recognizer);\ncase ATNState.PLUS_LOOP_BACK:case ATNState.STAR_LOOP_BACK:reportUnwantedToken(recognizer);\nIntervalSet expecting=recognizer.getExpectedTokens();\nIntervalSet whatFollowsLoopIterationOrRule=expecting.or(getErrorRecoverySet(recognizer));\nconsumeUntil(recognizer,whatFollowsLoopIterationOrRule);\nbreak;\ndefault:break;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 179,
      "astHeight" : 10
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 23,
        "startLineNumber" : 243,
        "startColumnNumber" : 6,
        "endLineNumber" : 243,
        "endColumnNumber" : 29
      },
      "nodeContext" : "nextTokens.contains(la)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "org.antlr.v4.runtime.misc.IntervalSet"
  }, {
    "nodeContext" : "nextTokens",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 10,
      "startLineNumber" : 250,
      "startColumnNumber" : 6,
      "endLineNumber" : 250,
      "endColumnNumber" : 16
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 250,
        "startColumnNumber" : 6,
        "endLineNumber" : 250,
        "endColumnNumber" : 40
      },
      "nodeContext" : "nextTokens.contains(Token.EPSILON)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 314,
        "startLineNumber" : 250,
        "startColumnNumber" : 2,
        "endLineNumber" : 258,
        "endColumnNumber" : 3
      },
      "nodeContext" : "if (nextTokens.contains(Token.EPSILON)) {\n  if (nextTokensContext == null) {\n    nextTokensContext=recognizer.getContext();\n    nextTokensState=recognizer.getState();\n  }\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 26,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 1852,
        "startLineNumber" : 230,
        "startColumnNumber" : 65,
        "endLineNumber" : 286,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  ATNState s=recognizer.getInterpreter().atn.states.get(recognizer.getState());\n  if (inErrorRecoveryMode(recognizer)) {\n    return;\n  }\n  TokenStream tokens=recognizer.getInputStream();\n  int la=tokens.LA(1);\n  IntervalSet nextTokens=recognizer.getATN().nextTokens(s);\n  if (nextTokens.contains(la)) {\n    nextTokensContext=null;\n    nextTokensState=ATNState.INVALID_STATE_NUMBER;\n    return;\n  }\n  if (nextTokens.contains(Token.EPSILON)) {\n    if (nextTokensContext == null) {\n      nextTokensContext=recognizer.getContext();\n      nextTokensState=recognizer.getState();\n    }\n    return;\n  }\nswitch (s.getStateType()) {\ncase ATNState.BLOCK_START:case ATNState.STAR_BLOCK_START:case ATNState.PLUS_BLOCK_START:case ATNState.STAR_LOOP_ENTRY:    if (singleTokenDeletion(recognizer) != null) {\n      return;\n    }\n  throw new InputMismatchException(recognizer);\ncase ATNState.PLUS_LOOP_BACK:case ATNState.STAR_LOOP_BACK:reportUnwantedToken(recognizer);\nIntervalSet expecting=recognizer.getExpectedTokens();\nIntervalSet whatFollowsLoopIterationOrRule=expecting.or(getErrorRecoverySet(recognizer));\nconsumeUntil(recognizer,whatFollowsLoopIterationOrRule);\nbreak;\ndefault:break;\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 166,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3971,
        "startLineNumber" : 183,
        "startColumnNumber" : 1,
        "endLineNumber" : 286,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * The default implementation of  {@link ANTLRErrorStrategy#sync} makes surethat the current lookahead symbol is consistent with what were expecting at this point in the ATN. You can call this anytime but ANTLR only generates code to check before subrules/loops and each iteration. <p>Implements Jim Idle's magic sync mechanism in closures and optional subrules. E.g.,</p> <pre> a : sync ( stuff sync )* ; sync : {consume to what can follow sync} ; </pre> At the start of a sub rule upon error,  {@link #sync} performs singletoken deletion, if possible. If it can't do that, it bails on the current rule and uses the default error recovery, which consumes until the resynchronization set of the current rule. <p>If the sub rule is optional ( {@code (...)?},  {@code (...)*}, or block with an empty alternative), then the expected set includes what follows the subrule.</p> <p>During loop iteration, it consumes until it sees a token that can start a sub rule or what follows loop. Yes, that is pretty aggressive. We opt to stay in the loop as long as possible.</p> <p><strong>ORIGINS</strong></p> <p>Previous versions of ANTLR did a poor job of their recovery within loops. A single mismatch token or missing token would force the parser to bail out of the entire rules surrounding the loop. So, for rule</p> <pre> classDef : 'class' ID '{' member* '}' </pre> input with an extra token between members would force the parser to consume until it found the next class definition rather than the next member definition of the current class. <p>This functionality cost a little bit of effort because the parser has to compare token set at the start of the loop and at each iteration. If for some reason speed is suffering for you, you can turn off this functionality by simply overriding this method as a blank { }.</p>\n */\n@Override public void sync(Parser recognizer) throws RecognitionException {\n  ATNState s=recognizer.getInterpreter().atn.states.get(recognizer.getState());\n  if (inErrorRecoveryMode(recognizer)) {\n    return;\n  }\n  TokenStream tokens=recognizer.getInputStream();\n  int la=tokens.LA(1);\n  IntervalSet nextTokens=recognizer.getATN().nextTokens(s);\n  if (nextTokens.contains(la)) {\n    nextTokensContext=null;\n    nextTokensState=ATNState.INVALID_STATE_NUMBER;\n    return;\n  }\n  if (nextTokens.contains(Token.EPSILON)) {\n    if (nextTokensContext == null) {\n      nextTokensContext=recognizer.getContext();\n      nextTokensState=recognizer.getState();\n    }\n    return;\n  }\nswitch (s.getStateType()) {\ncase ATNState.BLOCK_START:case ATNState.STAR_BLOCK_START:case ATNState.PLUS_BLOCK_START:case ATNState.STAR_LOOP_ENTRY:    if (singleTokenDeletion(recognizer) != null) {\n      return;\n    }\n  throw new InputMismatchException(recognizer);\ncase ATNState.PLUS_LOOP_BACK:case ATNState.STAR_LOOP_BACK:reportUnwantedToken(recognizer);\nIntervalSet expecting=recognizer.getExpectedTokens();\nIntervalSet whatFollowsLoopIterationOrRule=expecting.or(getErrorRecoverySet(recognizer));\nconsumeUntil(recognizer,whatFollowsLoopIterationOrRule);\nbreak;\ndefault:break;\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 179,
      "astHeight" : 10
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 250,
        "startColumnNumber" : 6,
        "endLineNumber" : 250,
        "endColumnNumber" : 40
      },
      "nodeContext" : "nextTokens.contains(Token.EPSILON)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "org.antlr.v4.runtime.misc.IntervalSet"
  } ],
  "positionList" : [ {
    "charLength" : 10,
    "startLineNumber" : 243,
    "startColumnNumber" : 6,
    "endLineNumber" : 243,
    "endColumnNumber" : 16
  }, {
    "charLength" : 10,
    "startLineNumber" : 250,
    "startColumnNumber" : 6,
    "endLineNumber" : 250,
    "endColumnNumber" : 16
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 2
  } ]
}