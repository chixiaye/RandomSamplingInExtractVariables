{
  "id" : 214,
  "expression" : "written",
  "projectName" : "TeamNewPipe@NewPipe",
  "commitID" : "d7574973e97fa7a3a21aa59967311f6091941830",
  "filePath" : "/app/src/main/java/org/schabi/newpipe/streams/WebMWriter.java",
  "occurrences" : 9,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "written",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 131,
      "startColumnNumber" : 36,
      "endLineNumber" : 131,
      "endColumnNumber" : 43
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 11,
        "startLineNumber" : 131,
        "startColumnNumber" : 36,
        "endLineNumber" : 131,
        "endColumnNumber" : 47
      },
      "nodeContext" : "written + 5",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 131,
        "startColumnNumber" : 13,
        "endLineNumber" : 131,
        "endColumnNumber" : 47
      },
      "nodeContext" : "offsetSegmentSizeSet=written + 5",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 131,
        "startColumnNumber" : 8,
        "endLineNumber" : 131,
        "endColumnNumber" : 48
      },
      "nodeContext" : "long offsetSegmentSizeSet=written + 5;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 40,
        "startLineNumber" : 131,
        "startColumnNumber" : 8,
        "endLineNumber" : 131,
        "endColumnNumber" : 48
      },
      "nodeContext" : "long offsetSegmentSizeSet=written + 5;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "written",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 132,
      "startColumnNumber" : 37,
      "endLineNumber" : 132,
      "endColumnNumber" : 44
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 12,
        "startLineNumber" : 132,
        "startColumnNumber" : 37,
        "endLineNumber" : 132,
        "endColumnNumber" : 49
      },
      "nodeContext" : "written + 94",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 36,
        "startLineNumber" : 132,
        "startColumnNumber" : 13,
        "endLineNumber" : 132,
        "endColumnNumber" : 49
      },
      "nodeContext" : "offsetInfoDurationSet=written + 94",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 132,
        "startColumnNumber" : 8,
        "endLineNumber" : 132,
        "endColumnNumber" : 50
      },
      "nodeContext" : "long offsetInfoDurationSet=written + 94;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 132,
        "startColumnNumber" : 8,
        "endLineNumber" : 132,
        "endColumnNumber" : 50
      },
      "nodeContext" : "long offsetInfoDurationSet=written + 94;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "written",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 133,
      "startColumnNumber" : 32,
      "endLineNumber" : 133,
      "endColumnNumber" : 39
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 12,
        "startLineNumber" : 133,
        "startColumnNumber" : 32,
        "endLineNumber" : 133,
        "endColumnNumber" : 44
      },
      "nodeContext" : "written + 58",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 31,
        "startLineNumber" : 133,
        "startColumnNumber" : 13,
        "endLineNumber" : 133,
        "endColumnNumber" : 44
      },
      "nodeContext" : "offsetClusterSet=written + 58",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 133,
        "startColumnNumber" : 8,
        "endLineNumber" : 133,
        "endColumnNumber" : 45
      },
      "nodeContext" : "long offsetClusterSet=written + 58;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 133,
        "startColumnNumber" : 8,
        "endLineNumber" : 133,
        "endColumnNumber" : 45
      },
      "nodeContext" : "long offsetClusterSet=written + 58;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "written",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 134,
      "startColumnNumber" : 29,
      "endLineNumber" : 134,
      "endColumnNumber" : 36
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 12,
        "startLineNumber" : 134,
        "startColumnNumber" : 29,
        "endLineNumber" : 134,
        "endColumnNumber" : 41
      },
      "nodeContext" : "written + 75",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 134,
        "startColumnNumber" : 13,
        "endLineNumber" : 134,
        "endColumnNumber" : 41
      },
      "nodeContext" : "offsetCuesSet=written + 75",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 134,
        "startColumnNumber" : 8,
        "endLineNumber" : 134,
        "endColumnNumber" : 42
      },
      "nodeContext" : "long offsetCuesSet=written + 75;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 134,
        "startColumnNumber" : 8,
        "endLineNumber" : 134,
        "endColumnNumber" : 42
      },
      "nodeContext" : "long offsetCuesSet=written + 75;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "written",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 144,
      "startColumnNumber" : 29,
      "endLineNumber" : 144,
      "endColumnNumber" : 36
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 144,
        "startColumnNumber" : 29,
        "endLineNumber" : 144,
        "endColumnNumber" : 63
      },
      "nodeContext" : "written + listBuffer.get(0).length",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 50,
        "startLineNumber" : 144,
        "startColumnNumber" : 13,
        "endLineNumber" : 144,
        "endColumnNumber" : 63
      },
      "nodeContext" : "segmentOffset=written + listBuffer.get(0).length",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 144,
        "startColumnNumber" : 8,
        "endLineNumber" : 144,
        "endColumnNumber" : 64
      },
      "nodeContext" : "long segmentOffset=written + listBuffer.get(0).length;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 12,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 144,
        "startColumnNumber" : 8,
        "endLineNumber" : 144,
        "endColumnNumber" : 64
      },
      "nodeContext" : "long segmentOffset=written + listBuffer.get(0).length;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 12,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "written",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 180,
      "startColumnNumber" : 25,
      "endLineNumber" : 180,
      "endColumnNumber" : 32
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 19,
        "startLineNumber" : 180,
        "startColumnNumber" : 13,
        "endLineNumber" : 180,
        "endColumnNumber" : 32
      },
      "nodeContext" : "cueOffset=written",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 180,
        "startColumnNumber" : 8,
        "endLineNumber" : 180,
        "endColumnNumber" : 33
      },
      "nodeContext" : "long cueOffset=written;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 25,
        "startLineNumber" : 180,
        "startColumnNumber" : 8,
        "endLineNumber" : 180,
        "endColumnNumber" : 33
      },
      "nodeContext" : "long cueOffset=written;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "written",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 201,
      "startColumnNumber" : 39,
      "endLineNumber" : 201,
      "endColumnNumber" : 46
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 13,
        "startLineNumber" : 201,
        "startColumnNumber" : 33,
        "endLineNumber" : 201,
        "endColumnNumber" : 46
      },
      "nodeContext" : "(int)written",
      "nodeType" : "CastExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 201,
        "startColumnNumber" : 12,
        "endLineNumber" : 201,
        "endColumnNumber" : 46
      },
      "nodeContext" : "firstClusterOffset=(int)written",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 201,
        "startColumnNumber" : 8,
        "endLineNumber" : 201,
        "endColumnNumber" : 47
      },
      "nodeContext" : "int firstClusterOffset=(int)written;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 39,
        "startLineNumber" : 201,
        "startColumnNumber" : 8,
        "endLineNumber" : 201,
        "endColumnNumber" : 47
      },
      "nodeContext" : "int firstClusterOffset=(int)written;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "written",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 244,
      "startColumnNumber" : 88,
      "endLineNumber" : 244,
      "endColumnNumber" : 95
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 113,
        "startLineNumber" : 244,
        "startColumnNumber" : 38,
        "endLineNumber" : 245,
        "endColumnNumber" : 54
      },
      "nodeContext" : "new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode)",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 9,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 128,
        "startLineNumber" : 244,
        "startColumnNumber" : 24,
        "endLineNumber" : 245,
        "endColumnNumber" : 55
      },
      "nodeContext" : "keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 129,
        "startLineNumber" : 244,
        "startColumnNumber" : 24,
        "endLineNumber" : 245,
        "endColumnNumber" : 56
      },
      "nodeContext" : "keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 316,
        "startLineNumber" : 240,
        "startColumnNumber" : 71,
        "endLineNumber" : 246,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (nextCueTime > -1) {\n    nextCueTime+=DEFAULT_CUES_EACH_MS;\n  }\n  keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 24,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 450,
        "startLineNumber" : 239,
        "startColumnNumber" : 20,
        "endLineNumber" : 246,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n  if (nextCueTime > -1) {\n    nextCueTime+=DEFAULT_CUES_EACH_MS;\n  }\n  keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 45,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 490,
        "startLineNumber" : 238,
        "startColumnNumber" : 41,
        "endLineNumber" : 247,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n    if (nextCueTime > -1) {\n      nextCueTime+=DEFAULT_CUES_EACH_MS;\n    }\n    keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 46,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 515,
        "startLineNumber" : 238,
        "startColumnNumber" : 16,
        "endLineNumber" : 247,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (cuesForTrackId == i) {\n  if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n    if (nextCueTime > -1) {\n      nextCueTime+=DEFAULT_CUES_EACH_MS;\n    }\n    keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 50,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 2216,
        "startLineNumber" : 215,
        "startColumnNumber" : 39,
        "endLineNumber" : 270,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  Block bloq=getNextBlockFrom(i);\n  if (bloq == null) {\n    i++;\n    continue;\n  }\n  if (bloq.data == null) {\n    blockWritten=1;\n    newClusterByTrackId=i;\n    i++;\n    continue;\n  }\n  if (newClusterByTrackId == i) {\n    limitTimecodeByTrackId=i;\n    newClusterByTrackId=-1;\n    baseTimecode=bloq.absoluteTimecode;\n    limitTimecode=baseTimecode + INTERV;\n    currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n  }\n  if (cuesForTrackId == i) {\n    if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n      if (nextCueTime > -1) {\n        nextCueTime+=DEFAULT_CUES_EACH_MS;\n      }\n      keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n    }\n  }\n  writeBlock(out,bloq,baseTimecode);\n  blockWritten++;\n  if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n    defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n  }\n  duration[i]=bloq.absoluteTimecode;\n  if (limitTimecode < 0) {\n    limitTimecode=bloq.absoluteTimecode + INTERV;\n    continue;\n  }\n  if (bloq.absoluteTimecode >= limitTimecode) {\n    if (limitTimecodeByTrackId != i) {\n      limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n    }\n    i++;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 207,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2243,
        "startLineNumber" : 215,
        "startColumnNumber" : 12,
        "endLineNumber" : 270,
        "endColumnNumber" : 13
      },
      "nodeContext" : "while (i < readers.length) {\n  Block bloq=getNextBlockFrom(i);\n  if (bloq == null) {\n    i++;\n    continue;\n  }\n  if (bloq.data == null) {\n    blockWritten=1;\n    newClusterByTrackId=i;\n    i++;\n    continue;\n  }\n  if (newClusterByTrackId == i) {\n    limitTimecodeByTrackId=i;\n    newClusterByTrackId=-1;\n    baseTimecode=bloq.absoluteTimecode;\n    limitTimecode=baseTimecode + INTERV;\n    currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n  }\n  if (cuesForTrackId == i) {\n    if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n      if (nextCueTime > -1) {\n        nextCueTime+=DEFAULT_CUES_EACH_MS;\n      }\n      keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n    }\n  }\n  writeBlock(out,bloq,baseTimecode);\n  blockWritten++;\n  if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n    defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n  }\n  duration[i]=bloq.absoluteTimecode;\n  if (limitTimecode < 0) {\n    limitTimecode=bloq.absoluteTimecode + INTERV;\n    continue;\n  }\n  if (bloq.absoluteTimecode >= limitTimecode) {\n    if (limitTimecodeByTrackId != i) {\n      limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n    }\n    i++;\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 213,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 2320,
        "startLineNumber" : 212,
        "startColumnNumber" : 33,
        "endLineNumber" : 271,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  blockWritten=0;\n  int i=0;\n  while (i < readers.length) {\n    Block bloq=getNextBlockFrom(i);\n    if (bloq == null) {\n      i++;\n      continue;\n    }\n    if (bloq.data == null) {\n      blockWritten=1;\n      newClusterByTrackId=i;\n      i++;\n      continue;\n    }\n    if (newClusterByTrackId == i) {\n      limitTimecodeByTrackId=i;\n      newClusterByTrackId=-1;\n      baseTimecode=bloq.absoluteTimecode;\n      limitTimecode=baseTimecode + INTERV;\n      currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n    }\n    if (cuesForTrackId == i) {\n      if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n        if (nextCueTime > -1) {\n          nextCueTime+=DEFAULT_CUES_EACH_MS;\n        }\n        keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n      }\n    }\n    writeBlock(out,bloq,baseTimecode);\n    blockWritten++;\n    if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n      defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n    }\n    duration[i]=bloq.absoluteTimecode;\n    if (limitTimecode < 0) {\n      limitTimecode=bloq.absoluteTimecode + INTERV;\n      continue;\n    }\n    if (bloq.absoluteTimecode >= limitTimecode) {\n      if (limitTimecodeByTrackId != i) {\n        limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n      }\n      i++;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 223,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2345,
        "startLineNumber" : 212,
        "startColumnNumber" : 8,
        "endLineNumber" : 271,
        "endColumnNumber" : 9
      },
      "nodeContext" : "while (blockWritten > 0) {\n  blockWritten=0;\n  int i=0;\n  while (i < readers.length) {\n    Block bloq=getNextBlockFrom(i);\n    if (bloq == null) {\n      i++;\n      continue;\n    }\n    if (bloq.data == null) {\n      blockWritten=1;\n      newClusterByTrackId=i;\n      i++;\n      continue;\n    }\n    if (newClusterByTrackId == i) {\n      limitTimecodeByTrackId=i;\n      newClusterByTrackId=-1;\n      baseTimecode=bloq.absoluteTimecode;\n      limitTimecode=baseTimecode + INTERV;\n      currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n    }\n    if (cuesForTrackId == i) {\n      if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n        if (nextCueTime > -1) {\n          nextCueTime+=DEFAULT_CUES_EACH_MS;\n        }\n        keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n      }\n    }\n    writeBlock(out,bloq,baseTimecode);\n    blockWritten++;\n    if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n      defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n    }\n    duration[i]=bloq.absoluteTimecode;\n    if (limitTimecode < 0) {\n      limitTimecode=bloq.absoluteTimecode + INTERV;\n      continue;\n    }\n    if (bloq.absoluteTimecode >= limitTimecode) {\n      if (limitTimecodeByTrackId != i) {\n        limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n      }\n      i++;\n    }\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 227,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 113,
        "startLineNumber" : 244,
        "startColumnNumber" : 38,
        "endLineNumber" : 245,
        "endColumnNumber" : 54
      },
      "nodeContext" : "new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode)",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 9,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "long"
  }, {
    "nodeContext" : "written",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 275,
      "startColumnNumber" : 27,
      "endLineNumber" : 275,
      "endColumnNumber" : 34
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 275,
        "startColumnNumber" : 27,
        "endLineNumber" : 275,
        "endColumnNumber" : 61
      },
      "nodeContext" : "written - offsetSegmentSizeSet - 7",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 275,
        "startColumnNumber" : 13,
        "endLineNumber" : 275,
        "endColumnNumber" : 61
      },
      "nodeContext" : "segmentSize=written - offsetSegmentSizeSet - 7",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 275,
        "startColumnNumber" : 8,
        "endLineNumber" : 275,
        "endColumnNumber" : 62
      },
      "nodeContext" : "long segmentSize=written - offsetSegmentSizeSet - 7;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7635,
        "startLineNumber" : 124,
        "startColumnNumber" : 82,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 933,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7713,
        "startLineNumber" : 124,
        "startColumnNumber" : 4,
        "endLineNumber" : 329,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void build(final SharpStream out) throws IOException, RuntimeException {\n  if (!out.canRewind()) {\n    throw new IOException(\"The output stream must be allow seek\");\n  }\n  makeEBML(out);\n  long offsetSegmentSizeSet=written + 5;\n  long offsetInfoDurationSet=written + 94;\n  long offsetClusterSet=written + 58;\n  long offsetCuesSet=written + 75;\n  ArrayList<byte[]> listBuffer=new ArrayList<>(4);\n  listBuffer.add(new byte[]{0x18,0x53,(byte)0x80,0x67,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00});\n  long segmentOffset=written + listBuffer.get(0).length;\n  listBuffer.add(new byte[]{0x11,0x4d,(byte)0x9b,0x74,(byte)0xbe,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x15,0x49,(byte)0xa9,0x66,0x53,(byte)0xac,(byte)0x81,0x43,0x4d,(byte)0xbb,(byte)0x8b,0x53,(byte)0xab,(byte)0x84,0x16,0x54,(byte)0xae,0x6b,0x53,(byte)0xac,(byte)0x81,0x56,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1f,0x43,(byte)0xb6,0x75,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00,0x4d,(byte)0xbb,(byte)0x8e,0x53,(byte)0xab,(byte)0x84,0x1c,0x53,(byte)0xbb,0x6b,0x53,(byte)0xac,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.add(new byte[]{0x15,0x49,(byte)0xa9,0x66,(byte)0x8e,0x2a,(byte)0xd7,(byte)0xb1});\n  listBuffer.add(encode(DEFAULT_TIMECODE_SCALE,true));\n  listBuffer.add(new byte[]{0x44,(byte)0x89,(byte)0x84,0x00,0x00,0x00,0x00});\n  listBuffer.addAll(makeTracks());\n  dump(listBuffer,out);\n  long cueOffset=written;\n  makeEbmlVoid(out,CUE_RESERVE_SIZE,true);\n  int[] defaultSampleDuration=new int[infoTracks.length];\n  long[] duration=new long[infoTracks.length];\n  for (int i=0; i < infoTracks.length; i++) {\n    if (infoTracks[i].defaultDuration < 0) {\n      defaultSampleDuration[i]=-1;\n    }\n else {\n      defaultSampleDuration[i]=(int)Math.ceil(infoTracks[i].defaultDuration / (float)DEFAULT_TIMECODE_SCALE);\n    }\n    duration[i]=-1;\n  }\n  int cuesForTrackId=selectTrackForCue();\n  long nextCueTime=infoTracks[cuesForTrackId].trackType == 1 ? -1 : 0;\n  ArrayList<KeyFrame> keyFrames=new ArrayList<>(32);\n  int firstClusterOffset=(int)written;\n  long currentClusterOffset=makeCluster(out,0,0,true);\n  long baseTimecode=0;\n  long limitTimecode=-1;\n  int limitTimecodeByTrackId=cuesForTrackId;\n  int blockWritten=Integer.MAX_VALUE;\n  int newClusterByTrackId=-1;\n  while (blockWritten > 0) {\n    blockWritten=0;\n    int i=0;\n    while (i < readers.length) {\n      Block bloq=getNextBlockFrom(i);\n      if (bloq == null) {\n        i++;\n        continue;\n      }\n      if (bloq.data == null) {\n        blockWritten=1;\n        newClusterByTrackId=i;\n        i++;\n        continue;\n      }\n      if (newClusterByTrackId == i) {\n        limitTimecodeByTrackId=i;\n        newClusterByTrackId=-1;\n        baseTimecode=bloq.absoluteTimecode;\n        limitTimecode=baseTimecode + INTERV;\n        currentClusterOffset=makeCluster(out,baseTimecode,currentClusterOffset,true);\n      }\n      if (cuesForTrackId == i) {\n        if ((nextCueTime > -1 && bloq.absoluteTimecode >= nextCueTime) || (nextCueTime < 0 && bloq.isKeyframe())) {\n          if (nextCueTime > -1) {\n            nextCueTime+=DEFAULT_CUES_EACH_MS;\n          }\n          keyFrames.add(new KeyFrame(segmentOffset,currentClusterOffset,written,bloq.absoluteTimecode));\n        }\n      }\n      writeBlock(out,bloq,baseTimecode);\n      blockWritten++;\n      if (defaultSampleDuration[i] < 0 && duration[i] >= 0) {\n        defaultSampleDuration[i]=(int)(bloq.absoluteTimecode - duration[i]);\n      }\n      duration[i]=bloq.absoluteTimecode;\n      if (limitTimecode < 0) {\n        limitTimecode=bloq.absoluteTimecode + INTERV;\n        continue;\n      }\n      if (bloq.absoluteTimecode >= limitTimecode) {\n        if (limitTimecodeByTrackId != i) {\n          limitTimecode+=INTERV - (bloq.absoluteTimecode - limitTimecode);\n        }\n        i++;\n      }\n    }\n  }\n  makeCluster(out,-1,currentClusterOffset,false);\n  long segmentSize=written - offsetSegmentSizeSet - 7;\n  seekTo(out,offsetSegmentSizeSet);\n  outByteBuffer.putLong(0,segmentSize);\n  out.write(outBuffer,1,DataReader.LONG_SIZE - 1);\n  long longestDuration=0;\n  for (int i=0; i < duration.length; i++) {\n    if (defaultSampleDuration[i] > 0) {\n      duration[i]+=defaultSampleDuration[i];\n    }\n    if (duration[i] > longestDuration) {\n      longestDuration=duration[i];\n    }\n  }\n  seekTo(out,offsetInfoDurationSet);\n  outByteBuffer.putFloat(0,longestDuration);\n  dump(outBuffer,DataReader.FLOAT_SIZE,out);\n  firstClusterOffset-=segmentOffset;\n  writeInt(out,offsetClusterSet,firstClusterOffset);\n  seekTo(out,cueOffset);\n  short cueSize=0;\n  dump(new byte[]{0x1c,0x53,(byte)0xbb,0x6b,0x20,0x00,0x00},out);\n  for (  KeyFrame keyFrame : keyFrames) {\n    int size=makeCuePoint(cuesForTrackId,keyFrame,outBuffer);\n    if ((cueSize + size + 7+ MINIMUM_EBML_VOID_SIZE) > CUE_RESERVE_SIZE) {\n      break;\n    }\n    cueSize+=size;\n    dump(outBuffer,size,out);\n  }\n  makeEbmlVoid(out,CUE_RESERVE_SIZE - cueSize - 7,false);\n  seekTo(out,cueOffset + 5);\n  outByteBuffer.putShort(0,cueSize);\n  dump(outBuffer,DataReader.SHORT_SIZE,out);\n  writeInt(out,offsetCuesSet,(int)(cueOffset - segmentOffset));\n  for (  ClusterInfo cluster : clustersOffsetsSizes) {\n    writeInt(out,cluster.offset,cluster.size | 0x10000000);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 946,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 275,
        "startColumnNumber" : 8,
        "endLineNumber" : 275,
        "endColumnNumber" : 62
      },
      "nodeContext" : "long segmentSize=written - offsetSegmentSizeSet - 7;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "long"
  } ],
  "positionList" : [ {
    "charLength" : 7,
    "startLineNumber" : 131,
    "startColumnNumber" : 36,
    "endLineNumber" : 131,
    "endColumnNumber" : 43
  }, {
    "charLength" : 7,
    "startLineNumber" : 132,
    "startColumnNumber" : 37,
    "endLineNumber" : 132,
    "endColumnNumber" : 44
  }, {
    "charLength" : 7,
    "startLineNumber" : 133,
    "startColumnNumber" : 32,
    "endLineNumber" : 133,
    "endColumnNumber" : 39
  }, {
    "charLength" : 7,
    "startLineNumber" : 134,
    "startColumnNumber" : 29,
    "endLineNumber" : 134,
    "endColumnNumber" : 36
  }, {
    "charLength" : 7,
    "startLineNumber" : 144,
    "startColumnNumber" : 29,
    "endLineNumber" : 144,
    "endColumnNumber" : 36
  }, {
    "charLength" : 7,
    "startLineNumber" : 180,
    "startColumnNumber" : 25,
    "endLineNumber" : 180,
    "endColumnNumber" : 32
  }, {
    "charLength" : 7,
    "startLineNumber" : 201,
    "startColumnNumber" : 39,
    "endLineNumber" : 201,
    "endColumnNumber" : 46
  }, {
    "charLength" : 7,
    "startLineNumber" : 244,
    "startColumnNumber" : 88,
    "endLineNumber" : 244,
    "endColumnNumber" : 95
  }, {
    "charLength" : 7,
    "startLineNumber" : 275,
    "startColumnNumber" : 27,
    "endLineNumber" : 275,
    "endColumnNumber" : 34
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 2
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 2
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 11
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 11
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 3
  } ]
}