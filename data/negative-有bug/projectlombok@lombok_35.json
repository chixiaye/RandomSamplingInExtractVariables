{
  "id" : 35,
  "expression" : "toEclipseModifier(level) | Modifier.STATIC",
  "projectName" : "projectlombok@lombok",
  "commitID" : "25def866b50860715ee7c315c678b8c3d1ba9b56",
  "filePath" : "/src/core/lombok/eclipse/handlers/HandleConstructor.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "toEclipseModifier(level) | Modifier.STATIC",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 42,
      "startLineNumber" : 295,
      "startColumnNumber" : 26,
      "endLineNumber" : 295,
      "endColumnNumber" : 68
    },
    "astNodeNumber" : 7,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 66,
        "startLineNumber" : 295,
        "startColumnNumber" : 2,
        "endLineNumber" : 295,
        "endColumnNumber" : 68
      },
      "nodeContext" : "constructor.modifiers=toEclipseModifier(level) | Modifier.STATIC",
      "nodeType" : "Assignment",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 67,
        "startLineNumber" : 295,
        "startColumnNumber" : 2,
        "endLineNumber" : 295,
        "endColumnNumber" : 69
      },
      "nodeContext" : "constructor.modifiers=toEclipseModifier(level) | Modifier.STATIC;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 2999,
        "startLineNumber" : 287,
        "startColumnNumber" : 149,
        "endLineNumber" : 343,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  int pS=source.sourceStart, pE=source.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  MethodDeclaration constructor=new MethodDeclaration(((CompilationUnitDeclaration)type.top().get()).compilationResult);\n  setGeneratedBy(constructor,source);\n  constructor.modifiers=toEclipseModifier(level) | Modifier.STATIC;\n  TypeDeclaration typeDecl=(TypeDeclaration)type.get();\n  if (typeDecl.typeParameters != null && typeDecl.typeParameters.length > 0) {\n    TypeReference[] refs=new TypeReference[typeDecl.typeParameters.length];\n    int idx=0;\n    for (    TypeParameter param : typeDecl.typeParameters) {\n      TypeReference typeRef=new SingleTypeReference(param.name,(long)param.sourceStart << 32 | param.sourceEnd);\n      setGeneratedBy(typeRef,source);\n      refs[idx++]=typeRef;\n    }\n    constructor.returnType=new ParameterizedSingleTypeReference(typeDecl.name,refs,0,p);\n  }\n else   constructor.returnType=new SingleTypeReference(((TypeDeclaration)type.get()).name,p);\n  setGeneratedBy(constructor.returnType,source);\n  constructor.annotations=null;\n  constructor.selector=name.toCharArray();\n  constructor.thrownExceptions=null;\n  constructor.typeParameters=copyTypeParams(((TypeDeclaration)type.get()).typeParameters,source);\n  constructor.bits|=ECLIPSE_DO_NOT_TOUCH_FLAG;\n  constructor.bodyStart=constructor.declarationSourceStart=constructor.sourceStart=source.sourceStart;\n  constructor.bodyEnd=constructor.declarationSourceEnd=constructor.sourceEnd=source.sourceEnd;\n  List<Argument> params=new ArrayList<Argument>();\n  List<Expression> assigns=new ArrayList<Expression>();\n  AllocationExpression statement=new AllocationExpression();\n  statement.sourceStart=pS;\n  statement.sourceEnd=pE;\n  setGeneratedBy(statement,source);\n  statement.type=copyType(constructor.returnType,source);\n  for (  EclipseNode fieldNode : fields) {\n    FieldDeclaration field=(FieldDeclaration)fieldNode.get();\n    long fieldPos=(((long)field.sourceStart) << 32) | field.sourceEnd;\n    SingleNameReference nameRef=new SingleNameReference(field.name,fieldPos);\n    setGeneratedBy(nameRef,source);\n    assigns.add(nameRef);\n    Argument parameter=new Argument(field.name,fieldPos,copyType(field.type,source),Modifier.FINAL);\n    setGeneratedBy(parameter,source);\n    Annotation[] copiedAnnotations=copyAnnotations(source,findAnnotations(field,TransformationsUtil.NON_NULL_PATTERN),findAnnotations(field,TransformationsUtil.NULLABLE_PATTERN));\n    if (copiedAnnotations.length != 0)     parameter.annotations=copiedAnnotations;\n    params.add(parameter);\n  }\n  statement.arguments=assigns.isEmpty() ? null : assigns.toArray(new Expression[assigns.size()]);\n  constructor.arguments=params.isEmpty() ? null : params.toArray(new Argument[params.size()]);\n  constructor.statements=new Statement[]{new ReturnStatement(statement,(int)(p >> 32),(int)p)};\n  setGeneratedBy(constructor.statements[0],source);\n  return constructor;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 528,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3147,
        "startLineNumber" : 287,
        "startColumnNumber" : 1,
        "endLineNumber" : 343,
        "endColumnNumber" : 2
      },
      "nodeContext" : "private MethodDeclaration createStaticConstructor(AccessLevel level,String name,EclipseNode type,Collection<EclipseNode> fields,ASTNode source){\n  int pS=source.sourceStart, pE=source.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  MethodDeclaration constructor=new MethodDeclaration(((CompilationUnitDeclaration)type.top().get()).compilationResult);\n  setGeneratedBy(constructor,source);\n  constructor.modifiers=toEclipseModifier(level) | Modifier.STATIC;\n  TypeDeclaration typeDecl=(TypeDeclaration)type.get();\n  if (typeDecl.typeParameters != null && typeDecl.typeParameters.length > 0) {\n    TypeReference[] refs=new TypeReference[typeDecl.typeParameters.length];\n    int idx=0;\n    for (    TypeParameter param : typeDecl.typeParameters) {\n      TypeReference typeRef=new SingleTypeReference(param.name,(long)param.sourceStart << 32 | param.sourceEnd);\n      setGeneratedBy(typeRef,source);\n      refs[idx++]=typeRef;\n    }\n    constructor.returnType=new ParameterizedSingleTypeReference(typeDecl.name,refs,0,p);\n  }\n else   constructor.returnType=new SingleTypeReference(((TypeDeclaration)type.get()).name,p);\n  setGeneratedBy(constructor.returnType,source);\n  constructor.annotations=null;\n  constructor.selector=name.toCharArray();\n  constructor.thrownExceptions=null;\n  constructor.typeParameters=copyTypeParams(((TypeDeclaration)type.get()).typeParameters,source);\n  constructor.bits|=ECLIPSE_DO_NOT_TOUCH_FLAG;\n  constructor.bodyStart=constructor.declarationSourceStart=constructor.sourceStart=source.sourceStart;\n  constructor.bodyEnd=constructor.declarationSourceEnd=constructor.sourceEnd=source.sourceEnd;\n  List<Argument> params=new ArrayList<Argument>();\n  List<Expression> assigns=new ArrayList<Expression>();\n  AllocationExpression statement=new AllocationExpression();\n  statement.sourceStart=pS;\n  statement.sourceEnd=pE;\n  setGeneratedBy(statement,source);\n  statement.type=copyType(constructor.returnType,source);\n  for (  EclipseNode fieldNode : fields) {\n    FieldDeclaration field=(FieldDeclaration)fieldNode.get();\n    long fieldPos=(((long)field.sourceStart) << 32) | field.sourceEnd;\n    SingleNameReference nameRef=new SingleNameReference(field.name,fieldPos);\n    setGeneratedBy(nameRef,source);\n    assigns.add(nameRef);\n    Argument parameter=new Argument(field.name,fieldPos,copyType(field.type,source),Modifier.FINAL);\n    setGeneratedBy(parameter,source);\n    Annotation[] copiedAnnotations=copyAnnotations(source,findAnnotations(field,TransformationsUtil.NON_NULL_PATTERN),findAnnotations(field,TransformationsUtil.NULLABLE_PATTERN));\n    if (copiedAnnotations.length != 0)     parameter.annotations=copiedAnnotations;\n    params.add(parameter);\n  }\n  statement.arguments=assigns.isEmpty() ? null : assigns.toArray(new Expression[assigns.size()]);\n  constructor.arguments=params.isEmpty() ? null : params.toArray(new Argument[params.size()]);\n  constructor.statements=new Statement[]{new ReturnStatement(statement,(int)(p >> 32),(int)p)};\n  setGeneratedBy(constructor.statements[0],source);\n  return constructor;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 556,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 67,
        "startLineNumber" : 295,
        "startColumnNumber" : 2,
        "endLineNumber" : 295,
        "endColumnNumber" : 69
      },
      "nodeContext" : "constructor.modifiers=toEclipseModifier(level) | Modifier.STATIC;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 12,
      "astHeight" : 5
    },
    "tokenLength" : 5,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 42,
    "startLineNumber" : 295,
    "startColumnNumber" : 26,
    "endLineNumber" : 295,
    "endColumnNumber" : 68
  } ],
  "layoutRelationDataList" : [ ]
}