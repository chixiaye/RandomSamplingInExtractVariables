{
  "id" : 192,
  "expression" : "session.getLocalCertificates().length",
  "projectName" : "Netflix@zuul",
  "commitID" : "f8ef3551d8dd57a512336315ec51bb6c0444c517",
  "filePath" : "/zuul-core/src/main/java/com/netflix/zuul/netty/server/ssl/SslHandshakeInfoHandler.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "session.getLocalCertificates().length",
    "nodeType" : "FieldAccess",
    "nodePosition" : {
      "charLength" : 37,
      "startLineNumber" : 94,
      "startColumnNumber" : 66,
      "endLineNumber" : 94,
      "endColumnNumber" : 103
    },
    "astNodeNumber" : 5,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,rightOperand]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 94,
        "startColumnNumber" : 66,
        "endLineNumber" : 94,
        "endColumnNumber" : 107
      },
      "nodeContext" : "session.getLocalCertificates().length > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 94,
        "startColumnNumber" : 24,
        "endLineNumber" : 94,
        "endColumnNumber" : 107
      },
      "nodeContext" : "session.getLocalCertificates() != null && session.getLocalCertificates().length > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 184,
        "startLineNumber" : 94,
        "startColumnNumber" : 20,
        "endLineNumber" : 96,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (session.getLocalCertificates() != null && session.getLocalCertificates().length > 0) {\n  serverCert=session.getLocalCertificates()[0];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 23,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1760,
        "startLineNumber" : 78,
        "startColumnNumber" : 42,
        "endLineNumber" : 110,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  CurrentPassport.fromChannel(ctx.channel()).add(PassportState.SERVER_CH_SSL_HANDSHAKE_COMPLETE);\n  SslHandler sslhandler=(SslHandler)ctx.channel().pipeline().get(\"ssl\");\n  SSLSession session=sslhandler.engine().getSession();\n  ClientAuth clientAuth=whichClientAuthEnum(sslhandler);\n  Certificate serverCert=null;\n  X509Certificate peerCert=null;\n  if ((clientAuth == ClientAuth.REQUIRE || clientAuth == ClientAuth.OPTIONAL) && session.getPeerCertificateChain() != null && session.getPeerCertificateChain().length > 0) {\n    peerCert=session.getPeerCertificateChain()[0];\n  }\n  if (session.getLocalCertificates() != null && session.getLocalCertificates().length > 0) {\n    serverCert=session.getLocalCertificates()[0];\n  }\n  SslHandshakeInfo info=new SslHandshakeInfo(isSSlFromIntermediary,session.getProtocol(),session.getCipherSuite(),clientAuth,serverCert,peerCert);\n  ctx.channel().attr(ATTR_SSL_INFO).set(info);\n  incrementCounters(sslEvent,info);\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Successful SSL Handshake: \" + String.valueOf(info));\n  }\n else   if (LOG.isInfoEnabled()) {\n    LOG.info(\"Successful SSL Handshake: protocol={}, ciphersuite={}, has_client_cert={}\",info.getProtocol(),info.getCipherSuite(),info.getClientCertificate() != null);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 187,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5580,
        "startLineNumber" : 78,
        "startColumnNumber" : 16,
        "endLineNumber" : 170,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (sslEvent.isSuccess()) {\n  CurrentPassport.fromChannel(ctx.channel()).add(PassportState.SERVER_CH_SSL_HANDSHAKE_COMPLETE);\n  SslHandler sslhandler=(SslHandler)ctx.channel().pipeline().get(\"ssl\");\n  SSLSession session=sslhandler.engine().getSession();\n  ClientAuth clientAuth=whichClientAuthEnum(sslhandler);\n  Certificate serverCert=null;\n  X509Certificate peerCert=null;\n  if ((clientAuth == ClientAuth.REQUIRE || clientAuth == ClientAuth.OPTIONAL) && session.getPeerCertificateChain() != null && session.getPeerCertificateChain().length > 0) {\n    peerCert=session.getPeerCertificateChain()[0];\n  }\n  if (session.getLocalCertificates() != null && session.getLocalCertificates().length > 0) {\n    serverCert=session.getLocalCertificates()[0];\n  }\n  SslHandshakeInfo info=new SslHandshakeInfo(isSSlFromIntermediary,session.getProtocol(),session.getCipherSuite(),clientAuth,serverCert,peerCert);\n  ctx.channel().attr(ATTR_SSL_INFO).set(info);\n  incrementCounters(sslEvent,info);\n  if (LOG.isDebugEnabled()) {\n    LOG.debug(\"Successful SSL Handshake: \" + String.valueOf(info));\n  }\n else   if (LOG.isInfoEnabled()) {\n    LOG.info(\"Successful SSL Handshake: protocol={}, ciphersuite={}, has_client_cert={}\",info.getProtocol(),info.getCipherSuite(),info.getClientCertificate() != null);\n  }\n}\n else {\n  String clientIP=ctx.channel().attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).get();\n  Throwable cause=sslEvent.cause();\n  PassportState passportState=CurrentPassport.fromChannel(ctx.channel()).getState();\n  if (cause instanceof ClosedChannelException && (PassportState.SERVER_CH_INACTIVE.equals(passportState) || PassportState.SERVER_CH_IDLE_TIMEOUT.equals(passportState))) {\n    LOG.info(\"Client closed connection or it idle timed-out without doing an ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n  }\n else   if (cause instanceof SSLException && \"handshake timed out\".equals(cause.getMessage())) {\n    LOG.info(\"Client timed-out doing the ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n  }\n else   if (cause instanceof SSLException && cause.getMessage().contains(\"failure when writing TLS control frames\")) {\n    LOG.info(\"Client terminated handshake early.\" + \", client_ip = \" + clientIP + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n  }\n else {\n    String msg=\"Unsuccessful SSL Handshake: \" + String.valueOf(sslEvent) + \", client_ip = \"+ String.valueOf(clientIP)+ \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel())+ \", error = \"+ String.valueOf(cause);\n    if (cause != null && cause instanceof ClosedChannelException) {\n      LOG.warn(msg);\n    }\n else {\n      LOG.warn(msg,cause);\n    }\n    incrementCounters(sslEvent,null);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 385,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5702,
        "startLineNumber" : 76,
        "startColumnNumber" : 16,
        "endLineNumber" : 171,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  SslHandshakeCompletionEvent sslEvent=(SslHandshakeCompletionEvent)evt;\n  if (sslEvent.isSuccess()) {\n    CurrentPassport.fromChannel(ctx.channel()).add(PassportState.SERVER_CH_SSL_HANDSHAKE_COMPLETE);\n    SslHandler sslhandler=(SslHandler)ctx.channel().pipeline().get(\"ssl\");\n    SSLSession session=sslhandler.engine().getSession();\n    ClientAuth clientAuth=whichClientAuthEnum(sslhandler);\n    Certificate serverCert=null;\n    X509Certificate peerCert=null;\n    if ((clientAuth == ClientAuth.REQUIRE || clientAuth == ClientAuth.OPTIONAL) && session.getPeerCertificateChain() != null && session.getPeerCertificateChain().length > 0) {\n      peerCert=session.getPeerCertificateChain()[0];\n    }\n    if (session.getLocalCertificates() != null && session.getLocalCertificates().length > 0) {\n      serverCert=session.getLocalCertificates()[0];\n    }\n    SslHandshakeInfo info=new SslHandshakeInfo(isSSlFromIntermediary,session.getProtocol(),session.getCipherSuite(),clientAuth,serverCert,peerCert);\n    ctx.channel().attr(ATTR_SSL_INFO).set(info);\n    incrementCounters(sslEvent,info);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Successful SSL Handshake: \" + String.valueOf(info));\n    }\n else     if (LOG.isInfoEnabled()) {\n      LOG.info(\"Successful SSL Handshake: protocol={}, ciphersuite={}, has_client_cert={}\",info.getProtocol(),info.getCipherSuite(),info.getClientCertificate() != null);\n    }\n  }\n else {\n    String clientIP=ctx.channel().attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).get();\n    Throwable cause=sslEvent.cause();\n    PassportState passportState=CurrentPassport.fromChannel(ctx.channel()).getState();\n    if (cause instanceof ClosedChannelException && (PassportState.SERVER_CH_INACTIVE.equals(passportState) || PassportState.SERVER_CH_IDLE_TIMEOUT.equals(passportState))) {\n      LOG.info(\"Client closed connection or it idle timed-out without doing an ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n    }\n else     if (cause instanceof SSLException && \"handshake timed out\".equals(cause.getMessage())) {\n      LOG.info(\"Client timed-out doing the ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n    }\n else     if (cause instanceof SSLException && cause.getMessage().contains(\"failure when writing TLS control frames\")) {\n      LOG.info(\"Client terminated handshake early.\" + \", client_ip = \" + clientIP + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n    }\n else {\n      String msg=\"Unsuccessful SSL Handshake: \" + String.valueOf(sslEvent) + \", client_ip = \"+ String.valueOf(clientIP)+ \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel())+ \", error = \"+ String.valueOf(cause);\n      if (cause != null && cause instanceof ClosedChannelException) {\n        LOG.warn(msg);\n      }\n else {\n        LOG.warn(msg,cause);\n      }\n      incrementCounters(sslEvent,null);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 395,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6024,
        "startLineNumber" : 76,
        "startColumnNumber" : 12,
        "endLineNumber" : 178,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  SslHandshakeCompletionEvent sslEvent=(SslHandshakeCompletionEvent)evt;\n  if (sslEvent.isSuccess()) {\n    CurrentPassport.fromChannel(ctx.channel()).add(PassportState.SERVER_CH_SSL_HANDSHAKE_COMPLETE);\n    SslHandler sslhandler=(SslHandler)ctx.channel().pipeline().get(\"ssl\");\n    SSLSession session=sslhandler.engine().getSession();\n    ClientAuth clientAuth=whichClientAuthEnum(sslhandler);\n    Certificate serverCert=null;\n    X509Certificate peerCert=null;\n    if ((clientAuth == ClientAuth.REQUIRE || clientAuth == ClientAuth.OPTIONAL) && session.getPeerCertificateChain() != null && session.getPeerCertificateChain().length > 0) {\n      peerCert=session.getPeerCertificateChain()[0];\n    }\n    if (session.getLocalCertificates() != null && session.getLocalCertificates().length > 0) {\n      serverCert=session.getLocalCertificates()[0];\n    }\n    SslHandshakeInfo info=new SslHandshakeInfo(isSSlFromIntermediary,session.getProtocol(),session.getCipherSuite(),clientAuth,serverCert,peerCert);\n    ctx.channel().attr(ATTR_SSL_INFO).set(info);\n    incrementCounters(sslEvent,info);\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Successful SSL Handshake: \" + String.valueOf(info));\n    }\n else     if (LOG.isInfoEnabled()) {\n      LOG.info(\"Successful SSL Handshake: protocol={}, ciphersuite={}, has_client_cert={}\",info.getProtocol(),info.getCipherSuite(),info.getClientCertificate() != null);\n    }\n  }\n else {\n    String clientIP=ctx.channel().attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).get();\n    Throwable cause=sslEvent.cause();\n    PassportState passportState=CurrentPassport.fromChannel(ctx.channel()).getState();\n    if (cause instanceof ClosedChannelException && (PassportState.SERVER_CH_INACTIVE.equals(passportState) || PassportState.SERVER_CH_IDLE_TIMEOUT.equals(passportState))) {\n      LOG.info(\"Client closed connection or it idle timed-out without doing an ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n    }\n else     if (cause instanceof SSLException && \"handshake timed out\".equals(cause.getMessage())) {\n      LOG.info(\"Client timed-out doing the ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n    }\n else     if (cause instanceof SSLException && cause.getMessage().contains(\"failure when writing TLS control frames\")) {\n      LOG.info(\"Client terminated handshake early.\" + \", client_ip = \" + clientIP + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n    }\n else {\n      String msg=\"Unsuccessful SSL Handshake: \" + String.valueOf(sslEvent) + \", client_ip = \"+ String.valueOf(clientIP)+ \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel())+ \", error = \"+ String.valueOf(cause);\n      if (cause != null && cause instanceof ClosedChannelException) {\n        LOG.warn(msg);\n      }\n else {\n        LOG.warn(msg,cause);\n      }\n      incrementCounters(sslEvent,null);\n    }\n  }\n}\n catch (Throwable e) {\n  LOG.warn(\"Error getting the SSL handshake info.\",e);\n}\n finally {\n  ctx.pipeline().remove(this);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 416,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 6048,
        "startLineNumber" : 75,
        "startColumnNumber" : 56,
        "endLineNumber" : 179,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  try {\n    SslHandshakeCompletionEvent sslEvent=(SslHandshakeCompletionEvent)evt;\n    if (sslEvent.isSuccess()) {\n      CurrentPassport.fromChannel(ctx.channel()).add(PassportState.SERVER_CH_SSL_HANDSHAKE_COMPLETE);\n      SslHandler sslhandler=(SslHandler)ctx.channel().pipeline().get(\"ssl\");\n      SSLSession session=sslhandler.engine().getSession();\n      ClientAuth clientAuth=whichClientAuthEnum(sslhandler);\n      Certificate serverCert=null;\n      X509Certificate peerCert=null;\n      if ((clientAuth == ClientAuth.REQUIRE || clientAuth == ClientAuth.OPTIONAL) && session.getPeerCertificateChain() != null && session.getPeerCertificateChain().length > 0) {\n        peerCert=session.getPeerCertificateChain()[0];\n      }\n      if (session.getLocalCertificates() != null && session.getLocalCertificates().length > 0) {\n        serverCert=session.getLocalCertificates()[0];\n      }\n      SslHandshakeInfo info=new SslHandshakeInfo(isSSlFromIntermediary,session.getProtocol(),session.getCipherSuite(),clientAuth,serverCert,peerCert);\n      ctx.channel().attr(ATTR_SSL_INFO).set(info);\n      incrementCounters(sslEvent,info);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Successful SSL Handshake: \" + String.valueOf(info));\n      }\n else       if (LOG.isInfoEnabled()) {\n        LOG.info(\"Successful SSL Handshake: protocol={}, ciphersuite={}, has_client_cert={}\",info.getProtocol(),info.getCipherSuite(),info.getClientCertificate() != null);\n      }\n    }\n else {\n      String clientIP=ctx.channel().attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).get();\n      Throwable cause=sslEvent.cause();\n      PassportState passportState=CurrentPassport.fromChannel(ctx.channel()).getState();\n      if (cause instanceof ClosedChannelException && (PassportState.SERVER_CH_INACTIVE.equals(passportState) || PassportState.SERVER_CH_IDLE_TIMEOUT.equals(passportState))) {\n        LOG.info(\"Client closed connection or it idle timed-out without doing an ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n      }\n else       if (cause instanceof SSLException && \"handshake timed out\".equals(cause.getMessage())) {\n        LOG.info(\"Client timed-out doing the ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n      }\n else       if (cause instanceof SSLException && cause.getMessage().contains(\"failure when writing TLS control frames\")) {\n        LOG.info(\"Client terminated handshake early.\" + \", client_ip = \" + clientIP + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n      }\n else {\n        String msg=\"Unsuccessful SSL Handshake: \" + String.valueOf(sslEvent) + \", client_ip = \"+ String.valueOf(clientIP)+ \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel())+ \", error = \"+ String.valueOf(cause);\n        if (cause != null && cause instanceof ClosedChannelException) {\n          LOG.warn(msg);\n        }\n else {\n          LOG.warn(msg,cause);\n        }\n        incrementCounters(sslEvent,null);\n      }\n    }\n  }\n catch (  Throwable e) {\n    LOG.warn(\"Error getting the SSL handshake info.\",e);\n  }\n finally {\n    ctx.pipeline().remove(this);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 417,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6231,
        "startLineNumber" : 75,
        "startColumnNumber" : 8,
        "endLineNumber" : 182,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (evt instanceof SslHandshakeCompletionEvent) {\n  try {\n    SslHandshakeCompletionEvent sslEvent=(SslHandshakeCompletionEvent)evt;\n    if (sslEvent.isSuccess()) {\n      CurrentPassport.fromChannel(ctx.channel()).add(PassportState.SERVER_CH_SSL_HANDSHAKE_COMPLETE);\n      SslHandler sslhandler=(SslHandler)ctx.channel().pipeline().get(\"ssl\");\n      SSLSession session=sslhandler.engine().getSession();\n      ClientAuth clientAuth=whichClientAuthEnum(sslhandler);\n      Certificate serverCert=null;\n      X509Certificate peerCert=null;\n      if ((clientAuth == ClientAuth.REQUIRE || clientAuth == ClientAuth.OPTIONAL) && session.getPeerCertificateChain() != null && session.getPeerCertificateChain().length > 0) {\n        peerCert=session.getPeerCertificateChain()[0];\n      }\n      if (session.getLocalCertificates() != null && session.getLocalCertificates().length > 0) {\n        serverCert=session.getLocalCertificates()[0];\n      }\n      SslHandshakeInfo info=new SslHandshakeInfo(isSSlFromIntermediary,session.getProtocol(),session.getCipherSuite(),clientAuth,serverCert,peerCert);\n      ctx.channel().attr(ATTR_SSL_INFO).set(info);\n      incrementCounters(sslEvent,info);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Successful SSL Handshake: \" + String.valueOf(info));\n      }\n else       if (LOG.isInfoEnabled()) {\n        LOG.info(\"Successful SSL Handshake: protocol={}, ciphersuite={}, has_client_cert={}\",info.getProtocol(),info.getCipherSuite(),info.getClientCertificate() != null);\n      }\n    }\n else {\n      String clientIP=ctx.channel().attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).get();\n      Throwable cause=sslEvent.cause();\n      PassportState passportState=CurrentPassport.fromChannel(ctx.channel()).getState();\n      if (cause instanceof ClosedChannelException && (PassportState.SERVER_CH_INACTIVE.equals(passportState) || PassportState.SERVER_CH_IDLE_TIMEOUT.equals(passportState))) {\n        LOG.info(\"Client closed connection or it idle timed-out without doing an ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n      }\n else       if (cause instanceof SSLException && \"handshake timed out\".equals(cause.getMessage())) {\n        LOG.info(\"Client timed-out doing the ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n      }\n else       if (cause instanceof SSLException && cause.getMessage().contains(\"failure when writing TLS control frames\")) {\n        LOG.info(\"Client terminated handshake early.\" + \", client_ip = \" + clientIP + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n      }\n else {\n        String msg=\"Unsuccessful SSL Handshake: \" + String.valueOf(sslEvent) + \", client_ip = \"+ String.valueOf(clientIP)+ \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel())+ \", error = \"+ String.valueOf(cause);\n        if (cause != null && cause instanceof ClosedChannelException) {\n          LOG.warn(msg);\n        }\n else {\n          LOG.warn(msg,cause);\n        }\n        incrementCounters(sslEvent,null);\n      }\n    }\n  }\n catch (  Throwable e) {\n    LOG.warn(\"Error getting the SSL handshake info.\",e);\n  }\n finally {\n    ctx.pipeline().remove(this);\n  }\n}\n else if (evt instanceof SslCloseCompletionEvent) {\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 428,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6292,
        "startLineNumber" : 74,
        "startColumnNumber" : 4,
        "endLineNumber" : 185,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (evt instanceof SslHandshakeCompletionEvent) {\n    try {\n      SslHandshakeCompletionEvent sslEvent=(SslHandshakeCompletionEvent)evt;\n      if (sslEvent.isSuccess()) {\n        CurrentPassport.fromChannel(ctx.channel()).add(PassportState.SERVER_CH_SSL_HANDSHAKE_COMPLETE);\n        SslHandler sslhandler=(SslHandler)ctx.channel().pipeline().get(\"ssl\");\n        SSLSession session=sslhandler.engine().getSession();\n        ClientAuth clientAuth=whichClientAuthEnum(sslhandler);\n        Certificate serverCert=null;\n        X509Certificate peerCert=null;\n        if ((clientAuth == ClientAuth.REQUIRE || clientAuth == ClientAuth.OPTIONAL) && session.getPeerCertificateChain() != null && session.getPeerCertificateChain().length > 0) {\n          peerCert=session.getPeerCertificateChain()[0];\n        }\n        if (session.getLocalCertificates() != null && session.getLocalCertificates().length > 0) {\n          serverCert=session.getLocalCertificates()[0];\n        }\n        SslHandshakeInfo info=new SslHandshakeInfo(isSSlFromIntermediary,session.getProtocol(),session.getCipherSuite(),clientAuth,serverCert,peerCert);\n        ctx.channel().attr(ATTR_SSL_INFO).set(info);\n        incrementCounters(sslEvent,info);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Successful SSL Handshake: \" + String.valueOf(info));\n        }\n else         if (LOG.isInfoEnabled()) {\n          LOG.info(\"Successful SSL Handshake: protocol={}, ciphersuite={}, has_client_cert={}\",info.getProtocol(),info.getCipherSuite(),info.getClientCertificate() != null);\n        }\n      }\n else {\n        String clientIP=ctx.channel().attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).get();\n        Throwable cause=sslEvent.cause();\n        PassportState passportState=CurrentPassport.fromChannel(ctx.channel()).getState();\n        if (cause instanceof ClosedChannelException && (PassportState.SERVER_CH_INACTIVE.equals(passportState) || PassportState.SERVER_CH_IDLE_TIMEOUT.equals(passportState))) {\n          LOG.info(\"Client closed connection or it idle timed-out without doing an ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n        }\n else         if (cause instanceof SSLException && \"handshake timed out\".equals(cause.getMessage())) {\n          LOG.info(\"Client timed-out doing the ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n        }\n else         if (cause instanceof SSLException && cause.getMessage().contains(\"failure when writing TLS control frames\")) {\n          LOG.info(\"Client terminated handshake early.\" + \", client_ip = \" + clientIP + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n        }\n else {\n          String msg=\"Unsuccessful SSL Handshake: \" + String.valueOf(sslEvent) + \", client_ip = \"+ String.valueOf(clientIP)+ \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel())+ \", error = \"+ String.valueOf(cause);\n          if (cause != null && cause instanceof ClosedChannelException) {\n            LOG.warn(msg);\n          }\n else {\n            LOG.warn(msg,cause);\n          }\n          incrementCounters(sslEvent,null);\n        }\n      }\n    }\n catch (    Throwable e) {\n      LOG.warn(\"Error getting the SSL handshake info.\",e);\n    }\n finally {\n      ctx.pipeline().remove(this);\n    }\n  }\n else   if (evt instanceof SslCloseCompletionEvent) {\n  }\n  super.userEventTriggered(ctx,evt);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 434,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6397,
        "startLineNumber" : 72,
        "startColumnNumber" : 4,
        "endLineNumber" : 185,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@Override public void userEventTriggered(ChannelHandlerContext ctx,Object evt) throws Exception {\n  if (evt instanceof SslHandshakeCompletionEvent) {\n    try {\n      SslHandshakeCompletionEvent sslEvent=(SslHandshakeCompletionEvent)evt;\n      if (sslEvent.isSuccess()) {\n        CurrentPassport.fromChannel(ctx.channel()).add(PassportState.SERVER_CH_SSL_HANDSHAKE_COMPLETE);\n        SslHandler sslhandler=(SslHandler)ctx.channel().pipeline().get(\"ssl\");\n        SSLSession session=sslhandler.engine().getSession();\n        ClientAuth clientAuth=whichClientAuthEnum(sslhandler);\n        Certificate serverCert=null;\n        X509Certificate peerCert=null;\n        if ((clientAuth == ClientAuth.REQUIRE || clientAuth == ClientAuth.OPTIONAL) && session.getPeerCertificateChain() != null && session.getPeerCertificateChain().length > 0) {\n          peerCert=session.getPeerCertificateChain()[0];\n        }\n        if (session.getLocalCertificates() != null && session.getLocalCertificates().length > 0) {\n          serverCert=session.getLocalCertificates()[0];\n        }\n        SslHandshakeInfo info=new SslHandshakeInfo(isSSlFromIntermediary,session.getProtocol(),session.getCipherSuite(),clientAuth,serverCert,peerCert);\n        ctx.channel().attr(ATTR_SSL_INFO).set(info);\n        incrementCounters(sslEvent,info);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Successful SSL Handshake: \" + String.valueOf(info));\n        }\n else         if (LOG.isInfoEnabled()) {\n          LOG.info(\"Successful SSL Handshake: protocol={}, ciphersuite={}, has_client_cert={}\",info.getProtocol(),info.getCipherSuite(),info.getClientCertificate() != null);\n        }\n      }\n else {\n        String clientIP=ctx.channel().attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).get();\n        Throwable cause=sslEvent.cause();\n        PassportState passportState=CurrentPassport.fromChannel(ctx.channel()).getState();\n        if (cause instanceof ClosedChannelException && (PassportState.SERVER_CH_INACTIVE.equals(passportState) || PassportState.SERVER_CH_IDLE_TIMEOUT.equals(passportState))) {\n          LOG.info(\"Client closed connection or it idle timed-out without doing an ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n        }\n else         if (cause instanceof SSLException && \"handshake timed out\".equals(cause.getMessage())) {\n          LOG.info(\"Client timed-out doing the ssl handshake. \" + \", client_ip = \" + String.valueOf(clientIP) + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n        }\n else         if (cause instanceof SSLException && cause.getMessage().contains(\"failure when writing TLS control frames\")) {\n          LOG.info(\"Client terminated handshake early.\" + \", client_ip = \" + clientIP + \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel()));\n        }\n else {\n          String msg=\"Unsuccessful SSL Handshake: \" + String.valueOf(sslEvent) + \", client_ip = \"+ String.valueOf(clientIP)+ \", channel_info = \"+ ChannelUtils.channelInfoForLogging(ctx.channel())+ \", error = \"+ String.valueOf(cause);\n          if (cause != null && cause instanceof ClosedChannelException) {\n            LOG.warn(msg);\n          }\n else {\n            LOG.warn(msg,cause);\n          }\n          incrementCounters(sslEvent,null);\n        }\n      }\n    }\n catch (    Throwable e) {\n      LOG.warn(\"Error getting the SSL handshake info.\",e);\n    }\n finally {\n      ctx.pipeline().remove(this);\n    }\n  }\n else   if (evt instanceof SslCloseCompletionEvent) {\n  }\n  super.userEventTriggered(ctx,evt);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 450,
      "astHeight" : 18
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 83,
        "startLineNumber" : 94,
        "startColumnNumber" : 24,
        "endLineNumber" : 94,
        "endColumnNumber" : 107
      },
      "nodeContext" : "session.getLocalCertificates() != null && session.getLocalCertificates().length > 0",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    },
    "tokenLength" : 3,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 37,
    "startLineNumber" : 94,
    "startColumnNumber" : 66,
    "endLineNumber" : 94,
    "endColumnNumber" : 103
  } ],
  "layoutRelationDataList" : [ ]
}