{
  "id" : 111,
  "expression" : "node.getFilter().get()",
  "projectName" : "prestodb@presto",
  "commitID" : "eff77883d0d24dc6022ecde252612d1430c9fbac",
  "filePath" : "/presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionAnalyzer.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "node.getFilter().get()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 22,
      "startLineNumber" : 912,
      "startColumnNumber" : 40,
      "endLineNumber" : 912,
      "endColumnNumber" : 62
    },
    "astNodeNumber" : 5,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 912,
        "startColumnNumber" : 27,
        "endLineNumber" : 912,
        "endColumnNumber" : 62
      },
      "nodeContext" : "expression=node.getFilter().get()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 912,
        "startColumnNumber" : 16,
        "endLineNumber" : 912,
        "endColumnNumber" : 63
      },
      "nodeContext" : "Expression expression=node.getFilter().get();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 125,
        "startLineNumber" : 911,
        "startColumnNumber" : 46,
        "endLineNumber" : 914,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  Expression expression=node.getFilter().get();\n  process(expression,context);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 159,
        "startLineNumber" : 911,
        "startColumnNumber" : 12,
        "endLineNumber" : 914,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (node.getFilter().isPresent()) {\n  Expression expression=node.getFilter().get();\n  process(expression,context);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 22,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7991,
        "startLineNumber" : 872,
        "startColumnNumber" : 8,
        "endLineNumber" : 1000,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  if (node.getWindow().isPresent()) {\n    for (    Expression expression : node.getWindow().get().getPartitionBy()) {\n      process(expression,context);\n      Type type=getExpressionType(expression);\n      if (!type.isComparable()) {\n        throw new SemanticException(TYPE_MISMATCH,node,\"%s is not comparable, and therefore cannot be used in window function PARTITION BY\",type);\n      }\n    }\n    for (    SortItem sortItem : getSortItemsFromOrderBy(node.getWindow().get().getOrderBy())) {\n      process(sortItem.getSortKey(),context);\n      Type type=getExpressionType(sortItem.getSortKey());\n      if (!type.isOrderable()) {\n        throw new SemanticException(TYPE_MISMATCH,node,\"%s is not orderable, and therefore cannot be used in window function ORDER BY\",type);\n      }\n    }\n    if (node.getWindow().get().getFrame().isPresent()) {\n      WindowFrame frame=node.getWindow().get().getFrame().get();\n      if (frame.getStart().getValue().isPresent()) {\n        Type type=process(frame.getStart().getValue().get(),context);\n        if (!type.equals(INTEGER) && !type.equals(BIGINT)) {\n          throw new SemanticException(TYPE_MISMATCH,node,\"Window frame start value type must be INTEGER or BIGINT(actual %s)\",type);\n        }\n      }\n      if (frame.getEnd().isPresent() && frame.getEnd().get().getValue().isPresent()) {\n        Type type=process(frame.getEnd().get().getValue().get(),context);\n        if (!type.equals(INTEGER) && !type.equals(BIGINT)) {\n          throw new SemanticException(TYPE_MISMATCH,node,\"Window frame end value type must be INTEGER or BIGINT (actual %s)\",type);\n        }\n      }\n    }\n    windowFunctions.add(NodeRef.of(node));\n  }\n  if (node.getFilter().isPresent()) {\n    Expression expression=node.getFilter().get();\n    process(expression,context);\n  }\n  ImmutableList.Builder<TypeSignatureProvider> argumentTypesBuilder=ImmutableList.builder();\n  for (  Expression expression : node.getArguments()) {\n    if (expression instanceof LambdaExpression || expression instanceof BindExpression) {\n      argumentTypesBuilder.add(new TypeSignatureProvider(types -> {\n        ExpressionAnalyzer innerExpressionAnalyzer=new ExpressionAnalyzer(functionAndTypeManager,statementAnalyzerFactory,sessionFunctions,transactionId,sqlFunctionProperties,symbolTypes,parameters,warningCollector,isDescribe);\n        if (context.getContext().isInLambda()) {\n          for (          LambdaArgumentDeclaration argument : context.getContext().getFieldToLambdaArgumentDeclaration().values()) {\n            innerExpressionAnalyzer.setExpressionType(argument,getExpressionType(argument));\n          }\n        }\n        Type type=innerExpressionAnalyzer.analyze(expression,baseScope,context.getContext().expectingLambda(types));\n        if (expression instanceof LambdaExpression) {\n          verifyNoAggregateWindowOrGroupingFunctions(innerExpressionAnalyzer.getResolvedFunctions(),functionAndTypeManager,((LambdaExpression)expression).getBody(),\"Lambda expression\");\n          verifyNoExternalFunctions(innerExpressionAnalyzer.getResolvedFunctions(),functionAndTypeManager,((LambdaExpression)expression).getBody(),\"Lambda expression\");\n        }\n        return type.getTypeSignature();\n      }\n));\n    }\n else {\n      argumentTypesBuilder.add(new TypeSignatureProvider(process(expression,context).getTypeSignature()));\n    }\n  }\n  ImmutableList<TypeSignatureProvider> argumentTypes=argumentTypesBuilder.build();\n  FunctionHandle function=resolveFunction(sessionFunctions,transactionId,node,argumentTypes,functionAndTypeManager);\n  FunctionMetadata functionMetadata=functionAndTypeManager.getFunctionMetadata(function);\n  if (node.getOrderBy().isPresent()) {\n    for (    SortItem sortItem : node.getOrderBy().get().getSortItems()) {\n      Type sortKeyType=process(sortItem.getSortKey(),context);\n      if (!sortKeyType.isOrderable()) {\n        throw new SemanticException(TYPE_MISMATCH,node,\"ORDER BY can only be applied to orderable types (actual: %s)\",sortKeyType.getDisplayName());\n      }\n    }\n  }\n  for (int i=0; i < node.getArguments().size(); i++) {\n    Expression expression=node.getArguments().get(i);\n    Type expectedType=functionAndTypeManager.getType(functionMetadata.getArgumentTypes().get(i));\n    requireNonNull(expectedType,format(\"Type %s not found\",functionMetadata.getArgumentTypes().get(i)));\n    if (node.isDistinct() && !expectedType.isComparable()) {\n      throw new SemanticException(TYPE_MISMATCH,node,\"DISTINCT can only be applied to comparable types (actual: %s)\",expectedType);\n    }\n    if (argumentTypes.get(i).hasDependency()) {\n      FunctionType expectedFunctionType=(FunctionType)expectedType;\n      process(expression,new StackableAstVisitorContext<>(context.getContext().expectingLambda(expectedFunctionType.getArgumentTypes())));\n    }\n else {\n      Type actualType=functionAndTypeManager.getType(argumentTypes.get(i).getTypeSignature());\n      coerceType(expression,actualType,expectedType,format(\"Function %s argument %d\",function,i));\n    }\n  }\n  resolvedFunctions.put(NodeRef.of(node),function);\n  if (functionMetadata.getName().equals(QualifiedObjectName.valueOf(DEFAULT_NAMESPACE,\"REDUCE_AGG\"))) {\n    Expression initialValueArg=node.getArguments().get(1);\n    if (!isNonNullConstant(initialValueArg)) {\n      throw new SemanticException(INVALID_PROCEDURE_ARGUMENTS,initialValueArg,\"REDUCE_AGG only supports non-NULL literal as the initial value\",initialValueArg);\n    }\n  }\n  Type type=functionAndTypeManager.getType(functionMetadata.getReturnType());\n  if (type instanceof MapType) {\n    Type keyType=((MapType)type).getKeyType();\n    if (TypeUtils.isApproximateNumericType(keyType)) {\n      String warningMessage=createWarningMessage(node,\"Map keys with real/double type can be non-deterministic. Please use decimal type instead\");\n      warningCollector.add(new PrestoWarning(SEMANTIC_WARNING,warningMessage));\n    }\n  }\n  return setExpressionType(node,type);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 722,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8114,
        "startLineNumber" : 870,
        "startColumnNumber" : 8,
        "endLineNumber" : 1000,
        "endColumnNumber" : 9
      },
      "nodeContext" : "@Override protected Type visitFunctionCall(FunctionCall node,StackableAstVisitorContext<Context> context){\n  if (node.getWindow().isPresent()) {\n    for (    Expression expression : node.getWindow().get().getPartitionBy()) {\n      process(expression,context);\n      Type type=getExpressionType(expression);\n      if (!type.isComparable()) {\n        throw new SemanticException(TYPE_MISMATCH,node,\"%s is not comparable, and therefore cannot be used in window function PARTITION BY\",type);\n      }\n    }\n    for (    SortItem sortItem : getSortItemsFromOrderBy(node.getWindow().get().getOrderBy())) {\n      process(sortItem.getSortKey(),context);\n      Type type=getExpressionType(sortItem.getSortKey());\n      if (!type.isOrderable()) {\n        throw new SemanticException(TYPE_MISMATCH,node,\"%s is not orderable, and therefore cannot be used in window function ORDER BY\",type);\n      }\n    }\n    if (node.getWindow().get().getFrame().isPresent()) {\n      WindowFrame frame=node.getWindow().get().getFrame().get();\n      if (frame.getStart().getValue().isPresent()) {\n        Type type=process(frame.getStart().getValue().get(),context);\n        if (!type.equals(INTEGER) && !type.equals(BIGINT)) {\n          throw new SemanticException(TYPE_MISMATCH,node,\"Window frame start value type must be INTEGER or BIGINT(actual %s)\",type);\n        }\n      }\n      if (frame.getEnd().isPresent() && frame.getEnd().get().getValue().isPresent()) {\n        Type type=process(frame.getEnd().get().getValue().get(),context);\n        if (!type.equals(INTEGER) && !type.equals(BIGINT)) {\n          throw new SemanticException(TYPE_MISMATCH,node,\"Window frame end value type must be INTEGER or BIGINT (actual %s)\",type);\n        }\n      }\n    }\n    windowFunctions.add(NodeRef.of(node));\n  }\n  if (node.getFilter().isPresent()) {\n    Expression expression=node.getFilter().get();\n    process(expression,context);\n  }\n  ImmutableList.Builder<TypeSignatureProvider> argumentTypesBuilder=ImmutableList.builder();\n  for (  Expression expression : node.getArguments()) {\n    if (expression instanceof LambdaExpression || expression instanceof BindExpression) {\n      argumentTypesBuilder.add(new TypeSignatureProvider(types -> {\n        ExpressionAnalyzer innerExpressionAnalyzer=new ExpressionAnalyzer(functionAndTypeManager,statementAnalyzerFactory,sessionFunctions,transactionId,sqlFunctionProperties,symbolTypes,parameters,warningCollector,isDescribe);\n        if (context.getContext().isInLambda()) {\n          for (          LambdaArgumentDeclaration argument : context.getContext().getFieldToLambdaArgumentDeclaration().values()) {\n            innerExpressionAnalyzer.setExpressionType(argument,getExpressionType(argument));\n          }\n        }\n        Type type=innerExpressionAnalyzer.analyze(expression,baseScope,context.getContext().expectingLambda(types));\n        if (expression instanceof LambdaExpression) {\n          verifyNoAggregateWindowOrGroupingFunctions(innerExpressionAnalyzer.getResolvedFunctions(),functionAndTypeManager,((LambdaExpression)expression).getBody(),\"Lambda expression\");\n          verifyNoExternalFunctions(innerExpressionAnalyzer.getResolvedFunctions(),functionAndTypeManager,((LambdaExpression)expression).getBody(),\"Lambda expression\");\n        }\n        return type.getTypeSignature();\n      }\n));\n    }\n else {\n      argumentTypesBuilder.add(new TypeSignatureProvider(process(expression,context).getTypeSignature()));\n    }\n  }\n  ImmutableList<TypeSignatureProvider> argumentTypes=argumentTypesBuilder.build();\n  FunctionHandle function=resolveFunction(sessionFunctions,transactionId,node,argumentTypes,functionAndTypeManager);\n  FunctionMetadata functionMetadata=functionAndTypeManager.getFunctionMetadata(function);\n  if (node.getOrderBy().isPresent()) {\n    for (    SortItem sortItem : node.getOrderBy().get().getSortItems()) {\n      Type sortKeyType=process(sortItem.getSortKey(),context);\n      if (!sortKeyType.isOrderable()) {\n        throw new SemanticException(TYPE_MISMATCH,node,\"ORDER BY can only be applied to orderable types (actual: %s)\",sortKeyType.getDisplayName());\n      }\n    }\n  }\n  for (int i=0; i < node.getArguments().size(); i++) {\n    Expression expression=node.getArguments().get(i);\n    Type expectedType=functionAndTypeManager.getType(functionMetadata.getArgumentTypes().get(i));\n    requireNonNull(expectedType,format(\"Type %s not found\",functionMetadata.getArgumentTypes().get(i)));\n    if (node.isDistinct() && !expectedType.isComparable()) {\n      throw new SemanticException(TYPE_MISMATCH,node,\"DISTINCT can only be applied to comparable types (actual: %s)\",expectedType);\n    }\n    if (argumentTypes.get(i).hasDependency()) {\n      FunctionType expectedFunctionType=(FunctionType)expectedType;\n      process(expression,new StackableAstVisitorContext<>(context.getContext().expectingLambda(expectedFunctionType.getArgumentTypes())));\n    }\n else {\n      Type actualType=functionAndTypeManager.getType(argumentTypes.get(i).getTypeSignature());\n      coerceType(expression,actualType,expectedType,format(\"Function %s argument %d\",function,i));\n    }\n  }\n  resolvedFunctions.put(NodeRef.of(node),function);\n  if (functionMetadata.getName().equals(QualifiedObjectName.valueOf(DEFAULT_NAMESPACE,\"REDUCE_AGG\"))) {\n    Expression initialValueArg=node.getArguments().get(1);\n    if (!isNonNullConstant(initialValueArg)) {\n      throw new SemanticException(INVALID_PROCEDURE_ARGUMENTS,initialValueArg,\"REDUCE_AGG only supports non-NULL literal as the initial value\",initialValueArg);\n    }\n  }\n  Type type=functionAndTypeManager.getType(functionMetadata.getReturnType());\n  if (type instanceof MapType) {\n    Type keyType=((MapType)type).getKeyType();\n    if (TypeUtils.isApproximateNumericType(keyType)) {\n      String warningMessage=createWarningMessage(node,\"Map keys with real/double type can be non-deterministic. Please use decimal type instead\");\n      warningCollector.add(new PrestoWarning(SEMANTIC_WARNING,warningMessage));\n    }\n  }\n  return setExpressionType(node,type);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 740,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 47,
        "startLineNumber" : 912,
        "startColumnNumber" : 16,
        "endLineNumber" : 912,
        "endColumnNumber" : 63
      },
      "nodeContext" : "Expression expression=node.getFilter().get();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 10,
      "astHeight" : 5
    },
    "tokenLength" : 3,
    "type" : "com.facebook.presto.sql.tree.Expression"
  } ],
  "positionList" : [ {
    "charLength" : 22,
    "startLineNumber" : 912,
    "startColumnNumber" : 40,
    "endLineNumber" : 912,
    "endColumnNumber" : 62
  } ],
  "layoutRelationDataList" : [ ]
}