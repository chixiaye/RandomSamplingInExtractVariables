{
  "id" : 98,
  "expression" : "argNames.iterator()",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/tool/src/org/antlr/v4/codegen/OutputModelWalker.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "argNames.iterator()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 19,
      "startLineNumber" : 79,
      "startColumnNumber" : 28,
      "endLineNumber" : 79,
      "endColumnNumber" : 47
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 28,
        "startLineNumber" : 79,
        "startColumnNumber" : 19,
        "endLineNumber" : 79,
        "endColumnNumber" : 47
      },
      "nodeContext" : "arg_it=argNames.iterator()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 79,
        "startColumnNumber" : 2,
        "endLineNumber" : 79,
        "endColumnNumber" : 48
      },
      "nodeContext" : "Iterator<String> arg_it=argNames.iterator();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3463,
        "startLineNumber" : 54,
        "startColumnNumber" : 55,
        "endLineNumber" : 143,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  Class<? extends OutputModelObject> cl=omo.getClass();\n  String templateName=cl.getSimpleName();\n  if (templateName == null) {\n    tool.errMgr.toolError(ErrorType.NO_MODEL_TO_TEMPLATE_MAPPING,cl.getSimpleName());\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (header)   templateName+=\"Header\";\n  ST st=templates.getInstanceOf(templateName);\n  if (st == null) {\n    tool.errMgr.toolError(ErrorType.CODE_GEN_TEMPLATES_INCOMPLETE,templateName);\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (st.impl.formalArguments == null) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,\"<none>\");\n    return st;\n  }\n  Map<String,FormalArgument> formalArgs=st.impl.formalArguments;\n  Set<String> argNames=formalArgs.keySet();\n  Iterator<String> arg_it=argNames.iterator();\n  String modelArgName=arg_it.next();\n  st.add(modelArgName,omo);\n  Set<String> usedFieldNames=new HashSet<String>();\n  Field fields[]=cl.getFields();\n  for (  Field fi : fields) {\n    ModelElement annotation=fi.getAnnotation(ModelElement.class);\n    if (annotation == null) {\n      continue;\n    }\n    String fieldName=fi.getName();\n    if (!usedFieldNames.add(fieldName)) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n      continue;\n    }\n    if (formalArgs.get(fieldName) == null)     continue;\n    try {\n      Object o=fi.get(omo);\n      if (o instanceof OutputModelObject) {\n        OutputModelObject nestedOmo=(OutputModelObject)o;\n        ST nestedST=walk(nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n else       if (o instanceof Collection || o instanceof OutputModelObject[]) {\n        if (o instanceof OutputModelObject[]) {\n          o=Arrays.asList((OutputModelObject[])o);\n        }\n        Collection<?> nestedOmos=(Collection<?>)o;\n        for (        Object nestedOmo : nestedOmos) {\n          if (nestedOmo == null)           continue;\n          ST nestedST=walk((OutputModelObject)nestedOmo,header);\n          st.add(fieldName,nestedST);\n        }\n      }\n else       if (o instanceof Map) {\n        Map<?,?> nestedOmoMap=(Map<?,?>)o;\n        Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n        for (        Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n          ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n          m.put(entry.getKey(),nestedST);\n        }\n        st.add(fieldName,m);\n      }\n else       if (o != null) {\n        tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n      }\n    }\n catch (    IllegalAccessException iae) {\n      tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n    }\n  }\n  return st;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 481,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3517,
        "startLineNumber" : 54,
        "startColumnNumber" : 1,
        "endLineNumber" : 143,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public ST walk(OutputModelObject omo,boolean header){\n  Class<? extends OutputModelObject> cl=omo.getClass();\n  String templateName=cl.getSimpleName();\n  if (templateName == null) {\n    tool.errMgr.toolError(ErrorType.NO_MODEL_TO_TEMPLATE_MAPPING,cl.getSimpleName());\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (header)   templateName+=\"Header\";\n  ST st=templates.getInstanceOf(templateName);\n  if (st == null) {\n    tool.errMgr.toolError(ErrorType.CODE_GEN_TEMPLATES_INCOMPLETE,templateName);\n    return new ST(\"[\" + templateName + \" invalid]\");\n  }\n  if (st.impl.formalArguments == null) {\n    tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,\"<none>\");\n    return st;\n  }\n  Map<String,FormalArgument> formalArgs=st.impl.formalArguments;\n  Set<String> argNames=formalArgs.keySet();\n  Iterator<String> arg_it=argNames.iterator();\n  String modelArgName=arg_it.next();\n  st.add(modelArgName,omo);\n  Set<String> usedFieldNames=new HashSet<String>();\n  Field fields[]=cl.getFields();\n  for (  Field fi : fields) {\n    ModelElement annotation=fi.getAnnotation(ModelElement.class);\n    if (annotation == null) {\n      continue;\n    }\n    String fieldName=fi.getName();\n    if (!usedFieldNames.add(fieldName)) {\n      tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"Model object \" + omo.getClass().getSimpleName() + \" has multiple fields named '\"+ fieldName+ \"'\");\n      continue;\n    }\n    if (formalArgs.get(fieldName) == null)     continue;\n    try {\n      Object o=fi.get(omo);\n      if (o instanceof OutputModelObject) {\n        OutputModelObject nestedOmo=(OutputModelObject)o;\n        ST nestedST=walk(nestedOmo,header);\n        st.add(fieldName,nestedST);\n      }\n else       if (o instanceof Collection || o instanceof OutputModelObject[]) {\n        if (o instanceof OutputModelObject[]) {\n          o=Arrays.asList((OutputModelObject[])o);\n        }\n        Collection<?> nestedOmos=(Collection<?>)o;\n        for (        Object nestedOmo : nestedOmos) {\n          if (nestedOmo == null)           continue;\n          ST nestedST=walk((OutputModelObject)nestedOmo,header);\n          st.add(fieldName,nestedST);\n        }\n      }\n else       if (o instanceof Map) {\n        Map<?,?> nestedOmoMap=(Map<?,?>)o;\n        Map<Object,ST> m=new LinkedHashMap<Object,ST>();\n        for (        Map.Entry<?,?> entry : nestedOmoMap.entrySet()) {\n          ST nestedST=walk((OutputModelObject)entry.getValue(),header);\n          m.put(entry.getKey(),nestedST);\n        }\n        st.add(fieldName,m);\n      }\n else       if (o != null) {\n        tool.errMgr.toolError(ErrorType.INTERNAL_ERROR,\"not recognized nested model element: \" + fieldName);\n      }\n    }\n catch (    IllegalAccessException iae) {\n      tool.errMgr.toolError(ErrorType.CODE_TEMPLATE_ARG_ISSUE,templateName,fieldName);\n    }\n  }\n  return st;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 493,
      "astHeight" : 18
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 46,
        "startLineNumber" : 79,
        "startColumnNumber" : 2,
        "endLineNumber" : 79,
        "endColumnNumber" : 48
      },
      "nodeContext" : "Iterator<String> arg_it=argNames.iterator();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 4
    },
    "tokenLength" : 2,
    "type" : "java.util.Iterator<java.lang.String>"
  } ],
  "positionList" : [ {
    "charLength" : 19,
    "startLineNumber" : 79,
    "startColumnNumber" : 28,
    "endLineNumber" : 79,
    "endColumnNumber" : 47
  } ],
  "layoutRelationDataList" : [ ]
}