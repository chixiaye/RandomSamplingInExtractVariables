{
  "id" : 438,
  "expression" : "new IntegerList()",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/tool/src/org/antlr/v4/codegen/target/SwiftTarget.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "new IntegerList()",
    "nodeType" : "ClassInstanceCreation",
    "nodePosition" : {
      "charLength" : 17,
      "startLineNumber" : 206,
      "startColumnNumber" : 38,
      "endLineNumber" : 206,
      "endColumnNumber" : 55
    },
    "astNodeNumber" : 3,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 206,
        "startColumnNumber" : 20,
        "endLineNumber" : 206,
        "endColumnNumber" : 55
      },
      "nodeContext" : "nonGreedyStates=new IntegerList()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 206,
        "startColumnNumber" : 8,
        "endLineNumber" : 206,
        "endColumnNumber" : 56
      },
      "nodeContext" : "IntegerList nonGreedyStates=new IntegerList();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14371,
        "startLineNumber" : 191,
        "startColumnNumber" : 43,
        "endLineNumber" : 539,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  JsonObjectBuilder builder=Json.createObjectBuilder();\n  builder.add(\"version\",ATNDeserializer.SERIALIZED_VERSION);\n  builder.add(\"uuid\",ATNDeserializer.SERIALIZED_UUID.toString());\n  builder.add(\"grammarType\",atn.grammarType.ordinal());\n  builder.add(\"maxTokenType\",atn.maxTokenType);\n  int nedges=0;\n  Map<IntervalSet,Integer> setIndices=new HashMap<IntervalSet,Integer>();\n  List<IntervalSet> sets=new ArrayList<IntervalSet>();\n  JsonArrayBuilder statesBuilder=Json.createArrayBuilder();\n  IntegerList nonGreedyStates=new IntegerList();\n  IntegerList precedenceStates=new IntegerList();\n  for (  ATNState s : atn.states) {\n    JsonObjectBuilder stateBuilder=Json.createObjectBuilder();\n    if (s == null) {\n      statesBuilder.addNull();\n      continue;\n    }\n    int stateType=s.getStateType();\n    stateBuilder.add(\"stateType\",stateType);\n    stateBuilder.add(\"ruleIndex\",s.ruleIndex);\n    if (s instanceof DecisionState && ((DecisionState)s).nonGreedy) {\n      nonGreedyStates.add(s.stateNumber);\n    }\n    if (s instanceof RuleStartState && ((RuleStartState)s).isLeftRecursiveRule) {\n      precedenceStates.add(s.stateNumber);\n    }\n    if (s.getStateType() == ATNState.LOOP_END) {\n      stateBuilder.add(\"detailStateNumber\",((LoopEndState)s).loopBackState.stateNumber);\n    }\n else     if (s instanceof BlockStartState) {\n      stateBuilder.add(\"detailStateNumber\",((BlockStartState)s).endState.stateNumber);\n    }\n    if (s.getStateType() != ATNState.RULE_STOP) {\n      nedges+=s.getNumberOfTransitions();\n    }\n    for (int i=0; i < s.getNumberOfTransitions(); i++) {\n      Transition t=s.transition(i);\n      int edgeType=Transition.serializationTypes.get(t.getClass());\n      if (edgeType == Transition.SET || edgeType == Transition.NOT_SET) {\n        SetTransition st=(SetTransition)t;\n        if (!setIndices.containsKey(st.set)) {\n          sets.add(st.set);\n          setIndices.put(st.set,sets.size() - 1);\n        }\n      }\n    }\n    statesBuilder.add(stateBuilder);\n  }\n  builder.add(\"states\",statesBuilder);\n  JsonArrayBuilder nonGreedyStatesBuilder=Json.createArrayBuilder();\n  for (int i=0; i < nonGreedyStates.size(); i++) {\n    nonGreedyStatesBuilder.add(nonGreedyStates.get(i));\n  }\n  builder.add(\"nonGreedyStates\",nonGreedyStatesBuilder);\n  JsonArrayBuilder precedenceStatesBuilder=Json.createArrayBuilder();\n  for (int i=0; i < precedenceStates.size(); i++) {\n    precedenceStatesBuilder.add(precedenceStates.get(i));\n  }\n  builder.add(\"precedenceStates\",precedenceStatesBuilder);\n  JsonArrayBuilder ruleToStartStateBuilder=Json.createArrayBuilder();\n  int nrules=atn.ruleToStartState.length;\n  for (int r=0; r < nrules; r++) {\n    JsonObjectBuilder stateBuilder=Json.createObjectBuilder();\n    ATNState ruleStartState=atn.ruleToStartState[r];\n    stateBuilder.add(\"stateNumber\",ruleStartState.stateNumber);\n    if (atn.grammarType == ATNType.LEXER) {\n      stateBuilder.add(\"ruleToTokenType\",atn.ruleToTokenType[r]);\n    }\n    ruleToStartStateBuilder.add(stateBuilder);\n  }\n  builder.add(\"ruleToStartState\",ruleToStartStateBuilder);\n  JsonArrayBuilder modeToStartStateBuilder=Json.createArrayBuilder();\n  int nmodes=atn.modeToStartState.size();\n  if (nmodes > 0) {\n    for (    ATNState modeStartState : atn.modeToStartState) {\n      modeToStartStateBuilder.add(modeStartState.stateNumber);\n    }\n  }\n  builder.add(\"modeToStartState\",modeToStartStateBuilder);\n  JsonArrayBuilder nsetsBuilder=Json.createArrayBuilder();\n  int nsets=sets.size();\n  builder.add(\"nsets\",nsets);\n  for (  IntervalSet set : sets) {\n    JsonObjectBuilder setBuilder=Json.createObjectBuilder();\n    boolean containsEof=set.contains(Token.EOF);\n    if (containsEof && set.getIntervals().get(0).b == Token.EOF) {\n      setBuilder.add(\"size\",set.getIntervals().size() - 1);\n    }\n else {\n      setBuilder.add(\"size\",set.getIntervals().size());\n    }\n    setBuilder.add(\"containsEof\",containsEof ? 1 : 0);\n    JsonArrayBuilder IntervalsBuilder=Json.createArrayBuilder();\n    for (    Interval I : set.getIntervals()) {\n      JsonObjectBuilder IntervalBuilder=Json.createObjectBuilder();\n      if (I.a == Token.EOF) {\n        if (I.b == Token.EOF) {\n          continue;\n        }\n else {\n          IntervalBuilder.add(\"a\",0);\n        }\n      }\n else {\n        IntervalBuilder.add(\"a\",I.a);\n      }\n      IntervalBuilder.add(\"b\",I.b);\n      IntervalsBuilder.add(IntervalBuilder);\n    }\n    setBuilder.add(\"Intervals\",IntervalsBuilder);\n    nsetsBuilder.add(setBuilder);\n  }\n  builder.add(\"IntervalSet\",nsetsBuilder);\n  JsonArrayBuilder allTransitionsBuilder=Json.createArrayBuilder();\n  for (  ATNState s : atn.states) {\n    if (s == null) {\n      continue;\n    }\n    if (s.getStateType() == ATNState.RULE_STOP) {\n      continue;\n    }\n    JsonArrayBuilder transitionsBuilder=Json.createArrayBuilder();\n    for (int i=0; i < s.getNumberOfTransitions(); i++) {\n      JsonObjectBuilder transitionBuilder=Json.createObjectBuilder();\n      Transition t=s.transition(i);\n      if (atn.states.get(t.target.stateNumber) == null) {\n        throw new IllegalStateException(\"Cannot serialize a transition to a removed state.\");\n      }\n      int src=s.stateNumber;\n      int trg=t.target.stateNumber;\n      int edgeType=Transition.serializationTypes.get(t.getClass());\n      int arg1=0;\n      int arg2=0;\n      int arg3=0;\nswitch (edgeType) {\ncase Transition.RULE:        trg=((RuleTransition)t).followState.stateNumber;\n      arg1=((RuleTransition)t).target.stateNumber;\n    arg2=((RuleTransition)t).ruleIndex;\n  arg3=((RuleTransition)t).precedence;\nbreak;\ncase Transition.PRECEDENCE:PrecedencePredicateTransition ppt=(PrecedencePredicateTransition)t;\narg1=ppt.precedence;\nbreak;\ncase Transition.PREDICATE:PredicateTransition pt=(PredicateTransition)t;\narg1=pt.ruleIndex;\narg2=pt.predIndex;\narg3=pt.isCtxDependent ? 1 : 0;\nbreak;\ncase Transition.RANGE:arg1=((RangeTransition)t).from;\narg2=((RangeTransition)t).to;\nif (arg1 == Token.EOF) {\narg1=0;\narg3=1;\n}\nbreak;\ncase Transition.ATOM:arg1=((AtomTransition)t).label;\nif (arg1 == Token.EOF) {\narg1=0;\narg3=1;\n}\nbreak;\ncase Transition.ACTION:ActionTransition at=(ActionTransition)t;\narg1=at.ruleIndex;\narg2=at.actionIndex;\narg3=at.isCtxDependent ? 1 : 0;\nbreak;\ncase Transition.SET:arg1=setIndices.get(((SetTransition)t).set);\nbreak;\ncase Transition.NOT_SET:arg1=setIndices.get(((SetTransition)t).set);\nbreak;\ncase Transition.WILDCARD:break;\n}\ntransitionBuilder.add(\"src\",src);\ntransitionBuilder.add(\"trg\",trg);\ntransitionBuilder.add(\"edgeType\",edgeType);\ntransitionBuilder.add(\"arg1\",arg1);\ntransitionBuilder.add(\"arg2\",arg2);\ntransitionBuilder.add(\"arg3\",arg3);\ntransitionsBuilder.add(transitionBuilder);\n}\nallTransitionsBuilder.add(transitionsBuilder);\n}\nbuilder.add(\"allTransitionsBuilder\",allTransitionsBuilder);\nint ndecisions=atn.decisionToState.size();\nJsonArrayBuilder decisionToStateBuilder=Json.createArrayBuilder();\nfor (DecisionState decStartState : atn.decisionToState) {\ndecisionToStateBuilder.add(decStartState.stateNumber);\n}\nbuilder.add(\"decisionToState\",decisionToStateBuilder);\nJsonArrayBuilder lexerActionsBuilder=Json.createArrayBuilder();\nif (atn.grammarType == ATNType.LEXER) {\nfor (LexerAction action : atn.lexerActions) {\nJsonObjectBuilder lexerActionBuilder=Json.createObjectBuilder();\nlexerActionBuilder.add(\"actionType\",action.getActionType().ordinal());\nswitch (action.getActionType()) {\ncase CHANNEL:int channel=((LexerChannelAction)action).getChannel();\nlexerActionBuilder.add(\"a\",channel);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase CUSTOM:int ruleIndex=((LexerCustomAction)action).getRuleIndex();\nint actionIndex=((LexerCustomAction)action).getActionIndex();\nlexerActionBuilder.add(\"a\",ruleIndex);\nlexerActionBuilder.add(\"b\",actionIndex);\nbreak;\ncase MODE:int mode=((LexerModeAction)action).getMode();\nlexerActionBuilder.add(\"a\",mode);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase MORE:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase POP_MODE:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase PUSH_MODE:mode=((LexerPushModeAction)action).getMode();\nlexerActionBuilder.add(\"a\",mode);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase SKIP:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase TYPE:int type=((LexerTypeAction)action).getType();\nlexerActionBuilder.add(\"a\",type);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ndefault:String message=String.format(Locale.getDefault(),\"The specified lexer action type %s is not valid.\",action.getActionType());\nthrow new IllegalArgumentException(message);\n}\nlexerActionsBuilder.add(lexerActionBuilder);\n}\n}\nbuilder.add(\"lexerActions\",lexerActionsBuilder);\nJsonObject data=builder.build();\nreturn data.toString();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1489,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14410,
        "startLineNumber" : 191,
        "startColumnNumber" : 4,
        "endLineNumber" : 539,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public String serializeTojson(ATN atn){\n  JsonObjectBuilder builder=Json.createObjectBuilder();\n  builder.add(\"version\",ATNDeserializer.SERIALIZED_VERSION);\n  builder.add(\"uuid\",ATNDeserializer.SERIALIZED_UUID.toString());\n  builder.add(\"grammarType\",atn.grammarType.ordinal());\n  builder.add(\"maxTokenType\",atn.maxTokenType);\n  int nedges=0;\n  Map<IntervalSet,Integer> setIndices=new HashMap<IntervalSet,Integer>();\n  List<IntervalSet> sets=new ArrayList<IntervalSet>();\n  JsonArrayBuilder statesBuilder=Json.createArrayBuilder();\n  IntegerList nonGreedyStates=new IntegerList();\n  IntegerList precedenceStates=new IntegerList();\n  for (  ATNState s : atn.states) {\n    JsonObjectBuilder stateBuilder=Json.createObjectBuilder();\n    if (s == null) {\n      statesBuilder.addNull();\n      continue;\n    }\n    int stateType=s.getStateType();\n    stateBuilder.add(\"stateType\",stateType);\n    stateBuilder.add(\"ruleIndex\",s.ruleIndex);\n    if (s instanceof DecisionState && ((DecisionState)s).nonGreedy) {\n      nonGreedyStates.add(s.stateNumber);\n    }\n    if (s instanceof RuleStartState && ((RuleStartState)s).isLeftRecursiveRule) {\n      precedenceStates.add(s.stateNumber);\n    }\n    if (s.getStateType() == ATNState.LOOP_END) {\n      stateBuilder.add(\"detailStateNumber\",((LoopEndState)s).loopBackState.stateNumber);\n    }\n else     if (s instanceof BlockStartState) {\n      stateBuilder.add(\"detailStateNumber\",((BlockStartState)s).endState.stateNumber);\n    }\n    if (s.getStateType() != ATNState.RULE_STOP) {\n      nedges+=s.getNumberOfTransitions();\n    }\n    for (int i=0; i < s.getNumberOfTransitions(); i++) {\n      Transition t=s.transition(i);\n      int edgeType=Transition.serializationTypes.get(t.getClass());\n      if (edgeType == Transition.SET || edgeType == Transition.NOT_SET) {\n        SetTransition st=(SetTransition)t;\n        if (!setIndices.containsKey(st.set)) {\n          sets.add(st.set);\n          setIndices.put(st.set,sets.size() - 1);\n        }\n      }\n    }\n    statesBuilder.add(stateBuilder);\n  }\n  builder.add(\"states\",statesBuilder);\n  JsonArrayBuilder nonGreedyStatesBuilder=Json.createArrayBuilder();\n  for (int i=0; i < nonGreedyStates.size(); i++) {\n    nonGreedyStatesBuilder.add(nonGreedyStates.get(i));\n  }\n  builder.add(\"nonGreedyStates\",nonGreedyStatesBuilder);\n  JsonArrayBuilder precedenceStatesBuilder=Json.createArrayBuilder();\n  for (int i=0; i < precedenceStates.size(); i++) {\n    precedenceStatesBuilder.add(precedenceStates.get(i));\n  }\n  builder.add(\"precedenceStates\",precedenceStatesBuilder);\n  JsonArrayBuilder ruleToStartStateBuilder=Json.createArrayBuilder();\n  int nrules=atn.ruleToStartState.length;\n  for (int r=0; r < nrules; r++) {\n    JsonObjectBuilder stateBuilder=Json.createObjectBuilder();\n    ATNState ruleStartState=atn.ruleToStartState[r];\n    stateBuilder.add(\"stateNumber\",ruleStartState.stateNumber);\n    if (atn.grammarType == ATNType.LEXER) {\n      stateBuilder.add(\"ruleToTokenType\",atn.ruleToTokenType[r]);\n    }\n    ruleToStartStateBuilder.add(stateBuilder);\n  }\n  builder.add(\"ruleToStartState\",ruleToStartStateBuilder);\n  JsonArrayBuilder modeToStartStateBuilder=Json.createArrayBuilder();\n  int nmodes=atn.modeToStartState.size();\n  if (nmodes > 0) {\n    for (    ATNState modeStartState : atn.modeToStartState) {\n      modeToStartStateBuilder.add(modeStartState.stateNumber);\n    }\n  }\n  builder.add(\"modeToStartState\",modeToStartStateBuilder);\n  JsonArrayBuilder nsetsBuilder=Json.createArrayBuilder();\n  int nsets=sets.size();\n  builder.add(\"nsets\",nsets);\n  for (  IntervalSet set : sets) {\n    JsonObjectBuilder setBuilder=Json.createObjectBuilder();\n    boolean containsEof=set.contains(Token.EOF);\n    if (containsEof && set.getIntervals().get(0).b == Token.EOF) {\n      setBuilder.add(\"size\",set.getIntervals().size() - 1);\n    }\n else {\n      setBuilder.add(\"size\",set.getIntervals().size());\n    }\n    setBuilder.add(\"containsEof\",containsEof ? 1 : 0);\n    JsonArrayBuilder IntervalsBuilder=Json.createArrayBuilder();\n    for (    Interval I : set.getIntervals()) {\n      JsonObjectBuilder IntervalBuilder=Json.createObjectBuilder();\n      if (I.a == Token.EOF) {\n        if (I.b == Token.EOF) {\n          continue;\n        }\n else {\n          IntervalBuilder.add(\"a\",0);\n        }\n      }\n else {\n        IntervalBuilder.add(\"a\",I.a);\n      }\n      IntervalBuilder.add(\"b\",I.b);\n      IntervalsBuilder.add(IntervalBuilder);\n    }\n    setBuilder.add(\"Intervals\",IntervalsBuilder);\n    nsetsBuilder.add(setBuilder);\n  }\n  builder.add(\"IntervalSet\",nsetsBuilder);\n  JsonArrayBuilder allTransitionsBuilder=Json.createArrayBuilder();\n  for (  ATNState s : atn.states) {\n    if (s == null) {\n      continue;\n    }\n    if (s.getStateType() == ATNState.RULE_STOP) {\n      continue;\n    }\n    JsonArrayBuilder transitionsBuilder=Json.createArrayBuilder();\n    for (int i=0; i < s.getNumberOfTransitions(); i++) {\n      JsonObjectBuilder transitionBuilder=Json.createObjectBuilder();\n      Transition t=s.transition(i);\n      if (atn.states.get(t.target.stateNumber) == null) {\n        throw new IllegalStateException(\"Cannot serialize a transition to a removed state.\");\n      }\n      int src=s.stateNumber;\n      int trg=t.target.stateNumber;\n      int edgeType=Transition.serializationTypes.get(t.getClass());\n      int arg1=0;\n      int arg2=0;\n      int arg3=0;\nswitch (edgeType) {\ncase Transition.RULE:        trg=((RuleTransition)t).followState.stateNumber;\n      arg1=((RuleTransition)t).target.stateNumber;\n    arg2=((RuleTransition)t).ruleIndex;\n  arg3=((RuleTransition)t).precedence;\nbreak;\ncase Transition.PRECEDENCE:PrecedencePredicateTransition ppt=(PrecedencePredicateTransition)t;\narg1=ppt.precedence;\nbreak;\ncase Transition.PREDICATE:PredicateTransition pt=(PredicateTransition)t;\narg1=pt.ruleIndex;\narg2=pt.predIndex;\narg3=pt.isCtxDependent ? 1 : 0;\nbreak;\ncase Transition.RANGE:arg1=((RangeTransition)t).from;\narg2=((RangeTransition)t).to;\nif (arg1 == Token.EOF) {\narg1=0;\narg3=1;\n}\nbreak;\ncase Transition.ATOM:arg1=((AtomTransition)t).label;\nif (arg1 == Token.EOF) {\narg1=0;\narg3=1;\n}\nbreak;\ncase Transition.ACTION:ActionTransition at=(ActionTransition)t;\narg1=at.ruleIndex;\narg2=at.actionIndex;\narg3=at.isCtxDependent ? 1 : 0;\nbreak;\ncase Transition.SET:arg1=setIndices.get(((SetTransition)t).set);\nbreak;\ncase Transition.NOT_SET:arg1=setIndices.get(((SetTransition)t).set);\nbreak;\ncase Transition.WILDCARD:break;\n}\ntransitionBuilder.add(\"src\",src);\ntransitionBuilder.add(\"trg\",trg);\ntransitionBuilder.add(\"edgeType\",edgeType);\ntransitionBuilder.add(\"arg1\",arg1);\ntransitionBuilder.add(\"arg2\",arg2);\ntransitionBuilder.add(\"arg3\",arg3);\ntransitionsBuilder.add(transitionBuilder);\n}\nallTransitionsBuilder.add(transitionsBuilder);\n}\nbuilder.add(\"allTransitionsBuilder\",allTransitionsBuilder);\nint ndecisions=atn.decisionToState.size();\nJsonArrayBuilder decisionToStateBuilder=Json.createArrayBuilder();\nfor (DecisionState decStartState : atn.decisionToState) {\ndecisionToStateBuilder.add(decStartState.stateNumber);\n}\nbuilder.add(\"decisionToState\",decisionToStateBuilder);\nJsonArrayBuilder lexerActionsBuilder=Json.createArrayBuilder();\nif (atn.grammarType == ATNType.LEXER) {\nfor (LexerAction action : atn.lexerActions) {\nJsonObjectBuilder lexerActionBuilder=Json.createObjectBuilder();\nlexerActionBuilder.add(\"actionType\",action.getActionType().ordinal());\nswitch (action.getActionType()) {\ncase CHANNEL:int channel=((LexerChannelAction)action).getChannel();\nlexerActionBuilder.add(\"a\",channel);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase CUSTOM:int ruleIndex=((LexerCustomAction)action).getRuleIndex();\nint actionIndex=((LexerCustomAction)action).getActionIndex();\nlexerActionBuilder.add(\"a\",ruleIndex);\nlexerActionBuilder.add(\"b\",actionIndex);\nbreak;\ncase MODE:int mode=((LexerModeAction)action).getMode();\nlexerActionBuilder.add(\"a\",mode);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase MORE:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase POP_MODE:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase PUSH_MODE:mode=((LexerPushModeAction)action).getMode();\nlexerActionBuilder.add(\"a\",mode);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase SKIP:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase TYPE:int type=((LexerTypeAction)action).getType();\nlexerActionBuilder.add(\"a\",type);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ndefault:String message=String.format(Locale.getDefault(),\"The specified lexer action type %s is not valid.\",action.getActionType());\nthrow new IllegalArgumentException(message);\n}\nlexerActionsBuilder.add(lexerActionBuilder);\n}\n}\nbuilder.add(\"lexerActions\",lexerActionsBuilder);\nJsonObject data=builder.build();\nreturn data.toString();\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1498,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 206,
        "startColumnNumber" : 8,
        "endLineNumber" : 206,
        "endColumnNumber" : 56
      },
      "nodeContext" : "IntegerList nonGreedyStates=new IntegerList();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "org.antlr.v4.runtime.misc.IntegerList"
  }, {
    "nodeContext" : "new IntegerList()",
    "nodeType" : "ClassInstanceCreation",
    "nodePosition" : {
      "charLength" : 17,
      "startLineNumber" : 207,
      "startColumnNumber" : 39,
      "endLineNumber" : 207,
      "endColumnNumber" : 56
    },
    "astNodeNumber" : 3,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 36,
        "startLineNumber" : 207,
        "startColumnNumber" : 20,
        "endLineNumber" : 207,
        "endColumnNumber" : 56
      },
      "nodeContext" : "precedenceStates=new IntegerList()",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 207,
        "startColumnNumber" : 8,
        "endLineNumber" : 207,
        "endColumnNumber" : 57
      },
      "nodeContext" : "IntegerList precedenceStates=new IntegerList();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 14371,
        "startLineNumber" : 191,
        "startColumnNumber" : 43,
        "endLineNumber" : 539,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  JsonObjectBuilder builder=Json.createObjectBuilder();\n  builder.add(\"version\",ATNDeserializer.SERIALIZED_VERSION);\n  builder.add(\"uuid\",ATNDeserializer.SERIALIZED_UUID.toString());\n  builder.add(\"grammarType\",atn.grammarType.ordinal());\n  builder.add(\"maxTokenType\",atn.maxTokenType);\n  int nedges=0;\n  Map<IntervalSet,Integer> setIndices=new HashMap<IntervalSet,Integer>();\n  List<IntervalSet> sets=new ArrayList<IntervalSet>();\n  JsonArrayBuilder statesBuilder=Json.createArrayBuilder();\n  IntegerList nonGreedyStates=new IntegerList();\n  IntegerList precedenceStates=new IntegerList();\n  for (  ATNState s : atn.states) {\n    JsonObjectBuilder stateBuilder=Json.createObjectBuilder();\n    if (s == null) {\n      statesBuilder.addNull();\n      continue;\n    }\n    int stateType=s.getStateType();\n    stateBuilder.add(\"stateType\",stateType);\n    stateBuilder.add(\"ruleIndex\",s.ruleIndex);\n    if (s instanceof DecisionState && ((DecisionState)s).nonGreedy) {\n      nonGreedyStates.add(s.stateNumber);\n    }\n    if (s instanceof RuleStartState && ((RuleStartState)s).isLeftRecursiveRule) {\n      precedenceStates.add(s.stateNumber);\n    }\n    if (s.getStateType() == ATNState.LOOP_END) {\n      stateBuilder.add(\"detailStateNumber\",((LoopEndState)s).loopBackState.stateNumber);\n    }\n else     if (s instanceof BlockStartState) {\n      stateBuilder.add(\"detailStateNumber\",((BlockStartState)s).endState.stateNumber);\n    }\n    if (s.getStateType() != ATNState.RULE_STOP) {\n      nedges+=s.getNumberOfTransitions();\n    }\n    for (int i=0; i < s.getNumberOfTransitions(); i++) {\n      Transition t=s.transition(i);\n      int edgeType=Transition.serializationTypes.get(t.getClass());\n      if (edgeType == Transition.SET || edgeType == Transition.NOT_SET) {\n        SetTransition st=(SetTransition)t;\n        if (!setIndices.containsKey(st.set)) {\n          sets.add(st.set);\n          setIndices.put(st.set,sets.size() - 1);\n        }\n      }\n    }\n    statesBuilder.add(stateBuilder);\n  }\n  builder.add(\"states\",statesBuilder);\n  JsonArrayBuilder nonGreedyStatesBuilder=Json.createArrayBuilder();\n  for (int i=0; i < nonGreedyStates.size(); i++) {\n    nonGreedyStatesBuilder.add(nonGreedyStates.get(i));\n  }\n  builder.add(\"nonGreedyStates\",nonGreedyStatesBuilder);\n  JsonArrayBuilder precedenceStatesBuilder=Json.createArrayBuilder();\n  for (int i=0; i < precedenceStates.size(); i++) {\n    precedenceStatesBuilder.add(precedenceStates.get(i));\n  }\n  builder.add(\"precedenceStates\",precedenceStatesBuilder);\n  JsonArrayBuilder ruleToStartStateBuilder=Json.createArrayBuilder();\n  int nrules=atn.ruleToStartState.length;\n  for (int r=0; r < nrules; r++) {\n    JsonObjectBuilder stateBuilder=Json.createObjectBuilder();\n    ATNState ruleStartState=atn.ruleToStartState[r];\n    stateBuilder.add(\"stateNumber\",ruleStartState.stateNumber);\n    if (atn.grammarType == ATNType.LEXER) {\n      stateBuilder.add(\"ruleToTokenType\",atn.ruleToTokenType[r]);\n    }\n    ruleToStartStateBuilder.add(stateBuilder);\n  }\n  builder.add(\"ruleToStartState\",ruleToStartStateBuilder);\n  JsonArrayBuilder modeToStartStateBuilder=Json.createArrayBuilder();\n  int nmodes=atn.modeToStartState.size();\n  if (nmodes > 0) {\n    for (    ATNState modeStartState : atn.modeToStartState) {\n      modeToStartStateBuilder.add(modeStartState.stateNumber);\n    }\n  }\n  builder.add(\"modeToStartState\",modeToStartStateBuilder);\n  JsonArrayBuilder nsetsBuilder=Json.createArrayBuilder();\n  int nsets=sets.size();\n  builder.add(\"nsets\",nsets);\n  for (  IntervalSet set : sets) {\n    JsonObjectBuilder setBuilder=Json.createObjectBuilder();\n    boolean containsEof=set.contains(Token.EOF);\n    if (containsEof && set.getIntervals().get(0).b == Token.EOF) {\n      setBuilder.add(\"size\",set.getIntervals().size() - 1);\n    }\n else {\n      setBuilder.add(\"size\",set.getIntervals().size());\n    }\n    setBuilder.add(\"containsEof\",containsEof ? 1 : 0);\n    JsonArrayBuilder IntervalsBuilder=Json.createArrayBuilder();\n    for (    Interval I : set.getIntervals()) {\n      JsonObjectBuilder IntervalBuilder=Json.createObjectBuilder();\n      if (I.a == Token.EOF) {\n        if (I.b == Token.EOF) {\n          continue;\n        }\n else {\n          IntervalBuilder.add(\"a\",0);\n        }\n      }\n else {\n        IntervalBuilder.add(\"a\",I.a);\n      }\n      IntervalBuilder.add(\"b\",I.b);\n      IntervalsBuilder.add(IntervalBuilder);\n    }\n    setBuilder.add(\"Intervals\",IntervalsBuilder);\n    nsetsBuilder.add(setBuilder);\n  }\n  builder.add(\"IntervalSet\",nsetsBuilder);\n  JsonArrayBuilder allTransitionsBuilder=Json.createArrayBuilder();\n  for (  ATNState s : atn.states) {\n    if (s == null) {\n      continue;\n    }\n    if (s.getStateType() == ATNState.RULE_STOP) {\n      continue;\n    }\n    JsonArrayBuilder transitionsBuilder=Json.createArrayBuilder();\n    for (int i=0; i < s.getNumberOfTransitions(); i++) {\n      JsonObjectBuilder transitionBuilder=Json.createObjectBuilder();\n      Transition t=s.transition(i);\n      if (atn.states.get(t.target.stateNumber) == null) {\n        throw new IllegalStateException(\"Cannot serialize a transition to a removed state.\");\n      }\n      int src=s.stateNumber;\n      int trg=t.target.stateNumber;\n      int edgeType=Transition.serializationTypes.get(t.getClass());\n      int arg1=0;\n      int arg2=0;\n      int arg3=0;\nswitch (edgeType) {\ncase Transition.RULE:        trg=((RuleTransition)t).followState.stateNumber;\n      arg1=((RuleTransition)t).target.stateNumber;\n    arg2=((RuleTransition)t).ruleIndex;\n  arg3=((RuleTransition)t).precedence;\nbreak;\ncase Transition.PRECEDENCE:PrecedencePredicateTransition ppt=(PrecedencePredicateTransition)t;\narg1=ppt.precedence;\nbreak;\ncase Transition.PREDICATE:PredicateTransition pt=(PredicateTransition)t;\narg1=pt.ruleIndex;\narg2=pt.predIndex;\narg3=pt.isCtxDependent ? 1 : 0;\nbreak;\ncase Transition.RANGE:arg1=((RangeTransition)t).from;\narg2=((RangeTransition)t).to;\nif (arg1 == Token.EOF) {\narg1=0;\narg3=1;\n}\nbreak;\ncase Transition.ATOM:arg1=((AtomTransition)t).label;\nif (arg1 == Token.EOF) {\narg1=0;\narg3=1;\n}\nbreak;\ncase Transition.ACTION:ActionTransition at=(ActionTransition)t;\narg1=at.ruleIndex;\narg2=at.actionIndex;\narg3=at.isCtxDependent ? 1 : 0;\nbreak;\ncase Transition.SET:arg1=setIndices.get(((SetTransition)t).set);\nbreak;\ncase Transition.NOT_SET:arg1=setIndices.get(((SetTransition)t).set);\nbreak;\ncase Transition.WILDCARD:break;\n}\ntransitionBuilder.add(\"src\",src);\ntransitionBuilder.add(\"trg\",trg);\ntransitionBuilder.add(\"edgeType\",edgeType);\ntransitionBuilder.add(\"arg1\",arg1);\ntransitionBuilder.add(\"arg2\",arg2);\ntransitionBuilder.add(\"arg3\",arg3);\ntransitionsBuilder.add(transitionBuilder);\n}\nallTransitionsBuilder.add(transitionsBuilder);\n}\nbuilder.add(\"allTransitionsBuilder\",allTransitionsBuilder);\nint ndecisions=atn.decisionToState.size();\nJsonArrayBuilder decisionToStateBuilder=Json.createArrayBuilder();\nfor (DecisionState decStartState : atn.decisionToState) {\ndecisionToStateBuilder.add(decStartState.stateNumber);\n}\nbuilder.add(\"decisionToState\",decisionToStateBuilder);\nJsonArrayBuilder lexerActionsBuilder=Json.createArrayBuilder();\nif (atn.grammarType == ATNType.LEXER) {\nfor (LexerAction action : atn.lexerActions) {\nJsonObjectBuilder lexerActionBuilder=Json.createObjectBuilder();\nlexerActionBuilder.add(\"actionType\",action.getActionType().ordinal());\nswitch (action.getActionType()) {\ncase CHANNEL:int channel=((LexerChannelAction)action).getChannel();\nlexerActionBuilder.add(\"a\",channel);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase CUSTOM:int ruleIndex=((LexerCustomAction)action).getRuleIndex();\nint actionIndex=((LexerCustomAction)action).getActionIndex();\nlexerActionBuilder.add(\"a\",ruleIndex);\nlexerActionBuilder.add(\"b\",actionIndex);\nbreak;\ncase MODE:int mode=((LexerModeAction)action).getMode();\nlexerActionBuilder.add(\"a\",mode);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase MORE:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase POP_MODE:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase PUSH_MODE:mode=((LexerPushModeAction)action).getMode();\nlexerActionBuilder.add(\"a\",mode);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase SKIP:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase TYPE:int type=((LexerTypeAction)action).getType();\nlexerActionBuilder.add(\"a\",type);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ndefault:String message=String.format(Locale.getDefault(),\"The specified lexer action type %s is not valid.\",action.getActionType());\nthrow new IllegalArgumentException(message);\n}\nlexerActionsBuilder.add(lexerActionBuilder);\n}\n}\nbuilder.add(\"lexerActions\",lexerActionsBuilder);\nJsonObject data=builder.build();\nreturn data.toString();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1489,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 14410,
        "startLineNumber" : 191,
        "startColumnNumber" : 4,
        "endLineNumber" : 539,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public String serializeTojson(ATN atn){\n  JsonObjectBuilder builder=Json.createObjectBuilder();\n  builder.add(\"version\",ATNDeserializer.SERIALIZED_VERSION);\n  builder.add(\"uuid\",ATNDeserializer.SERIALIZED_UUID.toString());\n  builder.add(\"grammarType\",atn.grammarType.ordinal());\n  builder.add(\"maxTokenType\",atn.maxTokenType);\n  int nedges=0;\n  Map<IntervalSet,Integer> setIndices=new HashMap<IntervalSet,Integer>();\n  List<IntervalSet> sets=new ArrayList<IntervalSet>();\n  JsonArrayBuilder statesBuilder=Json.createArrayBuilder();\n  IntegerList nonGreedyStates=new IntegerList();\n  IntegerList precedenceStates=new IntegerList();\n  for (  ATNState s : atn.states) {\n    JsonObjectBuilder stateBuilder=Json.createObjectBuilder();\n    if (s == null) {\n      statesBuilder.addNull();\n      continue;\n    }\n    int stateType=s.getStateType();\n    stateBuilder.add(\"stateType\",stateType);\n    stateBuilder.add(\"ruleIndex\",s.ruleIndex);\n    if (s instanceof DecisionState && ((DecisionState)s).nonGreedy) {\n      nonGreedyStates.add(s.stateNumber);\n    }\n    if (s instanceof RuleStartState && ((RuleStartState)s).isLeftRecursiveRule) {\n      precedenceStates.add(s.stateNumber);\n    }\n    if (s.getStateType() == ATNState.LOOP_END) {\n      stateBuilder.add(\"detailStateNumber\",((LoopEndState)s).loopBackState.stateNumber);\n    }\n else     if (s instanceof BlockStartState) {\n      stateBuilder.add(\"detailStateNumber\",((BlockStartState)s).endState.stateNumber);\n    }\n    if (s.getStateType() != ATNState.RULE_STOP) {\n      nedges+=s.getNumberOfTransitions();\n    }\n    for (int i=0; i < s.getNumberOfTransitions(); i++) {\n      Transition t=s.transition(i);\n      int edgeType=Transition.serializationTypes.get(t.getClass());\n      if (edgeType == Transition.SET || edgeType == Transition.NOT_SET) {\n        SetTransition st=(SetTransition)t;\n        if (!setIndices.containsKey(st.set)) {\n          sets.add(st.set);\n          setIndices.put(st.set,sets.size() - 1);\n        }\n      }\n    }\n    statesBuilder.add(stateBuilder);\n  }\n  builder.add(\"states\",statesBuilder);\n  JsonArrayBuilder nonGreedyStatesBuilder=Json.createArrayBuilder();\n  for (int i=0; i < nonGreedyStates.size(); i++) {\n    nonGreedyStatesBuilder.add(nonGreedyStates.get(i));\n  }\n  builder.add(\"nonGreedyStates\",nonGreedyStatesBuilder);\n  JsonArrayBuilder precedenceStatesBuilder=Json.createArrayBuilder();\n  for (int i=0; i < precedenceStates.size(); i++) {\n    precedenceStatesBuilder.add(precedenceStates.get(i));\n  }\n  builder.add(\"precedenceStates\",precedenceStatesBuilder);\n  JsonArrayBuilder ruleToStartStateBuilder=Json.createArrayBuilder();\n  int nrules=atn.ruleToStartState.length;\n  for (int r=0; r < nrules; r++) {\n    JsonObjectBuilder stateBuilder=Json.createObjectBuilder();\n    ATNState ruleStartState=atn.ruleToStartState[r];\n    stateBuilder.add(\"stateNumber\",ruleStartState.stateNumber);\n    if (atn.grammarType == ATNType.LEXER) {\n      stateBuilder.add(\"ruleToTokenType\",atn.ruleToTokenType[r]);\n    }\n    ruleToStartStateBuilder.add(stateBuilder);\n  }\n  builder.add(\"ruleToStartState\",ruleToStartStateBuilder);\n  JsonArrayBuilder modeToStartStateBuilder=Json.createArrayBuilder();\n  int nmodes=atn.modeToStartState.size();\n  if (nmodes > 0) {\n    for (    ATNState modeStartState : atn.modeToStartState) {\n      modeToStartStateBuilder.add(modeStartState.stateNumber);\n    }\n  }\n  builder.add(\"modeToStartState\",modeToStartStateBuilder);\n  JsonArrayBuilder nsetsBuilder=Json.createArrayBuilder();\n  int nsets=sets.size();\n  builder.add(\"nsets\",nsets);\n  for (  IntervalSet set : sets) {\n    JsonObjectBuilder setBuilder=Json.createObjectBuilder();\n    boolean containsEof=set.contains(Token.EOF);\n    if (containsEof && set.getIntervals().get(0).b == Token.EOF) {\n      setBuilder.add(\"size\",set.getIntervals().size() - 1);\n    }\n else {\n      setBuilder.add(\"size\",set.getIntervals().size());\n    }\n    setBuilder.add(\"containsEof\",containsEof ? 1 : 0);\n    JsonArrayBuilder IntervalsBuilder=Json.createArrayBuilder();\n    for (    Interval I : set.getIntervals()) {\n      JsonObjectBuilder IntervalBuilder=Json.createObjectBuilder();\n      if (I.a == Token.EOF) {\n        if (I.b == Token.EOF) {\n          continue;\n        }\n else {\n          IntervalBuilder.add(\"a\",0);\n        }\n      }\n else {\n        IntervalBuilder.add(\"a\",I.a);\n      }\n      IntervalBuilder.add(\"b\",I.b);\n      IntervalsBuilder.add(IntervalBuilder);\n    }\n    setBuilder.add(\"Intervals\",IntervalsBuilder);\n    nsetsBuilder.add(setBuilder);\n  }\n  builder.add(\"IntervalSet\",nsetsBuilder);\n  JsonArrayBuilder allTransitionsBuilder=Json.createArrayBuilder();\n  for (  ATNState s : atn.states) {\n    if (s == null) {\n      continue;\n    }\n    if (s.getStateType() == ATNState.RULE_STOP) {\n      continue;\n    }\n    JsonArrayBuilder transitionsBuilder=Json.createArrayBuilder();\n    for (int i=0; i < s.getNumberOfTransitions(); i++) {\n      JsonObjectBuilder transitionBuilder=Json.createObjectBuilder();\n      Transition t=s.transition(i);\n      if (atn.states.get(t.target.stateNumber) == null) {\n        throw new IllegalStateException(\"Cannot serialize a transition to a removed state.\");\n      }\n      int src=s.stateNumber;\n      int trg=t.target.stateNumber;\n      int edgeType=Transition.serializationTypes.get(t.getClass());\n      int arg1=0;\n      int arg2=0;\n      int arg3=0;\nswitch (edgeType) {\ncase Transition.RULE:        trg=((RuleTransition)t).followState.stateNumber;\n      arg1=((RuleTransition)t).target.stateNumber;\n    arg2=((RuleTransition)t).ruleIndex;\n  arg3=((RuleTransition)t).precedence;\nbreak;\ncase Transition.PRECEDENCE:PrecedencePredicateTransition ppt=(PrecedencePredicateTransition)t;\narg1=ppt.precedence;\nbreak;\ncase Transition.PREDICATE:PredicateTransition pt=(PredicateTransition)t;\narg1=pt.ruleIndex;\narg2=pt.predIndex;\narg3=pt.isCtxDependent ? 1 : 0;\nbreak;\ncase Transition.RANGE:arg1=((RangeTransition)t).from;\narg2=((RangeTransition)t).to;\nif (arg1 == Token.EOF) {\narg1=0;\narg3=1;\n}\nbreak;\ncase Transition.ATOM:arg1=((AtomTransition)t).label;\nif (arg1 == Token.EOF) {\narg1=0;\narg3=1;\n}\nbreak;\ncase Transition.ACTION:ActionTransition at=(ActionTransition)t;\narg1=at.ruleIndex;\narg2=at.actionIndex;\narg3=at.isCtxDependent ? 1 : 0;\nbreak;\ncase Transition.SET:arg1=setIndices.get(((SetTransition)t).set);\nbreak;\ncase Transition.NOT_SET:arg1=setIndices.get(((SetTransition)t).set);\nbreak;\ncase Transition.WILDCARD:break;\n}\ntransitionBuilder.add(\"src\",src);\ntransitionBuilder.add(\"trg\",trg);\ntransitionBuilder.add(\"edgeType\",edgeType);\ntransitionBuilder.add(\"arg1\",arg1);\ntransitionBuilder.add(\"arg2\",arg2);\ntransitionBuilder.add(\"arg3\",arg3);\ntransitionsBuilder.add(transitionBuilder);\n}\nallTransitionsBuilder.add(transitionsBuilder);\n}\nbuilder.add(\"allTransitionsBuilder\",allTransitionsBuilder);\nint ndecisions=atn.decisionToState.size();\nJsonArrayBuilder decisionToStateBuilder=Json.createArrayBuilder();\nfor (DecisionState decStartState : atn.decisionToState) {\ndecisionToStateBuilder.add(decStartState.stateNumber);\n}\nbuilder.add(\"decisionToState\",decisionToStateBuilder);\nJsonArrayBuilder lexerActionsBuilder=Json.createArrayBuilder();\nif (atn.grammarType == ATNType.LEXER) {\nfor (LexerAction action : atn.lexerActions) {\nJsonObjectBuilder lexerActionBuilder=Json.createObjectBuilder();\nlexerActionBuilder.add(\"actionType\",action.getActionType().ordinal());\nswitch (action.getActionType()) {\ncase CHANNEL:int channel=((LexerChannelAction)action).getChannel();\nlexerActionBuilder.add(\"a\",channel);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase CUSTOM:int ruleIndex=((LexerCustomAction)action).getRuleIndex();\nint actionIndex=((LexerCustomAction)action).getActionIndex();\nlexerActionBuilder.add(\"a\",ruleIndex);\nlexerActionBuilder.add(\"b\",actionIndex);\nbreak;\ncase MODE:int mode=((LexerModeAction)action).getMode();\nlexerActionBuilder.add(\"a\",mode);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase MORE:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase POP_MODE:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase PUSH_MODE:mode=((LexerPushModeAction)action).getMode();\nlexerActionBuilder.add(\"a\",mode);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase SKIP:lexerActionBuilder.add(\"a\",0);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ncase TYPE:int type=((LexerTypeAction)action).getType();\nlexerActionBuilder.add(\"a\",type);\nlexerActionBuilder.add(\"b\",0);\nbreak;\ndefault:String message=String.format(Locale.getDefault(),\"The specified lexer action type %s is not valid.\",action.getActionType());\nthrow new IllegalArgumentException(message);\n}\nlexerActionsBuilder.add(lexerActionBuilder);\n}\n}\nbuilder.add(\"lexerActions\",lexerActionsBuilder);\nJsonObject data=builder.build();\nreturn data.toString();\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1498,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 207,
        "startColumnNumber" : 8,
        "endLineNumber" : 207,
        "endColumnNumber" : 57
      },
      "nodeContext" : "IntegerList precedenceStates=new IntegerList();\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 8,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "org.antlr.v4.runtime.misc.IntegerList"
  } ],
  "positionList" : [ {
    "charLength" : 17,
    "startLineNumber" : 206,
    "startColumnNumber" : 38,
    "endLineNumber" : 206,
    "endColumnNumber" : 55
  }, {
    "charLength" : 17,
    "startLineNumber" : 207,
    "startColumnNumber" : 39,
    "endLineNumber" : 207,
    "endColumnNumber" : 56
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 2
  } ]
}