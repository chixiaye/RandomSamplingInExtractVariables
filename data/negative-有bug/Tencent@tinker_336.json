{
  "id" : 336,
  "expression" : "!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)",
  "projectName" : "Tencent@tinker",
  "commitID" : "df9e1d29420d53a650ab73569d828a22e3cfe728",
  "filePath" : "/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/patch/DexDiffPatchInternal.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)",
    "nodeType" : "PrefixExpression",
    "nodePosition" : {
      "charLength" : 47,
      "startLineNumber" : 576,
      "startColumnNumber" : 24,
      "endLineNumber" : 576,
      "endColumnNumber" : 71
    },
    "astNodeNumber" : 5,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 415,
        "startLineNumber" : 576,
        "startColumnNumber" : 20,
        "endLineNumber" : 580,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n  ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n  manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n  return false;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 34,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 2433,
        "startLineNumber" : 569,
        "startColumnNumber" : 23,
        "endLineNumber" : 606,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  if (patchFileEntry == null) {\n    ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n    ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n    manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n    return false;\n  }\n  if (rawApkFileEntry == null) {\n    ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n  if (!rawEntryCrc.equals(oldDexCrc)) {\n    ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  patchDexFile(apk,patch,rawApkFileEntry,patchFileEntry,info,extractedFile);\n  if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n    ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    SharePatchFileUtil.safeDeleteFile(extractedFile);\n    return false;\n  }\n  ShareTinkerLog.w(TAG,\"success recover dex file: %s, size: %d, use time: %d\",extractedFile.getPath(),extractedFile.length(),(System.currentTimeMillis() - start));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 194,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 4290,
        "startLineNumber" : 539,
        "startColumnNumber" : 23,
        "endLineNumber" : 606,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (dexDiffMd5.equals(\"0\")) {\n  if (!isVmArt) {\n    continue;\n  }\n  if (rawApkFileEntry == null) {\n    ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n  if (!rawEntryCrc.equals(oldDexCrc)) {\n    ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  extractDexFile(apk,rawApkFileEntry,extractedFile,info);\n  if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n    ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    SharePatchFileUtil.safeDeleteFile(extractedFile);\n    return false;\n  }\n}\n else {\n  if (patchFileEntry == null) {\n    ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n    ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n    manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n    return false;\n  }\n  if (rawApkFileEntry == null) {\n    ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n  if (!rawEntryCrc.equals(oldDexCrc)) {\n    ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  patchDexFile(apk,patch,rawApkFileEntry,patchFileEntry,info,extractedFile);\n  if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n    ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    SharePatchFileUtil.safeDeleteFile(extractedFile);\n    return false;\n  }\n  ShareTinkerLog.w(TAG,\"success recover dex file: %s, size: %d, use time: %d\",extractedFile.getPath(),extractedFile.length(),(System.currentTimeMillis() - start));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 317,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5126,
        "startLineNumber" : 526,
        "startColumnNumber" : 16,
        "endLineNumber" : 606,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (oldDexCrc.equals(\"0\")) {\n  if (patchFileEntry == null) {\n    ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  if (!extractDexFile(patch,patchFileEntry,extractedFile,info)) {\n    ShareTinkerLog.w(TAG,\"Failed to extract raw patch file \" + extractedFile.getPath());\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n}\n else if (dexDiffMd5.equals(\"0\")) {\n  if (!isVmArt) {\n    continue;\n  }\n  if (rawApkFileEntry == null) {\n    ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n  if (!rawEntryCrc.equals(oldDexCrc)) {\n    ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  extractDexFile(apk,rawApkFileEntry,extractedFile,info);\n  if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n    ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    SharePatchFileUtil.safeDeleteFile(extractedFile);\n    return false;\n  }\n}\n else {\n  if (patchFileEntry == null) {\n    ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n    ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n    manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n    return false;\n  }\n  if (rawApkFileEntry == null) {\n    ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n  if (!rawEntryCrc.equals(oldDexCrc)) {\n    ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    return false;\n  }\n  patchDexFile(apk,patch,rawApkFileEntry,patchFileEntry,info,extractedFile);\n  if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n    ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n    manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n    SharePatchFileUtil.safeDeleteFile(extractedFile);\n    return false;\n  }\n  ShareTinkerLog.w(TAG,\"success recover dex file: %s, size: %d, use time: %d\",extractedFile.getPath(),extractedFile.length(),(System.currentTimeMillis() - start));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 383,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 7290,
        "startLineNumber" : 481,
        "startColumnNumber" : 57,
        "endLineNumber" : 607,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  long start=System.currentTimeMillis();\n  final String infoPath=info.path;\n  String patchRealPath;\n  if (infoPath.equals(\"\")) {\n    patchRealPath=info.rawName;\n  }\n else {\n    patchRealPath=info.path + \"/\" + info.rawName;\n  }\n  String dexDiffMd5=info.dexDiffMd5;\n  String oldDexCrc=info.oldDexCrC;\n  if (!isVmArt && info.destMd5InDvm.equals(\"0\")) {\n    ShareTinkerLog.w(TAG,\"patch dex %s is only for art, just continue\",patchRealPath);\n    continue;\n  }\n  String extractedFileMd5=isVmArt ? info.destMd5InArt : info.destMd5InDvm;\n  if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {\n    ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,extractedFileMd5);\n    manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n    return false;\n  }\n  File extractedFile=new File(dir + info.realName);\n  if (extractedFile.exists()) {\n    if (SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n      ShareTinkerLog.w(TAG,\"dex file %s is already exist, and md5 match, just continue\",extractedFile.getPath());\n      continue;\n    }\n else {\n      ShareTinkerLog.w(TAG,\"have a mismatch corrupted dex \" + extractedFile.getPath());\n      extractedFile.delete();\n    }\n  }\n else {\n    extractedFile.getParentFile().mkdirs();\n  }\n  ZipEntry patchFileEntry=patch.getEntry(patchRealPath);\n  ZipEntry rawApkFileEntry=apk.getEntry(patchRealPath);\n  if (oldDexCrc.equals(\"0\")) {\n    if (patchFileEntry == null) {\n      ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    if (!extractDexFile(patch,patchFileEntry,extractedFile,info)) {\n      ShareTinkerLog.w(TAG,\"Failed to extract raw patch file \" + extractedFile.getPath());\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n  }\n else   if (dexDiffMd5.equals(\"0\")) {\n    if (!isVmArt) {\n      continue;\n    }\n    if (rawApkFileEntry == null) {\n      ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n    if (!rawEntryCrc.equals(oldDexCrc)) {\n      ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    extractDexFile(apk,rawApkFileEntry,extractedFile,info);\n    if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n      ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      SharePatchFileUtil.safeDeleteFile(extractedFile);\n      return false;\n    }\n  }\n else {\n    if (patchFileEntry == null) {\n      ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n      ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n      manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n      return false;\n    }\n    if (rawApkFileEntry == null) {\n      ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n    if (!rawEntryCrc.equals(oldDexCrc)) {\n      ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    patchDexFile(apk,patch,rawApkFileEntry,patchFileEntry,info,extractedFile);\n    if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n      ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      SharePatchFileUtil.safeDeleteFile(extractedFile);\n      return false;\n    }\n    ShareTinkerLog.w(TAG,\"success recover dex file: %s, size: %d, use time: %d\",extractedFile.getPath(),extractedFile.length(),(System.currentTimeMillis() - start));\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 586,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7335,
        "startLineNumber" : 481,
        "startColumnNumber" : 12,
        "endLineNumber" : 607,
        "endColumnNumber" : 13
      },
      "nodeContext" : "for (ShareDexDiffPatchInfo info : patchList) {\n  long start=System.currentTimeMillis();\n  final String infoPath=info.path;\n  String patchRealPath;\n  if (infoPath.equals(\"\")) {\n    patchRealPath=info.rawName;\n  }\n else {\n    patchRealPath=info.path + \"/\" + info.rawName;\n  }\n  String dexDiffMd5=info.dexDiffMd5;\n  String oldDexCrc=info.oldDexCrC;\n  if (!isVmArt && info.destMd5InDvm.equals(\"0\")) {\n    ShareTinkerLog.w(TAG,\"patch dex %s is only for art, just continue\",patchRealPath);\n    continue;\n  }\n  String extractedFileMd5=isVmArt ? info.destMd5InArt : info.destMd5InDvm;\n  if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {\n    ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,extractedFileMd5);\n    manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n    return false;\n  }\n  File extractedFile=new File(dir + info.realName);\n  if (extractedFile.exists()) {\n    if (SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n      ShareTinkerLog.w(TAG,\"dex file %s is already exist, and md5 match, just continue\",extractedFile.getPath());\n      continue;\n    }\n else {\n      ShareTinkerLog.w(TAG,\"have a mismatch corrupted dex \" + extractedFile.getPath());\n      extractedFile.delete();\n    }\n  }\n else {\n    extractedFile.getParentFile().mkdirs();\n  }\n  ZipEntry patchFileEntry=patch.getEntry(patchRealPath);\n  ZipEntry rawApkFileEntry=apk.getEntry(patchRealPath);\n  if (oldDexCrc.equals(\"0\")) {\n    if (patchFileEntry == null) {\n      ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    if (!extractDexFile(patch,patchFileEntry,extractedFile,info)) {\n      ShareTinkerLog.w(TAG,\"Failed to extract raw patch file \" + extractedFile.getPath());\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n  }\n else   if (dexDiffMd5.equals(\"0\")) {\n    if (!isVmArt) {\n      continue;\n    }\n    if (rawApkFileEntry == null) {\n      ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n    if (!rawEntryCrc.equals(oldDexCrc)) {\n      ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    extractDexFile(apk,rawApkFileEntry,extractedFile,info);\n    if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n      ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      SharePatchFileUtil.safeDeleteFile(extractedFile);\n      return false;\n    }\n  }\n else {\n    if (patchFileEntry == null) {\n      ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n      ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n      manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n      return false;\n    }\n    if (rawApkFileEntry == null) {\n      ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n    if (!rawEntryCrc.equals(oldDexCrc)) {\n      ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      return false;\n    }\n    patchDexFile(apk,patch,rawApkFileEntry,patchFileEntry,info,extractedFile);\n    if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n      ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n      manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n      SharePatchFileUtil.safeDeleteFile(extractedFile);\n      return false;\n    }\n    ShareTinkerLog.w(TAG,\"success recover dex file: %s, size: %d, use time: %d\",extractedFile.getPath(),extractedFile.length(),(System.currentTimeMillis() - start));\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 592,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 8161,
        "startLineNumber" : 466,
        "startColumnNumber" : 12,
        "endLineNumber" : 611,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  ApplicationInfo applicationInfo=context.getApplicationInfo();\n  if (applicationInfo == null) {\n    ShareTinkerLog.w(TAG,\"applicationInfo == null!!!!\");\n    return false;\n  }\n  String apkPath=applicationInfo.sourceDir;\n  apk=new ZipFile(apkPath);\n  patch=new ZipFile(patchFile);\n  if (checkClassNDexFiles(dir)) {\n    ShareTinkerLog.w(TAG,\"class n dex file %s is already exist, and md5 match, just continue\",ShareConstants.CLASS_N_APK_NAME);\n    return true;\n  }\n  for (  ShareDexDiffPatchInfo info : patchList) {\n    long start=System.currentTimeMillis();\n    final String infoPath=info.path;\n    String patchRealPath;\n    if (infoPath.equals(\"\")) {\n      patchRealPath=info.rawName;\n    }\n else {\n      patchRealPath=info.path + \"/\" + info.rawName;\n    }\n    String dexDiffMd5=info.dexDiffMd5;\n    String oldDexCrc=info.oldDexCrC;\n    if (!isVmArt && info.destMd5InDvm.equals(\"0\")) {\n      ShareTinkerLog.w(TAG,\"patch dex %s is only for art, just continue\",patchRealPath);\n      continue;\n    }\n    String extractedFileMd5=isVmArt ? info.destMd5InArt : info.destMd5InDvm;\n    if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {\n      ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,extractedFileMd5);\n      manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n      return false;\n    }\n    File extractedFile=new File(dir + info.realName);\n    if (extractedFile.exists()) {\n      if (SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n        ShareTinkerLog.w(TAG,\"dex file %s is already exist, and md5 match, just continue\",extractedFile.getPath());\n        continue;\n      }\n else {\n        ShareTinkerLog.w(TAG,\"have a mismatch corrupted dex \" + extractedFile.getPath());\n        extractedFile.delete();\n      }\n    }\n else {\n      extractedFile.getParentFile().mkdirs();\n    }\n    ZipEntry patchFileEntry=patch.getEntry(patchRealPath);\n    ZipEntry rawApkFileEntry=apk.getEntry(patchRealPath);\n    if (oldDexCrc.equals(\"0\")) {\n      if (patchFileEntry == null) {\n        ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      if (!extractDexFile(patch,patchFileEntry,extractedFile,info)) {\n        ShareTinkerLog.w(TAG,\"Failed to extract raw patch file \" + extractedFile.getPath());\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n    }\n else     if (dexDiffMd5.equals(\"0\")) {\n      if (!isVmArt) {\n        continue;\n      }\n      if (rawApkFileEntry == null) {\n        ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n      if (!rawEntryCrc.equals(oldDexCrc)) {\n        ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      extractDexFile(apk,rawApkFileEntry,extractedFile,info);\n      if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n        ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        SharePatchFileUtil.safeDeleteFile(extractedFile);\n        return false;\n      }\n    }\n else {\n      if (patchFileEntry == null) {\n        ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n        ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n        manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n        return false;\n      }\n      if (rawApkFileEntry == null) {\n        ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n      if (!rawEntryCrc.equals(oldDexCrc)) {\n        ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      patchDexFile(apk,patch,rawApkFileEntry,patchFileEntry,info,extractedFile);\n      if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n        ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        SharePatchFileUtil.safeDeleteFile(extractedFile);\n        return false;\n      }\n      ShareTinkerLog.w(TAG,\"success recover dex file: %s, size: %d, use time: %d\",extractedFile.getPath(),extractedFile.length(),(System.currentTimeMillis() - start));\n    }\n  }\n  if (!mergeClassNDexFiles(context,patchFile,dir)) {\n    return false;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 662,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8459,
        "startLineNumber" : 466,
        "startColumnNumber" : 8,
        "endLineNumber" : 616,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try {\n  ApplicationInfo applicationInfo=context.getApplicationInfo();\n  if (applicationInfo == null) {\n    ShareTinkerLog.w(TAG,\"applicationInfo == null!!!!\");\n    return false;\n  }\n  String apkPath=applicationInfo.sourceDir;\n  apk=new ZipFile(apkPath);\n  patch=new ZipFile(patchFile);\n  if (checkClassNDexFiles(dir)) {\n    ShareTinkerLog.w(TAG,\"class n dex file %s is already exist, and md5 match, just continue\",ShareConstants.CLASS_N_APK_NAME);\n    return true;\n  }\n  for (  ShareDexDiffPatchInfo info : patchList) {\n    long start=System.currentTimeMillis();\n    final String infoPath=info.path;\n    String patchRealPath;\n    if (infoPath.equals(\"\")) {\n      patchRealPath=info.rawName;\n    }\n else {\n      patchRealPath=info.path + \"/\" + info.rawName;\n    }\n    String dexDiffMd5=info.dexDiffMd5;\n    String oldDexCrc=info.oldDexCrC;\n    if (!isVmArt && info.destMd5InDvm.equals(\"0\")) {\n      ShareTinkerLog.w(TAG,\"patch dex %s is only for art, just continue\",patchRealPath);\n      continue;\n    }\n    String extractedFileMd5=isVmArt ? info.destMd5InArt : info.destMd5InDvm;\n    if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {\n      ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,extractedFileMd5);\n      manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n      return false;\n    }\n    File extractedFile=new File(dir + info.realName);\n    if (extractedFile.exists()) {\n      if (SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n        ShareTinkerLog.w(TAG,\"dex file %s is already exist, and md5 match, just continue\",extractedFile.getPath());\n        continue;\n      }\n else {\n        ShareTinkerLog.w(TAG,\"have a mismatch corrupted dex \" + extractedFile.getPath());\n        extractedFile.delete();\n      }\n    }\n else {\n      extractedFile.getParentFile().mkdirs();\n    }\n    ZipEntry patchFileEntry=patch.getEntry(patchRealPath);\n    ZipEntry rawApkFileEntry=apk.getEntry(patchRealPath);\n    if (oldDexCrc.equals(\"0\")) {\n      if (patchFileEntry == null) {\n        ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      if (!extractDexFile(patch,patchFileEntry,extractedFile,info)) {\n        ShareTinkerLog.w(TAG,\"Failed to extract raw patch file \" + extractedFile.getPath());\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n    }\n else     if (dexDiffMd5.equals(\"0\")) {\n      if (!isVmArt) {\n        continue;\n      }\n      if (rawApkFileEntry == null) {\n        ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n      if (!rawEntryCrc.equals(oldDexCrc)) {\n        ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      extractDexFile(apk,rawApkFileEntry,extractedFile,info);\n      if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n        ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        SharePatchFileUtil.safeDeleteFile(extractedFile);\n        return false;\n      }\n    }\n else {\n      if (patchFileEntry == null) {\n        ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n        ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n        manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n        return false;\n      }\n      if (rawApkFileEntry == null) {\n        ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n      if (!rawEntryCrc.equals(oldDexCrc)) {\n        ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        return false;\n      }\n      patchDexFile(apk,patch,rawApkFileEntry,patchFileEntry,info,extractedFile);\n      if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n        ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n        manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n        SharePatchFileUtil.safeDeleteFile(extractedFile);\n        return false;\n      }\n      ShareTinkerLog.w(TAG,\"success recover dex file: %s, size: %d, use time: %d\",extractedFile.getPath(),extractedFile.length(),(System.currentTimeMillis() - start));\n    }\n  }\n  if (!mergeClassNDexFiles(context,patchFile,dir)) {\n    return false;\n  }\n}\n catch (Throwable e) {\n  throw new TinkerRuntimeException(\"patch \" + ShareTinkerInternals.getTypeString(type) + \" extract failed (\"+ e.getMessage()+ \").\",e);\n}\n finally {\n  SharePatchFileUtil.closeZip(apk);\n  SharePatchFileUtil.closeZip(patch);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 696,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 9086,
        "startLineNumber" : 448,
        "startColumnNumber" : 119,
        "endLineNumber" : 618,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  patchList.clear();\n  ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta,patchList);\n  if (patchList.isEmpty()) {\n    ShareTinkerLog.w(TAG,\"extract patch list is empty! type:%s:\",ShareTinkerInternals.getTypeString(type));\n    return true;\n  }\n  File directory=new File(dir);\n  if (!directory.exists()) {\n    directory.mkdirs();\n  }\n  Tinker manager=Tinker.with(context);\n  ZipFile apk=null;\n  ZipFile patch=null;\n  try {\n    ApplicationInfo applicationInfo=context.getApplicationInfo();\n    if (applicationInfo == null) {\n      ShareTinkerLog.w(TAG,\"applicationInfo == null!!!!\");\n      return false;\n    }\n    String apkPath=applicationInfo.sourceDir;\n    apk=new ZipFile(apkPath);\n    patch=new ZipFile(patchFile);\n    if (checkClassNDexFiles(dir)) {\n      ShareTinkerLog.w(TAG,\"class n dex file %s is already exist, and md5 match, just continue\",ShareConstants.CLASS_N_APK_NAME);\n      return true;\n    }\n    for (    ShareDexDiffPatchInfo info : patchList) {\n      long start=System.currentTimeMillis();\n      final String infoPath=info.path;\n      String patchRealPath;\n      if (infoPath.equals(\"\")) {\n        patchRealPath=info.rawName;\n      }\n else {\n        patchRealPath=info.path + \"/\" + info.rawName;\n      }\n      String dexDiffMd5=info.dexDiffMd5;\n      String oldDexCrc=info.oldDexCrC;\n      if (!isVmArt && info.destMd5InDvm.equals(\"0\")) {\n        ShareTinkerLog.w(TAG,\"patch dex %s is only for art, just continue\",patchRealPath);\n        continue;\n      }\n      String extractedFileMd5=isVmArt ? info.destMd5InArt : info.destMd5InDvm;\n      if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {\n        ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,extractedFileMd5);\n        manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n        return false;\n      }\n      File extractedFile=new File(dir + info.realName);\n      if (extractedFile.exists()) {\n        if (SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n          ShareTinkerLog.w(TAG,\"dex file %s is already exist, and md5 match, just continue\",extractedFile.getPath());\n          continue;\n        }\n else {\n          ShareTinkerLog.w(TAG,\"have a mismatch corrupted dex \" + extractedFile.getPath());\n          extractedFile.delete();\n        }\n      }\n else {\n        extractedFile.getParentFile().mkdirs();\n      }\n      ZipEntry patchFileEntry=patch.getEntry(patchRealPath);\n      ZipEntry rawApkFileEntry=apk.getEntry(patchRealPath);\n      if (oldDexCrc.equals(\"0\")) {\n        if (patchFileEntry == null) {\n          ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        if (!extractDexFile(patch,patchFileEntry,extractedFile,info)) {\n          ShareTinkerLog.w(TAG,\"Failed to extract raw patch file \" + extractedFile.getPath());\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n      }\n else       if (dexDiffMd5.equals(\"0\")) {\n        if (!isVmArt) {\n          continue;\n        }\n        if (rawApkFileEntry == null) {\n          ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n        if (!rawEntryCrc.equals(oldDexCrc)) {\n          ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        extractDexFile(apk,rawApkFileEntry,extractedFile,info);\n        if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n          ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          SharePatchFileUtil.safeDeleteFile(extractedFile);\n          return false;\n        }\n      }\n else {\n        if (patchFileEntry == null) {\n          ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n          ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n          manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n          return false;\n        }\n        if (rawApkFileEntry == null) {\n          ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n        if (!rawEntryCrc.equals(oldDexCrc)) {\n          ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        patchDexFile(apk,patch,rawApkFileEntry,patchFileEntry,info,extractedFile);\n        if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n          ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          SharePatchFileUtil.safeDeleteFile(extractedFile);\n          return false;\n        }\n        ShareTinkerLog.w(TAG,\"success recover dex file: %s, size: %d, use time: %d\",extractedFile.getPath(),extractedFile.length(),(System.currentTimeMillis() - start));\n      }\n    }\n    if (!mergeClassNDexFiles(context,patchFile,dir)) {\n      return false;\n    }\n  }\n catch (  Throwable e) {\n    throw new TinkerRuntimeException(\"patch \" + ShareTinkerInternals.getTypeString(type) + \" extract failed (\"+ e.getMessage()+ \").\",e);\n  }\n finally {\n    SharePatchFileUtil.closeZip(apk);\n    SharePatchFileUtil.closeZip(patch);\n  }\n  return true;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 766,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 9201,
        "startLineNumber" : 448,
        "startColumnNumber" : 4,
        "endLineNumber" : 618,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private static boolean extractDexDiffInternals(Context context,String dir,String meta,File patchFile,int type){\n  patchList.clear();\n  ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta,patchList);\n  if (patchList.isEmpty()) {\n    ShareTinkerLog.w(TAG,\"extract patch list is empty! type:%s:\",ShareTinkerInternals.getTypeString(type));\n    return true;\n  }\n  File directory=new File(dir);\n  if (!directory.exists()) {\n    directory.mkdirs();\n  }\n  Tinker manager=Tinker.with(context);\n  ZipFile apk=null;\n  ZipFile patch=null;\n  try {\n    ApplicationInfo applicationInfo=context.getApplicationInfo();\n    if (applicationInfo == null) {\n      ShareTinkerLog.w(TAG,\"applicationInfo == null!!!!\");\n      return false;\n    }\n    String apkPath=applicationInfo.sourceDir;\n    apk=new ZipFile(apkPath);\n    patch=new ZipFile(patchFile);\n    if (checkClassNDexFiles(dir)) {\n      ShareTinkerLog.w(TAG,\"class n dex file %s is already exist, and md5 match, just continue\",ShareConstants.CLASS_N_APK_NAME);\n      return true;\n    }\n    for (    ShareDexDiffPatchInfo info : patchList) {\n      long start=System.currentTimeMillis();\n      final String infoPath=info.path;\n      String patchRealPath;\n      if (infoPath.equals(\"\")) {\n        patchRealPath=info.rawName;\n      }\n else {\n        patchRealPath=info.path + \"/\" + info.rawName;\n      }\n      String dexDiffMd5=info.dexDiffMd5;\n      String oldDexCrc=info.oldDexCrC;\n      if (!isVmArt && info.destMd5InDvm.equals(\"0\")) {\n        ShareTinkerLog.w(TAG,\"patch dex %s is only for art, just continue\",patchRealPath);\n        continue;\n      }\n      String extractedFileMd5=isVmArt ? info.destMd5InArt : info.destMd5InDvm;\n      if (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) {\n        ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,extractedFileMd5);\n        manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n        return false;\n      }\n      File extractedFile=new File(dir + info.realName);\n      if (extractedFile.exists()) {\n        if (SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n          ShareTinkerLog.w(TAG,\"dex file %s is already exist, and md5 match, just continue\",extractedFile.getPath());\n          continue;\n        }\n else {\n          ShareTinkerLog.w(TAG,\"have a mismatch corrupted dex \" + extractedFile.getPath());\n          extractedFile.delete();\n        }\n      }\n else {\n        extractedFile.getParentFile().mkdirs();\n      }\n      ZipEntry patchFileEntry=patch.getEntry(patchRealPath);\n      ZipEntry rawApkFileEntry=apk.getEntry(patchRealPath);\n      if (oldDexCrc.equals(\"0\")) {\n        if (patchFileEntry == null) {\n          ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        if (!extractDexFile(patch,patchFileEntry,extractedFile,info)) {\n          ShareTinkerLog.w(TAG,\"Failed to extract raw patch file \" + extractedFile.getPath());\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n      }\n else       if (dexDiffMd5.equals(\"0\")) {\n        if (!isVmArt) {\n          continue;\n        }\n        if (rawApkFileEntry == null) {\n          ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n        if (!rawEntryCrc.equals(oldDexCrc)) {\n          ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        extractDexFile(apk,rawApkFileEntry,extractedFile,info);\n        if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n          ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          SharePatchFileUtil.safeDeleteFile(extractedFile);\n          return false;\n        }\n      }\n else {\n        if (patchFileEntry == null) {\n          ShareTinkerLog.w(TAG,\"patch entry is null. path:\" + patchRealPath);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n          ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n          manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n          return false;\n        }\n        if (rawApkFileEntry == null) {\n          ShareTinkerLog.w(TAG,\"apk entry is null. path:\" + patchRealPath);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        String rawEntryCrc=String.valueOf(rawApkFileEntry.getCrc());\n        if (!rawEntryCrc.equals(oldDexCrc)) {\n          ShareTinkerLog.e(TAG,\"apk entry %s crc is not equal, expect crc: %s, got crc: %s\",patchRealPath,oldDexCrc,rawEntryCrc);\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          return false;\n        }\n        patchDexFile(apk,patch,rawApkFileEntry,patchFileEntry,info,extractedFile);\n        if (!SharePatchFileUtil.verifyDexFileMd5(extractedFile,extractedFileMd5)) {\n          ShareTinkerLog.w(TAG,\"Failed to recover dex file when verify patched dex: \" + extractedFile.getPath());\n          manager.getPatchReporter().onPatchTypeExtractFail(patchFile,extractedFile,info.rawName,type);\n          SharePatchFileUtil.safeDeleteFile(extractedFile);\n          return false;\n        }\n        ShareTinkerLog.w(TAG,\"success recover dex file: %s, size: %d, use time: %d\",extractedFile.getPath(),extractedFile.length(),(System.currentTimeMillis() - start));\n      }\n    }\n    if (!mergeClassNDexFiles(context,patchFile,dir)) {\n      return false;\n    }\n  }\n catch (  Throwable e) {\n    throw new TinkerRuntimeException(\"patch \" + ShareTinkerInternals.getTypeString(type) + \" extract failed (\"+ e.getMessage()+ \").\",e);\n  }\n finally {\n    SharePatchFileUtil.closeZip(apk);\n    SharePatchFileUtil.closeZip(patch);\n  }\n  return true;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 790,
      "astHeight" : 16
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 415,
        "startLineNumber" : 576,
        "startColumnNumber" : 20,
        "endLineNumber" : 580,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) {\n  ShareTinkerLog.w(TAG,\"meta file md5 invalid, type:%s, name: %s, md5: %s\",ShareTinkerInternals.getTypeString(type),info.rawName,dexDiffMd5);\n  manager.getPatchReporter().onPatchPackageCheckFail(patchFile,BasePatchInternal.getMetaCorruptedCode(type));\n  return false;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 34,
      "astHeight" : 6
    },
    "tokenLength" : 3,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 47,
    "startLineNumber" : 576,
    "startColumnNumber" : 24,
    "endLineNumber" : 576,
    "endColumnNumber" : 71
  } ],
  "layoutRelationDataList" : [ ]
}