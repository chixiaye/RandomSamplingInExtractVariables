{
  "id" : 342,
  "expression" : "i + 2 < totalLength - 1",
  "projectName" : "OpenAPITools@openapi-generator",
  "commitID" : "9e1972bb1d3a4f1e3f47c87613f4050feada0146",
  "filePath" : "/modules/openapi-generator/src/main/java/org/openapitools/codegen/ignore/rules/IgnoreLineParser.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "i + 2 < totalLength - 1",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 21,
      "startLineNumber" : 88,
      "startColumnNumber" : 25,
      "endLineNumber" : 88,
      "endColumnNumber" : 46
    },
    "astNodeNumber" : 7,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 23,
        "startLineNumber" : 88,
        "startColumnNumber" : 24,
        "endLineNumber" : 88,
        "endColumnNumber" : 47
      },
      "nodeContext" : "(i + 2 < totalLength - 1)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 118,
        "startLineNumber" : 88,
        "startColumnNumber" : 24,
        "endLineNumber" : 89,
        "endColumnNumber" : 91
      },
      "nodeContext" : "(i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 24,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 319,
        "startLineNumber" : 88,
        "startColumnNumber" : 20,
        "endLineNumber" : 92,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if ((i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)) {\n  throw new ParserException(\"The pattern *** is invalid.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 31,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 566,
        "startLineNumber" : 86,
        "startColumnNumber" : 58,
        "endLineNumber" : 97,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  if ((i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)) {\n    throw new ParserException(\"The pattern *** is invalid.\");\n  }\n  parts.add(new Part(Token.MATCH_ALL));\n  i++;\n  continue;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 46,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1049,
        "startLineNumber" : 86,
        "startColumnNumber" : 16,
        "endLineNumber" : 107,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (Token.MATCH_ANY.pattern.equals(next)) {\n  if ((i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)) {\n    throw new ParserException(\"The pattern *** is invalid.\");\n  }\n  parts.add(new Part(Token.MATCH_ALL));\n  i++;\n  continue;\n}\n else {\n  if (sb.length() > 0) {\n    parts.add(new Part(Token.TEXT,sb.toString()));\n    sb.delete(0,sb.length());\n  }\n  parts.add(new Part(Token.MATCH_ANY));\n  continue;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 95,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1082,
        "startLineNumber" : 84,
        "startColumnNumber" : 57,
        "endLineNumber" : 108,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  if (Token.MATCH_ANY.pattern.equals(next)) {\n    if ((i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)) {\n      throw new ParserException(\"The pattern *** is invalid.\");\n    }\n    parts.add(new Part(Token.MATCH_ALL));\n    i++;\n    continue;\n  }\n else {\n    if (sb.length() > 0) {\n      parts.add(new Part(Token.TEXT,sb.toString()));\n      sb.delete(0,sb.length());\n    }\n    parts.add(new Part(Token.MATCH_ANY));\n    continue;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 96,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1127,
        "startLineNumber" : 84,
        "startColumnNumber" : 12,
        "endLineNumber" : 108,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (Token.MATCH_ANY.pattern.equals(current)) {\n  if (Token.MATCH_ANY.pattern.equals(next)) {\n    if ((i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)) {\n      throw new ParserException(\"The pattern *** is invalid.\");\n    }\n    parts.add(new Part(Token.MATCH_ALL));\n    i++;\n    continue;\n  }\n else {\n    if (sb.length() > 0) {\n      parts.add(new Part(Token.TEXT,sb.toString()));\n      sb.delete(0,sb.length());\n    }\n    parts.add(new Part(Token.MATCH_ANY));\n    continue;\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 105,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 3861,
        "startLineNumber" : 56,
        "startColumnNumber" : 79,
        "endLineNumber" : 148,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  char character=characters[i];\n  current=String.valueOf(character);\n  next=i < totalLength - 1 ? String.valueOf(characters[i + 1]) : null;\n  if (i == 0) {\n    if (\"#\".equals(current)) {\n      parts.add(new Part(Token.COMMENT,text));\n      i=totalLength;\n      continue;\n    }\n else     if (\"!\".equals(current)) {\n      if (i == totalLength - 1) {\n        throw new ParserException(\"Negation with no negated pattern.\");\n      }\n else {\n        parts.add(new Part(Token.NEGATE));\n        continue;\n      }\n    }\n else     if (\"\\\\\".equals(current) && \"#\".equals(next)) {\n      current=next;\n      next=null;\n      i++;\n    }\n  }\n  if (Token.MATCH_ANY.pattern.equals(current)) {\n    if (Token.MATCH_ANY.pattern.equals(next)) {\n      if ((i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)) {\n        throw new ParserException(\"The pattern *** is invalid.\");\n      }\n      parts.add(new Part(Token.MATCH_ALL));\n      i++;\n      continue;\n    }\n else {\n      if (sb.length() > 0) {\n        parts.add(new Part(Token.TEXT,sb.toString()));\n        sb.delete(0,sb.length());\n      }\n      parts.add(new Part(Token.MATCH_ANY));\n      continue;\n    }\n  }\n  if (i == 0 && Token.ROOTED_MARKER.pattern.equals(current)) {\n    parts.add(new Part(Token.ROOTED_MARKER));\n    continue;\n  }\n  if (\"\\\\\".equals(current) && \" \".equals(next)) {\n    parts.add(new Part(Token.ESCAPED_SPACE));\n    i++;\n    continue;\n  }\n else   if (\"\\\\\".equals(current) && \"!\".equals(next)) {\n    parts.add(new Part(Token.ESCAPED_EXCLAMATION));\n    i++;\n    continue;\n  }\n  if (Token.PATH_DELIM.pattern.equals(current)) {\n    if (i != totalLength - 1) {\n      if (sb.length() > 0) {\n        parts.add(new Part(Token.TEXT,sb.toString()));\n        sb.delete(0,sb.length());\n      }\n      parts.add(new Part(Token.PATH_DELIM));\n      if (Token.PATH_DELIM.pattern.equals(next)) {\n        i++;\n      }\n      continue;\n    }\n else     if (i == totalLength - 1) {\n      parts.add(new Part(Token.TEXT,sb.toString()));\n      sb.delete(0,sb.length());\n      parts.add(new Part(Token.DIRECTORY_MARKER));\n      continue;\n    }\n  }\n  sb.append(current);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 405,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3932,
        "startLineNumber" : 56,
        "startColumnNumber" : 8,
        "endLineNumber" : 148,
        "endColumnNumber" : 9
      },
      "nodeContext" : "for (int i=0, totalLength=characters.length; i < totalLength; i++) {\n  char character=characters[i];\n  current=String.valueOf(character);\n  next=i < totalLength - 1 ? String.valueOf(characters[i + 1]) : null;\n  if (i == 0) {\n    if (\"#\".equals(current)) {\n      parts.add(new Part(Token.COMMENT,text));\n      i=totalLength;\n      continue;\n    }\n else     if (\"!\".equals(current)) {\n      if (i == totalLength - 1) {\n        throw new ParserException(\"Negation with no negated pattern.\");\n      }\n else {\n        parts.add(new Part(Token.NEGATE));\n        continue;\n      }\n    }\n else     if (\"\\\\\".equals(current) && \"#\".equals(next)) {\n      current=next;\n      next=null;\n      i++;\n    }\n  }\n  if (Token.MATCH_ANY.pattern.equals(current)) {\n    if (Token.MATCH_ANY.pattern.equals(next)) {\n      if ((i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)) {\n        throw new ParserException(\"The pattern *** is invalid.\");\n      }\n      parts.add(new Part(Token.MATCH_ALL));\n      i++;\n      continue;\n    }\n else {\n      if (sb.length() > 0) {\n        parts.add(new Part(Token.TEXT,sb.toString()));\n        sb.delete(0,sb.length());\n      }\n      parts.add(new Part(Token.MATCH_ANY));\n      continue;\n    }\n  }\n  if (i == 0 && Token.ROOTED_MARKER.pattern.equals(current)) {\n    parts.add(new Part(Token.ROOTED_MARKER));\n    continue;\n  }\n  if (\"\\\\\".equals(current) && \" \".equals(next)) {\n    parts.add(new Part(Token.ESCAPED_SPACE));\n    i++;\n    continue;\n  }\n else   if (\"\\\\\".equals(current) && \"!\".equals(next)) {\n    parts.add(new Part(Token.ESCAPED_EXCLAMATION));\n    i++;\n    continue;\n  }\n  if (Token.PATH_DELIM.pattern.equals(current)) {\n    if (i != totalLength - 1) {\n      if (sb.length() > 0) {\n        parts.add(new Part(Token.TEXT,sb.toString()));\n        sb.delete(0,sb.length());\n      }\n      parts.add(new Part(Token.PATH_DELIM));\n      if (Token.PATH_DELIM.pattern.equals(next)) {\n        i++;\n      }\n      continue;\n    }\n else     if (i == totalLength - 1) {\n      parts.add(new Part(Token.TEXT,sb.toString()));\n      sb.delete(0,sb.length());\n      parts.add(new Part(Token.DIRECTORY_MARKER));\n      continue;\n    }\n  }\n  sb.append(current);\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 421,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4454,
        "startLineNumber" : 49,
        "startColumnNumber" : 64,
        "endLineNumber" : 157,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  List<Part> parts=new ArrayList<>();\n  StringBuilder sb=new StringBuilder();\n  String current=null;\n  String next=null;\n  char[] characters=text.toCharArray();\n  for (int i=0, totalLength=characters.length; i < totalLength; i++) {\n    char character=characters[i];\n    current=String.valueOf(character);\n    next=i < totalLength - 1 ? String.valueOf(characters[i + 1]) : null;\n    if (i == 0) {\n      if (\"#\".equals(current)) {\n        parts.add(new Part(Token.COMMENT,text));\n        i=totalLength;\n        continue;\n      }\n else       if (\"!\".equals(current)) {\n        if (i == totalLength - 1) {\n          throw new ParserException(\"Negation with no negated pattern.\");\n        }\n else {\n          parts.add(new Part(Token.NEGATE));\n          continue;\n        }\n      }\n else       if (\"\\\\\".equals(current) && \"#\".equals(next)) {\n        current=next;\n        next=null;\n        i++;\n      }\n    }\n    if (Token.MATCH_ANY.pattern.equals(current)) {\n      if (Token.MATCH_ANY.pattern.equals(next)) {\n        if ((i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)) {\n          throw new ParserException(\"The pattern *** is invalid.\");\n        }\n        parts.add(new Part(Token.MATCH_ALL));\n        i++;\n        continue;\n      }\n else {\n        if (sb.length() > 0) {\n          parts.add(new Part(Token.TEXT,sb.toString()));\n          sb.delete(0,sb.length());\n        }\n        parts.add(new Part(Token.MATCH_ANY));\n        continue;\n      }\n    }\n    if (i == 0 && Token.ROOTED_MARKER.pattern.equals(current)) {\n      parts.add(new Part(Token.ROOTED_MARKER));\n      continue;\n    }\n    if (\"\\\\\".equals(current) && \" \".equals(next)) {\n      parts.add(new Part(Token.ESCAPED_SPACE));\n      i++;\n      continue;\n    }\n else     if (\"\\\\\".equals(current) && \"!\".equals(next)) {\n      parts.add(new Part(Token.ESCAPED_EXCLAMATION));\n      i++;\n      continue;\n    }\n    if (Token.PATH_DELIM.pattern.equals(current)) {\n      if (i != totalLength - 1) {\n        if (sb.length() > 0) {\n          parts.add(new Part(Token.TEXT,sb.toString()));\n          sb.delete(0,sb.length());\n        }\n        parts.add(new Part(Token.PATH_DELIM));\n        if (Token.PATH_DELIM.pattern.equals(next)) {\n          i++;\n        }\n        continue;\n      }\n else       if (i == totalLength - 1) {\n        parts.add(new Part(Token.TEXT,sb.toString()));\n        sb.delete(0,sb.length());\n        parts.add(new Part(Token.DIRECTORY_MARKER));\n        continue;\n      }\n    }\n    sb.append(current);\n  }\n  if (sb.length() > 0) {\n    parts.add(new Part(Token.TEXT,sb.toString().trim()));\n  }\n  return parts;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 487,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4514,
        "startLineNumber" : 49,
        "startColumnNumber" : 4,
        "endLineNumber" : 157,
        "endColumnNumber" : 5
      },
      "nodeContext" : "static List<Part> parse(String text) throws ParserException {\n  List<Part> parts=new ArrayList<>();\n  StringBuilder sb=new StringBuilder();\n  String current=null;\n  String next=null;\n  char[] characters=text.toCharArray();\n  for (int i=0, totalLength=characters.length; i < totalLength; i++) {\n    char character=characters[i];\n    current=String.valueOf(character);\n    next=i < totalLength - 1 ? String.valueOf(characters[i + 1]) : null;\n    if (i == 0) {\n      if (\"#\".equals(current)) {\n        parts.add(new Part(Token.COMMENT,text));\n        i=totalLength;\n        continue;\n      }\n else       if (\"!\".equals(current)) {\n        if (i == totalLength - 1) {\n          throw new ParserException(\"Negation with no negated pattern.\");\n        }\n else {\n          parts.add(new Part(Token.NEGATE));\n          continue;\n        }\n      }\n else       if (\"\\\\\".equals(current) && \"#\".equals(next)) {\n        current=next;\n        next=null;\n        i++;\n      }\n    }\n    if (Token.MATCH_ANY.pattern.equals(current)) {\n      if (Token.MATCH_ANY.pattern.equals(next)) {\n        if ((i + 2 < totalLength - 1) && String.valueOf(characters[i + 2]).equals(Token.MATCH_ANY.pattern)) {\n          throw new ParserException(\"The pattern *** is invalid.\");\n        }\n        parts.add(new Part(Token.MATCH_ALL));\n        i++;\n        continue;\n      }\n else {\n        if (sb.length() > 0) {\n          parts.add(new Part(Token.TEXT,sb.toString()));\n          sb.delete(0,sb.length());\n        }\n        parts.add(new Part(Token.MATCH_ANY));\n        continue;\n      }\n    }\n    if (i == 0 && Token.ROOTED_MARKER.pattern.equals(current)) {\n      parts.add(new Part(Token.ROOTED_MARKER));\n      continue;\n    }\n    if (\"\\\\\".equals(current) && \" \".equals(next)) {\n      parts.add(new Part(Token.ESCAPED_SPACE));\n      i++;\n      continue;\n    }\n else     if (\"\\\\\".equals(current) && \"!\".equals(next)) {\n      parts.add(new Part(Token.ESCAPED_EXCLAMATION));\n      i++;\n      continue;\n    }\n    if (Token.PATH_DELIM.pattern.equals(current)) {\n      if (i != totalLength - 1) {\n        if (sb.length() > 0) {\n          parts.add(new Part(Token.TEXT,sb.toString()));\n          sb.delete(0,sb.length());\n        }\n        parts.add(new Part(Token.PATH_DELIM));\n        if (Token.PATH_DELIM.pattern.equals(next)) {\n          i++;\n        }\n        continue;\n      }\n else       if (i == totalLength - 1) {\n        parts.add(new Part(Token.TEXT,sb.toString()));\n        sb.delete(0,sb.length());\n        parts.add(new Part(Token.DIRECTORY_MARKER));\n        continue;\n      }\n    }\n    sb.append(current);\n  }\n  if (sb.length() > 0) {\n    parts.add(new Part(Token.TEXT,sb.toString().trim()));\n  }\n  return parts;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 501,
      "astHeight" : 16
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 23,
        "startLineNumber" : 88,
        "startColumnNumber" : 24,
        "endLineNumber" : 88,
        "endColumnNumber" : 47
      },
      "nodeContext" : "(i + 2 < totalLength - 1)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 7,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 21,
    "startLineNumber" : 88,
    "startColumnNumber" : 25,
    "endLineNumber" : 88,
    "endColumnNumber" : 46
  } ],
  "layoutRelationDataList" : [ ]
}