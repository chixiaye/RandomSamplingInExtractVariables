{
  "id" : 478,
  "expression" : "inflater.inflate(outArray,outIndex,writable)",
  "projectName" : "netty@netty",
  "commitID" : "8a68c3e58d4663ae42e41a90d0d11aec3c25016b",
  "filePath" : "/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecompressor.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "inflater.inflate(outArray,outIndex,writable)",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 46,
      "startLineNumber" : 263,
      "startColumnNumber" : 35,
      "endLineNumber" : 263,
      "endColumnNumber" : 81
    },
    "astNodeNumber" : 6,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 61,
        "startLineNumber" : 263,
        "startColumnNumber" : 20,
        "endLineNumber" : 263,
        "endColumnNumber" : 81
      },
      "nodeContext" : "outputLength=inflater.inflate(outArray,outIndex,writable)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 62,
        "startLineNumber" : 263,
        "startColumnNumber" : 20,
        "endLineNumber" : 263,
        "endColumnNumber" : 82
      },
      "nodeContext" : "outputLength=inflater.inflate(outArray,outIndex,writable);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 243,
        "startLineNumber" : 260,
        "startColumnNumber" : 45,
        "endLineNumber" : 264,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  byte[] outArray=decompressed.array();\n  int outIndex=decompressed.arrayOffset() + writerIndex;\n  outputLength=inflater.inflate(outArray,outIndex,writable);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 28,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 684,
        "startLineNumber" : 260,
        "startColumnNumber" : 16,
        "endLineNumber" : 270,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (decompressed.hasArray()) {\n  byte[] outArray=decompressed.array();\n  int outIndex=decompressed.arrayOffset() + writerIndex;\n  outputLength=inflater.inflate(outArray,outIndex,writable);\n}\n else if (decompressed.nioBufferCount() == 1) {\n  ByteBuffer buffer=decompressed.internalNioBuffer(writerIndex,writable);\n  outputLength=inflater.inflate(buffer);\n}\n else {\n  throw new IllegalStateException(\"Decompress buffer must have array or exactly 1 NIO buffer: \" + decompressed);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 64,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 1945,
        "startLineNumber" : 256,
        "startColumnNumber" : 43,
        "endLineNumber" : 294,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  int writerIndex=decompressed.writerIndex();\n  int writable=decompressed.writableBytes();\n  int outputLength;\n  if (decompressed.hasArray()) {\n    byte[] outArray=decompressed.array();\n    int outIndex=decompressed.arrayOffset() + writerIndex;\n    outputLength=inflater.inflate(outArray,outIndex,writable);\n  }\n else   if (decompressed.nioBufferCount() == 1) {\n    ByteBuffer buffer=decompressed.internalNioBuffer(writerIndex,writable);\n    outputLength=inflater.inflate(buffer);\n  }\n else {\n    throw new IllegalStateException(\"Decompress buffer must have array or exactly 1 NIO buffer: \" + decompressed);\n  }\n  if (outputLength > 0) {\n    decompressed.writerIndex(writerIndex + outputLength);\n    if (crc != null) {\n      crc.update(decompressed,writerIndex,outputLength);\n    }\n  }\n else   if (inflater.needsDictionary()) {\n    if (dictionary == null) {\n      throw new DecompressionException(\"decompression failure, unable to set dictionary as non was specified\");\n    }\n    inflater.setDictionary(dictionary);\n  }\n  if (inflater.finished()) {\n    if (crc == null) {\n      finished=true;\n    }\n else {\n      readFooter=true;\n    }\n    break;\n  }\n else {\n    decompressed=prepareDecompressBuffer(allocator,decompressed,inflater.getRemaining() << 1);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 160,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1976,
        "startLineNumber" : 256,
        "startColumnNumber" : 12,
        "endLineNumber" : 294,
        "endColumnNumber" : 13
      },
      "nodeContext" : "while (!inflater.needsInput()) {\n  int writerIndex=decompressed.writerIndex();\n  int writable=decompressed.writableBytes();\n  int outputLength;\n  if (decompressed.hasArray()) {\n    byte[] outArray=decompressed.array();\n    int outIndex=decompressed.arrayOffset() + writerIndex;\n    outputLength=inflater.inflate(outArray,outIndex,writable);\n  }\n else   if (decompressed.nioBufferCount() == 1) {\n    ByteBuffer buffer=decompressed.internalNioBuffer(writerIndex,writable);\n    outputLength=inflater.inflate(buffer);\n  }\n else {\n    throw new IllegalStateException(\"Decompress buffer must have array or exactly 1 NIO buffer: \" + decompressed);\n  }\n  if (outputLength > 0) {\n    decompressed.writerIndex(writerIndex + outputLength);\n    if (crc != null) {\n      crc.update(decompressed,writerIndex,outputLength);\n    }\n  }\n else   if (inflater.needsDictionary()) {\n    if (dictionary == null) {\n      throw new DecompressionException(\"decompression failure, unable to set dictionary as non was specified\");\n    }\n    inflater.setDictionary(dictionary);\n  }\n  if (inflater.finished()) {\n    if (crc == null) {\n      finished=true;\n    }\n else {\n      readFooter=true;\n    }\n    break;\n  }\n else {\n    decompressed=prepareDecompressBuffer(allocator,decompressed,inflater.getRemaining() << 1);\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 165,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 2447,
        "startLineNumber" : 254,
        "startColumnNumber" : 12,
        "endLineNumber" : 309,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  boolean readFooter=false;\n  while (!inflater.needsInput()) {\n    int writerIndex=decompressed.writerIndex();\n    int writable=decompressed.writableBytes();\n    int outputLength;\n    if (decompressed.hasArray()) {\n      byte[] outArray=decompressed.array();\n      int outIndex=decompressed.arrayOffset() + writerIndex;\n      outputLength=inflater.inflate(outArray,outIndex,writable);\n    }\n else     if (decompressed.nioBufferCount() == 1) {\n      ByteBuffer buffer=decompressed.internalNioBuffer(writerIndex,writable);\n      outputLength=inflater.inflate(buffer);\n    }\n else {\n      throw new IllegalStateException(\"Decompress buffer must have array or exactly 1 NIO buffer: \" + decompressed);\n    }\n    if (outputLength > 0) {\n      decompressed.writerIndex(writerIndex + outputLength);\n      if (crc != null) {\n        crc.update(decompressed,writerIndex,outputLength);\n      }\n    }\n else     if (inflater.needsDictionary()) {\n      if (dictionary == null) {\n        throw new DecompressionException(\"decompression failure, unable to set dictionary as non was specified\");\n      }\n      inflater.setDictionary(dictionary);\n    }\n    if (inflater.finished()) {\n      if (crc == null) {\n        finished=true;\n      }\n else {\n        readFooter=true;\n      }\n      break;\n    }\n else {\n      decompressed=prepareDecompressBuffer(allocator,decompressed,inflater.getRemaining() << 1);\n    }\n  }\n  in.skipBytes(readableBytes - inflater.getRemaining());\n  if (readFooter) {\n    gzipState=GzipState.FOOTER_START;\n    handleGzipFooter(in);\n  }\n  if (decompressed.isReadable()) {\n    return decompressed;\n  }\n else {\n    decompressed.release();\n    return null;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 207,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2706,
        "startLineNumber" : 254,
        "startColumnNumber" : 8,
        "endLineNumber" : 315,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try {\n  boolean readFooter=false;\n  while (!inflater.needsInput()) {\n    int writerIndex=decompressed.writerIndex();\n    int writable=decompressed.writableBytes();\n    int outputLength;\n    if (decompressed.hasArray()) {\n      byte[] outArray=decompressed.array();\n      int outIndex=decompressed.arrayOffset() + writerIndex;\n      outputLength=inflater.inflate(outArray,outIndex,writable);\n    }\n else     if (decompressed.nioBufferCount() == 1) {\n      ByteBuffer buffer=decompressed.internalNioBuffer(writerIndex,writable);\n      outputLength=inflater.inflate(buffer);\n    }\n else {\n      throw new IllegalStateException(\"Decompress buffer must have array or exactly 1 NIO buffer: \" + decompressed);\n    }\n    if (outputLength > 0) {\n      decompressed.writerIndex(writerIndex + outputLength);\n      if (crc != null) {\n        crc.update(decompressed,writerIndex,outputLength);\n      }\n    }\n else     if (inflater.needsDictionary()) {\n      if (dictionary == null) {\n        throw new DecompressionException(\"decompression failure, unable to set dictionary as non was specified\");\n      }\n      inflater.setDictionary(dictionary);\n    }\n    if (inflater.finished()) {\n      if (crc == null) {\n        finished=true;\n      }\n else {\n        readFooter=true;\n      }\n      break;\n    }\n else {\n      decompressed=prepareDecompressBuffer(allocator,decompressed,inflater.getRemaining() << 1);\n    }\n  }\n  in.skipBytes(readableBytes - inflater.getRemaining());\n  if (readFooter) {\n    gzipState=GzipState.FOOTER_START;\n    handleGzipFooter(in);\n  }\n  if (decompressed.isReadable()) {\n    return decompressed;\n  }\n else {\n    decompressed.release();\n    return null;\n  }\n}\n catch (DataFormatException e) {\n  decompressed.release();\n  throw new DecompressionException(\"decompression failure\",e);\n}\ncatch (Throwable cause) {\n  decompressed.release();\n  throw cause;\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 236,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4858,
        "startLineNumber" : 197,
        "startColumnNumber" : 100,
        "endLineNumber" : 316,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (closed) {\n    throw new DecompressionException(\"Decompressor closed\");\n  }\n  if (finished) {\n    return Unpooled.EMPTY_BUFFER;\n  }\n  int readableBytes=in.readableBytes();\n  if (readableBytes == 0) {\n    return null;\n  }\n  if (decideZlibOrNone) {\n    if (readableBytes < 2) {\n      return null;\n    }\n    boolean nowrap=!looksLikeZlib(in.getShort(in.readerIndex()));\n    inflater=new Inflater(nowrap);\n    decideZlibOrNone=false;\n  }\n  if (crc != null) {\n    if (gzipState != GzipState.HEADER_END) {\n      if (gzipState == GzipState.FOOTER_START) {\n        if (!handleGzipFooter(in)) {\n          return null;\n        }\n        assert gzipState == GzipState.HEADER_START;\n      }\n      if (!readGZIPHeader(in)) {\n        return null;\n      }\n      readableBytes=in.readableBytes();\n      if (readableBytes == 0) {\n        return null;\n      }\n    }\n  }\n  if (inflater.needsInput()) {\n    if (in.hasArray()) {\n      inflater.setInput(in.array(),in.arrayOffset() + in.readerIndex(),readableBytes);\n    }\n else {\n      byte[] array=new byte[readableBytes];\n      in.getBytes(in.readerIndex(),array);\n      inflater.setInput(array);\n    }\n  }\n  ByteBuf decompressed=prepareDecompressBuffer(allocator,null,inflater.getRemaining() << 1);\n  try {\n    boolean readFooter=false;\n    while (!inflater.needsInput()) {\n      int writerIndex=decompressed.writerIndex();\n      int writable=decompressed.writableBytes();\n      int outputLength;\n      if (decompressed.hasArray()) {\n        byte[] outArray=decompressed.array();\n        int outIndex=decompressed.arrayOffset() + writerIndex;\n        outputLength=inflater.inflate(outArray,outIndex,writable);\n      }\n else       if (decompressed.nioBufferCount() == 1) {\n        ByteBuffer buffer=decompressed.internalNioBuffer(writerIndex,writable);\n        outputLength=inflater.inflate(buffer);\n      }\n else {\n        throw new IllegalStateException(\"Decompress buffer must have array or exactly 1 NIO buffer: \" + decompressed);\n      }\n      if (outputLength > 0) {\n        decompressed.writerIndex(writerIndex + outputLength);\n        if (crc != null) {\n          crc.update(decompressed,writerIndex,outputLength);\n        }\n      }\n else       if (inflater.needsDictionary()) {\n        if (dictionary == null) {\n          throw new DecompressionException(\"decompression failure, unable to set dictionary as non was specified\");\n        }\n        inflater.setDictionary(dictionary);\n      }\n      if (inflater.finished()) {\n        if (crc == null) {\n          finished=true;\n        }\n else {\n          readFooter=true;\n        }\n        break;\n      }\n else {\n        decompressed=prepareDecompressBuffer(allocator,decompressed,inflater.getRemaining() << 1);\n      }\n    }\n    in.skipBytes(readableBytes - inflater.getRemaining());\n    if (readFooter) {\n      gzipState=GzipState.FOOTER_START;\n      handleGzipFooter(in);\n    }\n    if (decompressed.isReadable()) {\n      return decompressed;\n    }\n else {\n      decompressed.release();\n      return null;\n    }\n  }\n catch (  DataFormatException e) {\n    decompressed.release();\n    throw new DecompressionException(\"decompression failure\",e);\n  }\ncatch (  Throwable cause) {\n    decompressed.release();\n    throw cause;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 418,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4969,
        "startLineNumber" : 196,
        "startColumnNumber" : 4,
        "endLineNumber" : 316,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@Override public ByteBuf decompress(ByteBuf in,ByteBufAllocator allocator) throws DecompressionException {\n  if (closed) {\n    throw new DecompressionException(\"Decompressor closed\");\n  }\n  if (finished) {\n    return Unpooled.EMPTY_BUFFER;\n  }\n  int readableBytes=in.readableBytes();\n  if (readableBytes == 0) {\n    return null;\n  }\n  if (decideZlibOrNone) {\n    if (readableBytes < 2) {\n      return null;\n    }\n    boolean nowrap=!looksLikeZlib(in.getShort(in.readerIndex()));\n    inflater=new Inflater(nowrap);\n    decideZlibOrNone=false;\n  }\n  if (crc != null) {\n    if (gzipState != GzipState.HEADER_END) {\n      if (gzipState == GzipState.FOOTER_START) {\n        if (!handleGzipFooter(in)) {\n          return null;\n        }\n        assert gzipState == GzipState.HEADER_START;\n      }\n      if (!readGZIPHeader(in)) {\n        return null;\n      }\n      readableBytes=in.readableBytes();\n      if (readableBytes == 0) {\n        return null;\n      }\n    }\n  }\n  if (inflater.needsInput()) {\n    if (in.hasArray()) {\n      inflater.setInput(in.array(),in.arrayOffset() + in.readerIndex(),readableBytes);\n    }\n else {\n      byte[] array=new byte[readableBytes];\n      in.getBytes(in.readerIndex(),array);\n      inflater.setInput(array);\n    }\n  }\n  ByteBuf decompressed=prepareDecompressBuffer(allocator,null,inflater.getRemaining() << 1);\n  try {\n    boolean readFooter=false;\n    while (!inflater.needsInput()) {\n      int writerIndex=decompressed.writerIndex();\n      int writable=decompressed.writableBytes();\n      int outputLength;\n      if (decompressed.hasArray()) {\n        byte[] outArray=decompressed.array();\n        int outIndex=decompressed.arrayOffset() + writerIndex;\n        outputLength=inflater.inflate(outArray,outIndex,writable);\n      }\n else       if (decompressed.nioBufferCount() == 1) {\n        ByteBuffer buffer=decompressed.internalNioBuffer(writerIndex,writable);\n        outputLength=inflater.inflate(buffer);\n      }\n else {\n        throw new IllegalStateException(\"Decompress buffer must have array or exactly 1 NIO buffer: \" + decompressed);\n      }\n      if (outputLength > 0) {\n        decompressed.writerIndex(writerIndex + outputLength);\n        if (crc != null) {\n          crc.update(decompressed,writerIndex,outputLength);\n        }\n      }\n else       if (inflater.needsDictionary()) {\n        if (dictionary == null) {\n          throw new DecompressionException(\"decompression failure, unable to set dictionary as non was specified\");\n        }\n        inflater.setDictionary(dictionary);\n      }\n      if (inflater.finished()) {\n        if (crc == null) {\n          finished=true;\n        }\n else {\n          readFooter=true;\n        }\n        break;\n      }\n else {\n        decompressed=prepareDecompressBuffer(allocator,decompressed,inflater.getRemaining() << 1);\n      }\n    }\n    in.skipBytes(readableBytes - inflater.getRemaining());\n    if (readFooter) {\n      gzipState=GzipState.FOOTER_START;\n      handleGzipFooter(in);\n    }\n    if (decompressed.isReadable()) {\n      return decompressed;\n    }\n else {\n      decompressed.release();\n      return null;\n    }\n  }\n catch (  DataFormatException e) {\n    decompressed.release();\n    throw new DecompressionException(\"decompression failure\",e);\n  }\ncatch (  Throwable cause) {\n    decompressed.release();\n    throw cause;\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 435,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 62,
        "startLineNumber" : 263,
        "startColumnNumber" : 20,
        "endLineNumber" : 263,
        "endColumnNumber" : 82
      },
      "nodeContext" : "outputLength=inflater.inflate(outArray,outIndex,writable);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 5,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 46,
    "startLineNumber" : 263,
    "startColumnNumber" : 35,
    "endLineNumber" : 263,
    "endColumnNumber" : 81
  } ],
  "layoutRelationDataList" : [ ]
}