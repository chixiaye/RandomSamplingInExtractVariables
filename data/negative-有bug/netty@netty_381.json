{
  "id" : 381,
  "expression" : "EventType.ACTIVE",
  "projectName" : "netty@netty",
  "commitID" : "8a68c3e58d4663ae42e41a90d0d11aec3c25016b",
  "filePath" : "/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "EventType.ACTIVE",
    "nodeType" : "QualifiedName",
    "nodePosition" : {
      "charLength" : 16,
      "startLineNumber" : 214,
      "startColumnNumber" : 36,
      "endLineNumber" : 214,
      "endColumnNumber" : 52
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 41,
        "startLineNumber" : 214,
        "startColumnNumber" : 12,
        "endLineNumber" : 214,
        "endColumnNumber" : 53
      },
      "nodeContext" : "expectedEvents.addFirst(EventType.ACTIVE)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 214,
        "startColumnNumber" : 12,
        "endLineNumber" : 214,
        "endColumnNumber" : 54
      },
      "nodeContext" : "expectedEvents.addFirst(EventType.ACTIVE);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 3751,
        "startLineNumber" : 136,
        "startColumnNumber" : 12,
        "endLineNumber" : 227,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  Deque<EventType> events=new ConcurrentLinkedDeque<EventType>();\n  final EventForwarder h1=new EventForwarder();\n  final EventForwarder h2=new EventForwarder();\n  final EventForwarder h3=new EventForwarder();\n  final EventForwarder h4=new EventForwarder();\n  final EventForwarder h5=new EventForwarder();\n  final EventRecorder h6=new EventRecorder(events,inbound);\n  final Channel ch=new LocalChannel();\n  if (!inbound) {\n    ch.config().setAutoRead(false);\n  }\n  ch.pipeline().addLast(e1,h1).addLast(e1,h2).addLast(e1,h3).addLast(e1,h4).addLast(e1,h5).addLast(e1,\"recorder\",h6);\n  l.register(ch).sync().channel().connect(localAddr).sync();\n  final LinkedList<EventType> expectedEvents=events(inbound,8192);\n  Throwable cause=new Throwable();\n  Thread pipelineModifier=new Thread(new Runnable(){\n    @Override public void run(){\n      Random random=new Random();\n      while (true) {\n        try {\n          Thread.sleep(100);\n        }\n catch (        InterruptedException e) {\n          return;\n        }\n        if (!ch.isRegistered()) {\n          continue;\n        }\n        ChannelHandler handler=ch.pipeline().removeFirst();\n        ch.pipeline().addBefore(groups[random.nextInt(groups.length)],\"recorder\",UUID.randomUUID().toString(),handler);\n      }\n    }\n  }\n);\n  pipelineModifier.setDaemon(true);\n  pipelineModifier.start();\n  for (  EventType event : expectedEvents) {\nswitch (event) {\ncase EXCEPTION_CAUGHT:      ch.pipeline().fireExceptionCaught(cause);\n    break;\ncase MESSAGE_RECEIVED:  ch.pipeline().fireChannelRead(\"\");\nbreak;\ncase MESSAGE_RECEIVED_LAST:ch.pipeline().fireChannelReadComplete();\nbreak;\ncase USER_EVENT:ch.pipeline().fireUserEventTriggered(\"\");\nbreak;\ncase WRITE:ch.pipeline().write(\"\");\nbreak;\ncase READ:ch.pipeline().read();\nbreak;\n}\n}\nch.close().sync();\nwhile (events.peekLast() != EventType.UNREGISTERED) {\nThread.sleep(10);\n}\nexpectedEvents.addFirst(EventType.ACTIVE);\nexpectedEvents.addFirst(EventType.REGISTERED);\nexpectedEvents.addLast(EventType.INACTIVE);\nexpectedEvents.addLast(EventType.UNREGISTERED);\nfor (; ; ) {\nEventType event=events.poll();\nif (event == null) {\nassertTrue(expectedEvents.isEmpty(),\"Missing events:\" + expectedEvents);\nbreak;\n}\nassertEquals(event,expectedEvents.poll());\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 393,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4268,
        "startLineNumber" : 136,
        "startColumnNumber" : 8,
        "endLineNumber" : 241,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try {\n  Deque<EventType> events=new ConcurrentLinkedDeque<EventType>();\n  final EventForwarder h1=new EventForwarder();\n  final EventForwarder h2=new EventForwarder();\n  final EventForwarder h3=new EventForwarder();\n  final EventForwarder h4=new EventForwarder();\n  final EventForwarder h5=new EventForwarder();\n  final EventRecorder h6=new EventRecorder(events,inbound);\n  final Channel ch=new LocalChannel();\n  if (!inbound) {\n    ch.config().setAutoRead(false);\n  }\n  ch.pipeline().addLast(e1,h1).addLast(e1,h2).addLast(e1,h3).addLast(e1,h4).addLast(e1,h5).addLast(e1,\"recorder\",h6);\n  l.register(ch).sync().channel().connect(localAddr).sync();\n  final LinkedList<EventType> expectedEvents=events(inbound,8192);\n  Throwable cause=new Throwable();\n  Thread pipelineModifier=new Thread(new Runnable(){\n    @Override public void run(){\n      Random random=new Random();\n      while (true) {\n        try {\n          Thread.sleep(100);\n        }\n catch (        InterruptedException e) {\n          return;\n        }\n        if (!ch.isRegistered()) {\n          continue;\n        }\n        ChannelHandler handler=ch.pipeline().removeFirst();\n        ch.pipeline().addBefore(groups[random.nextInt(groups.length)],\"recorder\",UUID.randomUUID().toString(),handler);\n      }\n    }\n  }\n);\n  pipelineModifier.setDaemon(true);\n  pipelineModifier.start();\n  for (  EventType event : expectedEvents) {\nswitch (event) {\ncase EXCEPTION_CAUGHT:      ch.pipeline().fireExceptionCaught(cause);\n    break;\ncase MESSAGE_RECEIVED:  ch.pipeline().fireChannelRead(\"\");\nbreak;\ncase MESSAGE_RECEIVED_LAST:ch.pipeline().fireChannelReadComplete();\nbreak;\ncase USER_EVENT:ch.pipeline().fireUserEventTriggered(\"\");\nbreak;\ncase WRITE:ch.pipeline().write(\"\");\nbreak;\ncase READ:ch.pipeline().read();\nbreak;\n}\n}\nch.close().sync();\nwhile (events.peekLast() != EventType.UNREGISTERED) {\nThread.sleep(10);\n}\nexpectedEvents.addFirst(EventType.ACTIVE);\nexpectedEvents.addFirst(EventType.REGISTERED);\nexpectedEvents.addLast(EventType.INACTIVE);\nexpectedEvents.addLast(EventType.UNREGISTERED);\nfor (; ; ) {\nEventType event=events.poll();\nif (event == null) {\nassertTrue(expectedEvents.isEmpty(),\"Missing events:\" + expectedEvents);\nbreak;\n}\nassertEquals(event,expectedEvents.poll());\n}\n}\n  finally {\nl.shutdownGracefully();\ne1.shutdownGracefully();\ne2.shutdownGracefully();\ne3.shutdownGracefully();\ne4.shutdownGracefully();\ne5.shutdownGracefully();\nl.terminationFuture().sync();\ne1.terminationFuture().sync();\ne2.terminationFuture().sync();\ne3.terminationFuture().sync();\ne4.terminationFuture().sync();\ne5.terminationFuture().sync();\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 455,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4939,
        "startLineNumber" : 127,
        "startColumnNumber" : 82,
        "endLineNumber" : 242,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  EventLoopGroup l=new DefaultEventLoopGroup(4,new DefaultThreadFactory(\"l\"));\n  EventExecutorGroup e1=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e1\"));\n  EventExecutorGroup e2=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e2\"));\n  EventExecutorGroup e3=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e3\"));\n  EventExecutorGroup e4=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e4\"));\n  EventExecutorGroup e5=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e5\"));\n  final EventExecutorGroup[] groups={e1,e2,e3,e4,e5};\n  try {\n    Deque<EventType> events=new ConcurrentLinkedDeque<EventType>();\n    final EventForwarder h1=new EventForwarder();\n    final EventForwarder h2=new EventForwarder();\n    final EventForwarder h3=new EventForwarder();\n    final EventForwarder h4=new EventForwarder();\n    final EventForwarder h5=new EventForwarder();\n    final EventRecorder h6=new EventRecorder(events,inbound);\n    final Channel ch=new LocalChannel();\n    if (!inbound) {\n      ch.config().setAutoRead(false);\n    }\n    ch.pipeline().addLast(e1,h1).addLast(e1,h2).addLast(e1,h3).addLast(e1,h4).addLast(e1,h5).addLast(e1,\"recorder\",h6);\n    l.register(ch).sync().channel().connect(localAddr).sync();\n    final LinkedList<EventType> expectedEvents=events(inbound,8192);\n    Throwable cause=new Throwable();\n    Thread pipelineModifier=new Thread(new Runnable(){\n      @Override public void run(){\n        Random random=new Random();\n        while (true) {\n          try {\n            Thread.sleep(100);\n          }\n catch (          InterruptedException e) {\n            return;\n          }\n          if (!ch.isRegistered()) {\n            continue;\n          }\n          ChannelHandler handler=ch.pipeline().removeFirst();\n          ch.pipeline().addBefore(groups[random.nextInt(groups.length)],\"recorder\",UUID.randomUUID().toString(),handler);\n        }\n      }\n    }\n);\n    pipelineModifier.setDaemon(true);\n    pipelineModifier.start();\n    for (    EventType event : expectedEvents) {\nswitch (event) {\ncase EXCEPTION_CAUGHT:        ch.pipeline().fireExceptionCaught(cause);\n      break;\ncase MESSAGE_RECEIVED:    ch.pipeline().fireChannelRead(\"\");\n  break;\ncase MESSAGE_RECEIVED_LAST:ch.pipeline().fireChannelReadComplete();\nbreak;\ncase USER_EVENT:ch.pipeline().fireUserEventTriggered(\"\");\nbreak;\ncase WRITE:ch.pipeline().write(\"\");\nbreak;\ncase READ:ch.pipeline().read();\nbreak;\n}\n}\nch.close().sync();\nwhile (events.peekLast() != EventType.UNREGISTERED) {\nThread.sleep(10);\n}\nexpectedEvents.addFirst(EventType.ACTIVE);\nexpectedEvents.addFirst(EventType.REGISTERED);\nexpectedEvents.addLast(EventType.INACTIVE);\nexpectedEvents.addLast(EventType.UNREGISTERED);\nfor (; ; ) {\nEventType event=events.poll();\nif (event == null) {\nassertTrue(expectedEvents.isEmpty(),\"Missing events:\" + expectedEvents);\nbreak;\n}\nassertEquals(event,expectedEvents.poll());\n}\n}\n  finally {\nl.shutdownGracefully();\ne1.shutdownGracefully();\ne2.shutdownGracefully();\ne3.shutdownGracefully();\ne4.shutdownGracefully();\ne5.shutdownGracefully();\nl.terminationFuture().sync();\ne1.terminationFuture().sync();\ne2.terminationFuture().sync();\ne3.terminationFuture().sync();\ne4.terminationFuture().sync();\ne5.terminationFuture().sync();\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 548,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5017,
        "startLineNumber" : 127,
        "startColumnNumber" : 4,
        "endLineNumber" : 242,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private static void testConcurrentAddRemove(boolean inbound) throws Exception {\n  EventLoopGroup l=new DefaultEventLoopGroup(4,new DefaultThreadFactory(\"l\"));\n  EventExecutorGroup e1=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e1\"));\n  EventExecutorGroup e2=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e2\"));\n  EventExecutorGroup e3=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e3\"));\n  EventExecutorGroup e4=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e4\"));\n  EventExecutorGroup e5=new DefaultEventExecutorGroup(4,new DefaultThreadFactory(\"e5\"));\n  final EventExecutorGroup[] groups={e1,e2,e3,e4,e5};\n  try {\n    Deque<EventType> events=new ConcurrentLinkedDeque<EventType>();\n    final EventForwarder h1=new EventForwarder();\n    final EventForwarder h2=new EventForwarder();\n    final EventForwarder h3=new EventForwarder();\n    final EventForwarder h4=new EventForwarder();\n    final EventForwarder h5=new EventForwarder();\n    final EventRecorder h6=new EventRecorder(events,inbound);\n    final Channel ch=new LocalChannel();\n    if (!inbound) {\n      ch.config().setAutoRead(false);\n    }\n    ch.pipeline().addLast(e1,h1).addLast(e1,h2).addLast(e1,h3).addLast(e1,h4).addLast(e1,h5).addLast(e1,\"recorder\",h6);\n    l.register(ch).sync().channel().connect(localAddr).sync();\n    final LinkedList<EventType> expectedEvents=events(inbound,8192);\n    Throwable cause=new Throwable();\n    Thread pipelineModifier=new Thread(new Runnable(){\n      @Override public void run(){\n        Random random=new Random();\n        while (true) {\n          try {\n            Thread.sleep(100);\n          }\n catch (          InterruptedException e) {\n            return;\n          }\n          if (!ch.isRegistered()) {\n            continue;\n          }\n          ChannelHandler handler=ch.pipeline().removeFirst();\n          ch.pipeline().addBefore(groups[random.nextInt(groups.length)],\"recorder\",UUID.randomUUID().toString(),handler);\n        }\n      }\n    }\n);\n    pipelineModifier.setDaemon(true);\n    pipelineModifier.start();\n    for (    EventType event : expectedEvents) {\nswitch (event) {\ncase EXCEPTION_CAUGHT:        ch.pipeline().fireExceptionCaught(cause);\n      break;\ncase MESSAGE_RECEIVED:    ch.pipeline().fireChannelRead(\"\");\n  break;\ncase MESSAGE_RECEIVED_LAST:ch.pipeline().fireChannelReadComplete();\nbreak;\ncase USER_EVENT:ch.pipeline().fireUserEventTriggered(\"\");\nbreak;\ncase WRITE:ch.pipeline().write(\"\");\nbreak;\ncase READ:ch.pipeline().read();\nbreak;\n}\n}\nch.close().sync();\nwhile (events.peekLast() != EventType.UNREGISTERED) {\nThread.sleep(10);\n}\nexpectedEvents.addFirst(EventType.ACTIVE);\nexpectedEvents.addFirst(EventType.REGISTERED);\nexpectedEvents.addLast(EventType.INACTIVE);\nexpectedEvents.addLast(EventType.UNREGISTERED);\nfor (; ; ) {\nEventType event=events.poll();\nif (event == null) {\nassertTrue(expectedEvents.isEmpty(),\"Missing events:\" + expectedEvents);\nbreak;\n}\nassertEquals(event,expectedEvents.poll());\n}\n}\n  finally {\nl.shutdownGracefully();\ne1.shutdownGracefully();\ne2.shutdownGracefully();\ne3.shutdownGracefully();\ne4.shutdownGracefully();\ne5.shutdownGracefully();\nl.terminationFuture().sync();\ne1.terminationFuture().sync();\ne2.terminationFuture().sync();\ne3.terminationFuture().sync();\ne4.terminationFuture().sync();\ne5.terminationFuture().sync();\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 558,
      "astHeight" : 19
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42,
        "startLineNumber" : 214,
        "startColumnNumber" : 12,
        "endLineNumber" : 214,
        "endColumnNumber" : 54
      },
      "nodeContext" : "expectedEvents.addFirst(EventType.ACTIVE);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 4
    },
    "tokenLength" : 2,
    "type" : "io.netty.channel.local.LocalTransportThreadModelTest3.EventType"
  } ],
  "positionList" : [ {
    "charLength" : 16,
    "startLineNumber" : 214,
    "startColumnNumber" : 36,
    "endLineNumber" : 214,
    "endColumnNumber" : 52
  } ],
  "layoutRelationDataList" : [ ]
}