{
  "id" : 59,
  "expression" : "\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\"",
  "projectName" : "prestodb@presto",
  "commitID" : "eff77883d0d24dc6022ecde252612d1430c9fbac",
  "filePath" : "/presto-orc/src/main/java/com/facebook/presto/orc/checkpoint/Checkpoints.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\"",
    "nodeType" : "StringLiteral",
    "nodePosition" : {
      "charLength" : 90,
      "startLineNumber" : 140,
      "startColumnNumber" : 60,
      "endLineNumber" : 140,
      "endColumnNumber" : 150
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
      "nodePosition" : {
        "charLength" : 268,
        "startLineNumber" : 140,
        "startColumnNumber" : 53,
        "endLineNumber" : 144,
        "endColumnNumber" : 55
      },
      "nodeContext" : "format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ThrowStatement,expression]",
      "nodePosition" : {
        "charLength" : 300,
        "startLineNumber" : 140,
        "startColumnNumber" : 22,
        "endLineNumber" : 144,
        "endColumnNumber" : 56
      },
      "nodeContext" : "new InvalidCheckpointException(format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex()))",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 14,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 307,
        "startLineNumber" : 140,
        "startColumnNumber" : 16,
        "endLineNumber" : 144,
        "endColumnNumber" : 57
      },
      "nodeContext" : "throw new InvalidCheckpointException(format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex()));\n",
      "nodeType" : "ThrowStatement",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 339,
        "startLineNumber" : 139,
        "startColumnNumber" : 100,
        "endLineNumber" : 145,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  throw new InvalidCheckpointException(format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex()));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 427,
        "startLineNumber" : 139,
        "startColumnNumber" : 12,
        "endLineNumber" : 145,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (columnPositionsList.hasNextPosition() && !Iterables.all(positionsList,equalTo(0))) {\n  throw new InvalidCheckpointException(format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex()));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 29,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 3948,
        "startLineNumber" : 78,
        "startColumnNumber" : 88,
        "endLineNumber" : 146,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  int column=entry.getKey().getColumn();\n  if (!columns.contains(column)) {\n    continue;\n  }\n  int sequence=entry.getKey().getSequence();\n  List<Integer> positionsList=entry.getValue().get(rowGroupId).getPositions();\n  ColumnEncodingKind columnEncoding=columnEncodings.get(column).getColumnEncoding(sequence).getColumnEncodingKind();\n  OrcTypeKind columnType=columnTypes.get(column).getOrcTypeKind();\n  Set<StreamKind> availableStreams=streamKinds.get(new ColumnAndSequence(column,sequence));\n  ColumnPositionsList columnPositionsList=new ColumnPositionsList(column,sequence,columnType,positionsList);\nswitch (columnType) {\ncase BOOLEAN:    checkpoints.putAll(getBooleanColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\n  break;\ncase BYTE:checkpoints.putAll(getByteColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase SHORT:case INT:case LONG:case DATE:checkpoints.putAll(getLongColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase FLOAT:checkpoints.putAll(getFloatColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase DOUBLE:checkpoints.putAll(getDoubleColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase TIMESTAMP:checkpoints.putAll(getTimestampColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase BINARY:case STRING:case VARCHAR:case CHAR:checkpoints.putAll(getSliceColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase LIST:case MAP:checkpoints.putAll(getListOrMapColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase STRUCT:checkpoints.putAll(getStructColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase DECIMAL:checkpoints.putAll(getDecimalColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ndefault:throw new IllegalArgumentException(\"Unsupported column type \" + columnType);\n}\nif (columnPositionsList.hasNextPosition() && !Iterables.all(positionsList,equalTo(0))) {\nthrow new InvalidCheckpointException(format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex()));\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 294,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4028,
        "startLineNumber" : 78,
        "startColumnNumber" : 8,
        "endLineNumber" : 146,
        "endColumnNumber" : 9
      },
      "nodeContext" : "for (Map.Entry<StreamId,List<RowGroupIndex>> entry : columnIndexes.entrySet()) {\n  int column=entry.getKey().getColumn();\n  if (!columns.contains(column)) {\n    continue;\n  }\n  int sequence=entry.getKey().getSequence();\n  List<Integer> positionsList=entry.getValue().get(rowGroupId).getPositions();\n  ColumnEncodingKind columnEncoding=columnEncodings.get(column).getColumnEncoding(sequence).getColumnEncodingKind();\n  OrcTypeKind columnType=columnTypes.get(column).getOrcTypeKind();\n  Set<StreamKind> availableStreams=streamKinds.get(new ColumnAndSequence(column,sequence));\n  ColumnPositionsList columnPositionsList=new ColumnPositionsList(column,sequence,columnType,positionsList);\nswitch (columnType) {\ncase BOOLEAN:    checkpoints.putAll(getBooleanColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\n  break;\ncase BYTE:checkpoints.putAll(getByteColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase SHORT:case INT:case LONG:case DATE:checkpoints.putAll(getLongColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase FLOAT:checkpoints.putAll(getFloatColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase DOUBLE:checkpoints.putAll(getDoubleColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase TIMESTAMP:checkpoints.putAll(getTimestampColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase BINARY:case STRING:case VARCHAR:case CHAR:checkpoints.putAll(getSliceColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase LIST:case MAP:checkpoints.putAll(getListOrMapColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase STRUCT:checkpoints.putAll(getStructColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase DECIMAL:checkpoints.putAll(getDecimalColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ndefault:throw new IllegalArgumentException(\"Unsupported column type \" + columnType);\n}\nif (columnPositionsList.hasNextPosition() && !Iterables.all(positionsList,equalTo(0))) {\nthrow new InvalidCheckpointException(format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex()));\n}\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 312,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 4637,
        "startLineNumber" : 69,
        "startColumnNumber" : 4,
        "endLineNumber" : 148,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  ImmutableSetMultimap.Builder<ColumnAndSequence,StreamKind> streamKindsBuilder=ImmutableSetMultimap.builder();\n  for (  Stream stream : streams.values()) {\n    streamKindsBuilder.put(new ColumnAndSequence(stream.getColumn(),stream.getSequence()),stream.getStreamKind());\n  }\n  SetMultimap<ColumnAndSequence,StreamKind> streamKinds=streamKindsBuilder.build();\n  ImmutableMap.Builder<StreamId,StreamCheckpoint> checkpoints=ImmutableMap.builder();\n  for (  Map.Entry<StreamId,List<RowGroupIndex>> entry : columnIndexes.entrySet()) {\n    int column=entry.getKey().getColumn();\n    if (!columns.contains(column)) {\n      continue;\n    }\n    int sequence=entry.getKey().getSequence();\n    List<Integer> positionsList=entry.getValue().get(rowGroupId).getPositions();\n    ColumnEncodingKind columnEncoding=columnEncodings.get(column).getColumnEncoding(sequence).getColumnEncodingKind();\n    OrcTypeKind columnType=columnTypes.get(column).getOrcTypeKind();\n    Set<StreamKind> availableStreams=streamKinds.get(new ColumnAndSequence(column,sequence));\n    ColumnPositionsList columnPositionsList=new ColumnPositionsList(column,sequence,columnType,positionsList);\nswitch (columnType) {\ncase BOOLEAN:      checkpoints.putAll(getBooleanColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\n    break;\ncase BYTE:  checkpoints.putAll(getByteColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase SHORT:case INT:case LONG:case DATE:checkpoints.putAll(getLongColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase FLOAT:checkpoints.putAll(getFloatColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase DOUBLE:checkpoints.putAll(getDoubleColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase TIMESTAMP:checkpoints.putAll(getTimestampColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase BINARY:case STRING:case VARCHAR:case CHAR:checkpoints.putAll(getSliceColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase LIST:case MAP:checkpoints.putAll(getListOrMapColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase STRUCT:checkpoints.putAll(getStructColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase DECIMAL:checkpoints.putAll(getDecimalColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ndefault:throw new IllegalArgumentException(\"Unsupported column type \" + columnType);\n}\nif (columnPositionsList.hasNextPosition() && !Iterables.all(positionsList,equalTo(0))) {\nthrow new InvalidCheckpointException(format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex()));\n}\n}\nreturn checkpoints.build();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 385,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5051,
        "startLineNumber" : 60,
        "startColumnNumber" : 4,
        "endLineNumber" : 148,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public static Map<StreamId,StreamCheckpoint> getStreamCheckpoints(Set<Integer> columns,List<OrcType> columnTypes,boolean compressed,int rowGroupId,Map<Integer,ColumnEncoding> columnEncodings,Map<StreamId,Stream> streams,Map<StreamId,List<RowGroupIndex>> columnIndexes) throws InvalidCheckpointException {\n  ImmutableSetMultimap.Builder<ColumnAndSequence,StreamKind> streamKindsBuilder=ImmutableSetMultimap.builder();\n  for (  Stream stream : streams.values()) {\n    streamKindsBuilder.put(new ColumnAndSequence(stream.getColumn(),stream.getSequence()),stream.getStreamKind());\n  }\n  SetMultimap<ColumnAndSequence,StreamKind> streamKinds=streamKindsBuilder.build();\n  ImmutableMap.Builder<StreamId,StreamCheckpoint> checkpoints=ImmutableMap.builder();\n  for (  Map.Entry<StreamId,List<RowGroupIndex>> entry : columnIndexes.entrySet()) {\n    int column=entry.getKey().getColumn();\n    if (!columns.contains(column)) {\n      continue;\n    }\n    int sequence=entry.getKey().getSequence();\n    List<Integer> positionsList=entry.getValue().get(rowGroupId).getPositions();\n    ColumnEncodingKind columnEncoding=columnEncodings.get(column).getColumnEncoding(sequence).getColumnEncodingKind();\n    OrcTypeKind columnType=columnTypes.get(column).getOrcTypeKind();\n    Set<StreamKind> availableStreams=streamKinds.get(new ColumnAndSequence(column,sequence));\n    ColumnPositionsList columnPositionsList=new ColumnPositionsList(column,sequence,columnType,positionsList);\nswitch (columnType) {\ncase BOOLEAN:      checkpoints.putAll(getBooleanColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\n    break;\ncase BYTE:  checkpoints.putAll(getByteColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase SHORT:case INT:case LONG:case DATE:checkpoints.putAll(getLongColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase FLOAT:checkpoints.putAll(getFloatColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase DOUBLE:checkpoints.putAll(getDoubleColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase TIMESTAMP:checkpoints.putAll(getTimestampColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase BINARY:case STRING:case VARCHAR:case CHAR:checkpoints.putAll(getSliceColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase LIST:case MAP:checkpoints.putAll(getListOrMapColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ncase STRUCT:checkpoints.putAll(getStructColumnCheckpoints(column,sequence,compressed,availableStreams,columnPositionsList));\nbreak;\ncase DECIMAL:checkpoints.putAll(getDecimalColumnCheckpoints(column,sequence,columnEncoding,compressed,availableStreams,columnPositionsList));\nbreak;\ndefault:throw new IllegalArgumentException(\"Unsupported column type \" + columnType);\n}\nif (columnPositionsList.hasNextPosition() && !Iterables.all(positionsList,equalTo(0))) {\nthrow new InvalidCheckpointException(format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex()));\n}\n}\nreturn checkpoints.build();\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 448,
      "astHeight" : 11
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
      "nodePosition" : {
        "charLength" : 268,
        "startLineNumber" : 140,
        "startColumnNumber" : 53,
        "endLineNumber" : 144,
        "endColumnNumber" : 55
      },
      "nodeContext" : "format(\"Column %s, of type %s, contains %s offset positions, but only %s positions were consumed\",column,columnType,positionsList.size(),columnPositionsList.getIndex())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 11,
      "astHeight" : 3
    },
    "tokenLength" : 15,
    "type" : "java.lang.String"
  } ],
  "positionList" : [ {
    "charLength" : 90,
    "startLineNumber" : 140,
    "startColumnNumber" : 60,
    "endLineNumber" : 140,
    "endColumnNumber" : 150
  } ],
  "layoutRelationDataList" : [ ]
}