{
  "id" : 121,
  "expression" : "tamperedMessageSendFuture",
  "projectName" : "apache@pulsar",
  "commitID" : "ded806fd52f6e2f182fa02052cbd82c2a6755098",
  "filePath" : "/pulsar-broker/src/test/java/org/apache/pulsar/client/impl/MessageChecksumTest.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "tamperedMessageSendFuture",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 184,
      "startColumnNumber" : 12,
      "endLineNumber" : 184,
      "endColumnNumber" : 37
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 184,
        "startColumnNumber" : 12,
        "endLineNumber" : 184,
        "endColumnNumber" : 63
      },
      "nodeContext" : "tamperedMessageSendFuture.get(10,TimeUnit.SECONDS)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 184,
        "startColumnNumber" : 12,
        "endLineNumber" : 184,
        "endColumnNumber" : 64
      },
      "nodeContext" : "tamperedMessageSendFuture.get(10,TimeUnit.SECONDS);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 261,
        "startLineNumber" : 181,
        "startColumnNumber" : 12,
        "endLineNumber" : 185,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  tamperedMessageSendFuture.get(10,TimeUnit.SECONDS);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 398,
        "startLineNumber" : 181,
        "startColumnNumber" : 8,
        "endLineNumber" : 187,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try {\n  tamperedMessageSendFuture.get(10,TimeUnit.SECONDS);\n}\n catch (Exception e) {\n  fail(\"Broker shouldn't verify checksum for corrupted message and it shouldn't fail\",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 21,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3845,
        "startLineNumber" : 114,
        "startColumnNumber" : 29,
        "endLineNumber" : 198,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  final String topicName=\"persistent://prop/use/ns-abc/testChecksumBackwardsCompatibilityWithOldBrokerWithoutChecksumHandling\";\n  if (mixedVersionScenario == MixedVersionScenario.CONNECTED_TO_OLD_THEN_NEW_VERSION) {\n    makeClientAssumeThatItsConnectedToBrokerWithoutChecksumSupport();\n  }\n  PulsarTestClient pulsarTestClient=(PulsarTestClient)pulsarClient;\n  ProducerImpl<byte[]> producer=(ProducerImpl<byte[]>)pulsarClient.newProducer().topic(topicName).enableBatching(false).messageRoutingMode(MessageRoutingMode.SinglePartition).create();\n  Consumer<byte[]> consumer=pulsarClient.newConsumer().topic(topicName).subscriptionName(\"my-sub\").subscribe();\n  CountDownLatch messageSendingProcessedLatch=new CountDownLatch(2);\n  producer.send(\"message-1\".getBytes());\n  pulsarTestClient.dropOpSendMessages();\n  byte[] messageBytes=\"message-2\".getBytes();\n  TypedMessageBuilder<byte[]> messageBuilder=producer.newMessage().value(messageBytes);\n  CompletableFuture<MessageId> tamperedMessageSendFuture=messageBuilder.sendAsync();\n  pulsarTestClient.setPendingMessageCallback(null);\n  pulsarTestClient.disconnectProducerAndRejectReconnecting(producer);\n  ((TypedMessageBuilderImpl<byte[]>)messageBuilder).getContent().put(messageBytes.length - 1,(byte)'3');\n  if (mixedVersionScenario == MixedVersionScenario.CONNECTED_TO_NEW_THEN_OLD_VERSION) {\n    makeClientAssumeThatItsConnectedToBrokerWithoutChecksumSupport();\n  }\n else {\n    resetOverridingConnectedBrokerVersion();\n  }\n  pulsarTestClient.allowReconnecting();\n  try {\n    tamperedMessageSendFuture.get(10,TimeUnit.SECONDS);\n  }\n catch (  Exception e) {\n    fail(\"Broker shouldn't verify checksum for corrupted message and it shouldn't fail\",e);\n  }\n  Message<byte[]> msg=consumer.receive(1,TimeUnit.SECONDS);\n  assertEquals(new String(msg.getData()),\"message-1\");\n  msg=consumer.receive(1,TimeUnit.SECONDS);\n  assertEquals(new String(msg.getData()),\"message-3\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 251,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 5578,
        "startLineNumber" : 87,
        "startColumnNumber" : 4,
        "endLineNumber" : 198,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Pulsar message checksums changed in protocol version v6, broker version v1.15. This test case verifies that a client is able to send messages to an older broker version (<= v1.14, protocol version <= v5) in a mixed environment of broker versions (<= v1.14 & >= v1.15) This test case makes the assumption that the message checksum is ignored if a tampered message can be read by the consumer in the test. Scenario behind this test case: MixedVersionScenario.CONNECTED_TO_NEW_THEN_OLD_VERSION A Pulsar client produces the message while connected to a broker that supports checksums. While sending the message to the broker is pending, the connection breaks and the client connects to another broker that doesn't support message checksums. In this case, the client should remove the message checksum before resending it to the broker. original PR https://github.com/apache/pulsar/pull/43 MixedVersionScenario.CONNECTED_TO_OLD_THEN_NEW_VERSION A Pulsar client produces the message while connected to a broker that doesn't support checksums. While sending the message to the broker is pending, the connection breaks and the client connects to another broker that supports message checksums. In this case, the client should remove the message checksum before resending it to the broker. original PR https://github.com/apache/pulsar/pull/89\n */\n@Test(dataProviderClass=EnumValuesDataProvider.class,dataProvider=\"values\") public void testChecksumCompatibilityInMixedVersionBrokerCluster(MixedVersionScenario mixedVersionScenario) throws Exception {\n  final String topicName=\"persistent://prop/use/ns-abc/testChecksumBackwardsCompatibilityWithOldBrokerWithoutChecksumHandling\";\n  if (mixedVersionScenario == MixedVersionScenario.CONNECTED_TO_OLD_THEN_NEW_VERSION) {\n    makeClientAssumeThatItsConnectedToBrokerWithoutChecksumSupport();\n  }\n  PulsarTestClient pulsarTestClient=(PulsarTestClient)pulsarClient;\n  ProducerImpl<byte[]> producer=(ProducerImpl<byte[]>)pulsarClient.newProducer().topic(topicName).enableBatching(false).messageRoutingMode(MessageRoutingMode.SinglePartition).create();\n  Consumer<byte[]> consumer=pulsarClient.newConsumer().topic(topicName).subscriptionName(\"my-sub\").subscribe();\n  CountDownLatch messageSendingProcessedLatch=new CountDownLatch(2);\n  producer.send(\"message-1\".getBytes());\n  pulsarTestClient.dropOpSendMessages();\n  byte[] messageBytes=\"message-2\".getBytes();\n  TypedMessageBuilder<byte[]> messageBuilder=producer.newMessage().value(messageBytes);\n  CompletableFuture<MessageId> tamperedMessageSendFuture=messageBuilder.sendAsync();\n  pulsarTestClient.setPendingMessageCallback(null);\n  pulsarTestClient.disconnectProducerAndRejectReconnecting(producer);\n  ((TypedMessageBuilderImpl<byte[]>)messageBuilder).getContent().put(messageBytes.length - 1,(byte)'3');\n  if (mixedVersionScenario == MixedVersionScenario.CONNECTED_TO_NEW_THEN_OLD_VERSION) {\n    makeClientAssumeThatItsConnectedToBrokerWithoutChecksumSupport();\n  }\n else {\n    resetOverridingConnectedBrokerVersion();\n  }\n  pulsarTestClient.allowReconnecting();\n  try {\n    tamperedMessageSendFuture.get(10,TimeUnit.SECONDS);\n  }\n catch (  Exception e) {\n    fail(\"Broker shouldn't verify checksum for corrupted message and it shouldn't fail\",e);\n  }\n  Message<byte[]> msg=consumer.receive(1,TimeUnit.SECONDS);\n  assertEquals(new String(msg.getData()),\"message-1\");\n  msg=consumer.receive(1,TimeUnit.SECONDS);\n  assertEquals(new String(msg.getData()),\"message-3\");\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 272,
      "astHeight" : 11
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 184,
        "startColumnNumber" : 12,
        "endLineNumber" : 184,
        "endColumnNumber" : 64
      },
      "nodeContext" : "tamperedMessageSendFuture.get(10,TimeUnit.SECONDS);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.util.concurrent.CompletableFuture<org.apache.pulsar.client.api.MessageId>"
  } ],
  "positionList" : [ {
    "charLength" : 25,
    "startLineNumber" : 184,
    "startColumnNumber" : 12,
    "endLineNumber" : 184,
    "endColumnNumber" : 37
  } ],
  "layoutRelationDataList" : [ ]
}