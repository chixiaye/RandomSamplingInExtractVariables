{
  "id" : 487,
  "expression" : "records.get(0).offset()",
  "projectName" : "apache@kafka",
  "commitID" : "539f006e65d9060cd46a4052d1b70f2312d8ca34",
  "filePath" : "/clients/src/main/java/org/apache/kafka/common/record/RecordsUtil.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "records.get(0).offset()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 23,
      "startLineNumber" : 75,
      "startColumnNumber" : 33,
      "endLineNumber" : 75,
      "endColumnNumber" : 56
    },
    "astNodeNumber" : 6,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 36,
        "startLineNumber" : 75,
        "startColumnNumber" : 20,
        "endLineNumber" : 75,
        "endColumnNumber" : 56
      },
      "nodeContext" : "baseOffset=records.get(0).offset()",
      "nodeType" : "Assignment",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 75,
        "startColumnNumber" : 20,
        "endLineNumber" : 75,
        "endColumnNumber" : 57
      },
      "nodeContext" : "baseOffset=records.get(0).offset();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 221,
        "startLineNumber" : 72,
        "startColumnNumber" : 16,
        "endLineNumber" : 75,
        "endColumnNumber" : 57
      },
      "nodeContext" : "if (batch.magic() >= RecordBatch.MAGIC_VALUE_V2 && toMagic >= RecordBatch.MAGIC_VALUE_V2) baseOffset=batch.baseOffset();\n else baseOffset=records.get(0).offset();\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 29,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 944,
        "startLineNumber" : 62,
        "startColumnNumber" : 19,
        "endLineNumber" : 78,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  List<Record> records=new ArrayList<>();\n  for (  Record record : batch) {\n    if (toMagic > RecordBatch.MAGIC_VALUE_V1 || batch.isCompressed() || record.offset() >= firstOffset)     records.add(record);\n  }\n  if (records.isEmpty())   continue;\n  final long baseOffset;\n  if (batch.magic() >= RecordBatch.MAGIC_VALUE_V2 && toMagic >= RecordBatch.MAGIC_VALUE_V2)   baseOffset=batch.baseOffset();\n else   baseOffset=records.get(0).offset();\n  totalSizeEstimate+=AbstractRecords.estimateSizeInBytes(toMagic,baseOffset,batch.compressionType(),records);\n  recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,records,baseOffset));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 102,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1146,
        "startLineNumber" : 59,
        "startColumnNumber" : 12,
        "endLineNumber" : 78,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (batch.magic() <= toMagic) {\n  totalSizeEstimate+=batch.sizeInBytes();\n  recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,null,null));\n}\n else {\n  List<Record> records=new ArrayList<>();\n  for (  Record record : batch) {\n    if (toMagic > RecordBatch.MAGIC_VALUE_V1 || batch.isCompressed() || record.offset() >= firstOffset)     records.add(record);\n  }\n  if (records.isEmpty())   continue;\n  final long baseOffset;\n  if (batch.magic() >= RecordBatch.MAGIC_VALUE_V2 && toMagic >= RecordBatch.MAGIC_VALUE_V2)   baseOffset=batch.baseOffset();\n else   baseOffset=records.get(0).offset();\n  totalSizeEstimate+=AbstractRecords.estimateSizeInBytes(toMagic,baseOffset,batch.compressionType(),records);\n  recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,records,baseOffset));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 125,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,body]",
      "nodePosition" : {
        "charLength" : 1549,
        "startLineNumber" : 49,
        "startColumnNumber" : 42,
        "endLineNumber" : 79,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  if (toMagic < RecordBatch.MAGIC_VALUE_V2) {\n    if (batch.isControlBatch())     continue;\n    if (batch.compressionType() == CompressionType.ZSTD)     throw new UnsupportedCompressionTypeException(\"Down-conversion of zstandard-compressed batches \" + \"is not supported\");\n  }\n  if (batch.magic() <= toMagic) {\n    totalSizeEstimate+=batch.sizeInBytes();\n    recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,null,null));\n  }\n else {\n    List<Record> records=new ArrayList<>();\n    for (    Record record : batch) {\n      if (toMagic > RecordBatch.MAGIC_VALUE_V1 || batch.isCompressed() || record.offset() >= firstOffset)       records.add(record);\n    }\n    if (records.isEmpty())     continue;\n    final long baseOffset;\n    if (batch.magic() >= RecordBatch.MAGIC_VALUE_V2 && toMagic >= RecordBatch.MAGIC_VALUE_V2)     baseOffset=batch.baseOffset();\n else     baseOffset=records.get(0).offset();\n    totalSizeEstimate+=AbstractRecords.estimateSizeInBytes(toMagic,baseOffset,batch.compressionType(),records);\n    recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,records,baseOffset));\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 153,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1583,
        "startLineNumber" : 49,
        "startColumnNumber" : 8,
        "endLineNumber" : 79,
        "endColumnNumber" : 9
      },
      "nodeContext" : "for (RecordBatch batch : batches) {\n  if (toMagic < RecordBatch.MAGIC_VALUE_V2) {\n    if (batch.isControlBatch())     continue;\n    if (batch.compressionType() == CompressionType.ZSTD)     throw new UnsupportedCompressionTypeException(\"Down-conversion of zstandard-compressed batches \" + \"is not supported\");\n  }\n  if (batch.magic() <= toMagic) {\n    totalSizeEstimate+=batch.sizeInBytes();\n    recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,null,null));\n  }\n else {\n    List<Record> records=new ArrayList<>();\n    for (    Record record : batch) {\n      if (toMagic > RecordBatch.MAGIC_VALUE_V1 || batch.isCompressed() || record.offset() >= firstOffset)       records.add(record);\n    }\n    if (records.isEmpty())     continue;\n    final long baseOffset;\n    if (batch.magic() >= RecordBatch.MAGIC_VALUE_V2 && toMagic >= RecordBatch.MAGIC_VALUE_V2)     baseOffset=batch.baseOffset();\n else     baseOffset=records.get(0).offset();\n    totalSizeEstimate+=AbstractRecords.estimateSizeInBytes(toMagic,baseOffset,batch.compressionType(),records);\n    recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,records,baseOffset));\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 159,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3024,
        "startLineNumber" : 43,
        "startColumnNumber" : 94,
        "endLineNumber" : 102,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  List<RecordBatchAndRecords> recordBatchAndRecordsList=new ArrayList<>();\n  int totalSizeEstimate=0;\n  long startNanos=time.nanoseconds();\n  for (  RecordBatch batch : batches) {\n    if (toMagic < RecordBatch.MAGIC_VALUE_V2) {\n      if (batch.isControlBatch())       continue;\n      if (batch.compressionType() == CompressionType.ZSTD)       throw new UnsupportedCompressionTypeException(\"Down-conversion of zstandard-compressed batches \" + \"is not supported\");\n    }\n    if (batch.magic() <= toMagic) {\n      totalSizeEstimate+=batch.sizeInBytes();\n      recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,null,null));\n    }\n else {\n      List<Record> records=new ArrayList<>();\n      for (      Record record : batch) {\n        if (toMagic > RecordBatch.MAGIC_VALUE_V1 || batch.isCompressed() || record.offset() >= firstOffset)         records.add(record);\n      }\n      if (records.isEmpty())       continue;\n      final long baseOffset;\n      if (batch.magic() >= RecordBatch.MAGIC_VALUE_V2 && toMagic >= RecordBatch.MAGIC_VALUE_V2)       baseOffset=batch.baseOffset();\n else       baseOffset=records.get(0).offset();\n      totalSizeEstimate+=AbstractRecords.estimateSizeInBytes(toMagic,baseOffset,batch.compressionType(),records);\n      recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,records,baseOffset));\n    }\n  }\n  ByteBuffer buffer=ByteBuffer.allocate(totalSizeEstimate);\n  long temporaryMemoryBytes=0;\n  int numRecordsConverted=0;\n  for (  RecordBatchAndRecords recordBatchAndRecords : recordBatchAndRecordsList) {\n    temporaryMemoryBytes+=recordBatchAndRecords.batch.sizeInBytes();\n    if (recordBatchAndRecords.batch.magic() <= toMagic) {\n      buffer=Utils.ensureCapacity(buffer,buffer.position() + recordBatchAndRecords.batch.sizeInBytes());\n      recordBatchAndRecords.batch.writeTo(buffer);\n    }\n else {\n      MemoryRecordsBuilder builder=convertRecordBatch(toMagic,buffer,recordBatchAndRecords);\n      buffer=builder.buffer();\n      temporaryMemoryBytes+=builder.uncompressedBytesWritten();\n      numRecordsConverted+=builder.numRecords();\n    }\n  }\n  buffer.flip();\n  RecordConversionStats stats=new RecordConversionStats(temporaryMemoryBytes,numRecordsConverted,time.nanoseconds() - startNanos);\n  return new ConvertedRecords<>(MemoryRecords.readableRecords(buffer),stats);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 308,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4254,
        "startLineNumber" : 28,
        "startColumnNumber" : 4,
        "endLineNumber" : 102,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Down convert batches to the provided message format version. The first offset parameter is only relevant in the conversion from uncompressed v2 or higher to v1 or lower. The reason is that uncompressed records in v0 and v1 are not batched (put another way, each batch always has 1 record). If a client requests records in v1 format starting from the middle of an uncompressed batch in v2 format, we need to drop records from the batch during the conversion. Some versions of librdkafka rely on this for correctness. The temporaryMemoryBytes computation assumes that the batches are not loaded into the heap (via classes like FileChannelRecordBatch) before this method is called. This is the case in the broker (we only load records into the heap when down converting), but it's not for the producer. However, down converting in the producer is very uncommon and the extra complexity to handle that case is not worth it.\n */\nprotected static ConvertedRecords<MemoryRecords> downConvert(Iterable<? extends RecordBatch> batches,byte toMagic,long firstOffset,Time time){\n  List<RecordBatchAndRecords> recordBatchAndRecordsList=new ArrayList<>();\n  int totalSizeEstimate=0;\n  long startNanos=time.nanoseconds();\n  for (  RecordBatch batch : batches) {\n    if (toMagic < RecordBatch.MAGIC_VALUE_V2) {\n      if (batch.isControlBatch())       continue;\n      if (batch.compressionType() == CompressionType.ZSTD)       throw new UnsupportedCompressionTypeException(\"Down-conversion of zstandard-compressed batches \" + \"is not supported\");\n    }\n    if (batch.magic() <= toMagic) {\n      totalSizeEstimate+=batch.sizeInBytes();\n      recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,null,null));\n    }\n else {\n      List<Record> records=new ArrayList<>();\n      for (      Record record : batch) {\n        if (toMagic > RecordBatch.MAGIC_VALUE_V1 || batch.isCompressed() || record.offset() >= firstOffset)         records.add(record);\n      }\n      if (records.isEmpty())       continue;\n      final long baseOffset;\n      if (batch.magic() >= RecordBatch.MAGIC_VALUE_V2 && toMagic >= RecordBatch.MAGIC_VALUE_V2)       baseOffset=batch.baseOffset();\n else       baseOffset=records.get(0).offset();\n      totalSizeEstimate+=AbstractRecords.estimateSizeInBytes(toMagic,baseOffset,batch.compressionType(),records);\n      recordBatchAndRecordsList.add(new RecordBatchAndRecords(batch,records,baseOffset));\n    }\n  }\n  ByteBuffer buffer=ByteBuffer.allocate(totalSizeEstimate);\n  long temporaryMemoryBytes=0;\n  int numRecordsConverted=0;\n  for (  RecordBatchAndRecords recordBatchAndRecords : recordBatchAndRecordsList) {\n    temporaryMemoryBytes+=recordBatchAndRecords.batch.sizeInBytes();\n    if (recordBatchAndRecords.batch.magic() <= toMagic) {\n      buffer=Utils.ensureCapacity(buffer,buffer.position() + recordBatchAndRecords.batch.sizeInBytes());\n      recordBatchAndRecords.batch.writeTo(buffer);\n    }\n else {\n      MemoryRecordsBuilder builder=convertRecordBatch(toMagic,buffer,recordBatchAndRecords);\n      buffer=builder.buffer();\n      temporaryMemoryBytes+=builder.uncompressedBytesWritten();\n      numRecordsConverted+=builder.numRecords();\n    }\n  }\n  buffer.flip();\n  RecordConversionStats stats=new RecordConversionStats(temporaryMemoryBytes,numRecordsConverted,time.nanoseconds() - startNanos);\n  return new ConvertedRecords<>(MemoryRecords.readableRecords(buffer),stats);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 336,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 75,
        "startColumnNumber" : 20,
        "endLineNumber" : 75,
        "endColumnNumber" : 57
      },
      "nodeContext" : "baseOffset=records.get(0).offset();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 9,
      "astHeight" : 5
    },
    "tokenLength" : 4,
    "type" : "long"
  } ],
  "positionList" : [ {
    "charLength" : 23,
    "startLineNumber" : 75,
    "startColumnNumber" : 33,
    "endLineNumber" : 75,
    "endColumnNumber" : 56
  } ],
  "layoutRelationDataList" : [ ]
}