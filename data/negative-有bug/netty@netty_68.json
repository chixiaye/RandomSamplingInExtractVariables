{
  "id" : 68,
  "expression" : "index - offset",
  "projectName" : "netty@netty",
  "commitID" : "8a68c3e58d4663ae42e41a90d0d11aec3c25016b",
  "filePath" : "/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "index - offset",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 14,
      "startLineNumber" : 224,
      "startColumnNumber" : 70,
      "endLineNumber" : 224,
      "endColumnNumber" : 84
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 55,
        "startLineNumber" : 224,
        "startColumnNumber" : 39,
        "endLineNumber" : 224,
        "endColumnNumber" : 94
      },
      "nodeContext" : "new String(valueBytes,offset,index - offset,\"UTF-8\")",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 9,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 63,
        "startLineNumber" : 224,
        "startColumnNumber" : 31,
        "endLineNumber" : 224,
        "endColumnNumber" : 94
      },
      "nodeContext" : "value=new String(valueBytes,offset,index - offset,\"UTF-8\")",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 224,
        "startColumnNumber" : 24,
        "endLineNumber" : 224,
        "endColumnNumber" : 95
      },
      "nodeContext" : "String value=new String(valueBytes,offset,index - offset,\"UTF-8\");\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 1437,
        "startLineNumber" : 209,
        "startColumnNumber" : 43,
        "endLineNumber" : 236,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  while (index < valueBytes.length && valueBytes[index] != (byte)0) {\n    index++;\n  }\n  if (index < valueBytes.length) {\n    if (index + 1 == valueBytes.length || valueBytes[index + 1] == (byte)0) {\n      state=State.ERROR;\n      frame.setInvalid();\n      break;\n    }\n  }\n  String value=new String(valueBytes,offset,index - offset,\"UTF-8\");\n  try {\n    frame.headers().add(name,value);\n  }\n catch (  IllegalArgumentException e) {\n    state=State.ERROR;\n    frame.setInvalid();\n    break;\n  }\n  index++;\n  offset=index;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 104,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 1460,
        "startLineNumber" : 209,
        "startColumnNumber" : 20,
        "endLineNumber" : 236,
        "endColumnNumber" : 21
      },
      "nodeContext" : "while (index < length) {\n  while (index < valueBytes.length && valueBytes[index] != (byte)0) {\n    index++;\n  }\n  if (index < valueBytes.length) {\n    if (index + 1 == valueBytes.length || valueBytes[index + 1] == (byte)0) {\n      state=State.ERROR;\n      frame.setInvalid();\n      break;\n    }\n  }\n  String value=new String(valueBytes,offset,index - offset,\"UTF-8\");\n  try {\n    frame.headers().add(name,value);\n  }\n catch (  IllegalArgumentException e) {\n    state=State.ERROR;\n    frame.setInvalid();\n    break;\n  }\n  index++;\n  offset=index;\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 108,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7580,
        "startLineNumber" : 88,
        "startColumnNumber" : 12,
        "endLineNumber" : 277,
        "endColumnNumber" : 13
      },
      "nodeContext" : "switch (state) {\ncase READ_NUM_HEADERS:  if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\n    return;\n  }\nnumHeaders=readLengthField(headerBlock);\nif (numHeaders < 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\nbreak;\ncase READ_NAME_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length <= 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nstate=State.SKIP_NAME;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_NAME;\n}\nbreak;\ncase READ_NAME:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] nameBytes=new byte[length];\nheaderBlock.readBytes(nameBytes);\nname=new String(nameBytes,\"UTF-8\");\nif (frame.headers().contains(name)) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase SKIP_NAME:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase READ_VALUE_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length < 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length == 0) {\nif (!frame.isTruncated()) {\nframe.headers().add(name,\"\");\n}\nname=null;\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nname=null;\nstate=State.SKIP_VALUE;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_VALUE;\n}\nbreak;\ncase READ_VALUE:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] valueBytes=new byte[length];\nheaderBlock.readBytes(valueBytes);\nint index=0;\nint offset=0;\nif (valueBytes[0] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nwhile (index < length) {\nwhile (index < valueBytes.length && valueBytes[index] != (byte)0) {\nindex++;\n}\nif (index < valueBytes.length) {\nif (index + 1 == valueBytes.length || valueBytes[index + 1] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\n}\nString value=new String(valueBytes,offset,index - offset,\"UTF-8\");\ntry {\nframe.headers().add(name,value);\n}\n catch (IllegalArgumentException e) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nindex++;\noffset=index;\n}\nname=null;\nif (state == State.ERROR) {\nbreak;\n}\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\nbreak;\ncase SKIP_VALUE:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\nbreak;\ncase END_HEADER_BLOCK:state=State.ERROR;\nframe.setInvalid();\nbreak;\ncase ERROR:headerBlock.skipBytes(headerBlock.readableBytes());\nreturn;\ndefault:throw new Error(\"Shouldn't reach here.\");\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 602,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 7606,
        "startLineNumber" : 87,
        "startColumnNumber" : 41,
        "endLineNumber" : 278,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\nswitch (state) {\ncase READ_NUM_HEADERS:    if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\n      return;\n    }\n  numHeaders=readLengthField(headerBlock);\nif (numHeaders < 0) {\n  state=State.ERROR;\n  frame.setInvalid();\n}\n else if (numHeaders == 0) {\n  state=State.END_HEADER_BLOCK;\n}\n else {\n  state=State.READ_NAME_LENGTH;\n}\nbreak;\ncase READ_NAME_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length <= 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nstate=State.SKIP_NAME;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_NAME;\n}\nbreak;\ncase READ_NAME:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] nameBytes=new byte[length];\nheaderBlock.readBytes(nameBytes);\nname=new String(nameBytes,\"UTF-8\");\nif (frame.headers().contains(name)) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase SKIP_NAME:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase READ_VALUE_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length < 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length == 0) {\nif (!frame.isTruncated()) {\nframe.headers().add(name,\"\");\n}\nname=null;\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nname=null;\nstate=State.SKIP_VALUE;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_VALUE;\n}\nbreak;\ncase READ_VALUE:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] valueBytes=new byte[length];\nheaderBlock.readBytes(valueBytes);\nint index=0;\nint offset=0;\nif (valueBytes[0] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nwhile (index < length) {\nwhile (index < valueBytes.length && valueBytes[index] != (byte)0) {\nindex++;\n}\nif (index < valueBytes.length) {\nif (index + 1 == valueBytes.length || valueBytes[index + 1] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\n}\nString value=new String(valueBytes,offset,index - offset,\"UTF-8\");\ntry {\nframe.headers().add(name,value);\n}\n catch (IllegalArgumentException e) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nindex++;\noffset=index;\n}\nname=null;\nif (state == State.ERROR) {\nbreak;\n}\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\nbreak;\ncase SKIP_VALUE:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\nbreak;\ncase END_HEADER_BLOCK:state=State.ERROR;\nframe.setInvalid();\nbreak;\ncase ERROR:headerBlock.skipBytes(headerBlock.readableBytes());\nreturn;\ndefault:throw new Error(\"Shouldn't reach here.\");\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 603,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7639,
        "startLineNumber" : 87,
        "startColumnNumber" : 8,
        "endLineNumber" : 278,
        "endColumnNumber" : 9
      },
      "nodeContext" : "while (headerBlock.isReadable()) {\nswitch (state) {\ncase READ_NUM_HEADERS:    if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\n      return;\n    }\n  numHeaders=readLengthField(headerBlock);\nif (numHeaders < 0) {\n  state=State.ERROR;\n  frame.setInvalid();\n}\n else if (numHeaders == 0) {\n  state=State.END_HEADER_BLOCK;\n}\n else {\n  state=State.READ_NAME_LENGTH;\n}\nbreak;\ncase READ_NAME_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length <= 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nstate=State.SKIP_NAME;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_NAME;\n}\nbreak;\ncase READ_NAME:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] nameBytes=new byte[length];\nheaderBlock.readBytes(nameBytes);\nname=new String(nameBytes,\"UTF-8\");\nif (frame.headers().contains(name)) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase SKIP_NAME:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase READ_VALUE_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length < 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length == 0) {\nif (!frame.isTruncated()) {\nframe.headers().add(name,\"\");\n}\nname=null;\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nname=null;\nstate=State.SKIP_VALUE;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_VALUE;\n}\nbreak;\ncase READ_VALUE:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] valueBytes=new byte[length];\nheaderBlock.readBytes(valueBytes);\nint index=0;\nint offset=0;\nif (valueBytes[0] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nwhile (index < length) {\nwhile (index < valueBytes.length && valueBytes[index] != (byte)0) {\nindex++;\n}\nif (index < valueBytes.length) {\nif (index + 1 == valueBytes.length || valueBytes[index + 1] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\n}\nString value=new String(valueBytes,offset,index - offset,\"UTF-8\");\ntry {\nframe.headers().add(name,value);\n}\n catch (IllegalArgumentException e) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nindex++;\noffset=index;\n}\nname=null;\nif (state == State.ERROR) {\nbreak;\n}\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\nbreak;\ncase SKIP_VALUE:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\nbreak;\ncase END_HEADER_BLOCK:state=State.ERROR;\nframe.setInvalid();\nbreak;\ncase ERROR:headerBlock.skipBytes(headerBlock.readableBytes());\nreturn;\ndefault:throw new Error(\"Shouldn't reach here.\");\n}\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 607,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7682,
        "startLineNumber" : 85,
        "startColumnNumber" : 99,
        "endLineNumber" : 279,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  int skipLength;\n  while (headerBlock.isReadable()) {\nswitch (state) {\ncase READ_NUM_HEADERS:      if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\n        return;\n      }\n    numHeaders=readLengthField(headerBlock);\n  if (numHeaders < 0) {\n    state=State.ERROR;\n    frame.setInvalid();\n  }\n else   if (numHeaders == 0) {\n    state=State.END_HEADER_BLOCK;\n  }\n else {\n    state=State.READ_NAME_LENGTH;\n  }\nbreak;\ncase READ_NAME_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length <= 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nstate=State.SKIP_NAME;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_NAME;\n}\nbreak;\ncase READ_NAME:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] nameBytes=new byte[length];\nheaderBlock.readBytes(nameBytes);\nname=new String(nameBytes,\"UTF-8\");\nif (frame.headers().contains(name)) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase SKIP_NAME:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase READ_VALUE_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length < 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length == 0) {\nif (!frame.isTruncated()) {\nframe.headers().add(name,\"\");\n}\nname=null;\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nname=null;\nstate=State.SKIP_VALUE;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_VALUE;\n}\nbreak;\ncase READ_VALUE:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] valueBytes=new byte[length];\nheaderBlock.readBytes(valueBytes);\nint index=0;\nint offset=0;\nif (valueBytes[0] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nwhile (index < length) {\nwhile (index < valueBytes.length && valueBytes[index] != (byte)0) {\nindex++;\n}\nif (index < valueBytes.length) {\nif (index + 1 == valueBytes.length || valueBytes[index + 1] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\n}\nString value=new String(valueBytes,offset,index - offset,\"UTF-8\");\ntry {\nframe.headers().add(name,value);\n}\n catch (IllegalArgumentException e) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nindex++;\noffset=index;\n}\nname=null;\nif (state == State.ERROR) {\nbreak;\n}\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\nbreak;\ncase SKIP_VALUE:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\nbreak;\ncase END_HEADER_BLOCK:state=State.ERROR;\nframe.setInvalid();\nbreak;\ncase ERROR:headerBlock.skipBytes(headerBlock.readableBytes());\nreturn;\ndefault:throw new Error(\"Shouldn't reach here.\");\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 612,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7777,
        "startLineNumber" : 85,
        "startColumnNumber" : 4,
        "endLineNumber" : 279,
        "endColumnNumber" : 5
      },
      "nodeContext" : "protected void decodeHeaderBlock(ByteBuf headerBlock,SpdyHeadersFrame frame) throws Exception {\n  int skipLength;\n  while (headerBlock.isReadable()) {\nswitch (state) {\ncase READ_NUM_HEADERS:      if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\n        return;\n      }\n    numHeaders=readLengthField(headerBlock);\n  if (numHeaders < 0) {\n    state=State.ERROR;\n    frame.setInvalid();\n  }\n else   if (numHeaders == 0) {\n    state=State.END_HEADER_BLOCK;\n  }\n else {\n    state=State.READ_NAME_LENGTH;\n  }\nbreak;\ncase READ_NAME_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length <= 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nstate=State.SKIP_NAME;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_NAME;\n}\nbreak;\ncase READ_NAME:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] nameBytes=new byte[length];\nheaderBlock.readBytes(nameBytes);\nname=new String(nameBytes,\"UTF-8\");\nif (frame.headers().contains(name)) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase SKIP_NAME:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nstate=State.READ_VALUE_LENGTH;\n}\nbreak;\ncase READ_VALUE_LENGTH:if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {\nreturn;\n}\nlength=readLengthField(headerBlock);\nif (length < 0) {\nstate=State.ERROR;\nframe.setInvalid();\n}\n else if (length == 0) {\nif (!frame.isTruncated()) {\nframe.headers().add(name,\"\");\n}\nname=null;\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\n else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {\nheaderSize=maxHeaderSize + 1;\nname=null;\nstate=State.SKIP_VALUE;\nframe.setTruncated();\n}\n else {\nheaderSize+=length;\nstate=State.READ_VALUE;\n}\nbreak;\ncase READ_VALUE:if (headerBlock.readableBytes() < length) {\nreturn;\n}\nbyte[] valueBytes=new byte[length];\nheaderBlock.readBytes(valueBytes);\nint index=0;\nint offset=0;\nif (valueBytes[0] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nwhile (index < length) {\nwhile (index < valueBytes.length && valueBytes[index] != (byte)0) {\nindex++;\n}\nif (index < valueBytes.length) {\nif (index + 1 == valueBytes.length || valueBytes[index + 1] == (byte)0) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\n}\nString value=new String(valueBytes,offset,index - offset,\"UTF-8\");\ntry {\nframe.headers().add(name,value);\n}\n catch (IllegalArgumentException e) {\nstate=State.ERROR;\nframe.setInvalid();\nbreak;\n}\nindex++;\noffset=index;\n}\nname=null;\nif (state == State.ERROR) {\nbreak;\n}\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\nbreak;\ncase SKIP_VALUE:skipLength=Math.min(headerBlock.readableBytes(),length);\nheaderBlock.skipBytes(skipLength);\nlength-=skipLength;\nif (length == 0) {\nif (--numHeaders == 0) {\nstate=State.END_HEADER_BLOCK;\n}\n else {\nstate=State.READ_NAME_LENGTH;\n}\n}\nbreak;\ncase END_HEADER_BLOCK:state=State.ERROR;\nframe.setInvalid();\nbreak;\ncase ERROR:headerBlock.skipBytes(headerBlock.readableBytes());\nreturn;\ndefault:throw new Error(\"Shouldn't reach here.\");\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 626,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 224,
        "startColumnNumber" : 24,
        "endLineNumber" : 224,
        "endColumnNumber" : 95
      },
      "nodeContext" : "String value=new String(valueBytes,offset,index - offset,\"UTF-8\");\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 14,
      "astHeight" : 5
    },
    "tokenLength" : 3,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 14,
    "startLineNumber" : 224,
    "startColumnNumber" : 70,
    "endLineNumber" : 224,
    "endColumnNumber" : 84
  } ],
  "layoutRelationDataList" : [ ]
}