{
  "id" : 111,
  "expression" : "networkFailures.isEmpty()",
  "projectName" : "signalapp@Signal-Android",
  "commitID" : "7e91132e7ed62a58b5f347de252ab1eda3f43b90",
  "filePath" : "/app/src/main/java/org/thoughtcrime/securesms/jobs/PushGroupSendJob.java",
  "occurrences" : 3,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "networkFailures.isEmpty()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 219,
      "startColumnNumber" : 11,
      "endLineNumber" : 219,
      "endColumnNumber" : 36
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 219,
        "startColumnNumber" : 10,
        "endLineNumber" : 219,
        "endColumnNumber" : 36
      },
      "nodeContext" : "!networkFailures.isEmpty()",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 99,
        "startLineNumber" : 219,
        "startColumnNumber" : 6,
        "endLineNumber" : 221,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (!networkFailures.isEmpty()) {\n  database.addFailures(messageId,networkFailures);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5440,
        "startLineNumber" : 176,
        "startColumnNumber" : 8,
        "endLineNumber" : 259,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n  if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n    RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n  }\n  List<Recipient> target;\n  if (filterRecipient != null)   target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else   if (!existingNetworkFailures.isEmpty())   target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else   target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n  RecipientAccessList accessList=new RecipientAccessList(target);\n  List<SendMessageResult> results=deliver(message,groupRecipient,target);\n  Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n  List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n  List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n  ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n  List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n  List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n  Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n  List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n  RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n  for (  Recipient unregistered : unregisteredRecipients) {\n    recipientDatabase.markUnregistered(unregistered.getId());\n  }\n  for (  NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n    database.removeFailure(messageId,resolvedFailure);\n    existingNetworkFailures.remove(resolvedFailure);\n  }\n  for (  IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n    database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n    existingIdentityMismatches.remove(resolvedIdentity);\n  }\n  if (!networkFailures.isEmpty()) {\n    database.addFailures(messageId,networkFailures);\n  }\n  for (  IdentityKeyMismatch mismatch : identityMismatches) {\n    database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n  }\n  DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n  if (proofRequired != null) {\n    handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n  }\n  if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n    database.markAsSent(messageId,true);\n    markAttachmentsUploaded(messageId,message);\n    if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n      database.markExpireStarted(messageId);\n      ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n    }\n    if (message.isViewOnce()) {\n      DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n    }\n  }\n else   if (!networkFailures.isEmpty()) {\n    throw new RetryLaterException();\n  }\n else   if (!identityMismatches.isEmpty()) {\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n    Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n    RetrieveProfileJob.enqueue(mismatchRecipientIds);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 652,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5690,
        "startLineNumber" : 176,
        "startColumnNumber" : 4,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "try {\n  log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n  if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n    RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n  }\n  List<Recipient> target;\n  if (filterRecipient != null)   target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else   if (!existingNetworkFailures.isEmpty())   target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else   target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n  RecipientAccessList accessList=new RecipientAccessList(target);\n  List<SendMessageResult> results=deliver(message,groupRecipient,target);\n  Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n  List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n  List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n  ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n  List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n  List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n  Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n  List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n  RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n  for (  Recipient unregistered : unregisteredRecipients) {\n    recipientDatabase.markUnregistered(unregistered.getId());\n  }\n  for (  NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n    database.removeFailure(messageId,resolvedFailure);\n    existingNetworkFailures.remove(resolvedFailure);\n  }\n  for (  IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n    database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n    existingIdentityMismatches.remove(resolvedIdentity);\n  }\n  if (!networkFailures.isEmpty()) {\n    database.addFailures(messageId,networkFailures);\n  }\n  for (  IdentityKeyMismatch mismatch : identityMismatches) {\n    database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n  }\n  DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n  if (proofRequired != null) {\n    handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n  }\n  if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n    database.markAsSent(messageId,true);\n    markAttachmentsUploaded(messageId,message);\n    if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n      database.markExpireStarted(messageId);\n      ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n    }\n    if (message.isViewOnce()) {\n      DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n    }\n  }\n else   if (!networkFailures.isEmpty()) {\n    throw new RetryLaterException();\n  }\n else   if (!identityMismatches.isEmpty()) {\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n    Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n    RetrieveProfileJob.enqueue(mismatchRecipientIds);\n  }\n}\n catch (UntrustedIdentityException|UndeliverableMessageException e) {\n  warn(TAG,String.valueOf(message.getSentTimeMillis()),e);\n  database.markAsSentFailed(messageId);\n  notifyMediaMessageDeliveryFailed(context,messageId);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 683,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6902,
        "startLineNumber" : 150,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  SignalLocalMetrics.GroupMessageSend.onJobStarted(messageId);\n  MessageDatabase database=DatabaseFactory.getMmsDatabase(context);\n  OutgoingMediaMessage message=database.getOutgoingMessage(messageId);\n  long threadId=database.getMessageRecord(messageId).getThreadId();\n  List<NetworkFailure> existingNetworkFailures=message.getNetworkFailures();\n  List<IdentityKeyMismatch> existingIdentityMismatches=message.getIdentityKeyMismatches();\n  ApplicationDependencies.getJobManager().cancelAllInQueue(TypingSendJob.getQueue(threadId));\n  if (database.isSent(messageId)) {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Message \" + messageId + \" was already sent. Ignoring.\");\n    return;\n  }\n  Recipient groupRecipient=message.getRecipient().resolve();\n  if (!groupRecipient.isPushGroup()) {\n    throw new MmsException(\"Message recipient isn't a group!\");\n  }\n  if (groupRecipient.isPushV1Group()) {\n    throw new MmsException(\"No GV1 messages can be sent anymore!\");\n  }\n  try {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n    if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n      RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n    }\n    List<Recipient> target;\n    if (filterRecipient != null)     target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else     if (!existingNetworkFailures.isEmpty())     target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else     target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n    RecipientAccessList accessList=new RecipientAccessList(target);\n    List<SendMessageResult> results=deliver(message,groupRecipient,target);\n    Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n    List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n    List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n    ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n    List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n    List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n    Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n    List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n    RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n    for (    Recipient unregistered : unregisteredRecipients) {\n      recipientDatabase.markUnregistered(unregistered.getId());\n    }\n    for (    NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n      database.removeFailure(messageId,resolvedFailure);\n      existingNetworkFailures.remove(resolvedFailure);\n    }\n    for (    IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n      database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n      existingIdentityMismatches.remove(resolvedIdentity);\n    }\n    if (!networkFailures.isEmpty()) {\n      database.addFailures(messageId,networkFailures);\n    }\n    for (    IdentityKeyMismatch mismatch : identityMismatches) {\n      database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n    }\n    DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n    if (proofRequired != null) {\n      handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n    }\n    if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n      database.markAsSent(messageId,true);\n      markAttachmentsUploaded(messageId,message);\n      if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n        database.markExpireStarted(messageId);\n        ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n      }\n      if (message.isViewOnce()) {\n        DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n      }\n    }\n else     if (!networkFailures.isEmpty()) {\n      throw new RetryLaterException();\n    }\n else     if (!identityMismatches.isEmpty()) {\n      database.markAsSentFailed(messageId);\n      notifyMediaMessageDeliveryFailed(context,messageId);\n      Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n      RetrieveProfileJob.enqueue(mismatchRecipientIds);\n    }\n  }\n catch (  UntrustedIdentityException|UndeliverableMessageException e) {\n    warn(TAG,String.valueOf(message.getSentTimeMillis()),e);\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n  }\n  SignalLocalMetrics.GroupMessageSend.onJobFinished(messageId);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 810,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7025,
        "startLineNumber" : 147,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@Override public void onPushSend() throws IOException, MmsException, NoSuchMessageException, RetryLaterException {\n  SignalLocalMetrics.GroupMessageSend.onJobStarted(messageId);\n  MessageDatabase database=DatabaseFactory.getMmsDatabase(context);\n  OutgoingMediaMessage message=database.getOutgoingMessage(messageId);\n  long threadId=database.getMessageRecord(messageId).getThreadId();\n  List<NetworkFailure> existingNetworkFailures=message.getNetworkFailures();\n  List<IdentityKeyMismatch> existingIdentityMismatches=message.getIdentityKeyMismatches();\n  ApplicationDependencies.getJobManager().cancelAllInQueue(TypingSendJob.getQueue(threadId));\n  if (database.isSent(messageId)) {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Message \" + messageId + \" was already sent. Ignoring.\");\n    return;\n  }\n  Recipient groupRecipient=message.getRecipient().resolve();\n  if (!groupRecipient.isPushGroup()) {\n    throw new MmsException(\"Message recipient isn't a group!\");\n  }\n  if (groupRecipient.isPushV1Group()) {\n    throw new MmsException(\"No GV1 messages can be sent anymore!\");\n  }\n  try {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n    if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n      RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n    }\n    List<Recipient> target;\n    if (filterRecipient != null)     target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else     if (!existingNetworkFailures.isEmpty())     target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else     target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n    RecipientAccessList accessList=new RecipientAccessList(target);\n    List<SendMessageResult> results=deliver(message,groupRecipient,target);\n    Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n    List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n    List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n    ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n    List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n    List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n    Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n    List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n    RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n    for (    Recipient unregistered : unregisteredRecipients) {\n      recipientDatabase.markUnregistered(unregistered.getId());\n    }\n    for (    NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n      database.removeFailure(messageId,resolvedFailure);\n      existingNetworkFailures.remove(resolvedFailure);\n    }\n    for (    IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n      database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n      existingIdentityMismatches.remove(resolvedIdentity);\n    }\n    if (!networkFailures.isEmpty()) {\n      database.addFailures(messageId,networkFailures);\n    }\n    for (    IdentityKeyMismatch mismatch : identityMismatches) {\n      database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n    }\n    DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n    if (proofRequired != null) {\n      handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n    }\n    if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n      database.markAsSent(messageId,true);\n      markAttachmentsUploaded(messageId,message);\n      if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n        database.markExpireStarted(messageId);\n        ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n      }\n      if (message.isViewOnce()) {\n        DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n      }\n    }\n else     if (!networkFailures.isEmpty()) {\n      throw new RetryLaterException();\n    }\n else     if (!identityMismatches.isEmpty()) {\n      database.markAsSentFailed(messageId);\n      notifyMediaMessageDeliveryFailed(context,messageId);\n      Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n      RetrieveProfileJob.enqueue(mismatchRecipientIds);\n    }\n  }\n catch (  UntrustedIdentityException|UndeliverableMessageException e) {\n    warn(TAG,String.valueOf(message.getSentTimeMillis()),e);\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n  }\n  SignalLocalMetrics.GroupMessageSend.onJobFinished(messageId);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 824,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 219,
        "startColumnNumber" : 10,
        "endLineNumber" : 219,
        "endColumnNumber" : 36
      },
      "nodeContext" : "!networkFailures.isEmpty()",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    },
    "tokenLength" : 2,
    "type" : "boolean"
  }, {
    "nodeContext" : "networkFailures.isEmpty()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 233,
      "startColumnNumber" : 47,
      "endLineNumber" : 233,
      "endColumnNumber" : 72
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 134,
        "startLineNumber" : 233,
        "startColumnNumber" : 10,
        "endLineNumber" : 233,
        "endColumnNumber" : 144
      },
      "nodeContext" : "existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1268,
        "startLineNumber" : 233,
        "startColumnNumber" : 6,
        "endLineNumber" : 258,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n  database.markAsSent(messageId,true);\n  markAttachmentsUploaded(messageId,message);\n  if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n    database.markExpireStarted(messageId);\n    ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n  }\n  if (message.isViewOnce()) {\n    DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n  }\n}\n else if (!networkFailures.isEmpty()) {\n  throw new RetryLaterException();\n}\n else if (!identityMismatches.isEmpty()) {\n  database.markAsSentFailed(messageId);\n  notifyMediaMessageDeliveryFailed(context,messageId);\n  Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n  RetrieveProfileJob.enqueue(mismatchRecipientIds);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 124,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5440,
        "startLineNumber" : 176,
        "startColumnNumber" : 8,
        "endLineNumber" : 259,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n  if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n    RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n  }\n  List<Recipient> target;\n  if (filterRecipient != null)   target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else   if (!existingNetworkFailures.isEmpty())   target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else   target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n  RecipientAccessList accessList=new RecipientAccessList(target);\n  List<SendMessageResult> results=deliver(message,groupRecipient,target);\n  Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n  List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n  List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n  ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n  List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n  List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n  Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n  List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n  RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n  for (  Recipient unregistered : unregisteredRecipients) {\n    recipientDatabase.markUnregistered(unregistered.getId());\n  }\n  for (  NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n    database.removeFailure(messageId,resolvedFailure);\n    existingNetworkFailures.remove(resolvedFailure);\n  }\n  for (  IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n    database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n    existingIdentityMismatches.remove(resolvedIdentity);\n  }\n  if (!networkFailures.isEmpty()) {\n    database.addFailures(messageId,networkFailures);\n  }\n  for (  IdentityKeyMismatch mismatch : identityMismatches) {\n    database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n  }\n  DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n  if (proofRequired != null) {\n    handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n  }\n  if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n    database.markAsSent(messageId,true);\n    markAttachmentsUploaded(messageId,message);\n    if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n      database.markExpireStarted(messageId);\n      ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n    }\n    if (message.isViewOnce()) {\n      DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n    }\n  }\n else   if (!networkFailures.isEmpty()) {\n    throw new RetryLaterException();\n  }\n else   if (!identityMismatches.isEmpty()) {\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n    Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n    RetrieveProfileJob.enqueue(mismatchRecipientIds);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 652,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5690,
        "startLineNumber" : 176,
        "startColumnNumber" : 4,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "try {\n  log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n  if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n    RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n  }\n  List<Recipient> target;\n  if (filterRecipient != null)   target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else   if (!existingNetworkFailures.isEmpty())   target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else   target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n  RecipientAccessList accessList=new RecipientAccessList(target);\n  List<SendMessageResult> results=deliver(message,groupRecipient,target);\n  Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n  List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n  List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n  ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n  List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n  List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n  Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n  List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n  RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n  for (  Recipient unregistered : unregisteredRecipients) {\n    recipientDatabase.markUnregistered(unregistered.getId());\n  }\n  for (  NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n    database.removeFailure(messageId,resolvedFailure);\n    existingNetworkFailures.remove(resolvedFailure);\n  }\n  for (  IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n    database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n    existingIdentityMismatches.remove(resolvedIdentity);\n  }\n  if (!networkFailures.isEmpty()) {\n    database.addFailures(messageId,networkFailures);\n  }\n  for (  IdentityKeyMismatch mismatch : identityMismatches) {\n    database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n  }\n  DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n  if (proofRequired != null) {\n    handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n  }\n  if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n    database.markAsSent(messageId,true);\n    markAttachmentsUploaded(messageId,message);\n    if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n      database.markExpireStarted(messageId);\n      ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n    }\n    if (message.isViewOnce()) {\n      DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n    }\n  }\n else   if (!networkFailures.isEmpty()) {\n    throw new RetryLaterException();\n  }\n else   if (!identityMismatches.isEmpty()) {\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n    Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n    RetrieveProfileJob.enqueue(mismatchRecipientIds);\n  }\n}\n catch (UntrustedIdentityException|UndeliverableMessageException e) {\n  warn(TAG,String.valueOf(message.getSentTimeMillis()),e);\n  database.markAsSentFailed(messageId);\n  notifyMediaMessageDeliveryFailed(context,messageId);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 683,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6902,
        "startLineNumber" : 150,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  SignalLocalMetrics.GroupMessageSend.onJobStarted(messageId);\n  MessageDatabase database=DatabaseFactory.getMmsDatabase(context);\n  OutgoingMediaMessage message=database.getOutgoingMessage(messageId);\n  long threadId=database.getMessageRecord(messageId).getThreadId();\n  List<NetworkFailure> existingNetworkFailures=message.getNetworkFailures();\n  List<IdentityKeyMismatch> existingIdentityMismatches=message.getIdentityKeyMismatches();\n  ApplicationDependencies.getJobManager().cancelAllInQueue(TypingSendJob.getQueue(threadId));\n  if (database.isSent(messageId)) {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Message \" + messageId + \" was already sent. Ignoring.\");\n    return;\n  }\n  Recipient groupRecipient=message.getRecipient().resolve();\n  if (!groupRecipient.isPushGroup()) {\n    throw new MmsException(\"Message recipient isn't a group!\");\n  }\n  if (groupRecipient.isPushV1Group()) {\n    throw new MmsException(\"No GV1 messages can be sent anymore!\");\n  }\n  try {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n    if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n      RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n    }\n    List<Recipient> target;\n    if (filterRecipient != null)     target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else     if (!existingNetworkFailures.isEmpty())     target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else     target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n    RecipientAccessList accessList=new RecipientAccessList(target);\n    List<SendMessageResult> results=deliver(message,groupRecipient,target);\n    Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n    List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n    List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n    ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n    List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n    List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n    Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n    List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n    RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n    for (    Recipient unregistered : unregisteredRecipients) {\n      recipientDatabase.markUnregistered(unregistered.getId());\n    }\n    for (    NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n      database.removeFailure(messageId,resolvedFailure);\n      existingNetworkFailures.remove(resolvedFailure);\n    }\n    for (    IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n      database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n      existingIdentityMismatches.remove(resolvedIdentity);\n    }\n    if (!networkFailures.isEmpty()) {\n      database.addFailures(messageId,networkFailures);\n    }\n    for (    IdentityKeyMismatch mismatch : identityMismatches) {\n      database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n    }\n    DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n    if (proofRequired != null) {\n      handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n    }\n    if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n      database.markAsSent(messageId,true);\n      markAttachmentsUploaded(messageId,message);\n      if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n        database.markExpireStarted(messageId);\n        ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n      }\n      if (message.isViewOnce()) {\n        DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n      }\n    }\n else     if (!networkFailures.isEmpty()) {\n      throw new RetryLaterException();\n    }\n else     if (!identityMismatches.isEmpty()) {\n      database.markAsSentFailed(messageId);\n      notifyMediaMessageDeliveryFailed(context,messageId);\n      Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n      RetrieveProfileJob.enqueue(mismatchRecipientIds);\n    }\n  }\n catch (  UntrustedIdentityException|UndeliverableMessageException e) {\n    warn(TAG,String.valueOf(message.getSentTimeMillis()),e);\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n  }\n  SignalLocalMetrics.GroupMessageSend.onJobFinished(messageId);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 810,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7025,
        "startLineNumber" : 147,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@Override public void onPushSend() throws IOException, MmsException, NoSuchMessageException, RetryLaterException {\n  SignalLocalMetrics.GroupMessageSend.onJobStarted(messageId);\n  MessageDatabase database=DatabaseFactory.getMmsDatabase(context);\n  OutgoingMediaMessage message=database.getOutgoingMessage(messageId);\n  long threadId=database.getMessageRecord(messageId).getThreadId();\n  List<NetworkFailure> existingNetworkFailures=message.getNetworkFailures();\n  List<IdentityKeyMismatch> existingIdentityMismatches=message.getIdentityKeyMismatches();\n  ApplicationDependencies.getJobManager().cancelAllInQueue(TypingSendJob.getQueue(threadId));\n  if (database.isSent(messageId)) {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Message \" + messageId + \" was already sent. Ignoring.\");\n    return;\n  }\n  Recipient groupRecipient=message.getRecipient().resolve();\n  if (!groupRecipient.isPushGroup()) {\n    throw new MmsException(\"Message recipient isn't a group!\");\n  }\n  if (groupRecipient.isPushV1Group()) {\n    throw new MmsException(\"No GV1 messages can be sent anymore!\");\n  }\n  try {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n    if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n      RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n    }\n    List<Recipient> target;\n    if (filterRecipient != null)     target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else     if (!existingNetworkFailures.isEmpty())     target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else     target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n    RecipientAccessList accessList=new RecipientAccessList(target);\n    List<SendMessageResult> results=deliver(message,groupRecipient,target);\n    Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n    List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n    List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n    ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n    List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n    List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n    Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n    List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n    RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n    for (    Recipient unregistered : unregisteredRecipients) {\n      recipientDatabase.markUnregistered(unregistered.getId());\n    }\n    for (    NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n      database.removeFailure(messageId,resolvedFailure);\n      existingNetworkFailures.remove(resolvedFailure);\n    }\n    for (    IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n      database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n      existingIdentityMismatches.remove(resolvedIdentity);\n    }\n    if (!networkFailures.isEmpty()) {\n      database.addFailures(messageId,networkFailures);\n    }\n    for (    IdentityKeyMismatch mismatch : identityMismatches) {\n      database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n    }\n    DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n    if (proofRequired != null) {\n      handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n    }\n    if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n      database.markAsSent(messageId,true);\n      markAttachmentsUploaded(messageId,message);\n      if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n        database.markExpireStarted(messageId);\n        ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n      }\n      if (message.isViewOnce()) {\n        DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n      }\n    }\n else     if (!networkFailures.isEmpty()) {\n      throw new RetryLaterException();\n    }\n else     if (!identityMismatches.isEmpty()) {\n      database.markAsSentFailed(messageId);\n      notifyMediaMessageDeliveryFailed(context,messageId);\n      Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n      RetrieveProfileJob.enqueue(mismatchRecipientIds);\n    }\n  }\n catch (  UntrustedIdentityException|UndeliverableMessageException e) {\n    warn(TAG,String.valueOf(message.getSentTimeMillis()),e);\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n  }\n  SignalLocalMetrics.GroupMessageSend.onJobFinished(messageId);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 824,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 134,
        "startLineNumber" : 233,
        "startColumnNumber" : 10,
        "endLineNumber" : 233,
        "endColumnNumber" : 144
      },
      "nodeContext" : "existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 13,
      "astHeight" : 3
    },
    "tokenLength" : 2,
    "type" : "boolean"
  }, {
    "nodeContext" : "networkFailures.isEmpty()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 247,
      "startColumnNumber" : 18,
      "endLineNumber" : 247,
      "endColumnNumber" : 43
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 247,
        "startColumnNumber" : 17,
        "endLineNumber" : 247,
        "endColumnNumber" : 43
      },
      "nodeContext" : "!networkFailures.isEmpty()",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 567,
        "startLineNumber" : 247,
        "startColumnNumber" : 13,
        "endLineNumber" : 258,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (!networkFailures.isEmpty()) {\n  throw new RetryLaterException();\n}\n else if (!identityMismatches.isEmpty()) {\n  database.markAsSentFailed(messageId);\n  notifyMediaMessageDeliveryFailed(context,messageId);\n  Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n  RetrieveProfileJob.enqueue(mismatchRecipientIds);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 57,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1268,
        "startLineNumber" : 233,
        "startColumnNumber" : 6,
        "endLineNumber" : 258,
        "endColumnNumber" : 7
      },
      "nodeContext" : "if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n  database.markAsSent(messageId,true);\n  markAttachmentsUploaded(messageId,message);\n  if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n    database.markExpireStarted(messageId);\n    ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n  }\n  if (message.isViewOnce()) {\n    DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n  }\n}\n else if (!networkFailures.isEmpty()) {\n  throw new RetryLaterException();\n}\n else if (!identityMismatches.isEmpty()) {\n  database.markAsSentFailed(messageId);\n  notifyMediaMessageDeliveryFailed(context,messageId);\n  Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n  RetrieveProfileJob.enqueue(mismatchRecipientIds);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 124,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5440,
        "startLineNumber" : 176,
        "startColumnNumber" : 8,
        "endLineNumber" : 259,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n  if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n    RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n  }\n  List<Recipient> target;\n  if (filterRecipient != null)   target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else   if (!existingNetworkFailures.isEmpty())   target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else   target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n  RecipientAccessList accessList=new RecipientAccessList(target);\n  List<SendMessageResult> results=deliver(message,groupRecipient,target);\n  Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n  List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n  List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n  ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n  List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n  List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n  Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n  List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n  RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n  for (  Recipient unregistered : unregisteredRecipients) {\n    recipientDatabase.markUnregistered(unregistered.getId());\n  }\n  for (  NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n    database.removeFailure(messageId,resolvedFailure);\n    existingNetworkFailures.remove(resolvedFailure);\n  }\n  for (  IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n    database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n    existingIdentityMismatches.remove(resolvedIdentity);\n  }\n  if (!networkFailures.isEmpty()) {\n    database.addFailures(messageId,networkFailures);\n  }\n  for (  IdentityKeyMismatch mismatch : identityMismatches) {\n    database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n  }\n  DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n  if (proofRequired != null) {\n    handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n  }\n  if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n    database.markAsSent(messageId,true);\n    markAttachmentsUploaded(messageId,message);\n    if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n      database.markExpireStarted(messageId);\n      ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n    }\n    if (message.isViewOnce()) {\n      DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n    }\n  }\n else   if (!networkFailures.isEmpty()) {\n    throw new RetryLaterException();\n  }\n else   if (!identityMismatches.isEmpty()) {\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n    Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n    RetrieveProfileJob.enqueue(mismatchRecipientIds);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 652,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5690,
        "startLineNumber" : 176,
        "startColumnNumber" : 4,
        "endLineNumber" : 263,
        "endColumnNumber" : 5
      },
      "nodeContext" : "try {\n  log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n  if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n    RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n  }\n  List<Recipient> target;\n  if (filterRecipient != null)   target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else   if (!existingNetworkFailures.isEmpty())   target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else   target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n  RecipientAccessList accessList=new RecipientAccessList(target);\n  List<SendMessageResult> results=deliver(message,groupRecipient,target);\n  Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n  List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n  List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n  ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n  List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n  List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n  Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n  List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n  List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n  RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n  for (  Recipient unregistered : unregisteredRecipients) {\n    recipientDatabase.markUnregistered(unregistered.getId());\n  }\n  for (  NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n    database.removeFailure(messageId,resolvedFailure);\n    existingNetworkFailures.remove(resolvedFailure);\n  }\n  for (  IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n    database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n    existingIdentityMismatches.remove(resolvedIdentity);\n  }\n  if (!networkFailures.isEmpty()) {\n    database.addFailures(messageId,networkFailures);\n  }\n  for (  IdentityKeyMismatch mismatch : identityMismatches) {\n    database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n  }\n  DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n  if (proofRequired != null) {\n    handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n  }\n  if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n    database.markAsSent(messageId,true);\n    markAttachmentsUploaded(messageId,message);\n    if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n      database.markExpireStarted(messageId);\n      ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n    }\n    if (message.isViewOnce()) {\n      DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n    }\n  }\n else   if (!networkFailures.isEmpty()) {\n    throw new RetryLaterException();\n  }\n else   if (!identityMismatches.isEmpty()) {\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n    Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n    RetrieveProfileJob.enqueue(mismatchRecipientIds);\n  }\n}\n catch (UntrustedIdentityException|UndeliverableMessageException e) {\n  warn(TAG,String.valueOf(message.getSentTimeMillis()),e);\n  database.markAsSentFailed(messageId);\n  notifyMediaMessageDeliveryFailed(context,messageId);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 683,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6902,
        "startLineNumber" : 150,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  SignalLocalMetrics.GroupMessageSend.onJobStarted(messageId);\n  MessageDatabase database=DatabaseFactory.getMmsDatabase(context);\n  OutgoingMediaMessage message=database.getOutgoingMessage(messageId);\n  long threadId=database.getMessageRecord(messageId).getThreadId();\n  List<NetworkFailure> existingNetworkFailures=message.getNetworkFailures();\n  List<IdentityKeyMismatch> existingIdentityMismatches=message.getIdentityKeyMismatches();\n  ApplicationDependencies.getJobManager().cancelAllInQueue(TypingSendJob.getQueue(threadId));\n  if (database.isSent(messageId)) {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Message \" + messageId + \" was already sent. Ignoring.\");\n    return;\n  }\n  Recipient groupRecipient=message.getRecipient().resolve();\n  if (!groupRecipient.isPushGroup()) {\n    throw new MmsException(\"Message recipient isn't a group!\");\n  }\n  if (groupRecipient.isPushV1Group()) {\n    throw new MmsException(\"No GV1 messages can be sent anymore!\");\n  }\n  try {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n    if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n      RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n    }\n    List<Recipient> target;\n    if (filterRecipient != null)     target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else     if (!existingNetworkFailures.isEmpty())     target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else     target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n    RecipientAccessList accessList=new RecipientAccessList(target);\n    List<SendMessageResult> results=deliver(message,groupRecipient,target);\n    Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n    List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n    List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n    ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n    List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n    List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n    Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n    List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n    RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n    for (    Recipient unregistered : unregisteredRecipients) {\n      recipientDatabase.markUnregistered(unregistered.getId());\n    }\n    for (    NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n      database.removeFailure(messageId,resolvedFailure);\n      existingNetworkFailures.remove(resolvedFailure);\n    }\n    for (    IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n      database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n      existingIdentityMismatches.remove(resolvedIdentity);\n    }\n    if (!networkFailures.isEmpty()) {\n      database.addFailures(messageId,networkFailures);\n    }\n    for (    IdentityKeyMismatch mismatch : identityMismatches) {\n      database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n    }\n    DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n    if (proofRequired != null) {\n      handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n    }\n    if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n      database.markAsSent(messageId,true);\n      markAttachmentsUploaded(messageId,message);\n      if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n        database.markExpireStarted(messageId);\n        ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n      }\n      if (message.isViewOnce()) {\n        DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n      }\n    }\n else     if (!networkFailures.isEmpty()) {\n      throw new RetryLaterException();\n    }\n else     if (!identityMismatches.isEmpty()) {\n      database.markAsSentFailed(messageId);\n      notifyMediaMessageDeliveryFailed(context,messageId);\n      Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n      RetrieveProfileJob.enqueue(mismatchRecipientIds);\n    }\n  }\n catch (  UntrustedIdentityException|UndeliverableMessageException e) {\n    warn(TAG,String.valueOf(message.getSentTimeMillis()),e);\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n  }\n  SignalLocalMetrics.GroupMessageSend.onJobFinished(messageId);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 810,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7025,
        "startLineNumber" : 147,
        "startColumnNumber" : 2,
        "endLineNumber" : 266,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@Override public void onPushSend() throws IOException, MmsException, NoSuchMessageException, RetryLaterException {\n  SignalLocalMetrics.GroupMessageSend.onJobStarted(messageId);\n  MessageDatabase database=DatabaseFactory.getMmsDatabase(context);\n  OutgoingMediaMessage message=database.getOutgoingMessage(messageId);\n  long threadId=database.getMessageRecord(messageId).getThreadId();\n  List<NetworkFailure> existingNetworkFailures=message.getNetworkFailures();\n  List<IdentityKeyMismatch> existingIdentityMismatches=message.getIdentityKeyMismatches();\n  ApplicationDependencies.getJobManager().cancelAllInQueue(TypingSendJob.getQueue(threadId));\n  if (database.isSent(messageId)) {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Message \" + messageId + \" was already sent. Ignoring.\");\n    return;\n  }\n  Recipient groupRecipient=message.getRecipient().resolve();\n  if (!groupRecipient.isPushGroup()) {\n    throw new MmsException(\"Message recipient isn't a group!\");\n  }\n  if (groupRecipient.isPushV1Group()) {\n    throw new MmsException(\"No GV1 messages can be sent anymore!\");\n  }\n  try {\n    log(TAG,String.valueOf(message.getSentTimeMillis()),\"Sending message: \" + messageId + \", Recipient: \"+ message.getRecipient().getId()+ \", Thread: \"+ threadId+ \", Attachments: \"+ buildAttachmentString(message.getAttachments()));\n    if (!groupRecipient.resolve().isProfileSharing() && !database.isGroupQuitMessage(messageId)) {\n      RecipientUtil.shareProfileIfFirstSecureMessage(context,groupRecipient);\n    }\n    List<Recipient> target;\n    if (filterRecipient != null)     target=Collections.singletonList(Recipient.resolved(filterRecipient));\n else     if (!existingNetworkFailures.isEmpty())     target=Stream.of(existingNetworkFailures).map(nf -> Recipient.resolved(nf.getRecipientId(context))).toList();\n else     target=getGroupMessageRecipients(groupRecipient.requireGroupId(),messageId);\n    RecipientAccessList accessList=new RecipientAccessList(target);\n    List<SendMessageResult> results=deliver(message,groupRecipient,target);\n    Log.i(TAG,JobLogger.format(this,\"Finished send.\"));\n    List<NetworkFailure> networkFailures=Stream.of(results).filter(SendMessageResult::isNetworkFailure).map(result -> new NetworkFailure(accessList.requireIdByAddress(result.getAddress()))).toList();\n    List<IdentityKeyMismatch> identityMismatches=Stream.of(results).filter(result -> result.getIdentityFailure() != null).map(result -> new IdentityKeyMismatch(accessList.requireIdByAddress(result.getAddress()),result.getIdentityFailure().getIdentityKey())).toList();\n    ProofRequiredException proofRequired=Stream.of(results).filter(r -> r.getProofRequiredFailure() != null).findLast().map(SendMessageResult::getProofRequiredFailure).orElse(null);\n    List<SendMessageResult> successes=Stream.of(results).filter(result -> result.getSuccess() != null).toList();\n    List<Pair<RecipientId,Boolean>> successUnidentifiedStatus=Stream.of(successes).map(result -> new Pair<>(accessList.requireIdByAddress(result.getAddress()),result.getSuccess().isUnidentified())).toList();\n    Set<RecipientId> successIds=Stream.of(successUnidentifiedStatus).map(Pair::first).collect(Collectors.toSet());\n    List<NetworkFailure> resolvedNetworkFailures=Stream.of(existingNetworkFailures).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<IdentityKeyMismatch> resolvedIdentityFailures=Stream.of(existingIdentityMismatches).filter(failure -> successIds.contains(failure.getRecipientId(context))).toList();\n    List<Recipient> unregisteredRecipients=Stream.of(results).filter(SendMessageResult::isUnregisteredFailure).map(result -> Recipient.externalPush(context,result.getAddress())).toList();\n    RecipientDatabase recipientDatabase=DatabaseFactory.getRecipientDatabase(context);\n    for (    Recipient unregistered : unregisteredRecipients) {\n      recipientDatabase.markUnregistered(unregistered.getId());\n    }\n    for (    NetworkFailure resolvedFailure : resolvedNetworkFailures) {\n      database.removeFailure(messageId,resolvedFailure);\n      existingNetworkFailures.remove(resolvedFailure);\n    }\n    for (    IdentityKeyMismatch resolvedIdentity : resolvedIdentityFailures) {\n      database.removeMismatchedIdentity(messageId,resolvedIdentity.getRecipientId(context),resolvedIdentity.getIdentityKey());\n      existingIdentityMismatches.remove(resolvedIdentity);\n    }\n    if (!networkFailures.isEmpty()) {\n      database.addFailures(messageId,networkFailures);\n    }\n    for (    IdentityKeyMismatch mismatch : identityMismatches) {\n      database.addMismatchedIdentity(messageId,mismatch.getRecipientId(context),mismatch.getIdentityKey());\n    }\n    DatabaseFactory.getGroupReceiptDatabase(context).setUnidentified(successUnidentifiedStatus,messageId);\n    if (proofRequired != null) {\n      handleProofRequiredException(proofRequired,groupRecipient,threadId,messageId,true);\n    }\n    if (existingNetworkFailures.isEmpty() && networkFailures.isEmpty() && identityMismatches.isEmpty()&& existingIdentityMismatches.isEmpty()) {\n      database.markAsSent(messageId,true);\n      markAttachmentsUploaded(messageId,message);\n      if (message.getExpiresIn() > 0 && !message.isExpirationUpdate()) {\n        database.markExpireStarted(messageId);\n        ApplicationDependencies.getExpiringMessageManager().scheduleDeletion(messageId,true,message.getExpiresIn());\n      }\n      if (message.isViewOnce()) {\n        DatabaseFactory.getAttachmentDatabase(context).deleteAttachmentFilesForViewOnceMessage(messageId);\n      }\n    }\n else     if (!networkFailures.isEmpty()) {\n      throw new RetryLaterException();\n    }\n else     if (!identityMismatches.isEmpty()) {\n      database.markAsSentFailed(messageId);\n      notifyMediaMessageDeliveryFailed(context,messageId);\n      Set<RecipientId> mismatchRecipientIds=Stream.of(identityMismatches).map(mismatch -> mismatch.getRecipientId(context)).collect(Collectors.toSet());\n      RetrieveProfileJob.enqueue(mismatchRecipientIds);\n    }\n  }\n catch (  UntrustedIdentityException|UndeliverableMessageException e) {\n    warn(TAG,String.valueOf(message.getSentTimeMillis()),e);\n    database.markAsSentFailed(messageId);\n    notifyMediaMessageDeliveryFailed(context,messageId);\n  }\n  SignalLocalMetrics.GroupMessageSend.onJobFinished(messageId);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 824,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 26,
        "startLineNumber" : 247,
        "startColumnNumber" : 17,
        "endLineNumber" : 247,
        "endColumnNumber" : 43
      },
      "nodeContext" : "!networkFailures.isEmpty()",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    },
    "tokenLength" : 2,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 25,
    "startLineNumber" : 219,
    "startColumnNumber" : 11,
    "endLineNumber" : 219,
    "endColumnNumber" : 36
  }, {
    "charLength" : 25,
    "startLineNumber" : 233,
    "startColumnNumber" : 47,
    "endLineNumber" : 233,
    "endColumnNumber" : 72
  }, {
    "charLength" : 25,
    "startLineNumber" : 247,
    "startColumnNumber" : 18,
    "endLineNumber" : 247,
    "endColumnNumber" : 43
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 1
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 3
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 2
  } ]
}