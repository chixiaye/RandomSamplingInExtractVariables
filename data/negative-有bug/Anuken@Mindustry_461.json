{
  "id" : 461,
  "expression" : "25",
  "projectName" : "Anuken@Mindustry",
  "commitID" : "a7188c48845dd423fc9b58bc6bcf6797f6d25b46",
  "filePath" : "/core/src/mindustry/maps/planet/SerpuloPlanetGenerator.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "25",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 2,
      "startLineNumber" : 389,
      "startColumnNumber" : 26,
      "endLineNumber" : 389,
      "endColumnNumber" : 28
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 12,
        "startLineNumber" : 389,
        "startColumnNumber" : 16,
        "endLineNumber" : 389,
        "endColumnNumber" : 28
      },
      "nodeContext" : "padding=25",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 389,
        "startColumnNumber" : 12,
        "endLineNumber" : 389,
        "endColumnNumber" : 29
      },
      "nodeContext" : "int padding=25;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 3260,
        "startLineNumber" : 388,
        "startColumnNumber" : 25,
        "endLineNumber" : 460,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  int padding=25;\n  for (int x=padding; x < width - padding; x++) {\n    for (int y=padding; y < height - padding; y++) {\n      Tile tile=tiles.getn(x,y);\n      if (!tile.solid() && (tile.drop() != null || tile.floor().liquidDrop != null)) {\n        ints.add(tile.pos());\n      }\n    }\n  }\n  ints.shuffle(rand);\n  int placed=0;\n  float diffRange=0.4f;\n  for (int i=0; i < ints.size && placed < ruinCount; i++) {\n    int val=ints.items[i];\n    int x=Point2.x(val), y=Point2.y(val);\n    if (Mathf.within(x,y,spawn.x,spawn.y,18f)) {\n      continue;\n    }\n    float range=difficulty + rand.random(diffRange);\n    Tile tile=tiles.getn(x,y);\n    BasePart part=null;\n    if (tile.overlay().itemDrop != null) {\n      part=bases.forResource(tile.drop()).getFrac(range);\n    }\n else     if (tile.floor().liquidDrop != null && rand.chance(0.05)) {\n      part=bases.forResource(tile.floor().liquidDrop).getFrac(range);\n    }\n else     if (rand.chance(0.05)) {\n      part=bases.parts.getFrac(range);\n    }\n    if (part != null && BaseGenerator.tryPlace(part,x,y,Team.derelict,(cx,cy) -> {\n      Tile other=tiles.getn(cx,cy);\n      if (other.floor().hasSurface()) {\n        other.setOverlay(Blocks.oreScrap);\n        for (int j=1; j <= 2; j++) {\n          for (          Point2 p : Geometry.d8) {\n            Tile t=tiles.get(cx + p.x * j,cy + p.y * j);\n            if (t != null && t.floor().hasSurface() && rand.chance(j == 1 ? 0.4 : 0.2)) {\n              t.setOverlay(Blocks.oreScrap);\n            }\n          }\n        }\n      }\n    }\n)) {\n      placed++;\n      int debrisRadius=Math.max(part.schematic.width,part.schematic.height) / 2 + 3;\n      Geometry.circle(x,y,tiles.width,tiles.height,debrisRadius,(cx,cy) -> {\n        float dst=Mathf.dst(cx,cy,x,y);\n        float removeChance=Mathf.lerp(0.05f,0.5f,dst / debrisRadius);\n        Tile other=tiles.getn(cx,cy);\n        if (other.build != null && other.isCenter()) {\n          if (other.team() == Team.derelict && rand.chance(removeChance)) {\n            other.remove();\n          }\n else           if (rand.chance(0.5)) {\n            other.build.health=other.build.health - rand.random(other.build.health * 0.9f);\n          }\n        }\n      }\n);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 483,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3277,
        "startLineNumber" : 388,
        "startColumnNumber" : 8,
        "endLineNumber" : 460,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (ruinCount > 0) {\n  int padding=25;\n  for (int x=padding; x < width - padding; x++) {\n    for (int y=padding; y < height - padding; y++) {\n      Tile tile=tiles.getn(x,y);\n      if (!tile.solid() && (tile.drop() != null || tile.floor().liquidDrop != null)) {\n        ints.add(tile.pos());\n      }\n    }\n  }\n  ints.shuffle(rand);\n  int placed=0;\n  float diffRange=0.4f;\n  for (int i=0; i < ints.size && placed < ruinCount; i++) {\n    int val=ints.items[i];\n    int x=Point2.x(val), y=Point2.y(val);\n    if (Mathf.within(x,y,spawn.x,spawn.y,18f)) {\n      continue;\n    }\n    float range=difficulty + rand.random(diffRange);\n    Tile tile=tiles.getn(x,y);\n    BasePart part=null;\n    if (tile.overlay().itemDrop != null) {\n      part=bases.forResource(tile.drop()).getFrac(range);\n    }\n else     if (tile.floor().liquidDrop != null && rand.chance(0.05)) {\n      part=bases.forResource(tile.floor().liquidDrop).getFrac(range);\n    }\n else     if (rand.chance(0.05)) {\n      part=bases.parts.getFrac(range);\n    }\n    if (part != null && BaseGenerator.tryPlace(part,x,y,Team.derelict,(cx,cy) -> {\n      Tile other=tiles.getn(cx,cy);\n      if (other.floor().hasSurface()) {\n        other.setOverlay(Blocks.oreScrap);\n        for (int j=1; j <= 2; j++) {\n          for (          Point2 p : Geometry.d8) {\n            Tile t=tiles.get(cx + p.x * j,cy + p.y * j);\n            if (t != null && t.floor().hasSurface() && rand.chance(j == 1 ? 0.4 : 0.2)) {\n              t.setOverlay(Blocks.oreScrap);\n            }\n          }\n        }\n      }\n    }\n)) {\n      placed++;\n      int debrisRadius=Math.max(part.schematic.width,part.schematic.height) / 2 + 3;\n      Geometry.circle(x,y,tiles.width,tiles.height,debrisRadius,(cx,cy) -> {\n        float dst=Mathf.dst(cx,cy,x,y);\n        float removeChance=Mathf.lerp(0.05f,0.5f,dst / debrisRadius);\n        Tile other=tiles.getn(cx,cy);\n        if (other.build != null && other.isCenter()) {\n          if (other.team() == Team.derelict && rand.chance(removeChance)) {\n            other.remove();\n          }\n else           if (rand.chance(0.5)) {\n            other.build.health=other.build.health - rand.random(other.build.health * 0.9f);\n          }\n        }\n      }\n);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 487,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 12885,
        "startLineNumber" : 155,
        "startColumnNumber" : 29,
        "endLineNumber" : 483,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\nclass Room {\n    int x, y, radius;\n    ObjectSet<Room> connected=new ObjectSet<>();\n    Room(    int x,    int y,    int radius){\n      this.x=x;\n      this.y=y;\n      this.radius=radius;\n      connected.add(this);\n    }\n    void connect(    Room to){\n      if (connected.contains(to))       return;\n      connected.add(to);\n      float nscl=rand.random(20f,60f);\n      int stroke=rand.random(4,12);\n      brush(pathfind(x,y,to.x,to.y,tile -> (tile.solid() ? 5f : 0f) + noise(tile.x,tile.y,1,1,1f / nscl) * 60,Astar.manhattan),stroke);\n    }\n  }\n  cells(4);\n  distort(10f,12f);\n  float constraint=1.3f;\n  float radius=width / 2f / Mathf.sqrt3;\n  int rooms=rand.random(2,5);\n  Seq<Room> roomseq=new Seq<>();\n  for (int i=0; i < rooms; i++) {\n    Tmp.v1.trns(rand.random(360f),rand.random(radius / constraint));\n    float rx=(width / 2f + Tmp.v1.x);\n    float ry=(height / 2f + Tmp.v1.y);\n    float maxrad=radius - Tmp.v1.len();\n    float rrad=Math.min(rand.random(9f,maxrad / 2f),30f);\n    roomseq.add(new Room((int)rx,(int)ry,(int)rrad));\n  }\n  Room spawn=null;\n  Seq<Room> enemies=new Seq<>();\n  int enemySpawns=rand.random(1,Math.max((int)(sector.threat * 4),1));\n  int offset=rand.nextInt(360);\n  float length=width / 2.55f - rand.random(13,23);\n  int angleStep=5;\n  int waterCheckRad=5;\n  for (int i=0; i < 360; i+=angleStep) {\n    int angle=offset + i;\n    int cx=(int)(width / 2 + Angles.trnsx(angle,length));\n    int cy=(int)(height / 2 + Angles.trnsy(angle,length));\n    int waterTiles=0;\n    for (int rx=-waterCheckRad; rx <= waterCheckRad; rx++) {\n      for (int ry=-waterCheckRad; ry <= waterCheckRad; ry++) {\n        Tile tile=tiles.get(cx + rx,cy + ry);\n        if (tile == null || tile.floor().liquidDrop != null) {\n          waterTiles++;\n        }\n      }\n    }\n    if (waterTiles <= 4 || (i + angleStep >= 360)) {\n      roomseq.add(spawn=new Room(cx,cy,rand.random(8,15)));\n      for (int j=0; j < enemySpawns; j++) {\n        float enemyOffset=rand.range(60f);\n        Tmp.v1.set(cx - width / 2,cy - height / 2).rotate(180f + enemyOffset).add(width / 2,height / 2);\n        Room espawn=new Room((int)Tmp.v1.x,(int)Tmp.v1.y,rand.random(8,15));\n        roomseq.add(espawn);\n        enemies.add(espawn);\n      }\n      break;\n    }\n  }\n  for (  Room room : roomseq) {\n    erase(room.x,room.y,room.radius);\n  }\n  int connections=rand.random(Math.max(rooms - 1,1),rooms + 3);\n  for (int i=0; i < connections; i++) {\n    roomseq.random(rand).connect(roomseq.random(rand));\n  }\n  for (  Room room : roomseq) {\n    spawn.connect(room);\n  }\n  cells(1);\n  distort(10f,6f);\n  inverseFloodFill(tiles.getn(spawn.x,spawn.y));\n  Seq<Block> ores=Seq.with(Blocks.oreCopper,Blocks.oreLead);\n  float poles=Math.abs(sector.tile.v.y);\n  float nmag=0.5f;\n  float scl=1f;\n  float addscl=1.3f;\n  if (noise.octaveNoise3D(2,0.5,scl,sector.tile.v.x,sector.tile.v.y,sector.tile.v.z) * nmag + poles > 0.25f * addscl) {\n    ores.add(Blocks.oreCoal);\n  }\n  if (noise.octaveNoise3D(2,0.5,scl,sector.tile.v.x + 1,sector.tile.v.y,sector.tile.v.z) * nmag + poles > 0.5f * addscl) {\n    ores.add(Blocks.oreTitanium);\n  }\n  if (noise.octaveNoise3D(2,0.5,scl,sector.tile.v.x + 2,sector.tile.v.y,sector.tile.v.z) * nmag + poles > 0.7f * addscl) {\n    ores.add(Blocks.oreThorium);\n  }\n  if (rand.chance(0.25)) {\n    ores.add(Blocks.oreScrap);\n  }\n  FloatSeq frequencies=new FloatSeq();\n  for (int i=0; i < ores.size; i++) {\n    frequencies.add(rand.random(-0.1f,0.01f) - i * 0.01f + poles * 0.04f);\n  }\n  pass((x,y) -> {\n    if (!floor.asFloor().hasSurface())     return;\n    int offsetX=x - 4, offsetY=y + 23;\n    for (int i=ores.size - 1; i >= 0; i--) {\n      Block entry=ores.get(i);\n      float freq=frequencies.get(i);\n      if (Math.abs(0.5f - noise(offsetX,offsetY + i * 999,2,0.7,(40 + i * 2))) > 0.22f + i * 0.01 && Math.abs(0.5f - noise(offsetX,offsetY - i * 999,1,1,(30 + i * 4))) > 0.37f + freq) {\n        ore=entry;\n        break;\n      }\n    }\n    if (ore == Blocks.oreScrap && rand.chance(0.33)) {\n      floor=Blocks.metalFloorDamaged;\n    }\n  }\n);\n  trimDark();\n  median(2);\n  tech();\n  pass((x,y) -> {\n    if (floor == Blocks.sporeMoss) {\n      if (Math.abs(0.5f - noise(x - 90,y,4,0.8,65)) > 0.02) {\n        floor=Blocks.moss;\n      }\n    }\n    if (floor == Blocks.darksand) {\n      if (Math.abs(0.5f - noise(x - 40,y,2,0.7,80)) > 0.25f && Math.abs(0.5f - noise(x,y + sector.id * 10,1,1,60)) > 0.41f && !(roomseq.contains(r -> Mathf.within(x,y,r.x,r.y,15)))) {\n        floor=Blocks.tar;\n        ore=Blocks.air;\n      }\n    }\n    if (floor == Blocks.hotrock) {\n      if (Math.abs(0.5f - noise(x - 90,y,4,0.8,80)) > 0.035) {\n        floor=Blocks.basalt;\n      }\n else {\n        ore=Blocks.air;\n        boolean all=true;\n        for (        Point2 p : Geometry.d4) {\n          Tile other=tiles.get(x + p.x,y + p.y);\n          if (other == null || (other.floor() != Blocks.hotrock && other.floor() != Blocks.magmarock)) {\n            all=false;\n          }\n        }\n        if (all) {\n          floor=Blocks.magmarock;\n        }\n      }\n    }\n else     if (floor != Blocks.basalt && floor != Blocks.ice && floor.asFloor().hasSurface()) {\n      float noise=noise(x + 782,y,5,0.75f,260f,1f);\n      if (noise > 0.67f && !enemies.contains(e -> Mathf.within(x,y,e.x,e.y,8))) {\n        if (noise > 0.72f) {\n          floor=noise > 0.78f ? Blocks.taintedWater : (floor == Blocks.sand ? Blocks.sandWater : Blocks.darksandTaintedWater);\n        }\n else {\n          floor=(floor == Blocks.sand ? floor : Blocks.darksand);\n        }\n        ore=Blocks.air;\n      }\n    }\n    if (rand.chance(0.0075)) {\n      boolean any=false;\n      boolean all=true;\n      for (      Point2 p : Geometry.d4) {\n        Tile other=tiles.get(x + p.x,y + p.y);\n        if (other != null && other.block() == Blocks.air) {\n          any=true;\n        }\n else {\n          all=false;\n        }\n      }\n      if (any && ((block == Blocks.snowWall || block == Blocks.iceWall) || (all && block == Blocks.air && floor == Blocks.snow && rand.chance(0.03)))) {\n        block=rand.chance(0.5) ? Blocks.whiteTree : Blocks.whiteTreeDead;\n      }\n    }\n    dec: {\n      for (int i=0; i < 4; i++) {\n        Tile near=world.tile(x + Geometry.d4[i].x,y + Geometry.d4[i].y);\n        if (near != null && near.block() != Blocks.air) {\n          break dec;\n        }\n      }\n      if (rand.chance(0.01) && floor.asFloor().hasSurface() && block == Blocks.air) {\n        block=dec.get(floor,floor.asFloor().decoration);\n      }\n    }\n  }\n);\n  float difficulty=sector.threat;\n  ints.clear();\n  ints.ensureCapacity(width * height / 4);\n  int ruinCount=rand.random(-2,4);\n  if (ruinCount > 0) {\n    int padding=25;\n    for (int x=padding; x < width - padding; x++) {\n      for (int y=padding; y < height - padding; y++) {\n        Tile tile=tiles.getn(x,y);\n        if (!tile.solid() && (tile.drop() != null || tile.floor().liquidDrop != null)) {\n          ints.add(tile.pos());\n        }\n      }\n    }\n    ints.shuffle(rand);\n    int placed=0;\n    float diffRange=0.4f;\n    for (int i=0; i < ints.size && placed < ruinCount; i++) {\n      int val=ints.items[i];\n      int x=Point2.x(val), y=Point2.y(val);\n      if (Mathf.within(x,y,spawn.x,spawn.y,18f)) {\n        continue;\n      }\n      float range=difficulty + rand.random(diffRange);\n      Tile tile=tiles.getn(x,y);\n      BasePart part=null;\n      if (tile.overlay().itemDrop != null) {\n        part=bases.forResource(tile.drop()).getFrac(range);\n      }\n else       if (tile.floor().liquidDrop != null && rand.chance(0.05)) {\n        part=bases.forResource(tile.floor().liquidDrop).getFrac(range);\n      }\n else       if (rand.chance(0.05)) {\n        part=bases.parts.getFrac(range);\n      }\n      if (part != null && BaseGenerator.tryPlace(part,x,y,Team.derelict,(cx,cy) -> {\n        Tile other=tiles.getn(cx,cy);\n        if (other.floor().hasSurface()) {\n          other.setOverlay(Blocks.oreScrap);\n          for (int j=1; j <= 2; j++) {\n            for (            Point2 p : Geometry.d8) {\n              Tile t=tiles.get(cx + p.x * j,cy + p.y * j);\n              if (t != null && t.floor().hasSurface() && rand.chance(j == 1 ? 0.4 : 0.2)) {\n                t.setOverlay(Blocks.oreScrap);\n              }\n            }\n          }\n        }\n      }\n)) {\n        placed++;\n        int debrisRadius=Math.max(part.schematic.width,part.schematic.height) / 2 + 3;\n        Geometry.circle(x,y,tiles.width,tiles.height,debrisRadius,(cx,cy) -> {\n          float dst=Mathf.dst(cx,cy,x,y);\n          float removeChance=Mathf.lerp(0.05f,0.5f,dst / debrisRadius);\n          Tile other=tiles.getn(cx,cy);\n          if (other.build != null && other.isCenter()) {\n            if (other.team() == Team.derelict && rand.chance(removeChance)) {\n              other.remove();\n            }\n else             if (rand.chance(0.5)) {\n              other.build.health=other.build.health - rand.random(other.build.health * 0.9f);\n            }\n          }\n        }\n);\n      }\n    }\n  }\n  Schematics.placeLaunchLoadout(spawn.x,spawn.y);\n  for (  Room espawn : enemies) {\n    tiles.getn(espawn.x,espawn.y).setOverlay(Blocks.spawn);\n  }\n  if (sector.hasEnemyBase()) {\n    basegen.generate(tiles,enemies.map(r -> tiles.getn(r.x,r.y)),tiles.get(spawn.x,spawn.y),state.rules.waveTeam,sector,difficulty);\n    state.rules.attackMode=sector.info.attack=true;\n  }\n else {\n    state.rules.winWave=sector.info.winWave=10 + 5 * (int)Math.max(difficulty * 10,1);\n  }\n  float waveTimeDec=0.4f;\n  state.rules.waveSpacing=Mathf.lerp(60 * 65 * 2,60f * 60f * 1f,Math.max(difficulty - waveTimeDec,0f) / 0.8f);\n  state.rules.waves=sector.info.waves=true;\n  state.rules.enemyCoreBuildRadius=600f;\n  state.rules.spawns=Waves.generate(difficulty,new Rand(),state.rules.attackMode);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2292,
      "astHeight" : 24
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 12924,
        "startLineNumber" : 154,
        "startColumnNumber" : 4,
        "endLineNumber" : 483,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@Override protected void generate(){\nclass Room {\n    int x, y, radius;\n    ObjectSet<Room> connected=new ObjectSet<>();\n    Room(    int x,    int y,    int radius){\n      this.x=x;\n      this.y=y;\n      this.radius=radius;\n      connected.add(this);\n    }\n    void connect(    Room to){\n      if (connected.contains(to))       return;\n      connected.add(to);\n      float nscl=rand.random(20f,60f);\n      int stroke=rand.random(4,12);\n      brush(pathfind(x,y,to.x,to.y,tile -> (tile.solid() ? 5f : 0f) + noise(tile.x,tile.y,1,1,1f / nscl) * 60,Astar.manhattan),stroke);\n    }\n  }\n  cells(4);\n  distort(10f,12f);\n  float constraint=1.3f;\n  float radius=width / 2f / Mathf.sqrt3;\n  int rooms=rand.random(2,5);\n  Seq<Room> roomseq=new Seq<>();\n  for (int i=0; i < rooms; i++) {\n    Tmp.v1.trns(rand.random(360f),rand.random(radius / constraint));\n    float rx=(width / 2f + Tmp.v1.x);\n    float ry=(height / 2f + Tmp.v1.y);\n    float maxrad=radius - Tmp.v1.len();\n    float rrad=Math.min(rand.random(9f,maxrad / 2f),30f);\n    roomseq.add(new Room((int)rx,(int)ry,(int)rrad));\n  }\n  Room spawn=null;\n  Seq<Room> enemies=new Seq<>();\n  int enemySpawns=rand.random(1,Math.max((int)(sector.threat * 4),1));\n  int offset=rand.nextInt(360);\n  float length=width / 2.55f - rand.random(13,23);\n  int angleStep=5;\n  int waterCheckRad=5;\n  for (int i=0; i < 360; i+=angleStep) {\n    int angle=offset + i;\n    int cx=(int)(width / 2 + Angles.trnsx(angle,length));\n    int cy=(int)(height / 2 + Angles.trnsy(angle,length));\n    int waterTiles=0;\n    for (int rx=-waterCheckRad; rx <= waterCheckRad; rx++) {\n      for (int ry=-waterCheckRad; ry <= waterCheckRad; ry++) {\n        Tile tile=tiles.get(cx + rx,cy + ry);\n        if (tile == null || tile.floor().liquidDrop != null) {\n          waterTiles++;\n        }\n      }\n    }\n    if (waterTiles <= 4 || (i + angleStep >= 360)) {\n      roomseq.add(spawn=new Room(cx,cy,rand.random(8,15)));\n      for (int j=0; j < enemySpawns; j++) {\n        float enemyOffset=rand.range(60f);\n        Tmp.v1.set(cx - width / 2,cy - height / 2).rotate(180f + enemyOffset).add(width / 2,height / 2);\n        Room espawn=new Room((int)Tmp.v1.x,(int)Tmp.v1.y,rand.random(8,15));\n        roomseq.add(espawn);\n        enemies.add(espawn);\n      }\n      break;\n    }\n  }\n  for (  Room room : roomseq) {\n    erase(room.x,room.y,room.radius);\n  }\n  int connections=rand.random(Math.max(rooms - 1,1),rooms + 3);\n  for (int i=0; i < connections; i++) {\n    roomseq.random(rand).connect(roomseq.random(rand));\n  }\n  for (  Room room : roomseq) {\n    spawn.connect(room);\n  }\n  cells(1);\n  distort(10f,6f);\n  inverseFloodFill(tiles.getn(spawn.x,spawn.y));\n  Seq<Block> ores=Seq.with(Blocks.oreCopper,Blocks.oreLead);\n  float poles=Math.abs(sector.tile.v.y);\n  float nmag=0.5f;\n  float scl=1f;\n  float addscl=1.3f;\n  if (noise.octaveNoise3D(2,0.5,scl,sector.tile.v.x,sector.tile.v.y,sector.tile.v.z) * nmag + poles > 0.25f * addscl) {\n    ores.add(Blocks.oreCoal);\n  }\n  if (noise.octaveNoise3D(2,0.5,scl,sector.tile.v.x + 1,sector.tile.v.y,sector.tile.v.z) * nmag + poles > 0.5f * addscl) {\n    ores.add(Blocks.oreTitanium);\n  }\n  if (noise.octaveNoise3D(2,0.5,scl,sector.tile.v.x + 2,sector.tile.v.y,sector.tile.v.z) * nmag + poles > 0.7f * addscl) {\n    ores.add(Blocks.oreThorium);\n  }\n  if (rand.chance(0.25)) {\n    ores.add(Blocks.oreScrap);\n  }\n  FloatSeq frequencies=new FloatSeq();\n  for (int i=0; i < ores.size; i++) {\n    frequencies.add(rand.random(-0.1f,0.01f) - i * 0.01f + poles * 0.04f);\n  }\n  pass((x,y) -> {\n    if (!floor.asFloor().hasSurface())     return;\n    int offsetX=x - 4, offsetY=y + 23;\n    for (int i=ores.size - 1; i >= 0; i--) {\n      Block entry=ores.get(i);\n      float freq=frequencies.get(i);\n      if (Math.abs(0.5f - noise(offsetX,offsetY + i * 999,2,0.7,(40 + i * 2))) > 0.22f + i * 0.01 && Math.abs(0.5f - noise(offsetX,offsetY - i * 999,1,1,(30 + i * 4))) > 0.37f + freq) {\n        ore=entry;\n        break;\n      }\n    }\n    if (ore == Blocks.oreScrap && rand.chance(0.33)) {\n      floor=Blocks.metalFloorDamaged;\n    }\n  }\n);\n  trimDark();\n  median(2);\n  tech();\n  pass((x,y) -> {\n    if (floor == Blocks.sporeMoss) {\n      if (Math.abs(0.5f - noise(x - 90,y,4,0.8,65)) > 0.02) {\n        floor=Blocks.moss;\n      }\n    }\n    if (floor == Blocks.darksand) {\n      if (Math.abs(0.5f - noise(x - 40,y,2,0.7,80)) > 0.25f && Math.abs(0.5f - noise(x,y + sector.id * 10,1,1,60)) > 0.41f && !(roomseq.contains(r -> Mathf.within(x,y,r.x,r.y,15)))) {\n        floor=Blocks.tar;\n        ore=Blocks.air;\n      }\n    }\n    if (floor == Blocks.hotrock) {\n      if (Math.abs(0.5f - noise(x - 90,y,4,0.8,80)) > 0.035) {\n        floor=Blocks.basalt;\n      }\n else {\n        ore=Blocks.air;\n        boolean all=true;\n        for (        Point2 p : Geometry.d4) {\n          Tile other=tiles.get(x + p.x,y + p.y);\n          if (other == null || (other.floor() != Blocks.hotrock && other.floor() != Blocks.magmarock)) {\n            all=false;\n          }\n        }\n        if (all) {\n          floor=Blocks.magmarock;\n        }\n      }\n    }\n else     if (floor != Blocks.basalt && floor != Blocks.ice && floor.asFloor().hasSurface()) {\n      float noise=noise(x + 782,y,5,0.75f,260f,1f);\n      if (noise > 0.67f && !enemies.contains(e -> Mathf.within(x,y,e.x,e.y,8))) {\n        if (noise > 0.72f) {\n          floor=noise > 0.78f ? Blocks.taintedWater : (floor == Blocks.sand ? Blocks.sandWater : Blocks.darksandTaintedWater);\n        }\n else {\n          floor=(floor == Blocks.sand ? floor : Blocks.darksand);\n        }\n        ore=Blocks.air;\n      }\n    }\n    if (rand.chance(0.0075)) {\n      boolean any=false;\n      boolean all=true;\n      for (      Point2 p : Geometry.d4) {\n        Tile other=tiles.get(x + p.x,y + p.y);\n        if (other != null && other.block() == Blocks.air) {\n          any=true;\n        }\n else {\n          all=false;\n        }\n      }\n      if (any && ((block == Blocks.snowWall || block == Blocks.iceWall) || (all && block == Blocks.air && floor == Blocks.snow && rand.chance(0.03)))) {\n        block=rand.chance(0.5) ? Blocks.whiteTree : Blocks.whiteTreeDead;\n      }\n    }\n    dec: {\n      for (int i=0; i < 4; i++) {\n        Tile near=world.tile(x + Geometry.d4[i].x,y + Geometry.d4[i].y);\n        if (near != null && near.block() != Blocks.air) {\n          break dec;\n        }\n      }\n      if (rand.chance(0.01) && floor.asFloor().hasSurface() && block == Blocks.air) {\n        block=dec.get(floor,floor.asFloor().decoration);\n      }\n    }\n  }\n);\n  float difficulty=sector.threat;\n  ints.clear();\n  ints.ensureCapacity(width * height / 4);\n  int ruinCount=rand.random(-2,4);\n  if (ruinCount > 0) {\n    int padding=25;\n    for (int x=padding; x < width - padding; x++) {\n      for (int y=padding; y < height - padding; y++) {\n        Tile tile=tiles.getn(x,y);\n        if (!tile.solid() && (tile.drop() != null || tile.floor().liquidDrop != null)) {\n          ints.add(tile.pos());\n        }\n      }\n    }\n    ints.shuffle(rand);\n    int placed=0;\n    float diffRange=0.4f;\n    for (int i=0; i < ints.size && placed < ruinCount; i++) {\n      int val=ints.items[i];\n      int x=Point2.x(val), y=Point2.y(val);\n      if (Mathf.within(x,y,spawn.x,spawn.y,18f)) {\n        continue;\n      }\n      float range=difficulty + rand.random(diffRange);\n      Tile tile=tiles.getn(x,y);\n      BasePart part=null;\n      if (tile.overlay().itemDrop != null) {\n        part=bases.forResource(tile.drop()).getFrac(range);\n      }\n else       if (tile.floor().liquidDrop != null && rand.chance(0.05)) {\n        part=bases.forResource(tile.floor().liquidDrop).getFrac(range);\n      }\n else       if (rand.chance(0.05)) {\n        part=bases.parts.getFrac(range);\n      }\n      if (part != null && BaseGenerator.tryPlace(part,x,y,Team.derelict,(cx,cy) -> {\n        Tile other=tiles.getn(cx,cy);\n        if (other.floor().hasSurface()) {\n          other.setOverlay(Blocks.oreScrap);\n          for (int j=1; j <= 2; j++) {\n            for (            Point2 p : Geometry.d8) {\n              Tile t=tiles.get(cx + p.x * j,cy + p.y * j);\n              if (t != null && t.floor().hasSurface() && rand.chance(j == 1 ? 0.4 : 0.2)) {\n                t.setOverlay(Blocks.oreScrap);\n              }\n            }\n          }\n        }\n      }\n)) {\n        placed++;\n        int debrisRadius=Math.max(part.schematic.width,part.schematic.height) / 2 + 3;\n        Geometry.circle(x,y,tiles.width,tiles.height,debrisRadius,(cx,cy) -> {\n          float dst=Mathf.dst(cx,cy,x,y);\n          float removeChance=Mathf.lerp(0.05f,0.5f,dst / debrisRadius);\n          Tile other=tiles.getn(cx,cy);\n          if (other.build != null && other.isCenter()) {\n            if (other.team() == Team.derelict && rand.chance(removeChance)) {\n              other.remove();\n            }\n else             if (rand.chance(0.5)) {\n              other.build.health=other.build.health - rand.random(other.build.health * 0.9f);\n            }\n          }\n        }\n);\n      }\n    }\n  }\n  Schematics.placeLaunchLoadout(spawn.x,spawn.y);\n  for (  Room espawn : enemies) {\n    tiles.getn(espawn.x,espawn.y).setOverlay(Blocks.spawn);\n  }\n  if (sector.hasEnemyBase()) {\n    basegen.generate(tiles,enemies.map(r -> tiles.getn(r.x,r.y)),tiles.get(spawn.x,spawn.y),state.rules.waveTeam,sector,difficulty);\n    state.rules.attackMode=sector.info.attack=true;\n  }\n else {\n    state.rules.winWave=sector.info.winWave=10 + 5 * (int)Math.max(difficulty * 10,1);\n  }\n  float waveTimeDec=0.4f;\n  state.rules.waveSpacing=Mathf.lerp(60 * 65 * 2,60f * 60f * 1f,Math.max(difficulty - waveTimeDec,0f) / 0.8f);\n  state.rules.waves=sector.info.waves=true;\n  state.rules.enemyCoreBuildRadius=600f;\n  state.rules.spawns=Waves.generate(difficulty,new Rand(),state.rules.attackMode);\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 2298,
      "astHeight" : 25
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 389,
        "startColumnNumber" : 12,
        "endLineNumber" : 389,
        "endColumnNumber" : 29
      },
      "nodeContext" : "int padding=25;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 2,
    "startLineNumber" : 389,
    "startColumnNumber" : 26,
    "endLineNumber" : 389,
    "endColumnNumber" : 28
  } ],
  "layoutRelationDataList" : [ ]
}