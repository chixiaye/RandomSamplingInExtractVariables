{
  "id" : 477,
  "expression" : "4",
  "projectName" : "netty@netty",
  "commitID" : "8a68c3e58d4663ae42e41a90d0d11aec3c25016b",
  "filePath" : "/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decompressor.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "4",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 111,
      "startColumnNumber" : 53,
      "endLineNumber" : 111,
      "endColumnNumber" : 54
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 111,
        "startColumnNumber" : 32,
        "endLineNumber" : 111,
        "endColumnNumber" : 54
      },
      "nodeContext" : "in.readableBytes() < 4",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 106,
        "startLineNumber" : 111,
        "startColumnNumber" : 28,
        "endLineNumber" : 113,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (in.readableBytes() < 4) {\n  return null;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14604,
        "startLineNumber" : 109,
        "startColumnNumber" : 20,
        "endLineNumber" : 345,
        "endColumnNumber" : 21
      },
      "nodeContext" : "switch (currentState) {\ncase INIT:  if (in.readableBytes() < 4) {\n    return null;\n  }\nint magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 967,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 14646,
        "startLineNumber" : 108,
        "startColumnNumber" : 25,
        "endLineNumber" : 346,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\nswitch (currentState) {\ncase INIT:    if (in.readableBytes() < 4) {\n      return null;\n    }\n  int magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\n  currentState=State.EOF;\n  throw new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 968,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 14655,
        "startLineNumber" : 108,
        "startColumnNumber" : 16,
        "endLineNumber" : 346,
        "endColumnNumber" : 17
      },
      "nodeContext" : "for (; ; ) {\nswitch (currentState) {\ncase INIT:    if (in.readableBytes() < 4) {\n      return null;\n    }\n  int magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\n  currentState=State.EOF;\n  throw new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 969,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 15099,
        "startLineNumber" : 94,
        "startColumnNumber" : 8,
        "endLineNumber" : 347,
        "endColumnNumber" : 9
      },
      "nodeContext" : "switch (currentState) {\ncase CLOSED:  throw new DecompressionException(\"Decompressor closed\");\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:if (!in.isReadable()) {\nreturn null;\n}\nfinal Bzip2BitReader reader=this.reader;\nreader.setByteBuf(in);\nfor (; ; ) {\nswitch (currentState) {\ncase INIT:if (in.readableBytes() < 4) {\nreturn null;\n}\nint magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1007,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 15117,
        "startLineNumber" : 93,
        "startColumnNumber" : 42,
        "endLineNumber" : 348,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\nswitch (currentState) {\ncase CLOSED:    throw new DecompressionException(\"Decompressor closed\");\ncase EOF:  return Unpooled.EMPTY_BUFFER;\ndefault:if (!in.isReadable()) {\n  return null;\n}\nfinal Bzip2BitReader reader=this.reader;\nreader.setByteBuf(in);\nfor (; ; ) {\nswitch (currentState) {\ncase INIT:if (in.readableBytes() < 4) {\nreturn null;\n}\nint magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1008,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 15241,
        "startLineNumber" : 91,
        "startColumnNumber" : 4,
        "endLineNumber" : 348,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@Override public ByteBuf decompress(ByteBuf in,ByteBufAllocator allocator) throws DecompressionException {\nswitch (currentState) {\ncase CLOSED:    throw new DecompressionException(\"Decompressor closed\");\ncase EOF:  return Unpooled.EMPTY_BUFFER;\ndefault:if (!in.isReadable()) {\n  return null;\n}\nfinal Bzip2BitReader reader=this.reader;\nreader.setByteBuf(in);\nfor (; ; ) {\nswitch (currentState) {\ncase INIT:if (in.readableBytes() < 4) {\nreturn null;\n}\nint magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1025,
      "astHeight" : 21
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 22,
        "startLineNumber" : 111,
        "startColumnNumber" : 32,
        "endLineNumber" : 111,
        "endColumnNumber" : 54
      },
      "nodeContext" : "in.readableBytes() < 4",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "int"
  }, {
    "nodeContext" : "4",
    "nodeType" : "NumberLiteral",
    "nodePosition" : {
      "charLength" : 1,
      "startLineNumber" : 186,
      "startColumnNumber" : 65,
      "endLineNumber" : 186,
      "endColumnNumber" : 66
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 6,
        "startLineNumber" : 186,
        "startColumnNumber" : 60,
        "endLineNumber" : 186,
        "endColumnNumber" : 66
      },
      "nodeContext" : "i << 4",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationExpression,fragments]",
      "nodePosition" : {
        "charLength" : 10,
        "startLineNumber" : 186,
        "startColumnNumber" : 56,
        "endLineNumber" : 186,
        "endColumnNumber" : 66
      },
      "nodeContext" : "k=i << 4",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 186,
        "startColumnNumber" : 45,
        "endLineNumber" : 186,
        "endColumnNumber" : 66
      },
      "nodeContext" : "int j=0, k=i << 4",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 333,
        "startLineNumber" : 186,
        "startColumnNumber" : 40,
        "endLineNumber" : 190,
        "endColumnNumber" : 41
      },
      "nodeContext" : "for (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\n  if (reader.readBoolean()) {\n    huffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 33,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 415,
        "startLineNumber" : 185,
        "startColumnNumber" : 72,
        "endLineNumber" : 191,
        "endColumnNumber" : 37
      },
      "nodeContext" : "{\n  for (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\n    if (reader.readBoolean()) {\n      huffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 34,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 451,
        "startLineNumber" : 185,
        "startColumnNumber" : 36,
        "endLineNumber" : 191,
        "endColumnNumber" : 37
      },
      "nodeContext" : "if ((inUse16 & 1 << 15 >>> i) != 0) {\n  for (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\n    if (reader.readBoolean()) {\n      huffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 45,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 525,
        "startLineNumber" : 184,
        "startColumnNumber" : 61,
        "endLineNumber" : 192,
        "endColumnNumber" : 33
      },
      "nodeContext" : "{\n  if ((inUse16 & 1 << 15 >>> i) != 0) {\n    for (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\n      if (reader.readBoolean()) {\n        huffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 46,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 554,
        "startLineNumber" : 184,
        "startColumnNumber" : 32,
        "endLineNumber" : 192,
        "endColumnNumber" : 33
      },
      "nodeContext" : "for (int i=0; i < 16; i++) {\n  if ((inUse16 & 1 << 15 >>> i) != 0) {\n    for (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\n      if (reader.readBoolean()) {\n        huffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n      }\n    }\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 57,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 620,
        "startLineNumber" : 183,
        "startColumnNumber" : 47,
        "endLineNumber" : 193,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  for (int i=0; i < 16; i++) {\n    if ((inUse16 & 1 << 15 >>> i) != 0) {\n      for (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\n        if (reader.readBoolean()) {\n          huffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n        }\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 58,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 639,
        "startLineNumber" : 183,
        "startColumnNumber" : 28,
        "endLineNumber" : 193,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (bitNumber > 0) {\n  for (int i=0; i < 16; i++) {\n    if ((inUse16 & 1 << 15 >>> i) != 0) {\n      for (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\n        if (reader.readBoolean()) {\n          huffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n        }\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 62,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14604,
        "startLineNumber" : 109,
        "startColumnNumber" : 20,
        "endLineNumber" : 345,
        "endColumnNumber" : 21
      },
      "nodeContext" : "switch (currentState) {\ncase INIT:  if (in.readableBytes() < 4) {\n    return null;\n  }\nint magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 967,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 14646,
        "startLineNumber" : 108,
        "startColumnNumber" : 25,
        "endLineNumber" : 346,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\nswitch (currentState) {\ncase INIT:    if (in.readableBytes() < 4) {\n      return null;\n    }\n  int magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\n  currentState=State.EOF;\n  throw new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 968,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 14655,
        "startLineNumber" : 108,
        "startColumnNumber" : 16,
        "endLineNumber" : 346,
        "endColumnNumber" : 17
      },
      "nodeContext" : "for (; ; ) {\nswitch (currentState) {\ncase INIT:    if (in.readableBytes() < 4) {\n      return null;\n    }\n  int magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\n  currentState=State.EOF;\n  throw new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 969,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 15099,
        "startLineNumber" : 94,
        "startColumnNumber" : 8,
        "endLineNumber" : 347,
        "endColumnNumber" : 9
      },
      "nodeContext" : "switch (currentState) {\ncase CLOSED:  throw new DecompressionException(\"Decompressor closed\");\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:if (!in.isReadable()) {\nreturn null;\n}\nfinal Bzip2BitReader reader=this.reader;\nreader.setByteBuf(in);\nfor (; ; ) {\nswitch (currentState) {\ncase INIT:if (in.readableBytes() < 4) {\nreturn null;\n}\nint magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 1007,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 15117,
        "startLineNumber" : 93,
        "startColumnNumber" : 42,
        "endLineNumber" : 348,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\nswitch (currentState) {\ncase CLOSED:    throw new DecompressionException(\"Decompressor closed\");\ncase EOF:  return Unpooled.EMPTY_BUFFER;\ndefault:if (!in.isReadable()) {\n  return null;\n}\nfinal Bzip2BitReader reader=this.reader;\nreader.setByteBuf(in);\nfor (; ; ) {\nswitch (currentState) {\ncase INIT:if (in.readableBytes() < 4) {\nreturn null;\n}\nint magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1008,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 15241,
        "startLineNumber" : 91,
        "startColumnNumber" : 4,
        "endLineNumber" : 348,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@Override public ByteBuf decompress(ByteBuf in,ByteBufAllocator allocator) throws DecompressionException {\nswitch (currentState) {\ncase CLOSED:    throw new DecompressionException(\"Decompressor closed\");\ncase EOF:  return Unpooled.EMPTY_BUFFER;\ndefault:if (!in.isReadable()) {\n  return null;\n}\nfinal Bzip2BitReader reader=this.reader;\nreader.setByteBuf(in);\nfor (; ; ) {\nswitch (currentState) {\ncase INIT:if (in.readableBytes() < 4) {\nreturn null;\n}\nint magicNumber=in.readUnsignedMedium();\nif (magicNumber != MAGIC_NUMBER) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"Unexpected stream identifier contents. \" + \"Mismatched bzip2 protocol version?\");\n}\nint blockSize=in.readByte() - '0';\nif (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"block size is invalid\");\n}\nthis.blockSize=blockSize * BASE_BLOCK_SIZE;\nstreamCRC=0;\ncurrentState=State.INIT_BLOCK;\ncase INIT_BLOCK:if (!reader.hasReadableBytes(10)) {\nreturn null;\n}\nfinal int magic1=reader.readBits(24);\nfinal int magic2=reader.readBits(24);\nif (magic1 == END_OF_STREAM_MAGIC_1 && magic2 == END_OF_STREAM_MAGIC_2) {\nfinal int storedCombinedCRC=reader.readInt();\nif (storedCombinedCRC != streamCRC) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"stream CRC error\");\n}\ncurrentState=State.EOF;\nbreak;\n}\nif (magic1 != BLOCK_HEADER_MAGIC_1 || magic2 != BLOCK_HEADER_MAGIC_2) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"bad block header\");\n}\nblockCRC=reader.readInt();\ncurrentState=State.INIT_BLOCK_PARAMS;\ncase INIT_BLOCK_PARAMS:if (!reader.hasReadableBits(25)) {\nreturn null;\n}\nfinal boolean blockRandomised=reader.readBoolean();\nfinal int bwtStartPointer=reader.readBits(24);\nblockDecompressor=new Bzip2BlockDecompressor(this.blockSize,blockCRC,blockRandomised,bwtStartPointer,reader);\ncurrentState=State.RECEIVE_HUFFMAN_USED_MAP;\ncase RECEIVE_HUFFMAN_USED_MAP:if (!reader.hasReadableBits(16)) {\nreturn null;\n}\nblockDecompressor.huffmanInUse16=reader.readBits(16);\ncurrentState=State.RECEIVE_HUFFMAN_USED_BITMAPS;\ncase RECEIVE_HUFFMAN_USED_BITMAPS:Bzip2BlockDecompressor blockDecompressor=this.blockDecompressor;\nfinal int inUse16=blockDecompressor.huffmanInUse16;\nfinal int bitNumber=Integer.bitCount(inUse16);\nfinal byte[] huffmanSymbolMap=blockDecompressor.huffmanSymbolMap;\nif (!reader.hasReadableBits(bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + 3)) {\nreturn null;\n}\nint huffmanSymbolCount=0;\nif (bitNumber > 0) {\nfor (int i=0; i < 16; i++) {\nif ((inUse16 & 1 << 15 >>> i) != 0) {\nfor (int j=0, k=i << 4; j < HUFFMAN_SYMBOL_RANGE_SIZE; j++, k++) {\nif (reader.readBoolean()) {\nhuffmanSymbolMap[huffmanSymbolCount++]=(byte)k;\n}\n}\n}\n}\n}\nblockDecompressor.huffmanEndOfBlockSymbol=huffmanSymbolCount + 1;\nint totalTables=reader.readBits(3);\nif (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {\nthrow new DecompressionException(\"incorrect huffman groups number\");\n}\nint alphaSize=huffmanSymbolCount + 2;\nif (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {\nthrow new DecompressionException(\"incorrect alphabet size\");\n}\nhuffmanStageDecoder=new Bzip2HuffmanStageDecoder(reader,totalTables,alphaSize);\ncurrentState=State.RECEIVE_SELECTORS_NUMBER;\ncase RECEIVE_SELECTORS_NUMBER:if (!reader.hasReadableBits(15)) {\nreturn null;\n}\nint totalSelectors=reader.readBits(15);\nif (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {\ncurrentState=State.EOF;\nthrow new DecompressionException(\"incorrect selectors number\");\n}\nhuffmanStageDecoder.selectors=new byte[totalSelectors];\ncurrentState=State.RECEIVE_SELECTORS;\ncase RECEIVE_SELECTORS:Bzip2HuffmanStageDecoder huffmanStageDecoder=this.huffmanStageDecoder;\nbyte[] selectors=huffmanStageDecoder.selectors;\ntotalSelectors=selectors.length;\nfinal Bzip2MoveToFrontTable tableMtf=huffmanStageDecoder.tableMTF;\nint currSelector;\nfor (currSelector=huffmanStageDecoder.currentSelector; currSelector < totalSelectors; currSelector++) {\nif (!reader.hasReadableBits(HUFFMAN_SELECTOR_LIST_MAX_LENGTH)) {\nhuffmanStageDecoder.currentSelector=currSelector;\nreturn null;\n}\nint index=0;\nwhile (reader.readBoolean()) {\nindex++;\n}\nselectors[currSelector]=tableMtf.indexToFront(index);\n}\ncurrentState=State.RECEIVE_HUFFMAN_LENGTH;\ncase RECEIVE_HUFFMAN_LENGTH:huffmanStageDecoder=this.huffmanStageDecoder;\ntotalTables=huffmanStageDecoder.totalTables;\nfinal byte[][] codeLength=huffmanStageDecoder.tableCodeLengths;\nalphaSize=huffmanStageDecoder.alphabetSize;\nint currGroup;\nint currLength=huffmanStageDecoder.currentLength;\nint currAlpha=0;\nboolean modifyLength=huffmanStageDecoder.modifyLength;\nboolean saveStateAndReturn=false;\nloop: for (currGroup=huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {\nif (!reader.hasReadableBits(5)) {\nsaveStateAndReturn=true;\nbreak;\n}\nif (currLength < 0) {\ncurrLength=reader.readBits(5);\n}\nfor (currAlpha=huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\nwhile (modifyLength || reader.readBoolean()) {\nif (!reader.isReadable()) {\nmodifyLength=true;\nsaveStateAndReturn=true;\nbreak loop;\n}\ncurrLength+=reader.readBoolean() ? -1 : 1;\nmodifyLength=false;\nif (!reader.isReadable()) {\nsaveStateAndReturn=true;\nbreak loop;\n}\n}\ncodeLength[currGroup][currAlpha]=(byte)currLength;\n}\ncurrLength=-1;\ncurrAlpha=huffmanStageDecoder.currentAlpha=0;\nmodifyLength=false;\n}\nif (saveStateAndReturn) {\nhuffmanStageDecoder.currentGroup=currGroup;\nhuffmanStageDecoder.currentLength=currLength;\nhuffmanStageDecoder.currentAlpha=currAlpha;\nhuffmanStageDecoder.modifyLength=modifyLength;\nreturn null;\n}\nhuffmanStageDecoder.createHuffmanDecodingTables();\ncurrentState=State.DECODE_HUFFMAN_DATA;\ncase DECODE_HUFFMAN_DATA:blockDecompressor=this.blockDecompressor;\nfinal int oldReaderIndex=in.readerIndex();\nfinal boolean decoded=blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder);\nif (!decoded) {\nreturn null;\n}\nif (in.readerIndex() == oldReaderIndex && in.isReadable()) {\nreader.refill();\n}\nfinal int blockLength=blockDecompressor.blockLength();\nByteBuf uncompressed=allocator.buffer(blockLength);\ntry {\nint uncByte;\nwhile ((uncByte=blockDecompressor.read()) >= 0) {\nuncompressed.writeByte(uncByte);\n}\ncurrentState=State.INIT_BLOCK;\nint currentBlockCRC=blockDecompressor.checkCRC();\nstreamCRC=(streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;\nByteBuf data=uncompressed;\nuncompressed=null;\nreturn data;\n}\n  finally {\nif (uncompressed != null) {\nuncompressed.release();\n}\n}\ncase EOF:return Unpooled.EMPTY_BUFFER;\ndefault:throw new IllegalStateException();\n}\n}\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1025,
      "astHeight" : 21
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ForStatement,initializers]",
      "nodePosition" : {
        "charLength" : 21,
        "startLineNumber" : 186,
        "startColumnNumber" : 45,
        "endLineNumber" : 186,
        "endColumnNumber" : 66
      },
      "nodeContext" : "int j=0, k=i << 4",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 10,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 1,
    "startLineNumber" : 111,
    "startColumnNumber" : 53,
    "endLineNumber" : 111,
    "endColumnNumber" : 54
  }, {
    "charLength" : 1,
    "startLineNumber" : 186,
    "startColumnNumber" : 65,
    "endLineNumber" : 186,
    "endColumnNumber" : 66
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 10
  } ]
}