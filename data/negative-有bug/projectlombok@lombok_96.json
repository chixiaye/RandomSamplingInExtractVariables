{
  "id" : 96,
  "expression" : "cleanupName.toCharArray()",
  "projectName" : "projectlombok@lombok",
  "commitID" : "25def866b50860715ee7c315c678b8c3d1ba9b56",
  "filePath" : "/src/core/lombok/eclipse/handlers/HandleCleanup.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "cleanupName.toCharArray()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 179,
      "startColumnNumber" : 25,
      "endLineNumber" : 179,
      "endColumnNumber" : 50
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 48,
        "startLineNumber" : 179,
        "startColumnNumber" : 2,
        "endLineNumber" : 179,
        "endColumnNumber" : 50
      },
      "nodeContext" : "unsafeClose.selector=cleanupName.toCharArray()",
      "nodeType" : "Assignment",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 179,
        "startColumnNumber" : 2,
        "endLineNumber" : 179,
        "endColumnNumber" : 51
      },
      "nodeContext" : "unsafeClose.selector=cleanupName.toCharArray();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6172,
        "startLineNumber" : 60,
        "startColumnNumber" : 102,
        "endLineNumber" : 226,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  String cleanupName=annotation.getInstance().value();\n  if (cleanupName.length() == 0) {\n    annotationNode.addError(\"cleanupName cannot be the empty string.\");\n    return;\n  }\n  if (annotationNode.up().getKind() != Kind.LOCAL) {\n    annotationNode.addError(\"@Cleanup is legal only on local variable declarations.\");\n    return;\n  }\n  LocalDeclaration decl=(LocalDeclaration)annotationNode.up().get();\n  if (decl.initialization == null) {\n    annotationNode.addError(\"@Cleanup variable declarations need to be initialized.\");\n    return;\n  }\n  EclipseNode ancestor=annotationNode.up().directUp();\n  ASTNode blockNode=ancestor.get();\n  final boolean isSwitch;\n  final Statement[] statements;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    isSwitch=false;\n    statements=((AbstractMethodDeclaration)blockNode).statements;\n  }\n else   if (blockNode instanceof Block) {\n    isSwitch=false;\n    statements=((Block)blockNode).statements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    isSwitch=true;\n    statements=((SwitchStatement)blockNode).statements;\n  }\n else {\n    annotationNode.addError(\"@Cleanup is legal only on a local variable declaration inside a block.\");\n    return;\n  }\n  if (statements == null) {\n    annotationNode.addError(\"LOMBOK BUG: Parent block does not contain any statements.\");\n    return;\n  }\n  int start=0;\n  for (; start < statements.length; start++) {\n    if (statements[start] == decl)     break;\n  }\n  if (start == statements.length) {\n    annotationNode.addError(\"LOMBOK BUG: Can't find this local variable declaration inside its parent.\");\n    return;\n  }\n  start++;\n  int end;\n  if (isSwitch) {\n    end=start + 1;\n    for (; end < statements.length; end++) {\n      if (statements[end] instanceof CaseStatement) {\n        break;\n      }\n    }\n  }\n else   end=statements.length;\n  Statement[] tryBlock=new Statement[end - start];\n  System.arraycopy(statements,start,tryBlock,0,end - start);\n  int newStatementsLength=statements.length - (end - start);\n  newStatementsLength+=1;\n  Statement[] newStatements=new Statement[newStatementsLength];\n  System.arraycopy(statements,0,newStatements,0,start);\n  System.arraycopy(statements,end,newStatements,start + 1,statements.length - end);\n  doAssignmentCheck(annotationNode,tryBlock,decl.name);\n  TryStatement tryStatement=new TryStatement();\n  setGeneratedBy(tryStatement,ast);\n  tryStatement.tryBlock=new Block(0);\n  tryStatement.tryBlock.statements=tryBlock;\n  setGeneratedBy(tryStatement.tryBlock,ast);\n  int ss=decl.declarationSourceEnd + 1;\n  int se=ss;\n  if (tryBlock.length > 0) {\n    se=tryBlock[tryBlock.length - 1].sourceEnd + 1;\n    tryStatement.sourceStart=ss;\n    tryStatement.sourceEnd=se;\n    tryStatement.tryBlock.sourceStart=ss;\n    tryStatement.tryBlock.sourceEnd=se;\n  }\n  newStatements[start]=tryStatement;\n  Statement[] finallyBlock=new Statement[1];\n  MessageSend unsafeClose=new MessageSend();\n  setGeneratedBy(unsafeClose,ast);\n  unsafeClose.sourceStart=ast.sourceStart;\n  unsafeClose.sourceEnd=ast.sourceEnd;\n  SingleNameReference receiver=new SingleNameReference(decl.name,0);\n  setGeneratedBy(receiver,ast);\n  unsafeClose.receiver=receiver;\n  long nameSourcePosition=(long)ast.sourceStart << 32 | ast.sourceEnd;\n  if (ast.memberValuePairs() != null)   for (  MemberValuePair pair : ast.memberValuePairs()) {\n    if (pair.name != null && new String(pair.name).equals(\"value\")) {\n      nameSourcePosition=(long)pair.value.sourceStart << 32 | pair.value.sourceEnd;\n      break;\n    }\n  }\n  unsafeClose.nameSourcePosition=nameSourcePosition;\n  unsafeClose.selector=cleanupName.toCharArray();\n  int pS=ast.sourceStart, pE=ast.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  SingleNameReference varName=new SingleNameReference(decl.name,p);\n  setGeneratedBy(varName,ast);\n  NullLiteral nullLiteral=new NullLiteral(pS,pE);\n  setGeneratedBy(nullLiteral,ast);\n  MessageSend preventNullAnalysis=preventNullAnalysis(ast,varName);\n  EqualExpression equalExpression=new EqualExpression(preventNullAnalysis,nullLiteral,OperatorIds.NOT_EQUAL);\n  equalExpression.sourceStart=pS;\n  equalExpression.sourceEnd=pE;\n  setGeneratedBy(equalExpression,ast);\n  Block closeBlock=new Block(0);\n  closeBlock.statements=new Statement[1];\n  closeBlock.statements[0]=unsafeClose;\n  setGeneratedBy(closeBlock,ast);\n  IfStatement ifStatement=new IfStatement(equalExpression,closeBlock,0,0);\n  setGeneratedBy(ifStatement,ast);\n  finallyBlock[0]=ifStatement;\n  tryStatement.finallyBlock=new Block(0);\n  if (!isSwitch) {\n    tryStatement.finallyBlock.sourceStart=blockNode.sourceEnd;\n    tryStatement.finallyBlock.sourceEnd=blockNode.sourceEnd;\n  }\n  setGeneratedBy(tryStatement.finallyBlock,ast);\n  tryStatement.finallyBlock.statements=finallyBlock;\n  tryStatement.catchArguments=null;\n  tryStatement.catchBlocks=null;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    ((AbstractMethodDeclaration)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof Block) {\n    ((Block)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    ((SwitchStatement)blockNode).statements=newStatements;\n  }\n  ancestor.rebuild();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 850,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6273,
        "startLineNumber" : 60,
        "startColumnNumber" : 1,
        "endLineNumber" : 226,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void handle(AnnotationValues<Cleanup> annotation,Annotation ast,EclipseNode annotationNode){\n  String cleanupName=annotation.getInstance().value();\n  if (cleanupName.length() == 0) {\n    annotationNode.addError(\"cleanupName cannot be the empty string.\");\n    return;\n  }\n  if (annotationNode.up().getKind() != Kind.LOCAL) {\n    annotationNode.addError(\"@Cleanup is legal only on local variable declarations.\");\n    return;\n  }\n  LocalDeclaration decl=(LocalDeclaration)annotationNode.up().get();\n  if (decl.initialization == null) {\n    annotationNode.addError(\"@Cleanup variable declarations need to be initialized.\");\n    return;\n  }\n  EclipseNode ancestor=annotationNode.up().directUp();\n  ASTNode blockNode=ancestor.get();\n  final boolean isSwitch;\n  final Statement[] statements;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    isSwitch=false;\n    statements=((AbstractMethodDeclaration)blockNode).statements;\n  }\n else   if (blockNode instanceof Block) {\n    isSwitch=false;\n    statements=((Block)blockNode).statements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    isSwitch=true;\n    statements=((SwitchStatement)blockNode).statements;\n  }\n else {\n    annotationNode.addError(\"@Cleanup is legal only on a local variable declaration inside a block.\");\n    return;\n  }\n  if (statements == null) {\n    annotationNode.addError(\"LOMBOK BUG: Parent block does not contain any statements.\");\n    return;\n  }\n  int start=0;\n  for (; start < statements.length; start++) {\n    if (statements[start] == decl)     break;\n  }\n  if (start == statements.length) {\n    annotationNode.addError(\"LOMBOK BUG: Can't find this local variable declaration inside its parent.\");\n    return;\n  }\n  start++;\n  int end;\n  if (isSwitch) {\n    end=start + 1;\n    for (; end < statements.length; end++) {\n      if (statements[end] instanceof CaseStatement) {\n        break;\n      }\n    }\n  }\n else   end=statements.length;\n  Statement[] tryBlock=new Statement[end - start];\n  System.arraycopy(statements,start,tryBlock,0,end - start);\n  int newStatementsLength=statements.length - (end - start);\n  newStatementsLength+=1;\n  Statement[] newStatements=new Statement[newStatementsLength];\n  System.arraycopy(statements,0,newStatements,0,start);\n  System.arraycopy(statements,end,newStatements,start + 1,statements.length - end);\n  doAssignmentCheck(annotationNode,tryBlock,decl.name);\n  TryStatement tryStatement=new TryStatement();\n  setGeneratedBy(tryStatement,ast);\n  tryStatement.tryBlock=new Block(0);\n  tryStatement.tryBlock.statements=tryBlock;\n  setGeneratedBy(tryStatement.tryBlock,ast);\n  int ss=decl.declarationSourceEnd + 1;\n  int se=ss;\n  if (tryBlock.length > 0) {\n    se=tryBlock[tryBlock.length - 1].sourceEnd + 1;\n    tryStatement.sourceStart=ss;\n    tryStatement.sourceEnd=se;\n    tryStatement.tryBlock.sourceStart=ss;\n    tryStatement.tryBlock.sourceEnd=se;\n  }\n  newStatements[start]=tryStatement;\n  Statement[] finallyBlock=new Statement[1];\n  MessageSend unsafeClose=new MessageSend();\n  setGeneratedBy(unsafeClose,ast);\n  unsafeClose.sourceStart=ast.sourceStart;\n  unsafeClose.sourceEnd=ast.sourceEnd;\n  SingleNameReference receiver=new SingleNameReference(decl.name,0);\n  setGeneratedBy(receiver,ast);\n  unsafeClose.receiver=receiver;\n  long nameSourcePosition=(long)ast.sourceStart << 32 | ast.sourceEnd;\n  if (ast.memberValuePairs() != null)   for (  MemberValuePair pair : ast.memberValuePairs()) {\n    if (pair.name != null && new String(pair.name).equals(\"value\")) {\n      nameSourcePosition=(long)pair.value.sourceStart << 32 | pair.value.sourceEnd;\n      break;\n    }\n  }\n  unsafeClose.nameSourcePosition=nameSourcePosition;\n  unsafeClose.selector=cleanupName.toCharArray();\n  int pS=ast.sourceStart, pE=ast.sourceEnd;\n  long p=(long)pS << 32 | pE;\n  SingleNameReference varName=new SingleNameReference(decl.name,p);\n  setGeneratedBy(varName,ast);\n  NullLiteral nullLiteral=new NullLiteral(pS,pE);\n  setGeneratedBy(nullLiteral,ast);\n  MessageSend preventNullAnalysis=preventNullAnalysis(ast,varName);\n  EqualExpression equalExpression=new EqualExpression(preventNullAnalysis,nullLiteral,OperatorIds.NOT_EQUAL);\n  equalExpression.sourceStart=pS;\n  equalExpression.sourceEnd=pE;\n  setGeneratedBy(equalExpression,ast);\n  Block closeBlock=new Block(0);\n  closeBlock.statements=new Statement[1];\n  closeBlock.statements[0]=unsafeClose;\n  setGeneratedBy(closeBlock,ast);\n  IfStatement ifStatement=new IfStatement(equalExpression,closeBlock,0,0);\n  setGeneratedBy(ifStatement,ast);\n  finallyBlock[0]=ifStatement;\n  tryStatement.finallyBlock=new Block(0);\n  if (!isSwitch) {\n    tryStatement.finallyBlock.sourceStart=blockNode.sourceEnd;\n    tryStatement.finallyBlock.sourceEnd=blockNode.sourceEnd;\n  }\n  setGeneratedBy(tryStatement.finallyBlock,ast);\n  tryStatement.finallyBlock.statements=finallyBlock;\n  tryStatement.catchArguments=null;\n  tryStatement.catchBlocks=null;\n  if (blockNode instanceof AbstractMethodDeclaration) {\n    ((AbstractMethodDeclaration)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof Block) {\n    ((Block)blockNode).statements=newStatements;\n  }\n else   if (blockNode instanceof SwitchStatement) {\n    ((SwitchStatement)blockNode).statements=newStatements;\n  }\n  ancestor.rebuild();\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 869,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 49,
        "startLineNumber" : 179,
        "startColumnNumber" : 2,
        "endLineNumber" : 179,
        "endColumnNumber" : 51
      },
      "nodeContext" : "unsafeClose.selector=cleanupName.toCharArray();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 2,
    "type" : "char[]"
  } ],
  "positionList" : [ {
    "charLength" : 25,
    "startLineNumber" : 179,
    "startColumnNumber" : 25,
    "endLineNumber" : 179,
    "endColumnNumber" : 50
  } ],
  "layoutRelationDataList" : [ ]
}