{
  "id" : 371,
  "expression" : "mission.offsets[i]",
  "projectName" : "TeamNewPipe@NewPipe",
  "commitID" : "d7574973e97fa7a3a21aa59967311f6091941830",
  "filePath" : "/app/src/main/java/us/shandian/giga/postprocessing/Postprocessing.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "mission.offsets[i]",
    "nodeType" : "ArrayAccess",
    "nodePosition" : {
      "charLength" : 18,
      "startLineNumber" : 132,
      "startColumnNumber" : 66,
      "endLineNumber" : 132,
      "endColumnNumber" : 84
    },
    "astNodeNumber" : 5,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 132,
        "startColumnNumber" : 33,
        "endLineNumber" : 132,
        "endColumnNumber" : 104
      },
      "nodeContext" : "new ChunkFileInputStream(source,mission.offsets[i],end,readProgress)",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 84,
        "startLineNumber" : 132,
        "startColumnNumber" : 20,
        "endLineNumber" : 132,
        "endColumnNumber" : 104
      },
      "nodeContext" : "sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 15,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 132,
        "startColumnNumber" : 20,
        "endLineNumber" : 132,
        "endColumnNumber" : 105
      },
      "nodeContext" : "sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 286,
        "startLineNumber" : 128,
        "startColumnNumber" : 69,
        "endLineNumber" : 133,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  SharpStream source=mission.storage.getStream();\n  long end=j < sources.length ? mission.offsets[j] : source.length();\n  sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 45,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 339,
        "startLineNumber" : 128,
        "startColumnNumber" : 16,
        "endLineNumber" : 133,
        "endColumnNumber" : 17
      },
      "nodeContext" : "for (int i=0, j=1; i < sources.length; i++, j++) {\n  SharpStream source=mission.storage.getStream();\n  long end=j < sources.length ? mission.offsets[j] : source.length();\n  sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 63,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 2350,
        "startLineNumber" : 127,
        "startColumnNumber" : 16,
        "endLineNumber" : 181,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  for (int i=0, j=1; i < sources.length; i++, j++) {\n    SharpStream source=mission.storage.getStream();\n    long end=j < sources.length ? mission.offsets[j] : source.length();\n    sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n  }\n  if (test(sources)) {\n    for (    SharpStream source : sources)     source.rewind();\n    OffsetChecker checker=() -> {\n      for (      ChunkFileInputStream source : sources) {\n        if (source.isClosed() || source.available() < 1) {\n          continue;\n        }\n        return source.getFilePointer() - 1;\n      }\n      return -1;\n    }\n;\n    out=new CircularFileWriter(mission.storage.getStream(),tempFile,checker);\n    out.onProgress=(    long position) -> mission.done=position;\n    out.onWriteError=(err) -> {\n      mission.psState=3;\n      mission.notifyError(ERROR_POSTPROCESSING_HOLD,err);\n      try {\nsynchronized (this) {\n          while (mission.psState == 3)           wait();\n        }\n      }\n catch (      InterruptedException e) {\n        Log.e(this.getClass().getSimpleName(),\"got InterruptedException\");\n      }\n      return mission.errCode == ERROR_NOTHING;\n    }\n;\n    result=process(out,sources);\n    if (result == OK_RESULT)     finalLength=out.finalizeFile();\n  }\n else {\n    result=OK_RESULT;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 220,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2856,
        "startLineNumber" : 127,
        "startColumnNumber" : 12,
        "endLineNumber" : 195,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  for (int i=0, j=1; i < sources.length; i++, j++) {\n    SharpStream source=mission.storage.getStream();\n    long end=j < sources.length ? mission.offsets[j] : source.length();\n    sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n  }\n  if (test(sources)) {\n    for (    SharpStream source : sources)     source.rewind();\n    OffsetChecker checker=() -> {\n      for (      ChunkFileInputStream source : sources) {\n        if (source.isClosed() || source.available() < 1) {\n          continue;\n        }\n        return source.getFilePointer() - 1;\n      }\n      return -1;\n    }\n;\n    out=new CircularFileWriter(mission.storage.getStream(),tempFile,checker);\n    out.onProgress=(    long position) -> mission.done=position;\n    out.onWriteError=(err) -> {\n      mission.psState=3;\n      mission.notifyError(ERROR_POSTPROCESSING_HOLD,err);\n      try {\nsynchronized (this) {\n          while (mission.psState == 3)           wait();\n        }\n      }\n catch (      InterruptedException e) {\n        Log.e(this.getClass().getSimpleName(),\"got InterruptedException\");\n      }\n      return mission.errCode == ERROR_NOTHING;\n    }\n;\n    result=process(out,sources);\n    if (result == OK_RESULT)     finalLength=out.finalizeFile();\n  }\n else {\n    result=OK_RESULT;\n  }\n}\n  finally {\n  for (  SharpStream source : sources) {\n    if (source != null && !source.isClosed()) {\n      source.close();\n    }\n  }\n  if (out != null) {\n    out.close();\n  }\n  if (tempFile != null) {\n    tempFile.delete();\n    tempFile=null;\n  }\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 265,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2972,
        "startLineNumber" : 125,
        "startColumnNumber" : 29,
        "endLineNumber" : 196,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  ChunkFileInputStream[] sources=new ChunkFileInputStream[mission.urls.length];\n  try {\n    for (int i=0, j=1; i < sources.length; i++, j++) {\n      SharpStream source=mission.storage.getStream();\n      long end=j < sources.length ? mission.offsets[j] : source.length();\n      sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n    }\n    if (test(sources)) {\n      for (      SharpStream source : sources)       source.rewind();\n      OffsetChecker checker=() -> {\n        for (        ChunkFileInputStream source : sources) {\n          if (source.isClosed() || source.available() < 1) {\n            continue;\n          }\n          return source.getFilePointer() - 1;\n        }\n        return -1;\n      }\n;\n      out=new CircularFileWriter(mission.storage.getStream(),tempFile,checker);\n      out.onProgress=(      long position) -> mission.done=position;\n      out.onWriteError=(err) -> {\n        mission.psState=3;\n        mission.notifyError(ERROR_POSTPROCESSING_HOLD,err);\n        try {\nsynchronized (this) {\n            while (mission.psState == 3)             wait();\n          }\n        }\n catch (        InterruptedException e) {\n          Log.e(this.getClass().getSimpleName(),\"got InterruptedException\");\n        }\n        return mission.errCode == ERROR_NOTHING;\n      }\n;\n      result=process(out,sources);\n      if (result == OK_RESULT)       finalLength=out.finalizeFile();\n    }\n else {\n      result=OK_RESULT;\n    }\n  }\n  finally {\n    for (    SharpStream source : sources) {\n      if (source != null && !source.isClosed()) {\n        source.close();\n      }\n    }\n    if (out != null) {\n      out.close();\n    }\n    if (tempFile != null) {\n      tempFile.delete();\n      tempFile=null;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 283,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3067,
        "startLineNumber" : 125,
        "startColumnNumber" : 8,
        "endLineNumber" : 198,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (worksOnSameFile) {\n  ChunkFileInputStream[] sources=new ChunkFileInputStream[mission.urls.length];\n  try {\n    for (int i=0, j=1; i < sources.length; i++, j++) {\n      SharpStream source=mission.storage.getStream();\n      long end=j < sources.length ? mission.offsets[j] : source.length();\n      sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n    }\n    if (test(sources)) {\n      for (      SharpStream source : sources)       source.rewind();\n      OffsetChecker checker=() -> {\n        for (        ChunkFileInputStream source : sources) {\n          if (source.isClosed() || source.available() < 1) {\n            continue;\n          }\n          return source.getFilePointer() - 1;\n        }\n        return -1;\n      }\n;\n      out=new CircularFileWriter(mission.storage.getStream(),tempFile,checker);\n      out.onProgress=(      long position) -> mission.done=position;\n      out.onWriteError=(err) -> {\n        mission.psState=3;\n        mission.notifyError(ERROR_POSTPROCESSING_HOLD,err);\n        try {\nsynchronized (this) {\n            while (mission.psState == 3)             wait();\n          }\n        }\n catch (        InterruptedException e) {\n          Log.e(this.getClass().getSimpleName(),\"got InterruptedException\");\n        }\n        return mission.errCode == ERROR_NOTHING;\n      }\n;\n      result=process(out,sources);\n      if (result == OK_RESULT)       finalLength=out.finalizeFile();\n    }\n else {\n      result=OK_RESULT;\n    }\n  }\n  finally {\n    for (    SharpStream source : sources) {\n      if (source != null && !source.isClosed()) {\n        source.close();\n      }\n    }\n    if (out != null) {\n      out.close();\n    }\n    if (tempFile != null) {\n      tempFile.delete();\n      tempFile=null;\n    }\n  }\n}\n else {\n  result=test() ? process(null) : OK_RESULT;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 296,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3997,
        "startLineNumber" : 108,
        "startColumnNumber" : 63,
        "endLineNumber" : 212,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  this.mission=target;\n  CircularFileWriter out=null;\n  int result;\n  long finalLength=-1;\n  mission.done=0;\n  long length=mission.storage.length() - mission.offsets[0];\n  mission.length=length > mission.nearLength ? length : mission.nearLength;\n  final ProgressReport readProgress=(  long position) -> {\n    position-=mission.offsets[0];\n    if (position > mission.done)     mission.done=position;\n  }\n;\n  if (worksOnSameFile) {\n    ChunkFileInputStream[] sources=new ChunkFileInputStream[mission.urls.length];\n    try {\n      for (int i=0, j=1; i < sources.length; i++, j++) {\n        SharpStream source=mission.storage.getStream();\n        long end=j < sources.length ? mission.offsets[j] : source.length();\n        sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n      }\n      if (test(sources)) {\n        for (        SharpStream source : sources)         source.rewind();\n        OffsetChecker checker=() -> {\n          for (          ChunkFileInputStream source : sources) {\n            if (source.isClosed() || source.available() < 1) {\n              continue;\n            }\n            return source.getFilePointer() - 1;\n          }\n          return -1;\n        }\n;\n        out=new CircularFileWriter(mission.storage.getStream(),tempFile,checker);\n        out.onProgress=(        long position) -> mission.done=position;\n        out.onWriteError=(err) -> {\n          mission.psState=3;\n          mission.notifyError(ERROR_POSTPROCESSING_HOLD,err);\n          try {\nsynchronized (this) {\n              while (mission.psState == 3)               wait();\n            }\n          }\n catch (          InterruptedException e) {\n            Log.e(this.getClass().getSimpleName(),\"got InterruptedException\");\n          }\n          return mission.errCode == ERROR_NOTHING;\n        }\n;\n        result=process(out,sources);\n        if (result == OK_RESULT)         finalLength=out.finalizeFile();\n      }\n else {\n        result=OK_RESULT;\n      }\n    }\n  finally {\n      for (      SharpStream source : sources) {\n        if (source != null && !source.isClosed()) {\n          source.close();\n        }\n      }\n      if (out != null) {\n        out.close();\n      }\n      if (tempFile != null) {\n        tempFile.delete();\n        tempFile=null;\n      }\n    }\n  }\n else {\n    result=test() ? process(null) : OK_RESULT;\n  }\n  if (result == OK_RESULT) {\n    if (finalLength != -1) {\n      mission.length=finalLength;\n    }\n  }\n else {\n    mission.errCode=ERROR_POSTPROCESSING;\n    mission.errObject=new RuntimeException(\"post-processing algorithm returned \" + result);\n  }\n  if (result != OK_RESULT && worksOnSameFile)   mission.storage.delete();\n  this.mission=null;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 439,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4056,
        "startLineNumber" : 108,
        "startColumnNumber" : 4,
        "endLineNumber" : 212,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void run(DownloadMission target) throws IOException {\n  this.mission=target;\n  CircularFileWriter out=null;\n  int result;\n  long finalLength=-1;\n  mission.done=0;\n  long length=mission.storage.length() - mission.offsets[0];\n  mission.length=length > mission.nearLength ? length : mission.nearLength;\n  final ProgressReport readProgress=(  long position) -> {\n    position-=mission.offsets[0];\n    if (position > mission.done)     mission.done=position;\n  }\n;\n  if (worksOnSameFile) {\n    ChunkFileInputStream[] sources=new ChunkFileInputStream[mission.urls.length];\n    try {\n      for (int i=0, j=1; i < sources.length; i++, j++) {\n        SharpStream source=mission.storage.getStream();\n        long end=j < sources.length ? mission.offsets[j] : source.length();\n        sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n      }\n      if (test(sources)) {\n        for (        SharpStream source : sources)         source.rewind();\n        OffsetChecker checker=() -> {\n          for (          ChunkFileInputStream source : sources) {\n            if (source.isClosed() || source.available() < 1) {\n              continue;\n            }\n            return source.getFilePointer() - 1;\n          }\n          return -1;\n        }\n;\n        out=new CircularFileWriter(mission.storage.getStream(),tempFile,checker);\n        out.onProgress=(        long position) -> mission.done=position;\n        out.onWriteError=(err) -> {\n          mission.psState=3;\n          mission.notifyError(ERROR_POSTPROCESSING_HOLD,err);\n          try {\nsynchronized (this) {\n              while (mission.psState == 3)               wait();\n            }\n          }\n catch (          InterruptedException e) {\n            Log.e(this.getClass().getSimpleName(),\"got InterruptedException\");\n          }\n          return mission.errCode == ERROR_NOTHING;\n        }\n;\n        result=process(out,sources);\n        if (result == OK_RESULT)         finalLength=out.finalizeFile();\n      }\n else {\n        result=OK_RESULT;\n      }\n    }\n  finally {\n      for (      SharpStream source : sources) {\n        if (source != null && !source.isClosed()) {\n          source.close();\n        }\n      }\n      if (out != null) {\n        out.close();\n      }\n      if (tempFile != null) {\n        tempFile.delete();\n        tempFile=null;\n      }\n    }\n  }\n else {\n    result=test() ? process(null) : OK_RESULT;\n  }\n  if (result == OK_RESULT) {\n    if (finalLength != -1) {\n      mission.length=finalLength;\n    }\n  }\n else {\n    mission.errCode=ERROR_POSTPROCESSING;\n    mission.errObject=new RuntimeException(\"post-processing algorithm returned \" + result);\n  }\n  if (result != OK_RESULT && worksOnSameFile)   mission.storage.delete();\n  this.mission=null;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 449,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 85,
        "startLineNumber" : 132,
        "startColumnNumber" : 20,
        "endLineNumber" : 132,
        "endColumnNumber" : 105
      },
      "nodeContext" : "sources[i]=new ChunkFileInputStream(source,mission.offsets[i],end,readProgress);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 16,
      "astHeight" : 6
    },
    "tokenLength" : 3,
    "type" : "long"
  } ],
  "positionList" : [ {
    "charLength" : 18,
    "startLineNumber" : 132,
    "startColumnNumber" : 66,
    "endLineNumber" : 132,
    "endColumnNumber" : 84
  } ],
  "layoutRelationDataList" : [ ]
}