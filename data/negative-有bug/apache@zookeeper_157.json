{
  "id" : 157,
  "expression" : "Leader.NEWLEADER",
  "projectName" : "apache@zookeeper",
  "commitID" : "c6639c9842973a7954c8baa412d6825cb833d51f",
  "filePath" : "/src/java/main/org/apache/zookeeper/server/quorum/Follower.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "Leader.NEWLEADER",
    "nodeType" : "QualifiedName",
    "nodePosition" : {
      "charLength" : 16,
      "startLineNumber" : 176,
      "startColumnNumber" : 36,
      "endLineNumber" : 176,
      "endColumnNumber" : 52
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 176,
        "startColumnNumber" : 20,
        "endLineNumber" : 176,
        "endColumnNumber" : 52
      },
      "nodeContext" : "qp.getType() != Leader.NEWLEADER",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 217,
        "startLineNumber" : 176,
        "startColumnNumber" : 16,
        "endLineNumber" : 179,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (qp.getType() != Leader.NEWLEADER) {\n  LOG.error(\"First packet should have been NEWLEADER\");\n  throw new IOException(\"First packet should have been NEWLEADER\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 19,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 7368,
        "startLineNumber" : 142,
        "startColumnNumber" : 16,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  QuorumPacket ack=new QuorumPacket(Leader.ACK,0,null,null);\n  sock.setSoTimeout(self.tickTime * self.initLimit);\n  for (int tries=0; tries < 5; tries++) {\n    try {\n      sock.connect(addr,self.tickTime * self.syncLimit);\n      sock.setTcpNoDelay(true);\n      break;\n    }\n catch (    ConnectException e) {\n      if (tries == 4) {\n        LOG.error(\"Unexpected exception\",e);\n        throw e;\n      }\n else {\n        LOG.warn(\"Unexpected exception, tries=\" + tries,e);\n        sock=new Socket();\n        sock.setSoTimeout(self.tickTime * self.initLimit);\n      }\n    }\n    Thread.sleep(1000);\n  }\n  leaderIs=BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));\n  bufferedOutput=new BufferedOutputStream(sock.getOutputStream());\n  leaderOs=BinaryOutputArchive.getArchive(bufferedOutput);\n  QuorumPacket qp=new QuorumPacket();\n  qp.setType(Leader.LASTZXID);\n  long sentLastZxid=self.getLastLoggedZxid();\n  qp.setZxid(sentLastZxid);\n  writePacket(qp);\n  readPacket(qp);\n  long newLeaderZxid=qp.getZxid();\n  if (qp.getType() != Leader.NEWLEADER) {\n    LOG.error(\"First packet should have been NEWLEADER\");\n    throw new IOException(\"First packet should have been NEWLEADER\");\n  }\n  readPacket(qp);\nsynchronized (zk) {\n    if (qp.getType() == Leader.DIFF) {\n      LOG.info(\"Getting a diff from the leader!\");\n      zk.loadData();\n    }\n else     if (qp.getType() == Leader.SNAP) {\n      LOG.info(\"Getting a snapshot from leader\");\n      zk.deserializeSnapshot(leaderIs);\n      String signature=leaderIs.readString(\"signature\");\n      if (!signature.equals(\"BenWasHere\")) {\n        LOG.error(\"Missing signature. Got \" + signature);\n        throw new IOException(\"Missing signature\");\n      }\n    }\n else     if (qp.getType() == Leader.TRUNC) {\n      LOG.warn(\"Truncating log to get in sync with the leader 0x\" + Long.toHexString(qp.getZxid()));\n      boolean truncated=zk.getLogWriter().truncateLog(qp.getZxid());\n      if (!truncated) {\n        LOG.fatal(\"Not able to truncate the log \" + Long.toHexString(qp.getZxid()));\n        System.exit(13);\n      }\n      zk.loadData();\n    }\n else {\n      LOG.fatal(\"Got unexpected packet from leader \" + qp.getType() + \" exiting ... \");\n      System.exit(13);\n    }\n    zk.dataTree.lastProcessedZxid=newLeaderZxid;\n  }\n  ack.setZxid(newLeaderZxid & ~0xffffffffL);\n  writePacket(ack);\n  sock.setSoTimeout(self.tickTime * self.syncLimit);\n  zk.startup();\n  while (self.running) {\n    readPacket(qp);\nswitch (qp.getType()) {\ncase Leader.PING:      ByteArrayOutputStream bos=new ByteArrayOutputStream();\n    DataOutputStream dos=new DataOutputStream(bos);\n  HashMap<Long,Integer> touchTable=zk.getTouchSnapshot();\nfor (Entry<Long,Integer> entry : touchTable.entrySet()) {\n  dos.writeLong(entry.getKey());\n  dos.writeInt(entry.getValue());\n}\nqp.setData(bos.toByteArray());\nwritePacket(qp);\nbreak;\ncase Leader.PROPOSAL:TxnHeader hdr=new TxnHeader();\nBinaryInputArchive ia=BinaryInputArchive.getArchive(new ByteArrayInputStream(qp.getData()));\nRecord txn=SerializeUtils.deserializeTxn(ia,hdr);\nif (hdr.getZxid() != lastQueued + 1) {\nLOG.warn(\"Got zxid 0x\" + Long.toHexString(hdr.getZxid()) + \" expected 0x\"+ Long.toHexString(lastQueued + 1));\n}\nlastQueued=hdr.getZxid();\nzk.logRequest(hdr,txn);\nbreak;\ncase Leader.COMMIT:zk.commit(qp.getZxid());\nbreak;\ncase Leader.UPTODATE:zk.takeSnapshot();\nself.cnxnFactory.setZooKeeperServer(zk);\nbreak;\ncase Leader.REVALIDATE:ByteArrayInputStream bis=new ByteArrayInputStream(qp.getData());\nDataInputStream dis=new DataInputStream(bis);\nlong sessionId=dis.readLong();\nboolean valid=dis.readBoolean();\nsynchronized (pendingRevalidations) {\nServerCnxn cnxn=pendingRevalidations.remove(sessionId);\nif (cnxn == null) {\nLOG.warn(\"Missing session 0x\" + Long.toHexString(sessionId) + \" for validation\");\n}\n else {\ncnxn.finishSessionInit(valid);\n}\n}\nZooTrace.logTraceMessage(LOG,ZooTrace.SESSION_TRACE_MASK,\"Session 0x\" + Long.toHexString(sessionId) + \" is valid: \"+ valid);\nbreak;\ncase Leader.SYNC:zk.sync();\nbreak;\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 668,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7867,
        "startLineNumber" : 142,
        "startColumnNumber" : 12,
        "endLineNumber" : 297,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  QuorumPacket ack=new QuorumPacket(Leader.ACK,0,null,null);\n  sock.setSoTimeout(self.tickTime * self.initLimit);\n  for (int tries=0; tries < 5; tries++) {\n    try {\n      sock.connect(addr,self.tickTime * self.syncLimit);\n      sock.setTcpNoDelay(true);\n      break;\n    }\n catch (    ConnectException e) {\n      if (tries == 4) {\n        LOG.error(\"Unexpected exception\",e);\n        throw e;\n      }\n else {\n        LOG.warn(\"Unexpected exception, tries=\" + tries,e);\n        sock=new Socket();\n        sock.setSoTimeout(self.tickTime * self.initLimit);\n      }\n    }\n    Thread.sleep(1000);\n  }\n  leaderIs=BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));\n  bufferedOutput=new BufferedOutputStream(sock.getOutputStream());\n  leaderOs=BinaryOutputArchive.getArchive(bufferedOutput);\n  QuorumPacket qp=new QuorumPacket();\n  qp.setType(Leader.LASTZXID);\n  long sentLastZxid=self.getLastLoggedZxid();\n  qp.setZxid(sentLastZxid);\n  writePacket(qp);\n  readPacket(qp);\n  long newLeaderZxid=qp.getZxid();\n  if (qp.getType() != Leader.NEWLEADER) {\n    LOG.error(\"First packet should have been NEWLEADER\");\n    throw new IOException(\"First packet should have been NEWLEADER\");\n  }\n  readPacket(qp);\nsynchronized (zk) {\n    if (qp.getType() == Leader.DIFF) {\n      LOG.info(\"Getting a diff from the leader!\");\n      zk.loadData();\n    }\n else     if (qp.getType() == Leader.SNAP) {\n      LOG.info(\"Getting a snapshot from leader\");\n      zk.deserializeSnapshot(leaderIs);\n      String signature=leaderIs.readString(\"signature\");\n      if (!signature.equals(\"BenWasHere\")) {\n        LOG.error(\"Missing signature. Got \" + signature);\n        throw new IOException(\"Missing signature\");\n      }\n    }\n else     if (qp.getType() == Leader.TRUNC) {\n      LOG.warn(\"Truncating log to get in sync with the leader 0x\" + Long.toHexString(qp.getZxid()));\n      boolean truncated=zk.getLogWriter().truncateLog(qp.getZxid());\n      if (!truncated) {\n        LOG.fatal(\"Not able to truncate the log \" + Long.toHexString(qp.getZxid()));\n        System.exit(13);\n      }\n      zk.loadData();\n    }\n else {\n      LOG.fatal(\"Got unexpected packet from leader \" + qp.getType() + \" exiting ... \");\n      System.exit(13);\n    }\n    zk.dataTree.lastProcessedZxid=newLeaderZxid;\n  }\n  ack.setZxid(newLeaderZxid & ~0xffffffffL);\n  writePacket(ack);\n  sock.setSoTimeout(self.tickTime * self.syncLimit);\n  zk.startup();\n  while (self.running) {\n    readPacket(qp);\nswitch (qp.getType()) {\ncase Leader.PING:      ByteArrayOutputStream bos=new ByteArrayOutputStream();\n    DataOutputStream dos=new DataOutputStream(bos);\n  HashMap<Long,Integer> touchTable=zk.getTouchSnapshot();\nfor (Entry<Long,Integer> entry : touchTable.entrySet()) {\n  dos.writeLong(entry.getKey());\n  dos.writeInt(entry.getValue());\n}\nqp.setData(bos.toByteArray());\nwritePacket(qp);\nbreak;\ncase Leader.PROPOSAL:TxnHeader hdr=new TxnHeader();\nBinaryInputArchive ia=BinaryInputArchive.getArchive(new ByteArrayInputStream(qp.getData()));\nRecord txn=SerializeUtils.deserializeTxn(ia,hdr);\nif (hdr.getZxid() != lastQueued + 1) {\nLOG.warn(\"Got zxid 0x\" + Long.toHexString(hdr.getZxid()) + \" expected 0x\"+ Long.toHexString(lastQueued + 1));\n}\nlastQueued=hdr.getZxid();\nzk.logRequest(hdr,txn);\nbreak;\ncase Leader.COMMIT:zk.commit(qp.getZxid());\nbreak;\ncase Leader.UPTODATE:zk.takeSnapshot();\nself.cnxnFactory.setZooKeeperServer(zk);\nbreak;\ncase Leader.REVALIDATE:ByteArrayInputStream bis=new ByteArrayInputStream(qp.getData());\nDataInputStream dis=new DataInputStream(bis);\nlong sessionId=dis.readLong();\nboolean valid=dis.readBoolean();\nsynchronized (pendingRevalidations) {\nServerCnxn cnxn=pendingRevalidations.remove(sessionId);\nif (cnxn == null) {\nLOG.warn(\"Missing session 0x\" + Long.toHexString(sessionId) + \" for validation\");\n}\n else {\ncnxn.finishSessionInit(valid);\n}\n}\nZooTrace.logTraceMessage(LOG,ZooTrace.SESSION_TRACE_MASK,\"Session 0x\" + Long.toHexString(sessionId) + \" is valid: \"+ valid);\nbreak;\ncase Leader.SYNC:zk.sync();\nbreak;\n}\n}\n}\n catch (IOException e) {\nLOG.warn(\"Exception when following the leader\",e);\ntry {\nsock.close();\n}\n catch (IOException e1) {\ne1.printStackTrace();\n}\nsynchronized (pendingRevalidations) {\npendingRevalidations.clear();\npendingRevalidations.notifyAll();\n}\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 708,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 8444,
        "startLineNumber" : 126,
        "startColumnNumber" : 12,
        "endLineNumber" : 298,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  InetSocketAddress addr=null;\n  Vote current=self.getCurrentVote();\n  for (  QuorumServer s : self.quorumPeers.values()) {\n    if (s.id == current.id) {\n      addr=s.addr;\n      break;\n    }\n  }\n  if (addr == null) {\n    LOG.warn(\"Couldn't find the leader with id = \" + current.id);\n  }\n  LOG.info(\"Following \" + addr);\n  sock=new Socket();\n  try {\n    QuorumPacket ack=new QuorumPacket(Leader.ACK,0,null,null);\n    sock.setSoTimeout(self.tickTime * self.initLimit);\n    for (int tries=0; tries < 5; tries++) {\n      try {\n        sock.connect(addr,self.tickTime * self.syncLimit);\n        sock.setTcpNoDelay(true);\n        break;\n      }\n catch (      ConnectException e) {\n        if (tries == 4) {\n          LOG.error(\"Unexpected exception\",e);\n          throw e;\n        }\n else {\n          LOG.warn(\"Unexpected exception, tries=\" + tries,e);\n          sock=new Socket();\n          sock.setSoTimeout(self.tickTime * self.initLimit);\n        }\n      }\n      Thread.sleep(1000);\n    }\n    leaderIs=BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));\n    bufferedOutput=new BufferedOutputStream(sock.getOutputStream());\n    leaderOs=BinaryOutputArchive.getArchive(bufferedOutput);\n    QuorumPacket qp=new QuorumPacket();\n    qp.setType(Leader.LASTZXID);\n    long sentLastZxid=self.getLastLoggedZxid();\n    qp.setZxid(sentLastZxid);\n    writePacket(qp);\n    readPacket(qp);\n    long newLeaderZxid=qp.getZxid();\n    if (qp.getType() != Leader.NEWLEADER) {\n      LOG.error(\"First packet should have been NEWLEADER\");\n      throw new IOException(\"First packet should have been NEWLEADER\");\n    }\n    readPacket(qp);\nsynchronized (zk) {\n      if (qp.getType() == Leader.DIFF) {\n        LOG.info(\"Getting a diff from the leader!\");\n        zk.loadData();\n      }\n else       if (qp.getType() == Leader.SNAP) {\n        LOG.info(\"Getting a snapshot from leader\");\n        zk.deserializeSnapshot(leaderIs);\n        String signature=leaderIs.readString(\"signature\");\n        if (!signature.equals(\"BenWasHere\")) {\n          LOG.error(\"Missing signature. Got \" + signature);\n          throw new IOException(\"Missing signature\");\n        }\n      }\n else       if (qp.getType() == Leader.TRUNC) {\n        LOG.warn(\"Truncating log to get in sync with the leader 0x\" + Long.toHexString(qp.getZxid()));\n        boolean truncated=zk.getLogWriter().truncateLog(qp.getZxid());\n        if (!truncated) {\n          LOG.fatal(\"Not able to truncate the log \" + Long.toHexString(qp.getZxid()));\n          System.exit(13);\n        }\n        zk.loadData();\n      }\n else {\n        LOG.fatal(\"Got unexpected packet from leader \" + qp.getType() + \" exiting ... \");\n        System.exit(13);\n      }\n      zk.dataTree.lastProcessedZxid=newLeaderZxid;\n    }\n    ack.setZxid(newLeaderZxid & ~0xffffffffL);\n    writePacket(ack);\n    sock.setSoTimeout(self.tickTime * self.syncLimit);\n    zk.startup();\n    while (self.running) {\n      readPacket(qp);\nswitch (qp.getType()) {\ncase Leader.PING:        ByteArrayOutputStream bos=new ByteArrayOutputStream();\n      DataOutputStream dos=new DataOutputStream(bos);\n    HashMap<Long,Integer> touchTable=zk.getTouchSnapshot();\n  for (  Entry<Long,Integer> entry : touchTable.entrySet()) {\n    dos.writeLong(entry.getKey());\n    dos.writeInt(entry.getValue());\n  }\nqp.setData(bos.toByteArray());\nwritePacket(qp);\nbreak;\ncase Leader.PROPOSAL:TxnHeader hdr=new TxnHeader();\nBinaryInputArchive ia=BinaryInputArchive.getArchive(new ByteArrayInputStream(qp.getData()));\nRecord txn=SerializeUtils.deserializeTxn(ia,hdr);\nif (hdr.getZxid() != lastQueued + 1) {\nLOG.warn(\"Got zxid 0x\" + Long.toHexString(hdr.getZxid()) + \" expected 0x\"+ Long.toHexString(lastQueued + 1));\n}\nlastQueued=hdr.getZxid();\nzk.logRequest(hdr,txn);\nbreak;\ncase Leader.COMMIT:zk.commit(qp.getZxid());\nbreak;\ncase Leader.UPTODATE:zk.takeSnapshot();\nself.cnxnFactory.setZooKeeperServer(zk);\nbreak;\ncase Leader.REVALIDATE:ByteArrayInputStream bis=new ByteArrayInputStream(qp.getData());\nDataInputStream dis=new DataInputStream(bis);\nlong sessionId=dis.readLong();\nboolean valid=dis.readBoolean();\nsynchronized (pendingRevalidations) {\nServerCnxn cnxn=pendingRevalidations.remove(sessionId);\nif (cnxn == null) {\nLOG.warn(\"Missing session 0x\" + Long.toHexString(sessionId) + \" for validation\");\n}\n else {\ncnxn.finishSessionInit(valid);\n}\n}\nZooTrace.logTraceMessage(LOG,ZooTrace.SESSION_TRACE_MASK,\"Session 0x\" + Long.toHexString(sessionId) + \" is valid: \"+ valid);\nbreak;\ncase Leader.SYNC:zk.sync();\nbreak;\n}\n}\n}\n catch (IOException e) {\nLOG.warn(\"Exception when following the leader\",e);\ntry {\nsock.close();\n}\n catch (IOException e1) {\ne1.printStackTrace();\n}\nsynchronized (pendingRevalidations) {\npendingRevalidations.clear();\npendingRevalidations.notifyAll();\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 777,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8504,
        "startLineNumber" : 126,
        "startColumnNumber" : 8,
        "endLineNumber" : 300,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try {\n  InetSocketAddress addr=null;\n  Vote current=self.getCurrentVote();\n  for (  QuorumServer s : self.quorumPeers.values()) {\n    if (s.id == current.id) {\n      addr=s.addr;\n      break;\n    }\n  }\n  if (addr == null) {\n    LOG.warn(\"Couldn't find the leader with id = \" + current.id);\n  }\n  LOG.info(\"Following \" + addr);\n  sock=new Socket();\n  try {\n    QuorumPacket ack=new QuorumPacket(Leader.ACK,0,null,null);\n    sock.setSoTimeout(self.tickTime * self.initLimit);\n    for (int tries=0; tries < 5; tries++) {\n      try {\n        sock.connect(addr,self.tickTime * self.syncLimit);\n        sock.setTcpNoDelay(true);\n        break;\n      }\n catch (      ConnectException e) {\n        if (tries == 4) {\n          LOG.error(\"Unexpected exception\",e);\n          throw e;\n        }\n else {\n          LOG.warn(\"Unexpected exception, tries=\" + tries,e);\n          sock=new Socket();\n          sock.setSoTimeout(self.tickTime * self.initLimit);\n        }\n      }\n      Thread.sleep(1000);\n    }\n    leaderIs=BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));\n    bufferedOutput=new BufferedOutputStream(sock.getOutputStream());\n    leaderOs=BinaryOutputArchive.getArchive(bufferedOutput);\n    QuorumPacket qp=new QuorumPacket();\n    qp.setType(Leader.LASTZXID);\n    long sentLastZxid=self.getLastLoggedZxid();\n    qp.setZxid(sentLastZxid);\n    writePacket(qp);\n    readPacket(qp);\n    long newLeaderZxid=qp.getZxid();\n    if (qp.getType() != Leader.NEWLEADER) {\n      LOG.error(\"First packet should have been NEWLEADER\");\n      throw new IOException(\"First packet should have been NEWLEADER\");\n    }\n    readPacket(qp);\nsynchronized (zk) {\n      if (qp.getType() == Leader.DIFF) {\n        LOG.info(\"Getting a diff from the leader!\");\n        zk.loadData();\n      }\n else       if (qp.getType() == Leader.SNAP) {\n        LOG.info(\"Getting a snapshot from leader\");\n        zk.deserializeSnapshot(leaderIs);\n        String signature=leaderIs.readString(\"signature\");\n        if (!signature.equals(\"BenWasHere\")) {\n          LOG.error(\"Missing signature. Got \" + signature);\n          throw new IOException(\"Missing signature\");\n        }\n      }\n else       if (qp.getType() == Leader.TRUNC) {\n        LOG.warn(\"Truncating log to get in sync with the leader 0x\" + Long.toHexString(qp.getZxid()));\n        boolean truncated=zk.getLogWriter().truncateLog(qp.getZxid());\n        if (!truncated) {\n          LOG.fatal(\"Not able to truncate the log \" + Long.toHexString(qp.getZxid()));\n          System.exit(13);\n        }\n        zk.loadData();\n      }\n else {\n        LOG.fatal(\"Got unexpected packet from leader \" + qp.getType() + \" exiting ... \");\n        System.exit(13);\n      }\n      zk.dataTree.lastProcessedZxid=newLeaderZxid;\n    }\n    ack.setZxid(newLeaderZxid & ~0xffffffffL);\n    writePacket(ack);\n    sock.setSoTimeout(self.tickTime * self.syncLimit);\n    zk.startup();\n    while (self.running) {\n      readPacket(qp);\nswitch (qp.getType()) {\ncase Leader.PING:        ByteArrayOutputStream bos=new ByteArrayOutputStream();\n      DataOutputStream dos=new DataOutputStream(bos);\n    HashMap<Long,Integer> touchTable=zk.getTouchSnapshot();\n  for (  Entry<Long,Integer> entry : touchTable.entrySet()) {\n    dos.writeLong(entry.getKey());\n    dos.writeInt(entry.getValue());\n  }\nqp.setData(bos.toByteArray());\nwritePacket(qp);\nbreak;\ncase Leader.PROPOSAL:TxnHeader hdr=new TxnHeader();\nBinaryInputArchive ia=BinaryInputArchive.getArchive(new ByteArrayInputStream(qp.getData()));\nRecord txn=SerializeUtils.deserializeTxn(ia,hdr);\nif (hdr.getZxid() != lastQueued + 1) {\nLOG.warn(\"Got zxid 0x\" + Long.toHexString(hdr.getZxid()) + \" expected 0x\"+ Long.toHexString(lastQueued + 1));\n}\nlastQueued=hdr.getZxid();\nzk.logRequest(hdr,txn);\nbreak;\ncase Leader.COMMIT:zk.commit(qp.getZxid());\nbreak;\ncase Leader.UPTODATE:zk.takeSnapshot();\nself.cnxnFactory.setZooKeeperServer(zk);\nbreak;\ncase Leader.REVALIDATE:ByteArrayInputStream bis=new ByteArrayInputStream(qp.getData());\nDataInputStream dis=new DataInputStream(bis);\nlong sessionId=dis.readLong();\nboolean valid=dis.readBoolean();\nsynchronized (pendingRevalidations) {\nServerCnxn cnxn=pendingRevalidations.remove(sessionId);\nif (cnxn == null) {\nLOG.warn(\"Missing session 0x\" + Long.toHexString(sessionId) + \" for validation\");\n}\n else {\ncnxn.finishSessionInit(valid);\n}\n}\nZooTrace.logTraceMessage(LOG,ZooTrace.SESSION_TRACE_MASK,\"Session 0x\" + Long.toHexString(sessionId) + \" is valid: \"+ valid);\nbreak;\ncase Leader.SYNC:zk.sync();\nbreak;\n}\n}\n}\n catch (IOException e) {\nLOG.warn(\"Exception when following the leader\",e);\ntry {\nsock.close();\n}\n catch (IOException e1) {\ne1.printStackTrace();\n}\nsynchronized (pendingRevalidations) {\npendingRevalidations.clear();\npendingRevalidations.notifyAll();\n}\n}\n}\n  finally {\nzk.unregisterJMX(this);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 784,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 8596,
        "startLineNumber" : 123,
        "startColumnNumber" : 52,
        "endLineNumber" : 301,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  zk.registerJMX(new FollowerBean(this,zk),self.jmxLocalPeerBean);\n  try {\n    InetSocketAddress addr=null;\n    Vote current=self.getCurrentVote();\n    for (    QuorumServer s : self.quorumPeers.values()) {\n      if (s.id == current.id) {\n        addr=s.addr;\n        break;\n      }\n    }\n    if (addr == null) {\n      LOG.warn(\"Couldn't find the leader with id = \" + current.id);\n    }\n    LOG.info(\"Following \" + addr);\n    sock=new Socket();\n    try {\n      QuorumPacket ack=new QuorumPacket(Leader.ACK,0,null,null);\n      sock.setSoTimeout(self.tickTime * self.initLimit);\n      for (int tries=0; tries < 5; tries++) {\n        try {\n          sock.connect(addr,self.tickTime * self.syncLimit);\n          sock.setTcpNoDelay(true);\n          break;\n        }\n catch (        ConnectException e) {\n          if (tries == 4) {\n            LOG.error(\"Unexpected exception\",e);\n            throw e;\n          }\n else {\n            LOG.warn(\"Unexpected exception, tries=\" + tries,e);\n            sock=new Socket();\n            sock.setSoTimeout(self.tickTime * self.initLimit);\n          }\n        }\n        Thread.sleep(1000);\n      }\n      leaderIs=BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));\n      bufferedOutput=new BufferedOutputStream(sock.getOutputStream());\n      leaderOs=BinaryOutputArchive.getArchive(bufferedOutput);\n      QuorumPacket qp=new QuorumPacket();\n      qp.setType(Leader.LASTZXID);\n      long sentLastZxid=self.getLastLoggedZxid();\n      qp.setZxid(sentLastZxid);\n      writePacket(qp);\n      readPacket(qp);\n      long newLeaderZxid=qp.getZxid();\n      if (qp.getType() != Leader.NEWLEADER) {\n        LOG.error(\"First packet should have been NEWLEADER\");\n        throw new IOException(\"First packet should have been NEWLEADER\");\n      }\n      readPacket(qp);\nsynchronized (zk) {\n        if (qp.getType() == Leader.DIFF) {\n          LOG.info(\"Getting a diff from the leader!\");\n          zk.loadData();\n        }\n else         if (qp.getType() == Leader.SNAP) {\n          LOG.info(\"Getting a snapshot from leader\");\n          zk.deserializeSnapshot(leaderIs);\n          String signature=leaderIs.readString(\"signature\");\n          if (!signature.equals(\"BenWasHere\")) {\n            LOG.error(\"Missing signature. Got \" + signature);\n            throw new IOException(\"Missing signature\");\n          }\n        }\n else         if (qp.getType() == Leader.TRUNC) {\n          LOG.warn(\"Truncating log to get in sync with the leader 0x\" + Long.toHexString(qp.getZxid()));\n          boolean truncated=zk.getLogWriter().truncateLog(qp.getZxid());\n          if (!truncated) {\n            LOG.fatal(\"Not able to truncate the log \" + Long.toHexString(qp.getZxid()));\n            System.exit(13);\n          }\n          zk.loadData();\n        }\n else {\n          LOG.fatal(\"Got unexpected packet from leader \" + qp.getType() + \" exiting ... \");\n          System.exit(13);\n        }\n        zk.dataTree.lastProcessedZxid=newLeaderZxid;\n      }\n      ack.setZxid(newLeaderZxid & ~0xffffffffL);\n      writePacket(ack);\n      sock.setSoTimeout(self.tickTime * self.syncLimit);\n      zk.startup();\n      while (self.running) {\n        readPacket(qp);\nswitch (qp.getType()) {\ncase Leader.PING:          ByteArrayOutputStream bos=new ByteArrayOutputStream();\n        DataOutputStream dos=new DataOutputStream(bos);\n      HashMap<Long,Integer> touchTable=zk.getTouchSnapshot();\n    for (    Entry<Long,Integer> entry : touchTable.entrySet()) {\n      dos.writeLong(entry.getKey());\n      dos.writeInt(entry.getValue());\n    }\n  qp.setData(bos.toByteArray());\nwritePacket(qp);\nbreak;\ncase Leader.PROPOSAL:TxnHeader hdr=new TxnHeader();\nBinaryInputArchive ia=BinaryInputArchive.getArchive(new ByteArrayInputStream(qp.getData()));\nRecord txn=SerializeUtils.deserializeTxn(ia,hdr);\nif (hdr.getZxid() != lastQueued + 1) {\nLOG.warn(\"Got zxid 0x\" + Long.toHexString(hdr.getZxid()) + \" expected 0x\"+ Long.toHexString(lastQueued + 1));\n}\nlastQueued=hdr.getZxid();\nzk.logRequest(hdr,txn);\nbreak;\ncase Leader.COMMIT:zk.commit(qp.getZxid());\nbreak;\ncase Leader.UPTODATE:zk.takeSnapshot();\nself.cnxnFactory.setZooKeeperServer(zk);\nbreak;\ncase Leader.REVALIDATE:ByteArrayInputStream bis=new ByteArrayInputStream(qp.getData());\nDataInputStream dis=new DataInputStream(bis);\nlong sessionId=dis.readLong();\nboolean valid=dis.readBoolean();\nsynchronized (pendingRevalidations) {\nServerCnxn cnxn=pendingRevalidations.remove(sessionId);\nif (cnxn == null) {\nLOG.warn(\"Missing session 0x\" + Long.toHexString(sessionId) + \" for validation\");\n}\n else {\ncnxn.finishSessionInit(valid);\n}\n}\nZooTrace.logTraceMessage(LOG,ZooTrace.SESSION_TRACE_MASK,\"Session 0x\" + Long.toHexString(sessionId) + \" is valid: \"+ valid);\nbreak;\ncase Leader.SYNC:zk.sync();\nbreak;\n}\n}\n}\n catch (IOException e) {\nLOG.warn(\"Exception when following the leader\",e);\ntry {\nsock.close();\n}\n catch (IOException e1) {\ne1.printStackTrace();\n}\nsynchronized (pendingRevalidations) {\npendingRevalidations.clear();\npendingRevalidations.notifyAll();\n}\n}\n}\n  finally {\nzk.unregisterJMX(this);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 797,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 8770,
        "startLineNumber" : 118,
        "startColumnNumber" : 4,
        "endLineNumber" : 301,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * the main method called by the follower to follow the leader\n * @throws InterruptedException\n */\nvoid followLeader() throws InterruptedException {\n  zk.registerJMX(new FollowerBean(this,zk),self.jmxLocalPeerBean);\n  try {\n    InetSocketAddress addr=null;\n    Vote current=self.getCurrentVote();\n    for (    QuorumServer s : self.quorumPeers.values()) {\n      if (s.id == current.id) {\n        addr=s.addr;\n        break;\n      }\n    }\n    if (addr == null) {\n      LOG.warn(\"Couldn't find the leader with id = \" + current.id);\n    }\n    LOG.info(\"Following \" + addr);\n    sock=new Socket();\n    try {\n      QuorumPacket ack=new QuorumPacket(Leader.ACK,0,null,null);\n      sock.setSoTimeout(self.tickTime * self.initLimit);\n      for (int tries=0; tries < 5; tries++) {\n        try {\n          sock.connect(addr,self.tickTime * self.syncLimit);\n          sock.setTcpNoDelay(true);\n          break;\n        }\n catch (        ConnectException e) {\n          if (tries == 4) {\n            LOG.error(\"Unexpected exception\",e);\n            throw e;\n          }\n else {\n            LOG.warn(\"Unexpected exception, tries=\" + tries,e);\n            sock=new Socket();\n            sock.setSoTimeout(self.tickTime * self.initLimit);\n          }\n        }\n        Thread.sleep(1000);\n      }\n      leaderIs=BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));\n      bufferedOutput=new BufferedOutputStream(sock.getOutputStream());\n      leaderOs=BinaryOutputArchive.getArchive(bufferedOutput);\n      QuorumPacket qp=new QuorumPacket();\n      qp.setType(Leader.LASTZXID);\n      long sentLastZxid=self.getLastLoggedZxid();\n      qp.setZxid(sentLastZxid);\n      writePacket(qp);\n      readPacket(qp);\n      long newLeaderZxid=qp.getZxid();\n      if (qp.getType() != Leader.NEWLEADER) {\n        LOG.error(\"First packet should have been NEWLEADER\");\n        throw new IOException(\"First packet should have been NEWLEADER\");\n      }\n      readPacket(qp);\nsynchronized (zk) {\n        if (qp.getType() == Leader.DIFF) {\n          LOG.info(\"Getting a diff from the leader!\");\n          zk.loadData();\n        }\n else         if (qp.getType() == Leader.SNAP) {\n          LOG.info(\"Getting a snapshot from leader\");\n          zk.deserializeSnapshot(leaderIs);\n          String signature=leaderIs.readString(\"signature\");\n          if (!signature.equals(\"BenWasHere\")) {\n            LOG.error(\"Missing signature. Got \" + signature);\n            throw new IOException(\"Missing signature\");\n          }\n        }\n else         if (qp.getType() == Leader.TRUNC) {\n          LOG.warn(\"Truncating log to get in sync with the leader 0x\" + Long.toHexString(qp.getZxid()));\n          boolean truncated=zk.getLogWriter().truncateLog(qp.getZxid());\n          if (!truncated) {\n            LOG.fatal(\"Not able to truncate the log \" + Long.toHexString(qp.getZxid()));\n            System.exit(13);\n          }\n          zk.loadData();\n        }\n else {\n          LOG.fatal(\"Got unexpected packet from leader \" + qp.getType() + \" exiting ... \");\n          System.exit(13);\n        }\n        zk.dataTree.lastProcessedZxid=newLeaderZxid;\n      }\n      ack.setZxid(newLeaderZxid & ~0xffffffffL);\n      writePacket(ack);\n      sock.setSoTimeout(self.tickTime * self.syncLimit);\n      zk.startup();\n      while (self.running) {\n        readPacket(qp);\nswitch (qp.getType()) {\ncase Leader.PING:          ByteArrayOutputStream bos=new ByteArrayOutputStream();\n        DataOutputStream dos=new DataOutputStream(bos);\n      HashMap<Long,Integer> touchTable=zk.getTouchSnapshot();\n    for (    Entry<Long,Integer> entry : touchTable.entrySet()) {\n      dos.writeLong(entry.getKey());\n      dos.writeInt(entry.getValue());\n    }\n  qp.setData(bos.toByteArray());\nwritePacket(qp);\nbreak;\ncase Leader.PROPOSAL:TxnHeader hdr=new TxnHeader();\nBinaryInputArchive ia=BinaryInputArchive.getArchive(new ByteArrayInputStream(qp.getData()));\nRecord txn=SerializeUtils.deserializeTxn(ia,hdr);\nif (hdr.getZxid() != lastQueued + 1) {\nLOG.warn(\"Got zxid 0x\" + Long.toHexString(hdr.getZxid()) + \" expected 0x\"+ Long.toHexString(lastQueued + 1));\n}\nlastQueued=hdr.getZxid();\nzk.logRequest(hdr,txn);\nbreak;\ncase Leader.COMMIT:zk.commit(qp.getZxid());\nbreak;\ncase Leader.UPTODATE:zk.takeSnapshot();\nself.cnxnFactory.setZooKeeperServer(zk);\nbreak;\ncase Leader.REVALIDATE:ByteArrayInputStream bis=new ByteArrayInputStream(qp.getData());\nDataInputStream dis=new DataInputStream(bis);\nlong sessionId=dis.readLong();\nboolean valid=dis.readBoolean();\nsynchronized (pendingRevalidations) {\nServerCnxn cnxn=pendingRevalidations.remove(sessionId);\nif (cnxn == null) {\nLOG.warn(\"Missing session 0x\" + Long.toHexString(sessionId) + \" for validation\");\n}\n else {\ncnxn.finishSessionInit(valid);\n}\n}\nZooTrace.logTraceMessage(LOG,ZooTrace.SESSION_TRACE_MASK,\"Session 0x\" + Long.toHexString(sessionId) + \" is valid: \"+ valid);\nbreak;\ncase Leader.SYNC:zk.sync();\nbreak;\n}\n}\n}\n catch (IOException e) {\nLOG.warn(\"Exception when following the leader\",e);\ntry {\nsock.close();\n}\n catch (IOException e1) {\ne1.printStackTrace();\n}\nsynchronized (pendingRevalidations) {\npendingRevalidations.clear();\npendingRevalidations.notifyAll();\n}\n}\n}\n  finally {\nzk.unregisterJMX(this);\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 803,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 32,
        "startLineNumber" : 176,
        "startColumnNumber" : 20,
        "endLineNumber" : 176,
        "endColumnNumber" : 52
      },
      "nodeContext" : "qp.getType() != Leader.NEWLEADER",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 7,
      "astHeight" : 3
    },
    "tokenLength" : 2,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 16,
    "startLineNumber" : 176,
    "startColumnNumber" : 36,
    "endLineNumber" : 176,
    "endColumnNumber" : 52
  } ],
  "layoutRelationDataList" : [ ]
}