{
  "id" : 435,
  "expression" : "OBJECT_ID",
  "projectName" : "realm@realm-java",
  "commitID" : "9da3b229a46407f73e2003fb40857cadf062086b",
  "filePath" : "/realm/realm-library/src/main/java/io/realm/RealmResults.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "OBJECT_ID",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 9,
      "startLineNumber" : 205,
      "startColumnNumber" : 21,
      "endLineNumber" : 205,
      "endColumnNumber" : 30
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 15,
        "startLineNumber" : 205,
        "startColumnNumber" : 16,
        "endLineNumber" : 205,
        "endColumnNumber" : 31
      },
      "nodeContext" : "case OBJECT_ID:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 2,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1294,
        "startLineNumber" : 186,
        "startColumnNumber" : 12,
        "endLineNumber" : 216,
        "endColumnNumber" : 13
      },
      "nodeContext" : "switch (type) {\ncase BOOLEAN:  value=Boolean.parseBoolean(strValue);\nbreak;\ncase INTEGER:value=Long.parseLong(strValue);\nbreak;\ncase FLOAT:value=Float.parseFloat(strValue);\nbreak;\ncase DOUBLE:value=Double.parseDouble(strValue);\nbreak;\ncase DATE:value=JsonUtils.stringToDate(strValue);\nbreak;\ncase DECIMAL128:value=Decimal128.parse(strValue);\nbreak;\ncase OBJECT_ID:value=new ObjectId(strValue);\nbreak;\ncase UUID:value=UUID.fromString(strValue);\nbreak;\ndefault:throw new IllegalArgumentException(String.format(Locale.US,\"Field %s is not a String field, \" + \"and the provide value could not be automatically converted: %s. Use a typed\" + \"setter instead\",fieldName,value));\n}\n",
      "nodeType" : "SwitchStatement",
      "astNodeNumber" : 99,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1318,
        "startLineNumber" : 185,
        "startColumnNumber" : 55,
        "endLineNumber" : 217,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\nswitch (type) {\ncase BOOLEAN:    value=Boolean.parseBoolean(strValue);\n  break;\ncase INTEGER:value=Long.parseLong(strValue);\nbreak;\ncase FLOAT:value=Float.parseFloat(strValue);\nbreak;\ncase DOUBLE:value=Double.parseDouble(strValue);\nbreak;\ncase DATE:value=JsonUtils.stringToDate(strValue);\nbreak;\ncase DECIMAL128:value=Decimal128.parse(strValue);\nbreak;\ncase OBJECT_ID:value=new ObjectId(strValue);\nbreak;\ncase UUID:value=UUID.fromString(strValue);\nbreak;\ndefault:throw new IllegalArgumentException(String.format(Locale.US,\"Field %s is not a String field, \" + \"and the provide value could not be automatically converted: %s. Use a typed\" + \"setter instead\",fieldName,value));\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 100,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1365,
        "startLineNumber" : 185,
        "startColumnNumber" : 8,
        "endLineNumber" : 217,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (isString && type != RealmFieldType.STRING) {\nswitch (type) {\ncase BOOLEAN:    value=Boolean.parseBoolean(strValue);\n  break;\ncase INTEGER:value=Long.parseLong(strValue);\nbreak;\ncase FLOAT:value=Float.parseFloat(strValue);\nbreak;\ncase DOUBLE:value=Double.parseDouble(strValue);\nbreak;\ncase DATE:value=JsonUtils.stringToDate(strValue);\nbreak;\ncase DECIMAL128:value=Decimal128.parse(strValue);\nbreak;\ncase OBJECT_ID:value=new ObjectId(strValue);\nbreak;\ncase UUID:value=UUID.fromString(strValue);\nbreak;\ndefault:throw new IllegalArgumentException(String.format(Locale.US,\"Field %s is not a String field, \" + \"and the provide value could not be automatically converted: %s. Use a typed\" + \"setter instead\",fieldName,value));\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 108,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3987,
        "startLineNumber" : 164,
        "startColumnNumber" : 67,
        "endLineNumber" : 256,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  checkNonEmptyFieldName(fieldName);\n  baseRealm.checkIfValidAndInTransaction();\n  fieldName=mapFieldNameToInternalName(fieldName);\n  boolean isString=(value instanceof String);\n  String strValue=isString ? (String)value : null;\n  String className=osResults.getTable().getClassName();\n  RealmObjectSchema schema=getRealm().getSchema().get(className);\n  if (!schema.hasField(fieldName)) {\n    throw new IllegalArgumentException(String.format(\"Field '%s' could not be found in class '%s'\",fieldName,className));\n  }\n  if (value == null) {\n    osResults.setNull(fieldName);\n    return;\n  }\n  RealmFieldType type=schema.getFieldType(fieldName);\n  if (isString && type != RealmFieldType.STRING) {\nswitch (type) {\ncase BOOLEAN:      value=Boolean.parseBoolean(strValue);\n    break;\ncase INTEGER:  value=Long.parseLong(strValue);\nbreak;\ncase FLOAT:value=Float.parseFloat(strValue);\nbreak;\ncase DOUBLE:value=Double.parseDouble(strValue);\nbreak;\ncase DATE:value=JsonUtils.stringToDate(strValue);\nbreak;\ncase DECIMAL128:value=Decimal128.parse(strValue);\nbreak;\ncase OBJECT_ID:value=new ObjectId(strValue);\nbreak;\ncase UUID:value=UUID.fromString(strValue);\nbreak;\ndefault:throw new IllegalArgumentException(String.format(Locale.US,\"Field %s is not a String field, \" + \"and the provide value could not be automatically converted: %s. Use a typed\" + \"setter instead\",fieldName,value));\n}\n}\nClass<?> valueClass=value.getClass();\nif (valueClass == Boolean.class) {\nsetBoolean(fieldName,(Boolean)value);\n}\n else if (valueClass == Short.class) {\nsetShort(fieldName,(Short)value);\n}\n else if (valueClass == Integer.class) {\nsetInt(fieldName,(Integer)value);\n}\n else if (valueClass == Long.class) {\nsetLong(fieldName,(Long)value);\n}\n else if (valueClass == Byte.class) {\nsetByte(fieldName,(Byte)value);\n}\n else if (valueClass == Float.class) {\nsetFloat(fieldName,(Float)value);\n}\n else if (valueClass == Double.class) {\nsetDouble(fieldName,(Double)value);\n}\n else if (valueClass == String.class) {\nsetString(fieldName,(String)value);\n}\n else if (value instanceof Date) {\nsetDate(fieldName,(Date)value);\n}\n else if (value instanceof Decimal128) {\nsetDecimal128(fieldName,(Decimal128)value);\n}\n else if (value instanceof ObjectId) {\nsetObjectId(fieldName,(ObjectId)value);\n}\n else if (value instanceof UUID) {\nsetUUID(fieldName,(UUID)value);\n}\n else if (value instanceof byte[]) {\nsetBlob(fieldName,(byte[])value);\n}\n else if (value instanceof RealmModel) {\nsetObject(fieldName,(RealmModel)value);\n}\n else if (valueClass == RealmList.class) {\nRealmList<?> list=(RealmList<?>)value;\nsetList(fieldName,list);\n}\n else {\nthrow new IllegalArgumentException(\"Value is of a type not supported: \" + value.getClass());\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 454,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 4852,
        "startLineNumber" : 148,
        "startColumnNumber" : 4,
        "endLineNumber" : 256,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Updates the field given by  {@code fieldName} in all objects inside the query result.<p> This method will automatically try to convert numbers and booleans that are given as {@code String} to their appropriate type. For example {@code \"10\"} will be converted to{@code 10} if the field type is {@link RealmFieldType#INTEGER}. <p> Using the typed setters like  {@link #setInt(String,int)} will be faster than usingthis method.\n * @param fieldName field to update\n * @param value value to update with.\n * @throws IllegalArgumentException if the field could not be found, could not be updated orthe argument didn't match the field type or could not be converted to match the underlying field type.\n */\npublic void setValue(String fieldName,@Nullable Object value){\n  checkNonEmptyFieldName(fieldName);\n  baseRealm.checkIfValidAndInTransaction();\n  fieldName=mapFieldNameToInternalName(fieldName);\n  boolean isString=(value instanceof String);\n  String strValue=isString ? (String)value : null;\n  String className=osResults.getTable().getClassName();\n  RealmObjectSchema schema=getRealm().getSchema().get(className);\n  if (!schema.hasField(fieldName)) {\n    throw new IllegalArgumentException(String.format(\"Field '%s' could not be found in class '%s'\",fieldName,className));\n  }\n  if (value == null) {\n    osResults.setNull(fieldName);\n    return;\n  }\n  RealmFieldType type=schema.getFieldType(fieldName);\n  if (isString && type != RealmFieldType.STRING) {\nswitch (type) {\ncase BOOLEAN:      value=Boolean.parseBoolean(strValue);\n    break;\ncase INTEGER:  value=Long.parseLong(strValue);\nbreak;\ncase FLOAT:value=Float.parseFloat(strValue);\nbreak;\ncase DOUBLE:value=Double.parseDouble(strValue);\nbreak;\ncase DATE:value=JsonUtils.stringToDate(strValue);\nbreak;\ncase DECIMAL128:value=Decimal128.parse(strValue);\nbreak;\ncase OBJECT_ID:value=new ObjectId(strValue);\nbreak;\ncase UUID:value=UUID.fromString(strValue);\nbreak;\ndefault:throw new IllegalArgumentException(String.format(Locale.US,\"Field %s is not a String field, \" + \"and the provide value could not be automatically converted: %s. Use a typed\" + \"setter instead\",fieldName,value));\n}\n}\nClass<?> valueClass=value.getClass();\nif (valueClass == Boolean.class) {\nsetBoolean(fieldName,(Boolean)value);\n}\n else if (valueClass == Short.class) {\nsetShort(fieldName,(Short)value);\n}\n else if (valueClass == Integer.class) {\nsetInt(fieldName,(Integer)value);\n}\n else if (valueClass == Long.class) {\nsetLong(fieldName,(Long)value);\n}\n else if (valueClass == Byte.class) {\nsetByte(fieldName,(Byte)value);\n}\n else if (valueClass == Float.class) {\nsetFloat(fieldName,(Float)value);\n}\n else if (valueClass == Double.class) {\nsetDouble(fieldName,(Double)value);\n}\n else if (valueClass == String.class) {\nsetString(fieldName,(String)value);\n}\n else if (value instanceof Date) {\nsetDate(fieldName,(Date)value);\n}\n else if (value instanceof Decimal128) {\nsetDecimal128(fieldName,(Decimal128)value);\n}\n else if (value instanceof ObjectId) {\nsetObjectId(fieldName,(ObjectId)value);\n}\n else if (value instanceof UUID) {\nsetUUID(fieldName,(UUID)value);\n}\n else if (value instanceof byte[]) {\nsetBlob(fieldName,(byte[])value);\n}\n else if (value instanceof RealmModel) {\nsetObject(fieldName,(RealmModel)value);\n}\n else if (valueClass == RealmList.class) {\nRealmList<?> list=(RealmList<?>)value;\nsetList(fieldName,list);\n}\n else {\nthrow new IllegalArgumentException(\"Value is of a type not supported: \" + value.getClass());\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 469,
      "astHeight" : 24
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.SwitchStatement,statements]",
      "nodePosition" : {
        "charLength" : 15,
        "startLineNumber" : 205,
        "startColumnNumber" : 16,
        "endLineNumber" : 205,
        "endColumnNumber" : 31
      },
      "nodeContext" : "case OBJECT_ID:",
      "nodeType" : "SwitchCase",
      "astNodeNumber" : 2,
      "astHeight" : 2
    },
    "tokenLength" : 2,
    "type" : "io.realm.RealmFieldType"
  } ],
  "positionList" : [ {
    "charLength" : 9,
    "startLineNumber" : 205,
    "startColumnNumber" : 21,
    "endLineNumber" : 205,
    "endColumnNumber" : 30
  } ],
  "layoutRelationDataList" : [ ]
}